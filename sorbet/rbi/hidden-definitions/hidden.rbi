# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AST
end

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
end

module AST
end

class AbstractController::ActionNotFound
end

class AbstractController::ActionNotFound
end

module AbstractController::AssetPaths
end

module AbstractController::AssetPaths
  extend ::ActiveSupport::Concern
end

class AbstractController::Base
  include ::ActiveSupport::Configurable
  def action_methods(); end

  def action_name(); end

  def action_name=(action_name); end

  def available_action?(action_name); end

  def controller_path(); end

  def formats(); end

  def formats=(formats); end

  def performed?(); end

  def process(action, *args); end

  def response_body(); end

  def response_body=(response_body); end

  def send_action(*_); end
end

class AbstractController::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.abstract(); end

  def self.abstract!(); end

  def self.abstract?(); end

  def self.action_methods(); end

  def self.clear_action_methods!(); end

  def self.controller_path(); end

  def self.inherited(klass); end

  def self.internal_methods(); end

  def self.method_added(name); end

  def self.supports_path?(); end
end

module AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  def view_cache_dependencies(); end
end

module AbstractController::Caching::ClassMethods
  def view_cache_dependency(&dependency); end
end

module AbstractController::Caching::ClassMethods
end

module AbstractController::Caching::ConfigMethods
  def cache_store(); end

  def cache_store=(store); end
end

module AbstractController::Caching::ConfigMethods
end

module AbstractController::Caching::Fragments
  def combined_fragment_cache_key(key); end

  def expire_fragment(key, options=T.unsafe(nil)); end

  def fragment_exist?(key, options=T.unsafe(nil)); end

  def instrument_fragment_cache(name, key); end

  def read_fragment(key, options=T.unsafe(nil)); end

  def write_fragment(key, content, options=T.unsafe(nil)); end
end

module AbstractController::Caching::Fragments::ClassMethods
  def fragment_cache_key(value=T.unsafe(nil), &key); end
end

module AbstractController::Caching::Fragments::ClassMethods
end

module AbstractController::Caching::Fragments
  extend ::ActiveSupport::Concern
end

module AbstractController::Caching
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module AbstractController::Callbacks
  def process_action(*args); end
end

module AbstractController::Callbacks::ClassMethods
  def _insert_callbacks(callbacks, block=T.unsafe(nil)); end

  def _normalize_callback_option(options, from, to); end

  def _normalize_callback_options(options); end
end

module AbstractController::Callbacks
  extend ::ActiveSupport::Concern
end

module AbstractController::Collector
  def atom(*args, &block); end

  def bmp(*args, &block); end

  def css(*args, &block); end

  def csv(*args, &block); end

  def gif(*args, &block); end

  def gzip(*args, &block); end

  def html(*args, &block); end

  def ics(*args, &block); end

  def jpeg(*args, &block); end

  def js(*args, &block); end

  def json(*args, &block); end

  def m4a(*args, &block); end

  def mp3(*args, &block); end

  def mp4(*args, &block); end

  def mpeg(*args, &block); end

  def multipart_form(*args, &block); end

  def ogg(*args, &block); end

  def otf(*args, &block); end

  def pdf(*args, &block); end

  def png(*args, &block); end

  def rss(*args, &block); end

  def svg(*args, &block); end

  def text(*args, &block); end

  def tiff(*args, &block); end

  def ttf(*args, &block); end

  def url_encoded_form(*args, &block); end

  def vcf(*args, &block); end

  def vtt(*args, &block); end

  def webm(*args, &block); end

  def woff(*args, &block); end

  def woff2(*args, &block); end

  def xml(*args, &block); end

  def yaml(*args, &block); end

  def zip(*args, &block); end
end

module AbstractController::Collector
  def self.generate_method_for_mime(mime); end
end

class AbstractController::DoubleRenderError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class AbstractController::DoubleRenderError
end

class AbstractController::Error
end

class AbstractController::Error
end

module AbstractController::Helpers
end

module AbstractController::Helpers::ClassMethods
  def clear_helpers(); end

  def helper(*args, &block); end

  def helper_method(*meths); end

  def inherited(klass); end

  def modules_for_helpers(args); end
end

module AbstractController::Helpers::ClassMethods
end

class AbstractController::Helpers::MissingHelperError
  def initialize(error, path); end
end

class AbstractController::Helpers::MissingHelperError
end

module AbstractController::Helpers
  extend ::ActiveSupport::Concern
end

module AbstractController::Logger
end

module AbstractController::Logger
  extend ::ActiveSupport::Concern
end

module AbstractController::Railties
end

module AbstractController::Railties::RoutesHelpers
end

module AbstractController::Railties::RoutesHelpers
  def self.with(routes, include_path_helpers=T.unsafe(nil)); end
end

module AbstractController::Railties
end

module AbstractController::Rendering
  def render(*args, &block); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*args, &block); end

  def rendered_format(); end

  def view_assigns(); end
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module AbstractController::Rendering
  extend ::ActiveSupport::Concern
end

module AbstractController::Translation
  def l(object, **options); end

  def localize(object, **options); end

  def t(key, **options); end

  def translate(key, **options); end
end

module AbstractController::Translation
end

module AbstractController::UrlFor
  def _routes(); end
end

module AbstractController::UrlFor::ClassMethods
  def _routes(); end

  def action_methods(); end
end

module AbstractController::UrlFor::ClassMethods
end

module AbstractController::UrlFor
  extend ::ActiveSupport::Concern
end

module AbstractController
  extend ::ActiveSupport::Autoload
end

module ActionCable
  INTERNAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel
end

class ActionCable::Channel::Base
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Channel::Callbacks
  include ::ActionCable::Channel::PeriodicTimers
  include ::ActionCable::Channel::Streams
  include ::ActionCable::Channel::Naming
  include ::ActionCable::Channel::Broadcasting
  include ::ActiveSupport::Rescuable
  def __callbacks(); end

  def __callbacks?(); end

  def _run_subscribe_callbacks(&block); end

  def _run_unsubscribe_callbacks(&block); end

  def _subscribe_callbacks(); end

  def _unsubscribe_callbacks(); end

  def connection(); end

  def identifier(); end

  def initialize(connection, identifier, params=T.unsafe(nil)); end

  def logger(*args, &block); end

  def params(); end

  def perform_action(data); end

  def periodic_timers=(val); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def subscribe_to_channel(); end

  def unsubscribe_from_channel(); end
end

class ActionCable::Channel::Base
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Channel::Callbacks::ClassMethods
  extend ::ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::ActionCable::Channel::Naming::ClassMethods
  extend ::ActionCable::Channel::Broadcasting::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._subscribe_callbacks(); end

  def self._subscribe_callbacks=(value); end

  def self._unsubscribe_callbacks(); end

  def self._unsubscribe_callbacks=(value); end

  def self.action_methods(); end

  def self.periodic_timers(); end

  def self.periodic_timers=(val); end

  def self.periodic_timers?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end
end

module ActionCable::Channel::Broadcasting
  def broadcast_to(*args, &block); end

  def broadcasting_for(*args, &block); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
  def broadcast_to(model, message); end

  def broadcasting_for(model); end

  def serialize_broadcasting(object); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
end

module ActionCable::Channel::Broadcasting
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::Callbacks
end

module ActionCable::Channel::Callbacks::ClassMethods
  def after_subscribe(*methods, &block); end

  def after_unsubscribe(*methods, &block); end

  def before_subscribe(*methods, &block); end

  def before_unsubscribe(*methods, &block); end

  def on_subscribe(*methods, &block); end

  def on_unsubscribe(*methods, &block); end
end

module ActionCable::Channel::Callbacks::ClassMethods
end

module ActionCable::Channel::Callbacks
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::ChannelStub
  def confirmed?(); end

  def rejected?(); end

  def start_periodic_timers(); end

  def stop_all_streams(); end

  def stop_periodic_timers(); end

  def stream_from(broadcasting, *_); end

  def streams(); end
end

module ActionCable::Channel::ChannelStub
end

class ActionCable::Channel::ConnectionStub
  def identifiers(); end

  def initialize(identifiers=T.unsafe(nil)); end

  def logger(); end

  def subscriptions(); end

  def transmissions(); end

  def transmit(cable_message); end
end

class ActionCable::Channel::ConnectionStub
end

module ActionCable::Channel::Naming
  def channel_name(*args, &block); end
end

module ActionCable::Channel::Naming::ClassMethods
  def channel_name(); end
end

module ActionCable::Channel::Naming::ClassMethods
end

module ActionCable::Channel::Naming
  extend ::ActiveSupport::Concern
end

class ActionCable::Channel::NonInferrableChannelError
  def initialize(name); end
end

class ActionCable::Channel::NonInferrableChannelError
end

module ActionCable::Channel::PeriodicTimers
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
  def periodically(callback_or_method_name=T.unsafe(nil), every:, &block); end
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
end

module ActionCable::Channel::PeriodicTimers
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::Streams
  def pubsub(*args, &block); end

  def stop_all_streams(); end

  def stream_for(model, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end

  def stream_from(broadcasting, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end
end

module ActionCable::Channel::Streams
  extend ::ActiveSupport::Concern
end

class ActionCable::Channel::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  def _channel_class(); end

  def _channel_class=(val); end

  def _channel_class?(); end

  def connection(); end

  def subscription(); end
end

module ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  def assert_broadcast_on(stream_or_object, *args); end

  def assert_broadcasts(stream_or_object, *args); end

  def assert_has_stream(stream); end

  def assert_has_stream_for(object); end

  def assert_no_streams(); end

  def perform(action, data=T.unsafe(nil)); end

  def stub_connection(identifiers=T.unsafe(nil)); end

  def subscribe(params=T.unsafe(nil)); end

  def transmissions(); end

  def unsubscribe(); end
  CHANNEL_IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
  def channel_class(); end

  def determine_default_channel(name); end

  def tests(channel); end
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
end

module ActionCable::Channel::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionCable::Channel::TestCase
  extend ::ActionCable::Channel::TestCase::Behavior::ClassMethods
  def self._channel_class(); end

  def self._channel_class=(val); end

  def self._channel_class?(); end
end

module ActionCable::Channel
  extend ::ActiveSupport::Autoload
end

module ActionCable::Connection
end

module ActionCable::Connection::Assertions
  def assert_reject_connection(&block); end
end

module ActionCable::Connection::Assertions
end

module ActionCable::Connection::Authorization
  def reject_unauthorized_connection(); end
end

class ActionCable::Connection::Authorization::UnauthorizedError
end

class ActionCable::Connection::Authorization::UnauthorizedError
end

module ActionCable::Connection::Authorization
end

class ActionCable::Connection::Base
  include ::ActionCable::Connection::Identification
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Authorization
  def beat(); end

  def close(reason: T.unsafe(nil), reconnect: T.unsafe(nil)); end

  def dispatch_websocket_message(websocket_message); end

  def env(); end

  def event_loop(*args, &block); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, env, coder: T.unsafe(nil)); end

  def logger(); end

  def on_close(reason, code); end

  def on_error(message); end

  def on_message(message); end

  def on_open(); end

  def process(); end

  def protocol(); end

  def pubsub(*args, &block); end

  def receive(websocket_message); end

  def send_async(method, *arguments); end

  def server(); end

  def statistics(); end

  def subscriptions(); end

  def transmit(cable_message); end

  def worker_pool(); end
end

class ActionCable::Connection::Base
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::Connection::ClientSocket
  def alive?(); end

  def client_gone(); end

  def close(code=T.unsafe(nil), reason=T.unsafe(nil)); end

  def env(); end

  def initialize(env, event_target, event_loop, protocols); end

  def parse(data); end

  def protocol(); end

  def rack_response(); end

  def start_driver(); end

  def transmit(message); end

  def url(); end

  def write(data); end
  CLOSED = ::T.let(nil, ::T.untyped)
  CLOSING = ::T.let(nil, ::T.untyped)
  CONNECTING = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

class ActionCable::Connection::ClientSocket
  def self.determine_url(env); end

  def self.secure_request?(env); end
end

module ActionCable::Connection::Identification
  def connection_identifier(); end
end

module ActionCable::Connection::Identification::ClassMethods
  def identified_by(*identifiers); end
end

module ActionCable::Connection::Identification::ClassMethods
end

module ActionCable::Connection::Identification
  extend ::ActiveSupport::Concern
end

module ActionCable::Connection::InternalChannel
end

module ActionCable::Connection::InternalChannel
  extend ::ActiveSupport::Concern
end

class ActionCable::Connection::MessageBuffer
  def append(message); end

  def initialize(connection); end

  def process!(); end

  def processing?(); end
end

class ActionCable::Connection::MessageBuffer
end

class ActionCable::Connection::NonInferrableConnectionError
  def initialize(name); end
end

class ActionCable::Connection::NonInferrableConnectionError
end

class ActionCable::Connection::Stream
  def close(); end

  def each(&callback); end

  def flush_write_buffer(); end

  def hijack_rack_socket(); end

  def initialize(event_loop, socket); end

  def receive(data); end

  def shutdown(); end

  def write(data); end
end

class ActionCable::Connection::Stream
end

class ActionCable::Connection::StreamEventLoop
  def attach(io, stream); end

  def detach(io, stream); end

  def post(task=T.unsafe(nil), &block); end

  def stop(); end

  def timer(interval, &block); end

  def writes_pending(io); end
end

class ActionCable::Connection::StreamEventLoop
end

class ActionCable::Connection::Subscriptions
  def add(data); end

  def execute_command(data); end

  def identifiers(); end

  def initialize(connection); end

  def logger(*args, &block); end

  def perform_action(data); end

  def remove(data); end

  def remove_subscription(subscription); end

  def unsubscribe_from_all(); end
end

class ActionCable::Connection::Subscriptions
end

class ActionCable::Connection::TaggedLoggerProxy
  def add_tags(*tags); end

  def debug(message); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def initialize(logger, tags:); end

  def tag(logger); end

  def tags(); end

  def unknown(message); end

  def warn(message); end
end

class ActionCable::Connection::TaggedLoggerProxy
end

class ActionCable::Connection::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  def _connection_class(); end

  def _connection_class=(val); end

  def _connection_class?(); end

  def connection(); end
end

module ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  def connect(path=T.unsafe(nil), **request_params); end

  def cookies(); end

  def disconnect(); end
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
  def connection_class(); end

  def determine_default_connection(name); end

  def tests(connection); end
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
end

module ActionCable::Connection::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionCable::Connection::TestCase
  extend ::ActionCable::Connection::TestCase::Behavior::ClassMethods
  def self._connection_class(); end

  def self._connection_class=(val); end

  def self._connection_class?(); end
end

module ActionCable::Connection::TestConnection
  def initialize(request); end

  def logger(); end

  def request(); end
end

module ActionCable::Connection::TestConnection
end

class ActionCable::Connection::TestCookieJar
  def encrypted(); end

  def signed(); end
end

class ActionCable::Connection::TestCookieJar
end

class ActionCable::Connection::TestRequest
  def cookie_jar=(cookie_jar); end

  def session=(session); end
end

class ActionCable::Connection::TestRequest
end

class ActionCable::Connection::WebSocket
  def alive?(); end

  def close(); end

  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  def possible?(); end

  def protocol(); end

  def rack_response(); end

  def transmit(data); end
end

class ActionCable::Connection::WebSocket
end

module ActionCable::Connection
  extend ::ActiveSupport::Autoload
end

class ActionCable::Engine
end

class ActionCable::Engine
end

module ActionCable::Helpers
end

module ActionCable::Helpers::ActionCableHelper
  def action_cable_meta_tag(); end
end

module ActionCable::Helpers::ActionCableHelper
end

module ActionCable::Helpers
end

class ActionCable::RemoteConnections
  def initialize(server); end

  def server(); end

  def where(identifier); end
end

class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Identification
  def disconnect(); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, ids); end

  def server(); end
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::RemoteConnections
end

module ActionCable::Server
end

class ActionCable::Server::Base
  include ::ActionCable::Server::Broadcasting
  include ::ActionCable::Server::Connections
  def call(env); end

  def config(); end

  def connection_identifiers(); end

  def disconnect(identifiers); end

  def event_loop(); end

  def initialize(config: T.unsafe(nil)); end

  def logger(*args, &block); end

  def mutex(); end

  def pubsub(); end

  def remote_connections(); end

  def restart(); end

  def worker_pool(); end
end

class ActionCable::Server::Base
  def self.config(); end

  def self.config=(obj); end

  def self.logger(); end
end

module ActionCable::Server::Broadcasting
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

class ActionCable::Server::Broadcasting::Broadcaster
  def broadcast(message); end

  def broadcasting(); end

  def coder(); end

  def initialize(server, broadcasting, coder:); end

  def server(); end
end

class ActionCable::Server::Broadcasting::Broadcaster
end

module ActionCable::Server::Broadcasting
end

class ActionCable::Server::Configuration
  def allow_same_origin_as_host(); end

  def allow_same_origin_as_host=(allow_same_origin_as_host); end

  def allowed_request_origins(); end

  def allowed_request_origins=(allowed_request_origins); end

  def cable(); end

  def cable=(cable); end

  def connection_class(); end

  def connection_class=(connection_class); end

  def disable_request_forgery_protection(); end

  def disable_request_forgery_protection=(disable_request_forgery_protection); end

  def log_tags(); end

  def log_tags=(log_tags); end

  def logger(); end

  def logger=(logger); end

  def mount_path(); end

  def mount_path=(mount_path); end

  def pubsub_adapter(); end

  def url(); end

  def url=(url); end

  def worker_pool_size(); end

  def worker_pool_size=(worker_pool_size); end
end

class ActionCable::Server::Configuration
end

module ActionCable::Server::Connections
  def add_connection(connection); end

  def connections(); end

  def open_connections_statistics(); end

  def remove_connection(connection); end

  def setup_heartbeat_timer(); end
  BEAT_INTERVAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Server::Connections
end

class ActionCable::Server::Worker
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def __callbacks(); end

  def __callbacks?(); end

  def _run_work_callbacks(&block); end

  def _work_callbacks(); end

  def async_exec(receiver, *args, connection:, &block); end

  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  def connection(); end

  def connection=(obj); end

  def executor(); end

  def halt(); end

  def initialize(max_size: T.unsafe(nil)); end

  def invoke(receiver, method, *args, connection:, &block); end

  def stopping?(); end

  def work(connection); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def with_database_connections(); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Concern
end

class ActionCable::Server::Worker
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._work_callbacks(); end

  def self._work_callbacks=(value); end

  def self.connection(); end

  def self.connection=(obj); end
end

module ActionCable::Server
  extend ::ActiveSupport::Autoload
end

module ActionCable::SubscriptionAdapter
end

class ActionCable::SubscriptionAdapter::Async
end

class ActionCable::SubscriptionAdapter::Async::AsyncSubscriberMap
  def add_subscriber(*_); end

  def initialize(event_loop); end

  def invoke_callback(*_); end
end

class ActionCable::SubscriptionAdapter::Async::AsyncSubscriberMap
end

class ActionCable::SubscriptionAdapter::Async
end

class ActionCable::SubscriptionAdapter::Base
  def broadcast(channel, payload); end

  def initialize(server); end

  def logger(); end

  def server(); end

  def shutdown(); end

  def subscribe(channel, message_callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, message_callback); end
end

class ActionCable::SubscriptionAdapter::Base
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  def broadcast(channel, payload); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
end

class ActionCable::SubscriptionAdapter::Inline
  def initialize(*_); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

class ActionCable::SubscriptionAdapter::Inline
end

class ActionCable::SubscriptionAdapter::SubscriberMap
  def add_channel(channel, on_success); end

  def add_subscriber(channel, subscriber, on_success); end

  def broadcast(channel, message); end

  def invoke_callback(callback, message); end

  def remove_channel(channel); end

  def remove_subscriber(channel, subscriber); end
end

class ActionCable::SubscriptionAdapter::SubscriberMap
end

class ActionCable::SubscriptionAdapter::Test
  def broadcasts(channel); end

  def clear(); end

  def clear_messages(channel); end
end

class ActionCable::SubscriptionAdapter::Test
end

module ActionCable::SubscriptionAdapter
  extend ::ActiveSupport::Autoload
end

class ActionCable::TestCase
  include ::ActionCable::TestHelper
end

class ActionCable::TestCase
end

module ActionCable::TestHelper
  def after_teardown(); end

  def assert_broadcast_on(stream, data); end

  def assert_broadcasts(stream, number); end

  def assert_no_broadcasts(stream, &block); end

  def before_setup(); end

  def broadcasts(*args, &block); end

  def clear_messages(*args, &block); end

  def pubsub_adapter(); end
end

module ActionCable::TestHelper
end

module ActionCable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionCable::VERSION
end

module ActionCable
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.server(); end

  def self.version(); end
end

class ActionController::API
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionController::ApiRendering
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::BasicImplicitRender
  include ::ActionController::StrongParameters
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::ForceSSL
  include ::ActionController::DataStreaming
  include ::ActionController::DefaultHeaders
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionController::RespondWith
  include ::Bugsnag::Rails::ControllerMethods
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::Devise::Controllers::Helpers
  include ::Devise::Controllers::SignInOut
  include ::Devise::Controllers::StoreLocation
  include ::Devise::Controllers::UrlHelpers
  include ::Turbolinks::Controller
  include ::Turbolinks::Redirection
  def __callbacks(); end

  def __callbacks?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(val); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _wrapper_options(); end

  def _wrapper_options=(val); end

  def _wrapper_options?(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def etaggers(); end

  def etaggers=(val); end

  def etaggers?(); end

  def logger(); end

  def logger=(value); end

  def mimes_for_respond_to(); end

  def mimes_for_respond_to=(val); end

  def mimes_for_respond_to?(); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def responder(); end

  def responder=(val); end

  def responder?(); end
  MODULES = ::T.let(nil, ::T.untyped)
end

class ActionController::API
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::ForceSSL::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::ActionController::RespondWith::ClassMethods
  extend ::ActionController::Railties::Helpers
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mimes_for_respond_to(); end

  def self.mimes_for_respond_to=(val); end

  def self.mimes_for_respond_to?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.responder(); end

  def self.responder=(val); end

  def self.responder?(); end

  def self.without_modules(*modules); end
end

class ActionController::ActionControllerError
end

class ActionController::ActionControllerError
end

module ActionController::ApiRendering
  def render_to_body(options=T.unsafe(nil)); end
end

module ActionController::ApiRendering
  extend ::ActiveSupport::Concern
end

class ActionController::BadRequest
  def initialize(msg=T.unsafe(nil)); end
end

class ActionController::BadRequest
end

class ActionController::Base
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::EtagWithTemplateDigest
  include ::ActionController::EtagWithFlash
  include ::ActionController::Caching
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionController::MimeResponds
  include ::ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  include ::ActionController::StrongParameters
  include ::ActionController::ParameterEncoding
  include ::ActionController::Cookies
  include ::ActionController::Flash
  include ::ActionController::FormBuilder
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::RequestForgeryProtection
  include ::ActionController::ContentSecurityPolicy
  include ::ActionController::ForceSSL
  include ::ActionController::Streaming
  include ::ActionController::DataStreaming
  include ::ActionController::HttpAuthentication::Basic::ControllerMethods
  include ::ActionController::HttpAuthentication::Digest::ControllerMethods
  include ::ActionController::HttpAuthentication::Token::ControllerMethods
  include ::ActionController::DefaultHeaders
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionController::RespondWith
  include ::Bugsnag::Rails::ControllerMethods
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::Devise::Controllers::Helpers
  include ::Devise::Controllers::SignInOut
  include ::Devise::Controllers::StoreLocation
  include ::Devise::Controllers::UrlHelpers
  include ::Turbolinks::Controller
  include ::Turbolinks::Redirection
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(val); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(val); end

  def _view_cache_dependencies?(); end

  def _wrapper_options(); end

  def _wrapper_options=(val); end

  def _wrapper_options?(); end

  def alert(); end

  def allow_forgery_protection(); end

  def allow_forgery_protection=(value); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_protect_from_forgery(); end

  def default_protect_from_forgery=(value); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def etag_with_template_digest(); end

  def etag_with_template_digest=(val); end

  def etag_with_template_digest?(); end

  def etaggers(); end

  def etaggers=(val); end

  def etaggers?(); end

  def flash(*args, &block); end

  def forgery_protection_origin_check(); end

  def forgery_protection_origin_check=(value); end

  def forgery_protection_strategy(); end

  def forgery_protection_strategy=(value); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(val); end

  def fragment_cache_keys?(); end

  def helpers_path(); end

  def helpers_path=(val); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(val); end

  def include_all_helpers?(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def log_warning_on_csrf_failure(); end

  def log_warning_on_csrf_failure=(value); end

  def logger(); end

  def logger=(value); end

  def mimes_for_respond_to(); end

  def mimes_for_respond_to=(val); end

  def mimes_for_respond_to?(); end

  def notice(); end

  def per_form_csrf_tokens(); end

  def per_form_csrf_tokens=(value); end

  def perform_caching(); end

  def perform_caching=(value); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def request_forgery_protection_token(); end

  def request_forgery_protection_token=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def responder(); end

  def responder=(val); end

  def responder?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end
  MODULES = ::T.let(nil, ::T.untyped)
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionController::Base
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionController::Helpers::ClassMethods
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::ActionController::ParameterEncoding::ClassMethods
  extend ::ActionController::Flash::ClassMethods
  extend ::ActionController::FormBuilder::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::RequestForgeryProtection::ClassMethods
  extend ::ActionController::ContentSecurityPolicy::ClassMethods
  extend ::ActionController::ForceSSL::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::Responders::ControllerMethod
  extend ::ActionController::RespondWith::ClassMethods
  extend ::ActionController::Railties::Helpers
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._default_form_builder(); end

  def self._default_form_builder=(val); end

  def self._default_form_builder?(); end

  def self._flash_types(); end

  def self._flash_types=(val); end

  def self._flash_types?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.allow_forgery_protection(); end

  def self.allow_forgery_protection=(value); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_protect_from_forgery(); end

  def self.default_protect_from_forgery=(value); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.etag_with_template_digest(); end

  def self.etag_with_template_digest=(val); end

  def self.etag_with_template_digest?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.forgery_protection_origin_check(); end

  def self.forgery_protection_origin_check=(value); end

  def self.forgery_protection_strategy(); end

  def self.forgery_protection_strategy=(value); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(val); end

  def self.fragment_cache_keys?(); end

  def self.helpers_path(); end

  def self.helpers_path=(val); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(val); end

  def self.include_all_helpers?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.log_warning_on_csrf_failure(); end

  def self.log_warning_on_csrf_failure=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mimes_for_respond_to(); end

  def self.mimes_for_respond_to=(val); end

  def self.mimes_for_respond_to?(); end

  def self.per_form_csrf_tokens(); end

  def self.per_form_csrf_tokens=(value); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.request_forgery_protection_token(); end

  def self.request_forgery_protection_token=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.responder(); end

  def self.responder=(val); end

  def self.responder?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.without_modules(*modules); end
end

module ActionController::BasicImplicitRender
  def default_render(); end

  def send_action(method, *args); end
end

module ActionController::BasicImplicitRender
end

module ActionController::Caching
end

module ActionController::Caching
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

module ActionController::ConditionalGet
  include ::ActionController::Head
  def expires_in(seconds, options=T.unsafe(nil)); end

  def expires_now(); end

  def fresh_when(object=T.unsafe(nil), etag: T.unsafe(nil), weak_etag: T.unsafe(nil), strong_etag: T.unsafe(nil), last_modified: T.unsafe(nil), public: T.unsafe(nil), template: T.unsafe(nil)); end

  def http_cache_forever(public: T.unsafe(nil)); end

  def stale?(object=T.unsafe(nil), **freshness_kwargs); end
end

module ActionController::ConditionalGet::ClassMethods
  def etag(&etagger); end
end

module ActionController::ConditionalGet::ClassMethods
end

module ActionController::ConditionalGet
  extend ::ActiveSupport::Concern
end

module ActionController::ContentSecurityPolicy
end

module ActionController::ContentSecurityPolicy::ClassMethods
  def content_security_policy(enabled=T.unsafe(nil), **options, &block); end

  def content_security_policy_report_only(report_only=T.unsafe(nil), **options); end
end

module ActionController::ContentSecurityPolicy::ClassMethods
end

module ActionController::ContentSecurityPolicy
  extend ::ActiveSupport::Concern
end

module ActionController::Cookies
end

module ActionController::Cookies
  extend ::ActiveSupport::Concern
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::DataStreaming
  extend ::ActiveSupport::Concern
end

module ActionController::DefaultHeaders
end

module ActionController::DefaultHeaders::ClassMethods
  def make_response!(request); end
end

module ActionController::DefaultHeaders::ClassMethods
end

module ActionController::DefaultHeaders
  extend ::ActiveSupport::Concern
end

module ActionController::EtagWithFlash
end

module ActionController::EtagWithFlash
  extend ::ActiveSupport::Concern
end

module ActionController::EtagWithTemplateDigest
end

module ActionController::EtagWithTemplateDigest
  extend ::ActiveSupport::Concern
end

module ActionController::Flash
  extend ::ActiveSupport::Concern
end

module ActionController::ForceSSL
  def force_ssl_redirect(host_or_options=T.unsafe(nil)); end
  ACTION_OPTIONS = ::T.let(nil, ::T.untyped)
  REDIRECT_OPTIONS = ::T.let(nil, ::T.untyped)
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::ForceSSL::ClassMethods
  def force_ssl(options=T.unsafe(nil)); end
end

module ActionController::ForceSSL::ClassMethods
end

module ActionController::ForceSSL
  extend ::ActiveSupport::Concern
end

module ActionController::FormBuilder
  def default_form_builder(); end
end

module ActionController::FormBuilder::ClassMethods
  def default_form_builder(builder); end
end

module ActionController::FormBuilder::ClassMethods
end

module ActionController::FormBuilder
  extend ::ActiveSupport::Concern
end

module ActionController::Head
  def head(status, options=T.unsafe(nil)); end
end

module ActionController::Head
end

module ActionController::Helpers
  def helpers(); end
end

module ActionController::Helpers::ClassMethods
  def all_helpers_from_path(path); end

  def helper_attr(*attrs); end

  def helpers(); end

  def modules_for_helpers(args); end
end

module ActionController::Helpers::ClassMethods
end

module ActionController::Helpers
  extend ::ActiveSupport::Concern
  def self.helpers_path(); end

  def self.helpers_path=(helpers_path); end
end

module ActionController::HttpAuthentication
end

module ActionController::HttpAuthentication::Basic
  def auth_param(request); end

  def auth_scheme(request); end

  def authenticate(request, &login_procedure); end

  def authentication_request(controller, realm, message); end

  def decode_credentials(request); end

  def encode_credentials(user_name, password); end

  def has_basic_credentials?(request); end

  def user_name_and_password(request); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  def authenticate_or_request_with_http_basic(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_basic(&login_procedure); end

  def http_basic_authenticate_or_request_with(name:, password:, realm: T.unsafe(nil), message: T.unsafe(nil)); end

  def request_http_basic_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  extend ::ActiveSupport::Concern
end

module ActionController::HttpAuthentication::Basic
  extend ::ActionController::HttpAuthentication::Basic
end

module ActionController::HttpAuthentication::Digest
  def authenticate(request, realm, &password_procedure); end

  def authentication_header(controller, realm); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def decode_credentials(header); end

  def decode_credentials_header(request); end

  def encode_credentials(http_method, credentials, password, password_is_ha1); end

  def expected_response(http_method, uri, credentials, password, password_is_ha1=T.unsafe(nil)); end

  def ha1(credentials, password); end

  def nonce(secret_key, time=T.unsafe(nil)); end

  def opaque(secret_key); end

  def secret_token(request); end

  def validate_digest_response(request, realm, &password_procedure); end

  def validate_nonce(secret_key, request, value, seconds_to_timeout=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  def authenticate_or_request_with_http_digest(realm=T.unsafe(nil), message=T.unsafe(nil), &password_procedure); end

  def authenticate_with_http_digest(realm=T.unsafe(nil), &password_procedure); end

  def request_http_digest_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
end

module ActionController::HttpAuthentication::Digest
  extend ::ActionController::HttpAuthentication::Digest
end

module ActionController::HttpAuthentication::Token
  def authenticate(controller, &login_procedure); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def encode_credentials(token, options=T.unsafe(nil)); end

  def params_array_from(raw_params); end

  def raw_params(auth); end

  def rewrite_param_values(array_params); end

  def token_and_options(request); end

  def token_params_from(auth); end
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token::ControllerMethods
  def authenticate_or_request_with_http_token(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_token(&login_procedure); end

  def request_http_token_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Token::ControllerMethods
end

module ActionController::HttpAuthentication::Token
  extend ::ActionController::HttpAuthentication::Token
end

module ActionController::HttpAuthentication
end

module ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  def default_render(); end

  def method_for_action(action_name); end
end

module ActionController::ImplicitRender
end

module ActionController::Instrumentation
  def process_action(*args); end

  def redirect_to(*args); end

  def render(*args); end

  def send_data(data, options=T.unsafe(nil)); end

  def send_file(path, options=T.unsafe(nil)); end

  def view_runtime(); end

  def view_runtime=(view_runtime); end
end

module ActionController::Instrumentation::ClassMethods
  def log_process_action(payload); end
end

module ActionController::Instrumentation::ClassMethods
end

module ActionController::Instrumentation
  extend ::ActiveSupport::Concern
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidCrossOriginRequest
end

class ActionController::InvalidCrossOriginRequest
end

module ActionController::Live
  def new_controller_thread(); end

  def process(name); end

  def response_body=(body); end
end

class ActionController::Live::Buffer
  include ::MonitorMixin
  def call_on_error(); end

  def connected?(); end

  def ignore_disconnect(); end

  def ignore_disconnect=(ignore_disconnect); end

  def initialize(response); end

  def on_error(&block); end
end

class ActionController::Live::Buffer
end

module ActionController::Live::ClassMethods
  def make_response!(request); end
end

module ActionController::Live::ClassMethods
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::Response
end

class ActionController::Live::Response
end

class ActionController::Live::SSE
  def close(); end

  def initialize(stream, options=T.unsafe(nil)); end

  def write(object, options=T.unsafe(nil)); end
  PERMITTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::Live::SSE
end

module ActionController::Live
  extend ::ActiveSupport::Concern
end

class ActionController::LiveTestResponse
  def error?(); end

  def missing?(); end

  def success?(); end
end

class ActionController::LiveTestResponse
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def expire_page(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end

  def write_page(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

class ActionController::LogSubscriber
end

class ActionController::Metal
  include ::ActionController::Testing::Functional
  def content_type(*args, &block); end

  def content_type=(arg); end

  def controller_name(); end

  def dispatch(name, request, response); end

  def headers(*args, &block); end

  def location(*args, &block); end

  def location=(arg); end

  def media_type(*args, &block); end

  def middleware_stack(); end

  def middleware_stack=(val); end

  def middleware_stack?(); end

  def params=(val); end

  def request=(request); end

  def reset_session(); end

  def response=(response); end

  def response_body=(body); end

  def response_code(*args, &block); end

  def session(*args, &block); end

  def set_request!(request); end

  def set_response!(response); end

  def status(*args, &block); end

  def status=(arg); end

  def to_a(); end

  def url_for(string); end
end

class ActionController::Metal
  def self.action(name); end

  def self.binary_params_for?(action); end

  def self.controller_name(); end

  def self.dispatch(name, req, res); end

  def self.inherited(base); end

  def self.make_response!(request); end

  def self.middleware(); end

  def self.middleware_stack(); end

  def self.middleware_stack=(val); end

  def self.middleware_stack?(); end

  def self.use(*args, &block); end
end

class ActionController::MethodNotAllowed
  def initialize(*allowed_methods); end
end

class ActionController::MethodNotAllowed
end

class ActionController::MiddlewareStack
  def build(action, app=T.unsafe(nil), &block); end
  EXCLUDE = ::T.let(nil, ::T.untyped)
  INCLUDE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionController::MiddlewareStack::Middleware
  def initialize(klass, args, actions, strategy, block); end

  def valid?(action); end
end

class ActionController::MiddlewareStack::Middleware
end

class ActionController::MiddlewareStack
end

class ActionController::MimeResponds::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime_type, &block); end

  def format(); end

  def format=(format); end

  def initialize(mimes, variant=T.unsafe(nil)); end

  def negotiate_format(request); end

  def response(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
  def all(*args, &block); end

  def any(*args, &block); end

  def initialize(variant=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def variant(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
end

class ActionController::MissingExactTemplate
end

class ActionController::MissingExactTemplate
end

class ActionController::MissingFile
end

class ActionController::MissingFile
end

class ActionController::MissingRenderer
  def initialize(format); end
end

class ActionController::MissingRenderer
end

class ActionController::NotImplemented
end

class ActionController::NotImplemented
end

module ActionController::ParameterEncoding
end

module ActionController::ParameterEncoding::ClassMethods
  def binary_params_for?(action); end

  def inherited(klass); end

  def setup_param_encode(); end

  def skip_parameter_encoding(action); end
end

module ActionController::ParameterEncoding::ClassMethods
end

module ActionController::ParameterEncoding
  extend ::ActiveSupport::Concern
end

class ActionController::ParameterMissing
  def initialize(param); end

  def param(); end
end

class ActionController::ParameterMissing
end

class ActionController::Parameters
  def converted_arrays(); end

  def each_key(*args, &block); end

  def each_value(&block); end

  def fields_for_style?(); end

  def init_with(coder); end

  def stringify_keys(); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActionController::Parameters
  def self.hook_into_yaml_loading(); end
end

module ActionController::ParamsWrapper
  def process_action(*args); end
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper::ClassMethods
  def _set_wrapper_options(options); end

  def inherited(klass); end

  def wrap_parameters(name_or_model_or_options, options=T.unsafe(nil)); end
end

module ActionController::ParamsWrapper::ClassMethods
end

class ActionController::ParamsWrapper::Options
  include ::Mutex_m
  def initialize(name, format, include, exclude, klass, model); end

  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActionController::ParamsWrapper::Options
  def self.from_hash(hash); end
end

module ActionController::ParamsWrapper
  extend ::ActiveSupport::Concern
end

class ActionController::Railtie
end

class ActionController::Railtie
end

module ActionController::Railties
end

module ActionController::Railties::Helpers
  def inherited(klass); end
end

module ActionController::Railties::Helpers
end

module ActionController::Railties
end

module ActionController::Redirecting
  def _compute_redirect_to_location(request, options); end

  def redirect_back(fallback_location:, allow_other_host: T.unsafe(nil), **args); end

  def redirect_to(options=T.unsafe(nil), response_options=T.unsafe(nil)); end
end

module ActionController::Redirecting
  extend ::ActiveSupport::Concern
  def self._compute_redirect_to_location(request, options); end
end

class ActionController::RenderError
end

class ActionController::RenderError
end

class ActionController::Renderer
  def controller(); end

  def defaults(); end

  def initialize(controller, env, defaults); end

  def new(env=T.unsafe(nil)); end

  def render(*args); end

  def with_defaults(defaults); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  RACK_KEY_TRANSLATION = ::T.let(nil, ::T.untyped)
  RACK_VALUE_TRANSLATION = ::T.let(nil, ::T.untyped)
end

class ActionController::Renderer
  def self.for(controller, env=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

module ActionController::Renderers
  def _render_to_body_with_renderer(options); end

  def _render_with_renderer_js(js, options); end

  def _render_with_renderer_json(json, options); end

  def _render_with_renderer_xml(xml, options); end

  def render_to_body(options); end
  RENDERERS = ::T.let(nil, ::T.untyped)
end

module ActionController::Renderers::All
end

module ActionController::Renderers::All
  extend ::ActiveSupport::Concern
end

module ActionController::Renderers::ClassMethods
  def use_renderer(*args); end

  def use_renderers(*args); end
end

module ActionController::Renderers::ClassMethods
end

module ActionController::Renderers
  extend ::ActiveSupport::Concern
  def self._render_with_renderer_method_name(key); end

  def self.add(key, &block); end

  def self.remove(key); end
end

module ActionController::Rendering
  def process_action(*_); end

  def render(*args); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*_); end
  RENDER_FORMATS_IN_PRIORITY = ::T.let(nil, ::T.untyped)
end

module ActionController::Rendering::ClassMethods
  def inherited(klass); end

  def render(*args, &block); end

  def renderer(); end

  def setup_renderer!(); end
end

module ActionController::Rendering::ClassMethods
end

module ActionController::Rendering
  extend ::ActiveSupport::Concern
end

module ActionController::RequestForgeryProtection
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
  NULL_ORIGIN_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActionController::RequestForgeryProtection::ClassMethods
  def skip_forgery_protection(options=T.unsafe(nil)); end
end

module ActionController::RequestForgeryProtection::ProtectionMethods
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
  def write(*_); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
  def initialize(req); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
end

module ActionController::RequestForgeryProtection::ProtectionMethods
end

module ActionController::RequestForgeryProtection
  extend ::ActiveSupport::Concern
end

module ActionController::Rescue
  def show_detailed_exceptions?(); end
end

module ActionController::Rescue
  extend ::ActiveSupport::Concern
end

class ActionController::RespondToMismatchError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::RespondToMismatchError
end

module ActionController::RespondWith
  def collect_mimes_from_class_level(); end

  def respond_with(*resources, &block); end

  def verify_request_format!(); end

  def verify_requested_format!(); end
end

module ActionController::RespondWith::ClassMethods
  def clear_respond_to(); end

  def respond_to(*mimes); end
end

module ActionController::RespondWith::ClassMethods
end

module ActionController::RespondWith
  extend ::ActiveSupport::Concern
end

class ActionController::Responder
  def api_behavior(); end

  def api_location(); end

  def controller(); end

  def default_action(); end

  def default_render(); end

  def delete?(*args, &block); end

  def display(resource, given_options=T.unsafe(nil)); end

  def display_errors(); end

  def format(); end

  def get?(*args, &block); end

  def has_errors?(); end

  def has_renderer?(); end

  def has_view_rendering?(); end

  def head(*args, &block); end

  def initialize(controller, resources, options=T.unsafe(nil)); end

  def json_resource_errors(); end

  def navigation_behavior(error); end

  def navigation_location(); end

  def options(); end

  def patch?(*args, &block); end

  def post?(*args, &block); end

  def put?(*args, &block); end

  def redirect_to(*args, &block); end

  def render(*args, &block); end

  def rendering_options(); end

  def request(); end

  def resource(); end

  def resource_errors(); end

  def resource_location(); end

  def resources(); end

  def respond(); end

  def response_overridden?(); end

  def to_format(); end

  def to_html(); end

  def to_js(); end
  DEFAULT_ACTIONS_FOR_VERBS = ::T.let(nil, ::T.untyped)
end

class ActionController::Responder
  def self.call(*args); end
end

class ActionController::RoutingError
  def failures(); end

  def initialize(message, failures=T.unsafe(nil)); end
end

class ActionController::RoutingError
end

class ActionController::SessionOverflowError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::SessionOverflowError
end

module ActionController::Streaming
end

module ActionController::Streaming
  extend ::ActiveSupport::Concern
end

module ActionController::StrongParameters
  def params=(value); end
end

module ActionController::TemplateAssertions
  def assert_template(options=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::TemplateAssertions
end

class ActionController::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  def _controller_class(); end

  def _controller_class=(val); end

  def _controller_class?(); end
end

module ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def build_response(klass); end

  def controller_class_name(); end

  def delete(action, **args); end

  def generated_path(generated_extras); end

  def get(action, **args); end

  def head(action, **args); end

  def patch(action, **args); end

  def post(action, **args); end

  def process(action, method: T.unsafe(nil), params: T.unsafe(nil), session: T.unsafe(nil), body: T.unsafe(nil), flash: T.unsafe(nil), format: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def put(action, **args); end

  def query_parameter_names(generated_extras); end

  def request(); end

  def response(); end

  def setup_controller_request_and_response(); end
end

module ActionController::TestCase::Behavior::ClassMethods
  def controller_class(); end

  def controller_class=(new_class); end

  def determine_default_controller_class(name); end

  def tests(controller_class); end
end

module ActionController::TestCase::Behavior::ClassMethods
end

module ActionController::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionController::TestCase
  extend ::ActionController::TestCase::Behavior::ClassMethods
  def self._controller_class(); end

  def self._controller_class=(val); end

  def self._controller_class?(); end
end

class ActionController::TestRequest
  def assign_parameters(routes, controller_path, action, parameters, generated_path, query_string_keys); end

  def content_type=(type); end

  def initialize(env, session, controller_class); end

  def query_string=(string); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionController::TestRequest
  def self.create(controller_class); end

  def self.new_session(); end
end

class ActionController::TestSession
  def dig(*keys); end

  def fetch(key, *args, &block); end

  def initialize(session=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::TestSession
end

module ActionController::Testing
end

module ActionController::Testing::Functional
  def recycle!(); end
end

module ActionController::Testing::Functional
end

module ActionController::Testing
  extend ::ActiveSupport::Concern
end

class ActionController::UnfilteredParameters
  def initialize(); end
end

class ActionController::UnfilteredParameters
end

class ActionController::UnknownFormat
end

class ActionController::UnknownFormat
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnpermittedParameters
  def initialize(params); end

  def params(); end
end

class ActionController::UnpermittedParameters
end

module ActionController::UrlFor
  def url_options(); end
end

module ActionController::UrlFor
  extend ::ActiveSupport::Concern
end

class ActionController::UrlGenerationError
end

class ActionController::UrlGenerationError
end

module ActionController
  extend ::ActiveSupport::Autoload
  def self.add_renderer(key, &block); end

  def self.remove_renderer(key); end
end

module ActionDispatch
  def test_app(); end

  def test_app=(obj); end
end

class ActionDispatch::ActionableExceptions
  def call(env); end

  def endpoint(); end

  def endpoint=(obj); end

  def initialize(app); end
end

class ActionDispatch::ActionableExceptions
  def self.endpoint(); end

  def self.endpoint=(obj); end
end

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  def html_document(); end
end

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response(type, message=T.unsafe(nil)); end
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Assertions::ResponseAssertions
end

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_recognizes(expected_options, path, extras=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_routing(path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def method_missing(selector, *args, &block); end

  def setup(); end

  def with_routing(); end
end

module ActionDispatch::Assertions::RoutingAssertions
end

module ActionDispatch::Assertions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Callbacks
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _call_callbacks(); end

  def _run_call_callbacks(&block); end

  def call(env); end

  def initialize(app); end
end

class ActionDispatch::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._call_callbacks(); end

  def self._call_callbacks=(value); end

  def self.after(*args, &block); end

  def self.before(*args, &block); end
end

class ActionDispatch::ContentSecurityPolicy
  def base_uri(*sources); end

  def block_all_mixed_content(enabled=T.unsafe(nil)); end

  def build(context=T.unsafe(nil), nonce=T.unsafe(nil), nonce_directives=T.unsafe(nil)); end

  def child_src(*sources); end

  def connect_src(*sources); end

  def default_src(*sources); end

  def directives(); end

  def font_src(*sources); end

  def form_action(*sources); end

  def frame_ancestors(*sources); end

  def frame_src(*sources); end

  def img_src(*sources); end

  def manifest_src(*sources); end

  def media_src(*sources); end

  def object_src(*sources); end

  def plugin_types(*types); end

  def prefetch_src(*sources); end

  def report_uri(uri); end

  def require_sri_for(*types); end

  def sandbox(*values); end

  def script_src(*sources); end

  def style_src(*sources); end

  def upgrade_insecure_requests(enabled=T.unsafe(nil)); end

  def worker_src(*sources); end
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  def call(env); end

  def initialize(app); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ContentSecurityPolicy::Middleware
end

module ActionDispatch::ContentSecurityPolicy::Request
  def content_security_policy(); end

  def content_security_policy=(policy); end

  def content_security_policy_nonce(); end

  def content_security_policy_nonce_directives(); end

  def content_security_policy_nonce_directives=(generator); end

  def content_security_policy_nonce_generator(); end

  def content_security_policy_nonce_generator=(generator); end

  def content_security_policy_report_only(); end

  def content_security_policy_report_only=(value); end
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_DIRECTIVES = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
end

class ActionDispatch::ContentSecurityPolicy
end

class ActionDispatch::Cookies
  def call(env); end

  def initialize(app); end
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
  USE_COOKIES_WITH_METADATA = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::AbstractCookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar); end

  def request(); end
end

class ActionDispatch::Cookies::AbstractCookieJar
end

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted(); end

  def permanent(); end

  def signed(); end

  def signed_or_encrypted(); end
end

module ActionDispatch::Cookies::ChainedCookieJars
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  include ::Enumerable
  def [](name); end

  def []=(name, options); end

  def always_write_cookie(); end

  def always_write_cookie=(obj); end

  def clear(options=T.unsafe(nil)); end

  def commit!(); end

  def committed?(); end

  def delete(name, options=T.unsafe(nil)); end

  def deleted?(name, options=T.unsafe(nil)); end

  def each(&block); end

  def fetch(name, *args, &block); end

  def handle_options(options); end

  def has_key?(name); end

  def initialize(request); end

  def key?(name); end

  def request(); end

  def to_hash(*_); end

  def to_header(); end

  def update(other_hash); end

  def update_cookies_from_jar(); end

  def write(headers); end
  DOMAIN_REGEXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::CookieJar
  def self.always_write_cookie(); end

  def self.always_write_cookie=(obj); end

  def self.build(req, cookies); end
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
end

class ActionDispatch::Cookies::JsonSerializer
end

class ActionDispatch::Cookies::JsonSerializer
  def self.dump(value); end

  def self.load(value); end
end

class ActionDispatch::Cookies::PermanentCookieJar
end

class ActionDispatch::Cookies::PermanentCookieJar
end

module ActionDispatch::Cookies::SerializedCookieJars
  def deserialize(name); end

  def digest(); end

  def needs_migration?(value); end

  def serialize(value); end

  def serializer(); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

module ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
end

class ActionDispatch::Cookies
end

class ActionDispatch::DebugExceptions
  def call(env); end

  def initialize(app, routes_app=T.unsafe(nil), response_format=T.unsafe(nil), interceptors=T.unsafe(nil)); end
end

class ActionDispatch::DebugExceptions
  def self.interceptors(); end

  def self.register_interceptor(object=T.unsafe(nil), &block); end
end

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::DebugView
  def debug_hash(object); end

  def debug_headers(headers); end

  def debug_params(params); end

  def initialize(assigns); end

  def params_valid?(); end

  def protect_against_forgery?(); end

  def render(*_); end
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugView
end

class ActionDispatch::ExceptionWrapper
  def application_trace(); end

  def backtrace_cleaner(); end

  def exception(); end

  def file(); end

  def framework_trace(); end

  def full_trace(); end

  def initialize(backtrace_cleaner, exception); end

  def line_number(); end

  def rescue_responses(); end

  def rescue_responses=(obj); end

  def rescue_template(); end

  def rescue_templates(); end

  def rescue_templates=(obj); end

  def source_extracts(); end

  def source_to_show_id(); end

  def status_code(); end

  def trace_to_show(); end

  def traces(); end

  def unwrapped_exception(); end

  def wrapped_causes(); end

  def wrapper_exceptions(); end

  def wrapper_exceptions=(obj); end
end

class ActionDispatch::ExceptionWrapper
  def self.rescue_responses(); end

  def self.rescue_responses=(obj); end

  def self.rescue_templates(); end

  def self.rescue_templates=(obj); end

  def self.status_code_for_exception(class_name); end

  def self.wrapper_exceptions(); end

  def self.wrapper_exceptions=(obj); end
end

class ActionDispatch::Executor
  def call(env); end

  def initialize(app, executor); end
end

class ActionDispatch::Executor
end

class ActionDispatch::FileHandler
  def call(env); end

  def initialize(root, index: T.unsafe(nil), headers: T.unsafe(nil)); end

  def match?(path); end

  def serve(request); end
end

class ActionDispatch::FileHandler
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash::FlashHash
  include ::Enumerable
  def [](k); end

  def []=(k, v); end

  def alert(); end

  def alert=(message); end

  def clear(); end

  def delete(key); end

  def discard(k=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def initialize(flashes=T.unsafe(nil), discard=T.unsafe(nil)); end

  def keep(k=T.unsafe(nil)); end

  def key?(name); end

  def keys(); end

  def merge!(h); end

  def notice(); end

  def notice=(message); end

  def now(); end

  def now_is_loaded?(); end

  def replace(h); end

  def sweep(); end

  def to_hash(); end

  def to_session_value(); end

  def update(h); end
end

class ActionDispatch::Flash::FlashHash
  def self.from_session_value(value); end
end

class ActionDispatch::Flash::FlashNow
  def [](k); end

  def []=(k, v); end

  def alert=(message); end

  def flash(); end

  def flash=(flash); end

  def initialize(flash); end

  def notice=(message); end
end

class ActionDispatch::Flash::FlashNow
end

module ActionDispatch::Flash::RequestMethods
  def commit_flash(); end

  def flash(); end

  def flash=(flash); end

  def flash_hash(); end

  def reset_session(); end
end

module ActionDispatch::Flash::RequestMethods
end

class ActionDispatch::Flash
  def self.new(app); end
end

class ActionDispatch::HostAuthorization
  def call(env); end

  def initialize(app, hosts, response_app=T.unsafe(nil)); end
  DEFAULT_RESPONSE_APP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization::Permissions
  def allows?(host); end

  def empty?(); end

  def initialize(hosts); end
end

class ActionDispatch::HostAuthorization::Permissions
end

class ActionDispatch::HostAuthorization
end

module ActionDispatch::Http
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end

  def fresh?(response); end

  def if_modified_since(); end

  def if_none_match(); end

  def if_none_match_etags(); end

  def not_modified?(modified_at); end
  HTTP_IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  HTTP_IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Request
end

module ActionDispatch::Http::Cache::Response
  def cache_control(); end

  def date(); end

  def date=(utc_time); end

  def date?(); end

  def etag=(weak_validators); end

  def etag?(); end

  def last_modified(); end

  def last_modified=(utc_time); end

  def last_modified?(); end

  def strong_etag=(strong_validators); end

  def strong_etag?(); end

  def weak_etag=(weak_validators); end

  def weak_etag?(); end
  DATE = ::T.let(nil, ::T.untyped)
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  MUST_REVALIDATE = ::T.let(nil, ::T.untyped)
  NO_CACHE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Response
end

module ActionDispatch::Http::Cache
end

class ActionDispatch::Http::ContentDisposition
  def ascii_filename(); end

  def disposition(); end

  def filename(); end

  def initialize(disposition:, filename:); end

  def utf8_filename(); end
  RFC_5987_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
  TRADITIONAL_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::ContentDisposition
  def self.format(disposition:, filename:); end
end

module ActionDispatch::Http::FilterParameters
  def filtered_env(); end

  def filtered_parameters(); end

  def filtered_path(); end

  def initialize(); end
  ENV_MATCH = ::T.let(nil, ::T.untyped)
  KV_RE = ::T.let(nil, ::T.untyped)
  NULL_ENV_FILTER = ::T.let(nil, ::T.untyped)
  NULL_PARAM_FILTER = ::T.let(nil, ::T.untyped)
  PAIR_RE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
end

module ActionDispatch::Http::FilterRedirect
  def filtered_location(); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
end

class ActionDispatch::Http::Headers
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def add(key, value); end

  def each(&block); end

  def env(); end

  def fetch(key, default=T.unsafe(nil)); end

  def include?(key); end

  def initialize(request); end

  def key?(key); end

  def merge(headers_or_env); end

  def merge!(headers_or_env); end
  CGI_VARIABLES = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::Headers
  def self.from_hash(hash); end
end

module ActionDispatch::Http::MimeNegotiation
  def accepts(); end

  def content_mime_type(); end

  def content_type(); end

  def format(view_path=T.unsafe(nil)); end

  def format=(extension); end

  def formats(); end

  def formats=(extensions); end

  def has_content_type?(); end

  def negotiate_mime(order); end

  def variant(); end

  def variant=(variant); end
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
  RESCUABLE_MIME_FORMAT_ERRORS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  extend ::ActiveSupport::Concern
end

ActionDispatch::Http::ParameterFilter = ActiveSupport::ParameterFilter

module ActionDispatch::Http::Parameters
  def path_parameters(); end

  def path_parameters=(parameters); end
  DEFAULT_PARSERS = ::T.let(nil, ::T.untyped)
  PARAMETERS_KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Parameters
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Http::URL
  def domain(tld_length=T.unsafe(nil)); end

  def host(); end

  def host_with_port(); end

  def initialize(); end

  def optional_port(); end

  def port(); end

  def port_string(); end

  def protocol(); end

  def raw_host_with_port(); end

  def server_port(); end

  def standard_port(); end

  def standard_port?(); end

  def subdomain(tld_length=T.unsafe(nil)); end

  def subdomains(tld_length=T.unsafe(nil)); end

  def tld_length(); end

  def tld_length=(obj); end

  def url(); end
  HOST_REGEXP = ::T.let(nil, ::T.untyped)
  IP_HOST_REGEXP = ::T.let(nil, ::T.untyped)
  PROTOCOL_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  def self.extract_domain(host, tld_length); end

  def self.extract_subdomain(host, tld_length); end

  def self.extract_subdomains(host, tld_length); end

  def self.full_url_for(options); end

  def self.path_for(options); end

  def self.tld_length(); end

  def self.tld_length=(obj); end

  def self.url_for(options); end
end

class ActionDispatch::Http::UploadedFile
  def close(unlink_now=T.unsafe(nil)); end

  def content_type(); end

  def content_type=(content_type); end

  def eof?(); end

  def headers(); end

  def headers=(headers); end

  def initialize(hash); end

  def open(); end

  def original_filename(); end

  def original_filename=(original_filename); end

  def path(); end

  def read(length=T.unsafe(nil), buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def tempfile(); end

  def tempfile=(tempfile); end

  def to_io(); end

  def to_path(); end
end

class ActionDispatch::Http::UploadedFile
end

module ActionDispatch::Http
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::IllegalStateError
end

class ActionDispatch::IllegalStateError
end

module ActionDispatch::Integration
end

module ActionDispatch::Integration::RequestHelpers
  def delete(path, **args); end

  def follow_redirect!(**args); end

  def get(path, **args); end

  def head(path, **args); end

  def patch(path, **args); end

  def post(path, **args); end

  def put(path, **args); end
end

module ActionDispatch::Integration::RequestHelpers
end

module ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  def app(); end

  def assertions(); end

  def assertions=(assertions); end

  def assigns(*args, **options); end

  def before_setup(); end

  def cookies(*args, **options); end

  def copy_session_variables!(); end

  def create_session(app); end

  def default_url_options(); end

  def default_url_options=(options); end

  def delete(*args, **options); end

  def follow_redirect!(*args, **options); end

  def get(*args, **options); end

  def head(*args, **options); end

  def initialize(*args, &blk); end

  def integration_session(); end

  def open_session(); end

  def patch(*args, **options); end

  def post(*args, **options); end

  def put(*args, **options); end

  def remove!(); end

  def reset!(); end

  def root_session(); end

  def root_session=(root_session); end
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration::Runner
end

class ActionDispatch::Integration::Session
  include ::Minitest::Assertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  include ::ActionDispatch::Integration::RequestHelpers
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def accept(); end

  def accept=(accept); end

  def body(*args, &block); end

  def controller(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def headers(*args, &block); end

  def host(); end

  def host!(_); end

  def host=(host); end

  def https!(flag=T.unsafe(nil)); end

  def https?(); end

  def initialize(app); end

  def path(*args, &block); end

  def process(method, path, params: T.unsafe(nil), headers: T.unsafe(nil), env: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def redirect?(*args, &block); end

  def remote_addr(); end

  def remote_addr=(remote_addr); end

  def request(); end

  def request_count(); end

  def request_count=(request_count); end

  def reset!(); end

  def response(); end

  def status(*args, &block); end

  def status_message(*args, &block); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Integration
end

class ActionDispatch::IntegrationTest
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::IntegrationTest::UrlOptions
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActionMailer::TestCase::ClearTestDeliveries
end

module ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  include ::ActionController::TemplateAssertions
  def app(); end

  def document_root_element(); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  def app(); end

  def app=(app); end

  def register_encoder(*args, **options); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::IntegrationTest::Behavior
  extend ::ActiveSupport::Concern
end

module ActionDispatch::IntegrationTest::UrlOptions
  def url_options(); end
end

module ActionDispatch::IntegrationTest::UrlOptions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::IntegrationTest
  extend ::ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::Journey
end

class ActionDispatch::Journey::Format
  def evaluate(hash); end

  def initialize(parts); end
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Format::Parameter
  def escape(value); end

  def escaper(); end

  def escaper=(_); end

  def name(); end

  def name=(_); end
end

class ActionDispatch::Journey::Format::Parameter
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Journey::Format
  def self.required_path(symbol); end

  def self.required_segment(symbol); end
end

class ActionDispatch::Journey::Formatter
  def clear(); end

  def generate(name, options, path_parameters, parameterize=T.unsafe(nil)); end

  def initialize(routes); end

  def routes(); end
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  DEFAULT_INPUT = ::T.let(nil, ::T.untyped)
  DEFAULT_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  def self.===(regex); end
end

class ActionDispatch::Journey::Formatter
end

module ActionDispatch::Journey::GTG
end

class ActionDispatch::Journey::GTG::Builder
  def ast(); end

  def endpoints(); end

  def firstpos(node); end

  def followpos(node); end

  def initialize(root); end

  def lastpos(node); end

  def nullable?(node); end

  def root(); end

  def transition_table(); end
  DUMMY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
end

class ActionDispatch::Journey::GTG::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::GTG::MatchData
end

class ActionDispatch::Journey::GTG::Simulator
  def initialize(transition_table); end

  def memos(string); end

  def tt(); end
end

class ActionDispatch::Journey::GTG::Simulator
end

class ActionDispatch::Journey::GTG::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(from, to, sym); end

  def accepting?(state); end

  def accepting_states(); end

  def add_accepting(state); end

  def add_memo(idx, memo); end

  def eclosure(t); end

  def memo(idx); end

  def memos(); end

  def move(t, a); end

  def states(); end

  def to_svg(); end

  def transitions(); end

  def visualizer(paths, title=T.unsafe(nil)); end
end

class ActionDispatch::Journey::GTG::TransitionTable
end

module ActionDispatch::Journey::GTG
end

module ActionDispatch::Journey::NFA
end

class ActionDispatch::Journey::NFA::Builder
  def initialize(ast); end

  def transition_table(); end
end

class ActionDispatch::Journey::NFA::Builder
end

module ActionDispatch::Journey::NFA::Dot
  def to_dot(); end
end

module ActionDispatch::Journey::NFA::Dot
end

class ActionDispatch::Journey::NFA::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::NFA::MatchData
end

class ActionDispatch::Journey::NFA::Simulator
  def =~(string); end

  def initialize(transition_table); end

  def match(string); end

  def simulate(string); end

  def tt(); end
end

class ActionDispatch::Journey::NFA::Simulator
end

class ActionDispatch::Journey::NFA::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(i, f, s); end

  def accepting(); end

  def accepting=(accepting); end

  def accepting?(state); end

  def accepting_states(); end

  def add_memo(idx, memo); end

  def alphabet(); end

  def eclosure(t); end

  def following_states(t, a); end

  def memo(idx); end

  def memos(); end

  def merge(left, right); end

  def move(t, a); end

  def states(); end

  def transitions(); end
end

class ActionDispatch::Journey::NFA::TransitionTable
end

class ActionDispatch::Journey::NFA::Visitor
  def initialize(tt); end

  def visit_CAT(node); end

  def visit_GROUP(node); end

  def visit_OR(node); end
end

class ActionDispatch::Journey::NFA::Visitor
end

module ActionDispatch::Journey::NFA
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Nodes::Binary
  def children(); end

  def initialize(left, right); end

  def right(); end

  def right=(right); end
end

class ActionDispatch::Journey::Nodes::Binary
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dummy
  def initialize(x=T.unsafe(nil)); end
end

class ActionDispatch::Journey::Nodes::Dummy
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Node
  include ::Enumerable
  def cat?(); end

  def each(&block); end

  def group?(); end

  def initialize(left); end

  def left(); end

  def left=(left); end

  def literal?(); end

  def memo(); end

  def memo=(memo); end

  def name(); end

  def star?(); end

  def symbol?(); end

  def terminal?(); end

  def to_dot(); end

  def to_sym(); end

  def type(); end
end

class ActionDispatch::Journey::Nodes::Node
end

class ActionDispatch::Journey::Nodes::Or
  def children(); end

  def initialize(children); end
end

class ActionDispatch::Journey::Nodes::Or
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Symbol
  def default_regexp?(); end

  def regexp(); end

  def regexp=(regexp); end
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
end

class ActionDispatch::Journey::Nodes::Terminal
  def symbol(); end
end

class ActionDispatch::Journey::Nodes::Terminal
end

class ActionDispatch::Journey::Nodes::Unary
  def children(); end
end

class ActionDispatch::Journey::Nodes::Unary
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Parser
  include ::ActionDispatch::Journey::Nodes
  def _reduce_1(val, _values); end

  def _reduce_10(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def parse(string); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
  def self.parse(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Path::Pattern
  def =~(other); end

  def anchored(); end

  def ast(); end

  def build_formatter(); end

  def eager_load!(); end

  def initialize(ast, requirements, separators, anchored); end

  def match(other); end

  def names(); end

  def optional_names(); end

  def required_names(); end

  def requirements(); end

  def source(); end

  def spec(); end

  def to_regexp(); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def initialize(separator, matchers); end

  def visit_CAT(node); end

  def visit_DOT(node); end

  def visit_GROUP(node); end

  def visit_LITERAL(node); end

  def visit_OR(node); end

  def visit_SLASH(node); end

  def visit_STAR(node); end

  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::MatchData
  def [](x); end

  def captures(); end

  def initialize(names, offsets, match); end

  def length(); end

  def named_captures(); end

  def names(); end

  def post_match(); end
end

class ActionDispatch::Journey::Path::Pattern::MatchData
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern
  def self.build(path, requirements, separators, anchored); end

  def self.from_string(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Route
  def app(); end

  def ast(); end

  def conditions(); end

  def constraints(); end

  def defaults(); end

  def dispatcher?(); end

  def eager_load!(); end

  def format(path_options); end

  def glob?(); end

  def initialize(name, app, path, constraints, required_defaults, defaults, request_method_match, precedence, scope_options, internal=T.unsafe(nil)); end

  def internal(); end

  def ip(); end

  def matches?(request); end

  def name(); end

  def parts(); end

  def path(); end

  def precedence(); end

  def required_default?(key); end

  def required_defaults(); end

  def required_keys(); end

  def required_parts(); end

  def requirements(); end

  def requires_matching_verb?(); end

  def scope_options(); end

  def score(supplied_keys); end

  def segment_keys(); end

  def segments(); end

  def verb(); end
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Route::VerbMatchers::All
end

class ActionDispatch::Journey::Route::VerbMatchers::All
  def self.call(_); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
  def call(request); end

  def initialize(verb); end

  def verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
end

module ActionDispatch::Journey::Route::VerbMatchers
end

class ActionDispatch::Journey::Route
  def self.build(name, app, path, constraints, required_defaults, defaults); end

  def self.verb_matcher(verb); end
end

class ActionDispatch::Journey::Router
  def eager_load!(); end

  def initialize(routes); end

  def recognize(rails_req); end

  def routes(); end

  def routes=(routes); end

  def serve(req); end

  def visualizer(); end
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  def escape_fragment(fragment); end

  def escape_path(path); end

  def escape_segment(segment); end

  def unescape_uri(uri); end
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
end

class ActionDispatch::Journey::Router::Utils
  def self.escape_fragment(fragment); end

  def self.escape_path(path); end

  def self.escape_segment(segment); end

  def self.normalize_path(path); end

  def self.unescape_uri(uri); end
end

class ActionDispatch::Journey::Router
end

class ActionDispatch::Journey::Routes
  include ::Enumerable
  def add_route(name, mapping); end

  def anchored_routes(); end

  def ast(); end

  def clear(); end

  def custom_routes(); end

  def each(&block); end

  def empty?(); end

  def last(); end

  def length(); end

  def partition_route(route); end

  def routes(); end

  def simulator(); end

  def size(); end
end

class ActionDispatch::Journey::Routes
end

class ActionDispatch::Journey::Scanner
  def eos?(); end

  def next_token(); end

  def pos(); end

  def pre_match(); end

  def scan_setup(str); end
end

class ActionDispatch::Journey::Scanner
end

module ActionDispatch::Journey::Visitors
end

class ActionDispatch::Journey::Visitors::Dot
  def accept(node, seed=T.unsafe(nil)); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
end

class ActionDispatch::Journey::Visitors::Each
  def visit(node, block); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  def accept(node, seed); end

  def binary(node, seed); end

  def nary(node, seed); end

  def terminal(node, seed); end

  def unary(node, seed); end

  def visit(node, seed); end

  def visit_CAT(n, seed); end

  def visit_DOT(n, seed); end

  def visit_GROUP(n, seed); end

  def visit_LITERAL(n, seed); end

  def visit_OR(n, seed); end

  def visit_SLASH(n, seed); end

  def visit_STAR(n, seed); end

  def visit_SYMBOL(n, seed); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
end

class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
end

module ActionDispatch::Journey::Visitors
end

module ActionDispatch::Journey
end

class ActionDispatch::MiddlewareStack
  include ::Enumerable
  def [](i); end

  def build(app=T.unsafe(nil), &block); end

  def delete(target); end

  def each(&blk); end

  def initialize(*args); end

  def insert(index, klass, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, klass, *args, &block); end

  def last(); end

  def middlewares(); end

  def middlewares=(middlewares); end

  def size(); end

  def swap(target, *args, &block); end

  def unshift(klass, *args, &block); end

  def use(klass, *args, &block); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def ==(middleware); end

  def args(); end

  def block(); end

  def build(app); end

  def build_instrumented(app); end

  def initialize(klass, args, block); end

  def klass(); end

  def name(); end
end

class ActionDispatch::MiddlewareStack::Middleware
end

class ActionDispatch::MiddlewareStack
end

class ActionDispatch::MissingController
end

class ActionDispatch::MissingController
end

class ActionDispatch::PublicExceptions
  def call(env); end

  def initialize(public_path); end

  def public_path(); end

  def public_path=(public_path); end
end

class ActionDispatch::PublicExceptions
end

class ActionDispatch::Railtie
end

class ActionDispatch::Railtie
end

class ActionDispatch::Reloader
end

class ActionDispatch::Reloader
end

class ActionDispatch::RemoteIp
  def call(env); end

  def check_ip(); end

  def initialize(app, ip_spoofing_check=T.unsafe(nil), custom_proxies=T.unsafe(nil)); end

  def proxies(); end
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RemoteIp::GetIp
  def calculate_ip(); end

  def initialize(req, check_ip, proxies); end
end

class ActionDispatch::RemoteIp::GetIp
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp
end

class ActionDispatch::Request
  include ::Rack::Request::Helpers
  include ::ActionDispatch::Http::Cache::Request
  include ::ActionDispatch::Http::MimeNegotiation
  include ::ActionDispatch::Http::Parameters
  include ::ActionDispatch::Http::FilterParameters
  include ::ActionDispatch::Http::URL
  include ::ActionDispatch::ContentSecurityPolicy::Request
  include ::Rack::Request::Env
  include ::ActionDispatch::Flash::RequestMethods
  def accept(); end

  def accept_charset(); end

  def auth_type(); end

  def authenticated_encrypted_cookie_salt(); end

  def authorization(); end

  def body_stream(); end

  def cache_control(); end

  def client_ip(); end

  def controller_class(); end

  def controller_class_for(name); end

  def controller_instance(); end

  def controller_instance=(controller); end

  def cookie_jar(); end

  def cookie_jar=(jar); end

  def cookies_digest(); end

  def cookies_rotations(); end

  def cookies_serializer(); end

  def encrypted_cookie_cipher(); end

  def encrypted_cookie_salt(); end

  def encrypted_signed_cookie_salt(); end

  def engine_script_name(_routes); end

  def engine_script_name=(name); end

  def from(); end

  def gateway_interface(); end

  def have_cookie_jar?(); end

  def http_auth_salt(); end

  def ignore_accept_header(); end

  def ignore_accept_header=(obj); end

  def key_generator(); end

  def method(); end

  def method_symbol(); end

  def negotiate(); end

  def origin(); end

  def original_script_name(); end

  def path_translated(); end

  def pragma(); end

  def query_parameters(); end

  def raw_post(); end

  def remote_addr(); end

  def remote_host(); end

  def remote_ident(); end

  def remote_ip=(remote_ip); end

  def remote_user(); end

  def request_id=(id); end

  def request_method=(request_method); end

  def request_method_symbol(); end

  def request_parameters(); end

  def request_parameters=(params); end

  def routes(); end

  def routes=(routes); end

  def secret_key_base(); end

  def send_early_hints(links); end

  def server_addr(); end

  def server_protocol(); end

  def server_software(); end

  def session=(session); end

  def session_options=(options); end

  def show_exceptions?(); end

  def signed_cookie_digest(); end

  def signed_cookie_salt(); end

  def use_authenticated_cookie_encryption(); end

  def use_cookies_with_metadata(); end

  def uuid(); end

  def version(); end

  def x_csrf_token(); end

  def x_forwarded_for(); end

  def x_forwarded_host(); end

  def x_request_id(); end

  def xml_http_request?(); end
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request
  def self.empty(); end

  def self.ignore_accept_header(); end

  def self.ignore_accept_header=(obj); end

  def self.parameter_parsers(); end
end

class ActionDispatch::RequestId
  def call(env); end

  def initialize(app); end
  X_REQUEST_ID = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RequestId
end

class ActionDispatch::Response
  include ::Rack::Response::Helpers
  include ::ActionDispatch::Http::FilterRedirect
  include ::ActionDispatch::Http::Cache::Response
  include ::MonitorMixin
  def [](*args, &block); end

  def []=(*args, &block); end

  def _cache_control(); end

  def _cache_control=(v); end

  def abort(); end

  def await_commit(); end

  def await_sent(); end

  def body(); end

  def body=(body); end

  def body_parts(); end

  def charset(); end

  def charset=(charset); end

  def close(); end

  def code(); end

  def commit!(); end

  def committed?(); end

  def cookies(); end

  def default_charset(); end

  def default_charset=(obj); end

  def default_headers(); end

  def default_headers=(obj); end

  def delete_header(key); end

  def each(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil)); end

  def message(); end

  def prepare!(); end

  def redirect_url(); end

  def request(); end

  def request=(request); end

  def reset_body!(); end

  def response_code(); end

  def return_only_media_type_on_content_type(); end

  def return_only_media_type_on_content_type=(obj); end

  def send_file(path); end

  def sending!(); end

  def sending?(); end

  def sending_file=(v); end

  def sent!(); end

  def sent?(); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def status_message(); end

  def stream(); end

  def to_a(); end

  def write(string); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE_PARSER = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  NullContentTypeHeader = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response::Buffer
  def abort(); end

  def body(); end

  def close(); end

  def closed?(); end

  def each(&block); end

  def initialize(response, buf); end

  def write(string); end
end

class ActionDispatch::Response::Buffer
end

class ActionDispatch::Response
  def self.create(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil), default_headers: T.unsafe(nil)); end

  def self.default_charset(); end

  def self.default_charset=(obj); end

  def self.default_headers(); end

  def self.default_headers=(obj); end

  def self.merge_default_headers(original, default); end

  def self.return_only_media_type_on_content_type(); end

  def self.return_only_media_type_on_content_type=(obj); end
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::ConsoleFormatter::Base
  def header(routes); end

  def no_routes(routes, filter); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter::Base
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded
end

class ActionDispatch::Routing::ConsoleFormatter::Sheet
end

class ActionDispatch::Routing::ConsoleFormatter::Sheet
end

module ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::Endpoint
  def app(); end

  def dispatcher?(); end

  def engine?(); end

  def matches?(req); end

  def rack_app(); end

  def redirect?(); end
end

class ActionDispatch::Routing::Endpoint
end

class ActionDispatch::Routing::HtmlTableFormatter
  def header(routes); end

  def initialize(view); end

  def no_routes(*_); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::HtmlTableFormatter
end

class ActionDispatch::Routing::Mapper
  include ::ActionDispatch::Routing::Mapper::Base
  include ::ActionDispatch::Routing::Mapper::HttpHelpers
  include ::ActionDispatch::Routing::Redirection
  include ::ActionDispatch::Routing::Mapper::Scoping
  include ::ActionDispatch::Routing::Mapper::Concerns
  include ::ActionDispatch::Routing::Mapper::Resources
  include ::ActionDispatch::Routing::Mapper::CustomUrls
  def as(scope); end

  def authenticate(scope=T.unsafe(nil), block=T.unsafe(nil)); end

  def authenticated(scope=T.unsafe(nil), block=T.unsafe(nil)); end

  def constraints_for(method_to_apply, scope=T.unsafe(nil), block=T.unsafe(nil)); end

  def devise_confirmation(mapping, controllers); end

  def devise_for(*resources); end

  def devise_omniauth_callback(mapping, controllers); end

  def devise_password(mapping, controllers); end

  def devise_registration(mapping, controllers); end

  def devise_scope(scope); end

  def devise_session(mapping, controllers); end

  def devise_unlock(mapping, controllers); end

  def initialize(set); end

  def raise_no_devise_method_error!(klass); end

  def raise_no_secret_key(); end

  def set_omniauth_path_prefix!(path_prefix); end

  def unauthenticated(scope=T.unsafe(nil)); end

  def with_devise_exclusive_scope(new_path, new_as, options); end
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end

  def default_url_options=(options); end

  def has_named_route?(name); end

  def match(path, options=T.unsafe(nil)); end

  def mount(app, options=T.unsafe(nil)); end

  def with_default_scope(scope, &block); end
end

module ActionDispatch::Routing::Mapper::Base
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable=T.unsafe(nil), &block); end

  def concerns(*args); end
end

module ActionDispatch::Routing::Mapper::Concerns
end

class ActionDispatch::Routing::Mapper::Constraints
  def constraints(); end

  def initialize(app, constraints, strategy); end

  def serve(req); end
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Constraints
end

module ActionDispatch::Routing::Mapper::CustomUrls
  def direct(name, options=T.unsafe(nil), &block); end

  def resolve(*args, &block); end
end

module ActionDispatch::Routing::Mapper::CustomUrls
end

class ActionDispatch::Routing::Mapper::Mapping
  def application(); end

  def ast(); end

  def conditions(); end

  def default_action(); end

  def default_controller(); end

  def defaults(); end

  def initialize(set, ast, defaults, controller, default_action, modyoule, to, formatted, scope_constraints, scope_options, blocks, via, options_constraints, anchor, options); end

  def make_route(name, precedence); end

  def path(); end

  def required_defaults(); end

  def requirements(); end

  def scope_options(); end

  def to(); end
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  def self.build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end

  def self.check_via(via); end

  def self.normalize_path(path, format); end

  def self.optional_format?(path, format); end
end

module ActionDispatch::Routing::Mapper::Resources
  def nested(); end

  def new(); end

  def resources_path_names(options); end
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Resources::Resource
  def actions(); end

  def available_actions(); end

  def collection_name(); end

  def collection_scope(); end

  def controller(); end

  def default_actions(); end

  def initialize(entities, api_only, shallow, options=T.unsafe(nil)); end

  def member_name(); end

  def member_scope(); end

  def name(); end

  def nested_param(); end

  def nested_scope(); end

  def new_scope(new_path); end

  def param(); end

  def path(); end

  def plural(); end

  def resource_scope(); end

  def shallow?(); end

  def shallow_scope(); end

  def singleton?(); end

  def singular(); end
end

class ActionDispatch::Routing::Mapper::Resources::Resource
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
  def initialize(entities, api_only, shallow, options); end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
end

class ActionDispatch::Routing::Mapper::Scope
  include ::Enumerable
  def [](key); end

  def action_name(name_prefix, prefix, collection_name, member_name); end

  def each(&blk); end

  def frame(); end

  def initialize(hash, parent=T.unsafe(nil), scope_level=T.unsafe(nil)); end

  def nested?(); end

  def new(hash); end

  def new_level(level); end

  def null?(); end

  def options(); end

  def parent(); end

  def resource_method_scope?(); end

  def resource_scope?(); end

  def resources?(); end

  def root?(); end

  def scope_level(); end
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
end

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints=T.unsafe(nil)); end

  def controller(controller); end

  def defaults(defaults=T.unsafe(nil)); end

  def namespace(path, options=T.unsafe(nil)); end

  def scope(*args); end
  POISON = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
end

class ActionDispatch::Routing::Mapper
  def self.normalize_name(name); end

  def self.normalize_path(path); end
end

class ActionDispatch::Routing::OptionRedirect
  def options(); end
end

class ActionDispatch::Routing::OptionRedirect
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::PathRedirect
end

module ActionDispatch::Routing::PolymorphicRoutes
  def edit_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def edit_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def polymorphic_path(record_or_hash_or_array, options=T.unsafe(nil)); end

  def polymorphic_url(record_or_hash_or_array, options=T.unsafe(nil)); end
end

module ActionDispatch::Routing::PolymorphicRoutes
end

class ActionDispatch::Routing::Redirect
  def block(); end

  def call(env); end

  def initialize(status, block); end

  def path(params, request); end

  def serve(req); end

  def status(); end
end

class ActionDispatch::Routing::Redirect
end

module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end

module ActionDispatch::Routing::Redirection
end

class ActionDispatch::Routing::RouteSet
  include ::Devise::RouteSet
  def add_polymorphic_mapping(klass, options, &block); end

  def add_route(mapping, name); end

  def add_url_helper(name, options, &block); end

  def api_only?(); end

  def append(&block); end

  def call(env); end

  def clear!(); end

  def default_scope(); end

  def default_scope=(default_scope); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def define_mounted_helper(name, script_namer=T.unsafe(nil)); end

  def disable_clear_and_finalize(); end

  def disable_clear_and_finalize=(disable_clear_and_finalize); end

  def eager_load!(); end

  def empty?(); end

  def env_key(); end

  def extra_keys(options, recall=T.unsafe(nil)); end

  def find_relative_url_root(options); end

  def find_script_name(options); end

  def formatter(); end

  def formatter=(formatter); end

  def generate_extras(options, recall=T.unsafe(nil)); end

  def initialize(config=T.unsafe(nil)); end

  def mounted_helpers(); end

  def named_routes(); end

  def named_routes=(named_routes); end

  def optimize_routes_generation?(); end

  def path_for(options, route_name=T.unsafe(nil)); end

  def polymorphic_mappings(); end

  def prepend(&block); end

  def recognize_path(path, environment=T.unsafe(nil)); end

  def recognize_path_with_request(req, path, extras, raise_on_missing: T.unsafe(nil)); end

  def relative_url_root(); end

  def request_class(); end

  def resources_path_names(); end

  def resources_path_names=(resources_path_names); end

  def router(); end

  def router=(router); end

  def routes(); end

  def set(); end

  def set=(set); end

  def url_for(options, route_name=T.unsafe(nil), url_strategy=T.unsafe(nil)); end

  def url_helpers(supports_path=T.unsafe(nil)); end
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Config
  def api_only(); end

  def api_only=(_); end

  def relative_url_root(); end

  def relative_url_root=(_); end
end

class ActionDispatch::Routing::RouteSet::Config
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
  def block(); end

  def call(t, args, only_path=T.unsafe(nil)); end

  def defaults(); end

  def initialize(name, defaults, &block); end

  def name(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
end

class ActionDispatch::Routing::RouteSet::Dispatcher
  def initialize(raise_on_name_error); end

  def serve(req); end
end

class ActionDispatch::Routing::RouteSet::Dispatcher
end

class ActionDispatch::Routing::RouteSet::Generator
  def controller(); end

  def current_controller(); end

  def different_controller?(); end

  def generate(); end

  def initialize(named_route, options, recall, set); end

  def named_route(); end

  def normalize_controller!(); end

  def normalize_controller_action_id!(); end

  def normalize_options!(); end

  def options(); end

  def recall(); end

  def set(); end

  def use_recall_for(key); end

  def use_relative_controller!(); end
  PARAMETERIZE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Generator
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def main_app(); end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include ::Enumerable
  def [](name); end

  def []=(name, route); end

  def add(name, route); end

  def add_url_helper(name, defaults, &block); end

  def clear(); end

  def clear!(); end

  def each(&blk); end

  def get(name); end

  def helper_names(); end

  def key?(name); end

  def length(); end

  def names(); end

  def path_helpers_module(); end

  def route_defined?(name); end

  def url_helpers_module(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def call(t, args, inner_options); end

  def handle_positional_args(controller_options, inner_options, args, result, path_params); end

  def initialize(route, options, route_name, url_strategy); end

  def route_name(); end

  def url_strategy(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
  def arg_size(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def self.create(route, options, route_name, url_strategy); end

  def self.optimize_helper?(route); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
  def initialize(controller_class); end
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
end

class ActionDispatch::Routing::RouteSet
  def self.default_resources_path_names(); end

  def self.new_with_config(config); end
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def action(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def constraints(); end

  def controller(); end

  def endpoint(); end

  def engine?(); end

  def name(); end

  def path(); end

  def rack_app(); end

  def reqs(); end
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Routing::RoutesInspector
  def format(formatter, filter=T.unsafe(nil)); end

  def initialize(routes); end
end

class ActionDispatch::Routing::RoutesInspector
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def full_url_for(options=T.unsafe(nil)); end

  def initialize(*_); end

  def optimize_routes_generation?(); end

  def route_for(name, *args); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionDispatch::Routing::UrlFor
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Routing
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

module ActionDispatch::Session
end

class ActionDispatch::Session::AbstractSecureStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractSecureStore
end

class ActionDispatch::Session::AbstractStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractStore
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  def generate_sid(); end

  def initialize(app, options=T.unsafe(nil)); end
end

module ActionDispatch::Session::Compatibility
end

class ActionDispatch::Session::CookieStore
  def delete_session(req, session_id, options); end

  def load_session(req); end
end

class ActionDispatch::Session::CookieStore::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value=T.unsafe(nil)); end
end

class ActionDispatch::Session::CookieStore::SessionId
end

class ActionDispatch::Session::CookieStore
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end

  def prepare_session(req); end
end

module ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::SessionRestoreError
  def initialize(); end
end

class ActionDispatch::Session::SessionRestoreError
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end

  def load_session(env); end

  def stale_session_check!(); end
end

module ActionDispatch::Session::StaleSessionCheck
end

module ActionDispatch::Session
end

class ActionDispatch::ShowExceptions
  def call(env); end

  def initialize(app, exceptions_app); end
  FAILSAFE_RESPONSE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ShowExceptions
end

class ActionDispatch::Static
  def call(env); end

  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end
end

class ActionDispatch::Static
end

class ActionDispatch::SystemTestCase
  include ::Capybara::DSL
  include ::Capybara::Minitest::Assertions
  include ::ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  include ::ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  def initialize(*_); end

  def method_missing(method, *args, &block); end
end

class ActionDispatch::SystemTestCase
  def self.driven_by(driver, using: T.unsafe(nil), screen_size: T.unsafe(nil), options: T.unsafe(nil), &capabilities); end

  def self.driver(); end

  def self.driver=(val); end

  def self.driver?(); end

  def self.start_application(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  def take_failed_screenshot(); end

  def take_screenshot(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def host!(host); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
end

module ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def assigns(key=T.unsafe(nil)); end

  def cookies(); end

  def flash(); end

  def redirect_to_url(); end

  def session(); end
end

module ActionDispatch::TestProcess::FixtureFile
  def fixture_file_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end
end

module ActionDispatch::TestProcess::FixtureFile
end

module ActionDispatch::TestProcess
end

class ActionDispatch::TestRequest
  def accept=(mime_types); end

  def action=(action_name); end

  def host=(host); end

  def if_modified_since=(last_modified); end

  def if_none_match=(etag); end

  def path=(path); end

  def port=(number); end

  def remote_addr=(addr); end

  def request_method=(method); end

  def request_uri=(uri); end

  def user_agent=(user_agent); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestRequest
  def self.create(env=T.unsafe(nil)); end
end

class ActionDispatch::TestResponse
  def parsed_body(); end

  def response_parser(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

module ActionDispatch
  extend ::ActiveSupport::Autoload
  def self.test_app(); end

  def self.test_app=(obj); end
end

module ActionMailbox
  def incinerate(); end

  def incinerate=(obj); end

  def incinerate_after(); end

  def incinerate_after=(obj); end

  def ingress(); end

  def ingress=(obj); end

  def logger(); end

  def logger=(obj); end

  def queues(); end

  def queues=(obj); end
end

class ActionMailbox::Base
  include ::ActiveSupport::Rescuable
  include ::ActionMailbox::Routing
  include ::ActiveSupport::Callbacks
  include ::ActionMailbox::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _process_callbacks(); end

  def _run_process_callbacks(&block); end

  def bounce_with(message); end

  def bounced!(*args, &block); end

  def delivered!(*args, &block); end

  def finished_processing?(); end

  def inbound_email(); end

  def initialize(inbound_email); end

  def logger(*args, &block); end

  def mail(*args, &block); end

  def perform_processing(); end

  def process(); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def router(); end

  def router=(obj); end
end

class ActionMailbox::Base
  extend ::ActionMailbox::Routing::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionMailbox::Callbacks::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._process_callbacks(); end

  def self._process_callbacks=(value); end

  def self.receive(inbound_email); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.router(); end

  def self.router=(obj); end
end

class ActionMailbox::BaseController
end

class ActionMailbox::BaseController
end

module ActionMailbox::Callbacks
  TERMINATOR = ::T.let(nil, ::T.untyped)
end

module ActionMailbox::Callbacks::ClassMethods
  def after_processing(*methods, &block); end

  def around_processing(*methods, &block); end

  def before_processing(*methods, &block); end
end

module ActionMailbox::Callbacks::ClassMethods
end

module ActionMailbox::Callbacks
  extend ::ActiveSupport::Concern
end

class ActionMailbox::Engine
end

class ActionMailbox::Engine
end

class ActionMailbox::InboundEmail
  include ::ActionMailbox::InboundEmail::GeneratedAttributeMethods
  include ::ActionMailbox::InboundEmail::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  include ::ActionMailbox::InboundEmail::Routable
  include ::ActionMailbox::InboundEmail::MessageId
  include ::ActionMailbox::InboundEmail::Incineratable
  def autosave_associated_records_for_raw_email_attachment(); end

  def autosave_associated_records_for_raw_email_blob(); end

  def mail(); end

  def processed?(); end

  def source(); end
end

module ActionMailbox::InboundEmail::GeneratedAssociationMethods
  def build_raw_email_attachment(*args, &block); end

  def create_raw_email_attachment(*args, &block); end

  def create_raw_email_attachment!(*args, &block); end

  def raw_email(); end

  def raw_email=(attachable); end

  def raw_email_attachment(); end

  def raw_email_attachment=(value); end

  def raw_email_blob(); end

  def raw_email_blob=(value); end

  def reload_raw_email_attachment(); end

  def reload_raw_email_blob(); end
end

module ActionMailbox::InboundEmail::GeneratedAssociationMethods
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionMailbox::InboundEmail::Incineratable
  def incinerate(); end

  def incinerate_later(); end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
  def initialize(inbound_email); end

  def run(); end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
end

module ActionMailbox::InboundEmail::Incineratable
  extend ::ActiveSupport::Concern
end

module ActionMailbox::InboundEmail::MessageId
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
  def create_and_extract_message_id!(source, **options); end
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
end

module ActionMailbox::InboundEmail::MessageId
  extend ::ActiveSupport::Concern
end

module ActionMailbox::InboundEmail::Routable
  def route(); end

  def route_later(); end
end

module ActionMailbox::InboundEmail::Routable
  extend ::ActiveSupport::Concern
end

class ActionMailbox::InboundEmail
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  extend ::ActionMailbox::InboundEmail::MessageId::ClassMethods
  def self.bounced(*args); end

  def self.delivered(*args); end

  def self.failed(*args); end

  def self.not_bounced(*args); end

  def self.not_delivered(*args); end

  def self.not_failed(*args); end

  def self.not_pending(*args); end

  def self.not_processing(*args); end

  def self.page(num=T.unsafe(nil)); end

  def self.pending(*args); end

  def self.processing(*args); end

  def self.statuses(); end

  def self.with_attached_raw_email(*args); end
end

class ActionMailbox::IncinerationJob
  def perform(inbound_email); end
end

class ActionMailbox::IncinerationJob
  def self.schedule(inbound_email); end
end

module ActionMailbox::Ingresses
end

module ActionMailbox::Ingresses::Mailgun
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(key:, timestamp:, token:, signature:); end

  def key(); end

  def signature(); end

  def timestamp(); end

  def token(); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController::Authenticator
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController
end

module ActionMailbox::Ingresses::Mailgun
end

module ActionMailbox::Ingresses::Mandrill
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController
  def create(); end

  def health_check(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(request, key); end

  def key(); end

  def request(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController::Authenticator
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController
end

module ActionMailbox::Ingresses::Mandrill
end

module ActionMailbox::Ingresses::Postmark
end

class ActionMailbox::Ingresses::Postmark::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Postmark::InboundEmailsController
end

module ActionMailbox::Ingresses::Postmark
end

module ActionMailbox::Ingresses::Relay
end

class ActionMailbox::Ingresses::Relay::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Relay::InboundEmailsController
end

module ActionMailbox::Ingresses::Relay
end

module ActionMailbox::Ingresses::Sendgrid
end

class ActionMailbox::Ingresses::Sendgrid::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Sendgrid::InboundEmailsController
end

module ActionMailbox::Ingresses::Sendgrid
end

module ActionMailbox::Ingresses
end

class ActionMailbox::Router
  def add_route(address, to:); end

  def add_routes(routes); end

  def route(inbound_email); end
end

class ActionMailbox::Router::Route
  def address(); end

  def initialize(address, to:); end

  def mailbox_class(); end

  def mailbox_name(); end

  def match?(inbound_email); end
end

class ActionMailbox::Router::Route
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router
end

module ActionMailbox::Routing
end

module ActionMailbox::Routing::ClassMethods
  def route(inbound_email); end

  def routing(routes); end
end

module ActionMailbox::Routing::ClassMethods
end

module ActionMailbox::Routing
  extend ::ActiveSupport::Concern
end

class ActionMailbox::RoutingJob
  def perform(inbound_email); end
end

class ActionMailbox::RoutingJob
end

class ActionMailbox::TestCase
  include ::ActionMailbox::TestHelper
end

class ActionMailbox::TestCase
end

module ActionMailbox::TestHelper
  def create_inbound_email_from_fixture(fixture_name, status: T.unsafe(nil)); end

  def create_inbound_email_from_mail(status: T.unsafe(nil), **mail_options); end

  def create_inbound_email_from_source(source, status: T.unsafe(nil)); end

  def receive_inbound_email_from_fixture(*args); end

  def receive_inbound_email_from_mail(**kwargs); end

  def receive_inbound_email_from_source(*args); end
end

module ActionMailbox::TestHelper
end

module ActionMailbox
  extend ::ActiveSupport::Autoload
  def self.incinerate(); end

  def self.incinerate=(obj); end

  def self.incinerate_after(); end

  def self.incinerate_after=(obj); end

  def self.ingress(); end

  def self.ingress=(obj); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.queues(); end

  def self.queues=(obj); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class ActionMailer::Base
  include ::ActionMailer::DeliveryMethods
  include ::ActiveSupport::Rescuable
  include ::ActionMailer::Rescuable
  include ::ActionMailer::Parameterized
  include ::ActionMailer::Previews
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::AbstractController::Helpers
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(val); end

  def _view_cache_dependencies?(); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def attachments(); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_params(); end

  def default_params=(val); end

  def default_params?(); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def deliver_later_queue_name(); end

  def deliver_later_queue_name=(obj); end

  def delivery_job(); end

  def delivery_job=(val); end

  def delivery_job?(); end

  def delivery_method(); end

  def delivery_method=(val); end

  def delivery_method?(); end

  def delivery_methods(); end

  def delivery_methods=(val); end

  def delivery_methods?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def file_settings(); end

  def file_settings=(val); end

  def file_settings?(); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(val); end

  def fragment_cache_keys?(); end

  def headers(args=T.unsafe(nil)); end

  def initialize(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def logger(); end

  def logger=(value); end

  def mailer_name(); end

  def message(); end

  def message=(message); end

  def params(); end

  def params=(params); end

  def perform_caching(); end

  def perform_caching=(value); end

  def perform_deliveries(); end

  def perform_deliveries=(obj); end

  def preview_interceptors(); end

  def preview_path(); end

  def process(method_name, *args); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(obj); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def sendmail_settings(); end

  def sendmail_settings=(val); end

  def sendmail_settings?(); end

  def show_previews(); end

  def smtp_settings(); end

  def smtp_settings=(val); end

  def smtp_settings?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def test_settings(); end

  def test_settings=(val); end

  def test_settings?(); end
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base::LateAttachmentsProxy
  def []=(_name, _content); end

  def inline(); end
end

class ActionMailer::Base::LateAttachmentsProxy
end

class ActionMailer::Base::NullMail
  def body(); end

  def header(); end

  def method_missing(*args); end

  def respond_to?(string, include_all=T.unsafe(nil)); end
end

class ActionMailer::Base::NullMail
end

class ActionMailer::Base
  extend ::ActionMailer::DeliveryMethods::ClassMethods
  extend ::ActionMailer::Rescuable::ClassMethods
  extend ::ActionMailer::Parameterized::ClassMethods
  extend ::ActionMailer::Previews::ClassMethods
  extend ::AbstractController::Helpers::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::AbstractController::UrlFor::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default(value=T.unsafe(nil)); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_options=(value=T.unsafe(nil)); end

  def self.default_params(); end

  def self.default_params=(val); end

  def self.default_params?(); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.deliver_later_queue_name(); end

  def self.deliver_later_queue_name=(obj); end

  def self.deliver_mail(mail); end

  def self.delivery_job(); end

  def self.delivery_job=(val); end

  def self.delivery_job?(); end

  def self.delivery_method(); end

  def self.delivery_method=(val); end

  def self.delivery_method?(); end

  def self.delivery_methods(); end

  def self.delivery_methods=(val); end

  def self.delivery_methods?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.file_settings(); end

  def self.file_settings=(val); end

  def self.file_settings?(); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(val); end

  def self.fragment_cache_keys?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mailer_name(); end

  def self.mailer_name=(mailer_name); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.perform_deliveries(); end

  def self.perform_deliveries=(obj); end

  def self.preview_interceptors(); end

  def self.preview_interceptors=(obj); end

  def self.preview_path(); end

  def self.preview_path=(obj); end

  def self.raise_delivery_errors(); end

  def self.raise_delivery_errors=(obj); end

  def self.receive(raw_mail); end

  def self.register_interceptor(interceptor); end

  def self.register_interceptors(*interceptors); end

  def self.register_observer(observer); end

  def self.register_observers(*observers); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.sendmail_settings(); end

  def self.sendmail_settings=(val); end

  def self.sendmail_settings?(); end

  def self.show_previews(); end

  def self.show_previews=(obj); end

  def self.smtp_settings(); end

  def self.smtp_settings=(val); end

  def self.smtp_settings?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.test_settings(); end

  def self.test_settings=(val); end

  def self.test_settings?(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_interceptors(*interceptors); end

  def self.unregister_observer(observer); end

  def self.unregister_observers(*observers); end
end

class ActionMailer::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime, options=T.unsafe(nil)); end

  def initialize(context, &block); end

  def responses(); end
end

class ActionMailer::Collector
end

class ActionMailer::DeliveryJob
  def perform(mailer, mail_method, delivery_method, *args); end
end

class ActionMailer::DeliveryJob
end

module ActionMailer::DeliveryMethods
  def wrap_delivery_behavior!(*args); end
end

module ActionMailer::DeliveryMethods::ClassMethods
  def add_delivery_method(symbol, klass, default_options=T.unsafe(nil)); end

  def deliveries(*args, &block); end

  def deliveries=(arg); end

  def wrap_delivery_behavior(mail, method=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionMailer::DeliveryMethods::ClassMethods
end

module ActionMailer::DeliveryMethods
  extend ::ActiveSupport::Concern
end

class ActionMailer::InlinePreviewInterceptor
  include ::Base64
  def initialize(message); end

  def transform!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  def self.previewing_email(message); end
end

class ActionMailer::LogSubscriber
  def deliver(event); end

  def process(event); end

  def receive(event); end
end

class ActionMailer::LogSubscriber
end

class ActionMailer::MailDeliveryJob
  def perform(mailer, mail_method, delivery_method, args:, kwargs: T.unsafe(nil), params: T.unsafe(nil)); end
end

class ActionMailer::MailDeliveryJob
end

module ActionMailer::MailHelper
  def attachments(); end

  def block_format(text); end

  def format_paragraph(text, len=T.unsafe(nil), indent=T.unsafe(nil)); end

  def mailer(); end

  def message(); end
end

module ActionMailer::MailHelper
end

class ActionMailer::MessageDelivery
  def __setobj__(mail_message); end

  def deliver_later(options=T.unsafe(nil)); end

  def deliver_later!(options=T.unsafe(nil)); end

  def deliver_now(); end

  def deliver_now!(); end

  def initialize(mailer_class, action, *args); end

  def message(); end

  def processed?(); end
end

class ActionMailer::MessageDelivery
end

class ActionMailer::NonInferrableMailerError
  def initialize(name); end
end

class ActionMailer::NonInferrableMailerError
end

module ActionMailer::Parameterized
end

module ActionMailer::Parameterized::ClassMethods
  def with(params); end
end

module ActionMailer::Parameterized::ClassMethods
end

class ActionMailer::Parameterized::DeliveryJob
  def perform(mailer, mail_method, delivery_method, params, *args); end
end

class ActionMailer::Parameterized::DeliveryJob
end

class ActionMailer::Parameterized::Mailer
  def initialize(mailer, params); end
end

class ActionMailer::Parameterized::Mailer
end

class ActionMailer::Parameterized::MessageDelivery
  def initialize(mailer_class, action, params, *args); end
end

class ActionMailer::Parameterized::MessageDelivery
end

module ActionMailer::Parameterized
  extend ::ActiveSupport::Concern
end

class ActionMailer::Preview
  def initialize(params=T.unsafe(nil)); end

  def params(); end
end

class ActionMailer::Preview
  extend ::ActiveSupport::DescendantsTracker
  def self.all(); end

  def self.call(email, params=T.unsafe(nil)); end

  def self.email_exists?(email); end

  def self.emails(); end

  def self.exists?(preview); end

  def self.find(preview); end

  def self.preview_name(); end
end

module ActionMailer::Previews
end

module ActionMailer::Previews::ClassMethods
  def register_preview_interceptor(interceptor); end

  def register_preview_interceptors(*interceptors); end

  def unregister_preview_interceptor(interceptor); end

  def unregister_preview_interceptors(*interceptors); end
end

module ActionMailer::Previews::ClassMethods
end

module ActionMailer::Previews
  extend ::ActiveSupport::Concern
end

class ActionMailer::Railtie
end

class ActionMailer::Railtie
end

module ActionMailer::Rescuable
  def handle_exceptions(); end
end

module ActionMailer::Rescuable::ClassMethods
  def handle_exception(exception); end
end

module ActionMailer::Rescuable::ClassMethods
end

module ActionMailer::Rescuable
  extend ::ActiveSupport::Concern
end

class ActionMailer::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  def _mailer_class(); end

  def _mailer_class=(val); end

  def _mailer_class?(); end
end

module ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
end

module ActionMailer::TestCase::Behavior::ClassMethods
  def determine_default_mailer(name); end

  def mailer_class(); end

  def tests(mailer); end
end

module ActionMailer::TestCase::Behavior::ClassMethods
end

module ActionMailer::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

module ActionMailer::TestCase::ClearTestDeliveries
end

module ActionMailer::TestCase::ClearTestDeliveries
  extend ::ActiveSupport::Concern
end

class ActionMailer::TestCase
  extend ::ActionMailer::TestCase::Behavior::ClassMethods
  def self._mailer_class(); end

  def self._mailer_class=(val); end

  def self._mailer_class?(); end
end

module ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  def assert_emails(number, &block); end

  def assert_enqueued_email_with(mailer, method, args: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_enqueued_emails(number, &block); end

  def assert_no_emails(&block); end

  def assert_no_enqueued_emails(&block); end
end

module ActionMailer::TestHelper
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionMailer::VERSION
end

module ActionMailer
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActionPack
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
end

module ActionPack
  def self.gem_version(); end

  def self.version(); end
end

module ActionText
end

module ActionText::Attachable
  def as_json(*_); end

  def attachable_content_type(); end

  def attachable_filename(); end

  def attachable_filesize(); end

  def attachable_metadata(); end

  def attachable_sgid(); end

  def previewable_attachable?(); end

  def to_rich_text_attributes(attributes=T.unsafe(nil)); end

  def to_trix_content_attachment_partial_path(); end
  LOCATOR_NAME = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable::ClassMethods
  def from_attachable_sgid(sgid); end
end

module ActionText::Attachable::ClassMethods
end

module ActionText::Attachable
  extend ::ActiveSupport::Concern
  def self.from_attachable_sgid(sgid, options=T.unsafe(nil)); end

  def self.from_node(node); end
end

module ActionText::Attachables
end

class ActionText::Attachables::ContentAttachment
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachable_plain_text_representation(caption); end

  def model_name(*args, &block); end

  def name(); end

  def name=(name); end

  def to_trix_content_attachment_partial_path(); end

  def validation_context(); end
end

class ActionText::Attachables::ContentAttachment
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.from_node(node); end
end

module ActionText::Attachables::MissingAttachable
  def model_name(*args, &block); end
end

module ActionText::Attachables::MissingAttachable
  extend ::ActiveModel::Naming
  def self.to_partial_path(); end
end

class ActionText::Attachables::RemoteImage
  def attachable_plain_text_representation(caption); end

  def content_type(); end

  def height(); end

  def initialize(attributes=T.unsafe(nil)); end

  def model_name(*args, &block); end

  def to_partial_path(); end

  def url(); end

  def width(); end
end

class ActionText::Attachables::RemoteImage
  extend ::ActiveModel::Naming
  def self.from_node(node); end
end

module ActionText::Attachables
  extend ::ActiveSupport::Autoload
end

class ActionText::Attachment
  include ::ActionText::Attachments::Caching
  include ::ActionText::Attachments::Minification
  include ::ActionText::Attachments::TrixConversion
  def attachable(); end

  def caption(); end

  def full_attributes(); end

  def initialize(node, attachable); end

  def method_missing(method, *args, &block); end

  def node(); end

  def to_html(); end

  def to_param(*args, &block); end

  def to_plain_text(); end

  def with_full_attributes(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::Attachment
  def self.fragment_by_canonicalizing_attachments(content); end

  def self.from_attachable(attachable, attributes=T.unsafe(nil)); end

  def self.from_attachables(attachables); end

  def self.from_attributes(attributes, attachable=T.unsafe(nil)); end

  def self.from_node(node, attachable=T.unsafe(nil)); end
end

class ActionText::AttachmentGallery
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachments(); end

  def initialize(node); end

  def model_name(*args, &block); end

  def node(); end

  def size(); end

  def validation_context(); end
end

class ActionText::AttachmentGallery
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.find_attachment_gallery_nodes(content); end

  def self.fragment_by_canonicalizing_attachment_galleries(content); end

  def self.fragment_by_replacing_attachment_gallery_nodes(content); end

  def self.from_node(node); end
end

module ActionText::Attachments
end

module ActionText::Attachments::Caching
  def cache_key(*args); end
end

module ActionText::Attachments::Caching
end

module ActionText::Attachments::Minification
end

module ActionText::Attachments::Minification
  extend ::ActiveSupport::Concern
end

module ActionText::Attachments::TrixConversion
  def to_trix_attachment(content=T.unsafe(nil)); end
end

module ActionText::Attachments::TrixConversion
  extend ::ActiveSupport::Concern
end

module ActionText::Attachments
  extend ::ActiveSupport::Autoload
end

module ActionText::Attribute
end

module ActionText::Attribute
  extend ::ActiveSupport::Concern
end

class ActionText::Content
  include ::ActionText::Serialization
  def ==(other); end

  def append_attachables(attachables); end

  def as_json(*_); end

  def attachables(); end

  def attachment_galleries(); end

  def attachments(); end

  def blank?(*args, &block); end

  def empty?(*args, &block); end

  def fragment(); end

  def gallery_attachments(); end

  def html_safe(*args, &block); end

  def initialize(content=T.unsafe(nil), options=T.unsafe(nil)); end

  def links(); end

  def present?(*args, &block); end

  def render_attachment_galleries(&block); end

  def render_attachments(**options, &block); end

  def renderer(); end

  def renderer=(obj); end

  def to_html(); end

  def to_plain_text(); end

  def to_rendered_html_with_layout(); end

  def to_trix_html(); end
end

class ActionText::Content
  extend ::ActionText::Serialization::ClassMethods
  def self.fragment_by_canonicalizing_content(content); end

  def self.renderer(); end

  def self.renderer=(obj); end
end

module ActionText::ContentHelper
  def allowed_attributes(); end

  def allowed_attributes=(obj); end

  def allowed_tags(); end

  def allowed_tags=(obj); end

  def render_action_text_attachments(content); end

  def render_action_text_content(content); end

  def sanitize_action_text_content(content); end

  def sanitizer(); end

  def sanitizer=(obj); end

  def scrubber(); end

  def scrubber=(obj); end
end

module ActionText::ContentHelper
  def self.allowed_attributes(); end

  def self.allowed_attributes=(obj); end

  def self.allowed_tags(); end

  def self.allowed_tags=(obj); end

  def self.sanitizer(); end

  def self.sanitizer=(obj); end

  def self.scrubber(); end

  def self.scrubber=(obj); end
end

class ActionText::Engine
end

class ActionText::Engine
end

class ActionText::Fragment
  def find_all(selector); end

  def initialize(source); end

  def replace(selector); end

  def source(); end

  def to_html(); end

  def to_plain_text(); end

  def update(); end
end

class ActionText::Fragment
  def self.from_html(html); end

  def self.wrap(fragment_or_html); end
end

module ActionText::HtmlConversion
  def create_element(tag_name, attributes=T.unsafe(nil)); end

  def fragment_for_html(html); end

  def node_to_html(node); end
end

module ActionText::HtmlConversion
  extend ::ActionText::HtmlConversion
end

module ActionText::PlainTextConversion
  def node_to_plain_text(node); end
end

module ActionText::PlainTextConversion
  extend ::ActionText::PlainTextConversion
end

class ActionText::RichText
  include ::ActionText::RichText::GeneratedAttributeMethods
  include ::ActionText::RichText::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  def after_add_for_embeds_attachments(); end

  def after_add_for_embeds_attachments=(val); end

  def after_add_for_embeds_attachments?(); end

  def after_add_for_embeds_blobs(); end

  def after_add_for_embeds_blobs=(val); end

  def after_add_for_embeds_blobs?(); end

  def after_remove_for_embeds_attachments(); end

  def after_remove_for_embeds_attachments=(val); end

  def after_remove_for_embeds_attachments?(); end

  def after_remove_for_embeds_blobs(); end

  def after_remove_for_embeds_blobs=(val); end

  def after_remove_for_embeds_blobs?(); end

  def autosave_associated_records_for_embeds_attachments(*args); end

  def autosave_associated_records_for_embeds_blobs(*args); end

  def autosave_associated_records_for_record(*args); end

  def before_add_for_embeds_attachments(); end

  def before_add_for_embeds_attachments=(val); end

  def before_add_for_embeds_attachments?(); end

  def before_add_for_embeds_blobs(); end

  def before_add_for_embeds_blobs=(val); end

  def before_add_for_embeds_blobs?(); end

  def before_remove_for_embeds_attachments(); end

  def before_remove_for_embeds_attachments=(val); end

  def before_remove_for_embeds_attachments?(); end

  def before_remove_for_embeds_blobs(); end

  def before_remove_for_embeds_blobs=(val); end

  def before_remove_for_embeds_blobs?(); end

  def blank?(*args, &block); end

  def empty?(*args, &block); end

  def nil?(*args, &block); end

  def present?(*args, &block); end

  def to_plain_text(); end

  def to_s(*args, &block); end

  def validate_associated_records_for_embeds_attachments(*args); end

  def validate_associated_records_for_embeds_blobs(*args); end
end

module ActionText::RichText::EmbedsAttachmentsAssociationExtension
  def purge(); end

  def purge_later(); end
end

module ActionText::RichText::EmbedsAttachmentsAssociationExtension
end

module ActionText::RichText::GeneratedAssociationMethods
  def embeds(); end

  def embeds=(attachables); end

  def embeds_attachment_ids(); end

  def embeds_attachment_ids=(ids); end

  def embeds_attachments(); end

  def embeds_attachments=(value); end

  def embeds_blob_ids(); end

  def embeds_blob_ids=(ids); end

  def embeds_blobs(); end

  def embeds_blobs=(value); end

  def record(); end

  def record=(value); end

  def reload_record(); end
end

module ActionText::RichText::GeneratedAssociationMethods
end

module ActionText::RichText::GeneratedAttributeMethods
end

module ActionText::RichText::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActionText::RichText
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.after_add_for_embeds_attachments(); end

  def self.after_add_for_embeds_attachments=(val); end

  def self.after_add_for_embeds_attachments?(); end

  def self.after_add_for_embeds_blobs(); end

  def self.after_add_for_embeds_blobs=(val); end

  def self.after_add_for_embeds_blobs?(); end

  def self.after_remove_for_embeds_attachments(); end

  def self.after_remove_for_embeds_attachments=(val); end

  def self.after_remove_for_embeds_attachments?(); end

  def self.after_remove_for_embeds_blobs(); end

  def self.after_remove_for_embeds_blobs=(val); end

  def self.after_remove_for_embeds_blobs?(); end

  def self.before_add_for_embeds_attachments(); end

  def self.before_add_for_embeds_attachments=(val); end

  def self.before_add_for_embeds_attachments?(); end

  def self.before_add_for_embeds_blobs(); end

  def self.before_add_for_embeds_blobs=(val); end

  def self.before_add_for_embeds_blobs?(); end

  def self.before_remove_for_embeds_attachments(); end

  def self.before_remove_for_embeds_attachments=(val); end

  def self.before_remove_for_embeds_attachments?(); end

  def self.before_remove_for_embeds_blobs(); end

  def self.before_remove_for_embeds_blobs=(val); end

  def self.before_remove_for_embeds_blobs?(); end

  def self.page(num=T.unsafe(nil)); end

  def self.with_attached_embeds(*args); end
end

module ActionText::Serialization
  def _dump(*_); end
end

module ActionText::Serialization::ClassMethods
  def _load(content); end

  def dump(content); end

  def load(content); end
end

module ActionText::Serialization::ClassMethods
end

module ActionText::Serialization
  extend ::ActiveSupport::Concern
end

module ActionText::TagHelper
  def rich_text_area_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionText::TagHelper
  def self.id(); end

  def self.id=(obj); end
end

class ActionText::TrixAttachment
  def attributes(); end

  def initialize(node); end

  def node(); end

  def to_html(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
  COMPOSED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::TrixAttachment
  def self.from_attributes(attributes); end
end

module ActionText
  extend ::ActiveSupport::Autoload
  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer
  def any_templates?(*args, &block); end

  def formats(*args, &block); end

  def initialize(lookup_context); end

  def render(); end

  def template_exists?(*args, &block); end
end

class ActionView::AbstractRenderer::RenderedCollection
  def body(); end

  def format(); end

  def initialize(rendered_templates, spacer); end

  def rendered_templates(); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
  def body(); end

  def format(); end

  def initialize(format); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
end

class ActionView::AbstractRenderer::RenderedCollection
  def self.empty(format); end
end

class ActionView::AbstractRenderer::RenderedTemplate
  def body(); end

  def format(); end

  def initialize(body, layout, template); end

  def layout(); end

  def template(); end
  EMPTY_SPACER = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer::RenderedTemplate
end

class ActionView::AbstractRenderer
end

class ActionView::Base
  include ::ActionView::Context
  include ::ERB::Util
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::Kaminari::Helpers::HelperMethods
  include ::Kaminari::Helpers::UrlHelper
  include ::SimpleForm::ActionViewExtensions::FormHelper
  include ::DeviseBootstrapViewsHelper
  include ::ActionCable::Helpers::ActionCableHelper
  include ::Devise::Controllers::UrlHelpers
  include ::Sprockets::Rails::Helper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::Sprockets::Rails::Utils
  def _routes(); end

  def _routes=(val); end

  def _routes?(); end

  def _run(method, template, locals, buffer, &block); end

  def assets_environment(); end

  def assets_environment=(val); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(val); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(val); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def assign(new_assigns); end

  def assigns(); end

  def assigns=(assigns); end

  def automatically_disable_submit_tag(); end

  def automatically_disable_submit_tag=(obj); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(val); end

  def check_precompiled_asset?(); end

  def compiled_method_container(); end

  def config(); end

  def config=(config); end

  def debug_assets(); end

  def debug_assets=(val); end

  def debug_assets?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end

  def default_formats(); end

  def default_formats=(obj); end

  def digest_assets(); end

  def digest_assets=(val); end

  def digest_assets?(); end

  def field_error_proc(); end

  def field_error_proc=(obj); end

  def formats(*args, &block); end

  def formats=(arg); end

  def in_rendering_context(options); end

  def initialize(lookup_context=T.unsafe(nil), assigns=T.unsafe(nil), controller=T.unsafe(nil), formats=T.unsafe(nil)); end

  def locale(*args, &block); end

  def locale=(arg); end

  def logger=(val); end

  def logger?(); end

  def lookup_context(); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(val); end

  def precompiled_asset_checker?(); end

  def prefix_partial_path_with_controller_namespace(); end

  def prefix_partial_path_with_controller_namespace=(obj); end

  def raise_on_missing_translations(); end

  def raise_on_missing_translations=(obj); end

  def resolve_assets_with(); end

  def resolve_assets_with=(val); end

  def resolve_assets_with?(); end

  def streaming_completion_on_exception(); end

  def streaming_completion_on_exception=(obj); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(val); end

  def unknown_asset_fallback?(); end

  def view_paths(*args, &block); end

  def view_paths=(arg); end

  def view_renderer(); end
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  def self._routes(); end

  def self._routes=(val); end

  def self._routes?(); end

  def self.assets_environment(); end

  def self.assets_environment=(val); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(val); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(val); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end

  def self.automatically_disable_submit_tag(); end

  def self.automatically_disable_submit_tag=(obj); end

  def self.build_lookup_context(context); end

  def self.cache_template_loading(); end

  def self.cache_template_loading=(value); end

  def self.changed?(other); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(val); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(val); end

  def self.debug_assets?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end

  def self.default_form_builder(); end

  def self.default_form_builder=(obj); end

  def self.default_formats(); end

  def self.default_formats=(obj); end

  def self.digest_assets(); end

  def self.digest_assets=(val); end

  def self.digest_assets?(); end

  def self.empty(); end

  def self.erb_trim_mode=(arg); end

  def self.field_error_proc(); end

  def self.field_error_proc=(obj); end

  def self.logger(); end

  def self.logger=(val); end

  def self.logger?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(val); end

  def self.precompiled_asset_checker?(); end

  def self.prefix_partial_path_with_controller_namespace(); end

  def self.prefix_partial_path_with_controller_namespace=(obj); end

  def self.raise_on_missing_translations(); end

  def self.raise_on_missing_translations=(obj); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(val); end

  def self.resolve_assets_with?(); end

  def self.streaming_completion_on_exception(); end

  def self.streaming_completion_on_exception=(obj); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(val); end

  def self.unknown_asset_fallback?(); end

  def self.with_context(context, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.with_empty_template_cache(); end

  def self.with_view_paths(view_paths, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.xss_safe?(); end
end

class ActionView::CacheExpiry
  def clear_cache(); end

  def clear_cache_if_necessary(); end

  def initialize(watcher:); end
end

class ActionView::CacheExpiry::Executor
  def before(target); end

  def initialize(watcher:); end
end

class ActionView::CacheExpiry::Executor
end

class ActionView::CacheExpiry
end

module ActionView::CollectionCaching
end

module ActionView::CollectionCaching
  extend ::ActiveSupport::Concern
end

module ActionView::Context
  def _layout_for(name=T.unsafe(nil)); end

  def _prepare_context(); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def view_flow(); end

  def view_flow=(view_flow); end
end

module ActionView::Context
end

class ActionView::DependencyTracker
end

class ActionView::DependencyTracker::ERBTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::ERBTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end

  def self.supports_view_paths?(); end
end

class ActionView::DependencyTracker
  def self.find_dependencies(name, template, view_paths=T.unsafe(nil)); end

  def self.register_tracker(extension, tracker); end

  def self.remove_tracker(handler); end
end

class ActionView::Digestor
end

class ActionView::Digestor::Injected
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Injected
end

class ActionView::Digestor::Missing
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Missing
end

class ActionView::Digestor::Node
  def children(); end

  def dependency_digest(finder, stack); end

  def digest(finder, stack=T.unsafe(nil)); end

  def initialize(name, logical_name, template, children=T.unsafe(nil)); end

  def logical_name(); end

  def name(); end

  def template(); end

  def to_dep_map(); end
end

class ActionView::Digestor::Node
  def self.create(name, logical_name, template, partial); end
end

class ActionView::Digestor::NullLogger
end

class ActionView::Digestor::NullLogger
  def self.debug(_); end

  def self.error(_); end
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor
  def self.digest(name:, finder:, format: T.unsafe(nil), dependencies: T.unsafe(nil)); end

  def self.logger(); end

  def self.tree(name, finder, partial=T.unsafe(nil), seen=T.unsafe(nil)); end
end

class ActionView::FallbackFileSystemResolver
  def build_unbound_template(template, _); end
end

class ActionView::FallbackFileSystemResolver
  def self.instances(); end
end

class ActionView::FileSystemResolver
  def ==(resolver); end

  def eql?(resolver); end

  def initialize(path, pattern=T.unsafe(nil)); end

  def path(); end

  def to_path(); end
end

class ActionView::FileSystemResolver
end

module ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def audio_tag(*sources); end

  def auto_discovery_link_tag(type=T.unsafe(nil), url_options=T.unsafe(nil), tag_options=T.unsafe(nil)); end

  def favicon_link_tag(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_tag(source, options=T.unsafe(nil)); end

  def javascript_include_tag(*sources); end

  def preload_link_tag(source, options=T.unsafe(nil)); end

  def stylesheet_link_tag(*sources); end

  def video_tag(*sources); end
end

module ActionView::Helpers::AssetTagHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::AssetUrlHelper
  def asset_path(source, options=T.unsafe(nil)); end

  def asset_url(source, options=T.unsafe(nil)); end

  def audio_path(source, options=T.unsafe(nil)); end

  def audio_url(source, options=T.unsafe(nil)); end

  def compute_asset_extname(source, options=T.unsafe(nil)); end

  def compute_asset_host(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def compute_asset_path(source, options=T.unsafe(nil)); end

  def font_path(source, options=T.unsafe(nil)); end

  def font_url(source, options=T.unsafe(nil)); end

  def image_path(source, options=T.unsafe(nil)); end

  def image_url(source, options=T.unsafe(nil)); end

  def javascript_path(source, options=T.unsafe(nil)); end

  def javascript_url(source, options=T.unsafe(nil)); end

  def path_to_asset(source, options=T.unsafe(nil)); end

  def path_to_audio(source, options=T.unsafe(nil)); end

  def path_to_font(source, options=T.unsafe(nil)); end

  def path_to_image(source, options=T.unsafe(nil)); end

  def path_to_javascript(source, options=T.unsafe(nil)); end

  def path_to_stylesheet(source, options=T.unsafe(nil)); end

  def path_to_video(source, options=T.unsafe(nil)); end

  def public_compute_asset_path(source, options=T.unsafe(nil)); end

  def stylesheet_path(source, options=T.unsafe(nil)); end

  def stylesheet_url(source, options=T.unsafe(nil)); end

  def url_to_asset(source, options=T.unsafe(nil)); end

  def url_to_audio(source, options=T.unsafe(nil)); end

  def url_to_font(source, options=T.unsafe(nil)); end

  def url_to_image(source, options=T.unsafe(nil)); end

  def url_to_javascript(source, options=T.unsafe(nil)); end

  def url_to_stylesheet(source, options=T.unsafe(nil)); end

  def url_to_video(source, options=T.unsafe(nil)); end

  def video_path(source, options=T.unsafe(nil)); end

  def video_url(source, options=T.unsafe(nil)); end
  ASSET_EXTENSIONS = ::T.let(nil, ::T.untyped)
  ASSET_PUBLIC_DIRECTORIES = ::T.let(nil, ::T.untyped)
  URI_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetUrlHelper
end

module ActionView::Helpers::AtomFeedHelper
  def atom_feed(options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::AtomFeedHelper
end

module ActionView::Helpers::CacheHelper
  def cache(name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_fragment_name(name=T.unsafe(nil), skip_digest: T.unsafe(nil), virtual_path: T.unsafe(nil), digest_path: T.unsafe(nil)); end

  def cache_if(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_unless(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def digest_path_from_template(template); end
end

module ActionView::Helpers::CacheHelper
end

module ActionView::Helpers::CaptureHelper
  def capture(*args); end

  def content_for(name, content=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def content_for?(name); end

  def provide(name, content=T.unsafe(nil), &block); end

  def with_output_buffer(buf=T.unsafe(nil)); end
end

module ActionView::Helpers::CaptureHelper
end

module ActionView::Helpers::ControllerHelper
  def action_name(*args, &block); end

  def assign_controller(controller); end

  def controller(); end

  def controller=(controller); end

  def controller_name(*args, &block); end

  def controller_path(*args, &block); end

  def cookies(*args, &block); end

  def flash(*args, &block); end

  def headers(*args, &block); end

  def logger(); end

  def params(*args, &block); end

  def request(); end

  def request=(request); end

  def request_forgery_protection_token(*args, &block); end

  def respond_to?(method_name, include_private=T.unsafe(nil)); end

  def response(*args, &block); end

  def session(*args, &block); end
  CONTROLLER_DELEGATES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::ControllerHelper
end

module ActionView::Helpers::CspHelper
  def csp_meta_tag(**options); end
end

module ActionView::Helpers::CspHelper
end

module ActionView::Helpers::CsrfHelper
  def csrf_meta_tag(); end

  def csrf_meta_tags(); end
end

module ActionView::Helpers::CsrfHelper
end

module ActionView::Helpers::DateHelper
  def date_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def distance_of_time_in_words(from_time, to_time=T.unsafe(nil), options=T.unsafe(nil)); end

  def distance_of_time_in_words_to_now(from_time, options=T.unsafe(nil)); end

  def select_date(date=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_datetime(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_day(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_hour(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_minute(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_month(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_second(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_time(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_year(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_ago_in_words(from_time, options=T.unsafe(nil)); end

  def time_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_tag(date_or_time, *args, &block); end
  MINUTES_IN_QUARTER_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_THREE_QUARTERS_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_YEAR = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::DateHelper
end

module ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def debug(object); end
end

module ActionView::Helpers::DebugHelper
end

class ActionView::Helpers::FormBuilder
  include ::ActionView::ModelNaming
  include ::SimpleForm::ActionViewExtensions::Builder
  def button(value=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box(method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def collection_check_boxes(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def color_field(method, options=T.unsafe(nil)); end

  def date_field(method, options=T.unsafe(nil)); end

  def date_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_field(method, options=T.unsafe(nil)); end

  def datetime_local_field(method, options=T.unsafe(nil)); end

  def datetime_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def email_field(method, options=T.unsafe(nil)); end

  def emitted_hidden_id?(); end

  def field_helpers(); end

  def field_helpers=(val); end

  def field_helpers?(); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), fields_options=T.unsafe(nil), &block); end

  def file_field(method, options=T.unsafe(nil)); end

  def grouped_collection_select(method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def hidden_field(method, options=T.unsafe(nil)); end

  def index(); end

  def initialize(object_name, object, template, options); end

  def label(method, text=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(method, options=T.unsafe(nil)); end

  def multipart(); end

  def multipart=(multipart); end

  def multipart?(); end

  def number_field(method, options=T.unsafe(nil)); end

  def object(); end

  def object=(object); end

  def object_name(); end

  def object_name=(object_name); end

  def options(); end

  def options=(options); end

  def password_field(method, options=T.unsafe(nil)); end

  def phone_field(method, options=T.unsafe(nil)); end

  def radio_button(method, tag_value, options=T.unsafe(nil)); end

  def range_field(method, options=T.unsafe(nil)); end

  def rich_text_area(method, options=T.unsafe(nil)); end

  def search_field(method, options=T.unsafe(nil)); end

  def select(method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def submit(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field(method, options=T.unsafe(nil)); end

  def text_area(method, options=T.unsafe(nil)); end

  def text_field(method, options=T.unsafe(nil)); end

  def time_field(method, options=T.unsafe(nil)); end

  def time_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_zone_select(method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def to_model(); end

  def to_partial_path(); end

  def url_field(method, options=T.unsafe(nil)); end

  def week_field(method, options=T.unsafe(nil)); end
end

class ActionView::Helpers::FormBuilder
  def self._to_partial_path(); end

  def self.field_helpers(); end

  def self.field_helpers=(val); end

  def self.field_helpers?(); end
end

module ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def check_box(object_name, method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def color_field(object_name, method, options=T.unsafe(nil)); end

  def date_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_local_field(object_name, method, options=T.unsafe(nil)); end

  def default_form_builder(); end

  def default_form_builder=(default_form_builder); end

  def email_field(object_name, method, options=T.unsafe(nil)); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field(object_name, method, options=T.unsafe(nil)); end

  def form_for(record, options=T.unsafe(nil), &block); end

  def form_with(model: T.unsafe(nil), scope: T.unsafe(nil), url: T.unsafe(nil), format: T.unsafe(nil), **options, &block); end

  def form_with_generates_ids(); end

  def form_with_generates_ids=(obj); end

  def form_with_generates_remote_forms(); end

  def form_with_generates_remote_forms=(obj); end

  def hidden_field(object_name, method, options=T.unsafe(nil)); end

  def label(object_name, method, content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(object_name, method, options=T.unsafe(nil)); end

  def number_field(object_name, method, options=T.unsafe(nil)); end

  def password_field(object_name, method, options=T.unsafe(nil)); end

  def phone_field(object_name, method, options=T.unsafe(nil)); end

  def radio_button(object_name, method, tag_value, options=T.unsafe(nil)); end

  def range_field(object_name, method, options=T.unsafe(nil)); end

  def rich_text_area(object_name, method, options=T.unsafe(nil)); end

  def search_field(object_name, method, options=T.unsafe(nil)); end

  def telephone_field(object_name, method, options=T.unsafe(nil)); end

  def text_area(object_name, method, options=T.unsafe(nil)); end

  def text_field(object_name, method, options=T.unsafe(nil)); end

  def time_field(object_name, method, options=T.unsafe(nil)); end

  def url_field(object_name, method, options=T.unsafe(nil)); end

  def week_field(object_name, method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormHelper
  extend ::ActiveSupport::Concern
  def self.form_with_generates_ids(); end

  def self.form_with_generates_ids=(obj); end

  def self.form_with_generates_remote_forms(); end

  def self.form_with_generates_remote_forms=(obj); end
end

module ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def collection_check_boxes(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_options_for_select(grouped_options, selected_key=T.unsafe(nil), options=T.unsafe(nil)); end

  def option_groups_from_collection_for_select(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key=T.unsafe(nil)); end

  def options_for_select(container, selected=T.unsafe(nil)); end

  def options_from_collection_for_select(collection, value_method, text_method, selected=T.unsafe(nil)); end

  def select(object, method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def time_zone_options_for_select(selected=T.unsafe(nil), priority_zones=T.unsafe(nil), model=T.unsafe(nil)); end

  def time_zone_select(object, method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormOptionsHelper
end

module ActionView::Helpers::FormTagHelper
  def button_tag(content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box_tag(name, value=T.unsafe(nil), checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def color_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def date_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_local_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def default_enforce_utf8(); end

  def default_enforce_utf8=(obj); end

  def email_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def embed_authenticity_token_in_remote_forms(); end

  def embed_authenticity_token_in_remote_forms=(obj); end

  def field_set_tag(legend=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field_tag(name, options=T.unsafe(nil)); end

  def form_tag(url_for_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def hidden_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_submit_tag(source, options=T.unsafe(nil)); end

  def label_tag(name=T.unsafe(nil), content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def number_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def password_field_tag(name=T.unsafe(nil), value=T.unsafe(nil), options=T.unsafe(nil)); end

  def phone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def radio_button_tag(name, value, checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def range_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_tag(name, option_tags=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_tag(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_area_tag(name, content=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def time_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def url_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def utf8_enforcer_tag(); end

  def week_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormTagHelper
  extend ::ActiveSupport::Concern
  def self.default_enforce_utf8(); end

  def self.default_enforce_utf8=(obj); end

  def self.embed_authenticity_token_in_remote_forms(); end

  def self.embed_authenticity_token_in_remote_forms=(obj); end
end

module ActionView::Helpers::JavaScriptHelper
  def escape_javascript(javascript); end

  def j(javascript); end

  def javascript_cdata_section(content); end

  def javascript_tag(content_or_options_with_block=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
  JS_ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::JavaScriptHelper
end

module ActionView::Helpers::NumberHelper
  def number_to_currency(number, options=T.unsafe(nil)); end

  def number_to_human(number, options=T.unsafe(nil)); end

  def number_to_human_size(number, options=T.unsafe(nil)); end

  def number_to_percentage(number, options=T.unsafe(nil)); end

  def number_to_phone(number, options=T.unsafe(nil)); end

  def number_with_delimiter(number, options=T.unsafe(nil)); end

  def number_with_precision(number, options=T.unsafe(nil)); end
end

module ActionView::Helpers::NumberHelper
end

module ActionView::Helpers::OutputSafetyHelper
  def raw(stringish); end

  def safe_join(array, sep=T.unsafe(nil)); end

  def to_sentence(array, options=T.unsafe(nil)); end
end

module ActionView::Helpers::OutputSafetyHelper
end

module ActionView::Helpers::RenderingHelper
  def _layout_for(*args, &block); end

  def render(options=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

module ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::SanitizeHelper
  def sanitize(html, options=T.unsafe(nil)); end

  def sanitize_css(style); end

  def strip_links(html); end

  def strip_tags(html); end
end

module ActionView::Helpers::SanitizeHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def cdata_section(content); end

  def content_tag(name, content_or_options_with_block=T.unsafe(nil), options=T.unsafe(nil), escape=T.unsafe(nil), &block); end

  def escape_once(html); end

  def tag(name=T.unsafe(nil), options=T.unsafe(nil), open=T.unsafe(nil), escape=T.unsafe(nil)); end
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  PRE_CONTENT_STRINGS = ::T.let(nil, ::T.untyped)
  TAG_PREFIXES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def concat(string); end

  def current_cycle(name=T.unsafe(nil)); end

  def cycle(first_value, *values); end

  def excerpt(text, phrase, options=T.unsafe(nil)); end

  def highlight(text, phrases, options=T.unsafe(nil)); end

  def pluralize(count, singular, plural_arg=T.unsafe(nil), plural: T.unsafe(nil), locale: T.unsafe(nil)); end

  def reset_cycle(name=T.unsafe(nil)); end

  def safe_concat(string); end

  def simple_format(text, html_options=T.unsafe(nil), options=T.unsafe(nil)); end

  def truncate(text, options=T.unsafe(nil), &block); end

  def word_wrap(text, line_width: T.unsafe(nil), break_sequence: T.unsafe(nil)); end
end

module ActionView::Helpers::TextHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TranslationHelper
  def l(object, **options); end

  def localize(object, **options); end

  def t(key, **options); end

  def translate(key, **options); end
end

module ActionView::Helpers::TranslationHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::UrlHelper
  def _back_url(); end

  def _filtered_referrer(); end

  def button_to(name=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless(condition, name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless_current(name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def mail_to(email_address, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def url_for(options=T.unsafe(nil)); end
  BUTTON_TAG_METHOD_VERBS = ::T.let(nil, ::T.untyped)
  STRINGIFIED_COMMON_METHODS = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::UrlHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

class ActionView::I18nProxy
  def initialize(original_config, lookup_context); end

  def locale=(value); end

  def lookup_context(); end

  def original_config(); end
end

class ActionView::I18nProxy
end

module ActionView::Layouts
  def _layout_conditions(*args, &block); end

  def _normalize_options(options); end

  def action_has_layout=(action_has_layout); end

  def action_has_layout?(); end

  def initialize(*_); end
end

module ActionView::Layouts
  extend ::ActiveSupport::Concern
end

class ActionView::LogSubscriber
  include ::Kaminari::ActionViewExtension::LogSubscriberSilencer
  def render_collection(event); end

  def render_template(event); end
  EMPTY = ::T.let(nil, ::T.untyped)
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionView::LogSubscriber
end

class ActionView::LookupContext
  include ::ActionView::LookupContext::Accessors
  include ::ActionView::LookupContext::DetailsCache
  include ::ActionView::LookupContext::ViewPaths
  def digest_cache(); end

  def fallbacks(); end

  def fallbacks=(obj); end

  def formats=(values); end

  def initialize(view_paths, details=T.unsafe(nil), prefixes=T.unsafe(nil)); end

  def prefixes(); end

  def prefixes=(prefixes); end

  def registered_details(); end

  def registered_details=(obj); end

  def rendered_format(*args, &block); end

  def rendered_format=(*args, &block); end

  def with_prepended_formats(formats); end
end

module ActionView::LookupContext::Accessors
  def default_formats(); end

  def default_handlers(); end

  def default_locale(); end

  def default_variants(); end

  def formats(); end

  def formats=(value); end

  def handlers(); end

  def handlers=(value); end

  def locale(); end

  def locale=(value); end

  def variants(); end

  def variants=(value); end
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::Accessors
end

module ActionView::LookupContext::DetailsCache
  def cache(); end

  def cache=(cache); end

  def details_key(); end

  def disable_cache(); end
end

module ActionView::LookupContext::DetailsCache
end

class ActionView::LookupContext::DetailsKey
end

class ActionView::LookupContext::DetailsKey
  def self.clear(); end

  def self.details_cache_key(details); end

  def self.digest_cache(details); end

  def self.digest_caches(); end

  def self.view_context_class(klass); end
end

module ActionView::LookupContext::ViewPaths
  def any?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def any_templates?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def find(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_all(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_file(*args, &block); end

  def find_template(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def html_fallback_for_js(); end

  def template_exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def view_paths(); end

  def with_fallbacks(); end
end

module ActionView::LookupContext::ViewPaths
end

class ActionView::LookupContext
  def self.fallbacks(); end

  def self.fallbacks=(obj); end

  def self.register_detail(name, &block); end

  def self.registered_details(); end

  def self.registered_details=(obj); end
end

class ActionView::MissingTemplate
  def initialize(paths, path, prefixes, partial, details, *_); end
end

module ActionView::ModelNaming
  def convert_to_model(object); end

  def model_name_from_record_or_class(record_or_class); end
end

module ActionView::ModelNaming
end

class ActionView::OptimizedFileSystemResolver
  def initialize(path); end
end

class ActionView::OptimizedFileSystemResolver
end

class ActionView::OutputBuffer
  def append=(value); end

  def initialize(*_); end

  def safe_append=(value); end

  def safe_expr_append=(val); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

class ActionView::PartialIteration
  def first?(); end

  def index(); end

  def initialize(size); end

  def iterate!(); end

  def last?(); end

  def size(); end
end

class ActionView::PartialIteration
end

class ActionView::PartialRenderer
  include ::ActionView::CollectionCaching
  include ::ActiveRecord::Railties::CollectionCacheAssociationLoading
  def collection_cache(); end

  def collection_cache=(obj); end

  def initialize(*_); end

  def render(context, options, block); end
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

class ActionView::PartialRenderer
  def self.collection_cache(); end

  def self.collection_cache=(obj); end
end

class ActionView::PathResolver
  def initialize(pattern=T.unsafe(nil)); end
  DEFAULT_PATTERN = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class ActionView::PathResolver
end

class ActionView::PathSet
  include ::Enumerable
  def +(array); end

  def <<(*args); end

  def [](*args, &block); end

  def compact(); end

  def concat(*args); end

  def each(*args, &block); end

  def exists?(path, prefixes, *args); end

  def find(*args); end

  def find_all(path, prefixes=T.unsafe(nil), *args); end

  def find_all_with_query(query); end

  def find_file(*args, &block); end

  def include?(*args, &block); end

  def initialize(paths=T.unsafe(nil)); end

  def insert(*args); end

  def paths(); end

  def pop(*args, &block); end

  def push(*args); end

  def size(*args, &block); end

  def to_ary(); end

  def unshift(*args); end
end

class ActionView::PathSet
end

class ActionView::Railtie
  NULL_OPTION = ::T.let(nil, ::T.untyped)
end

class ActionView::Railtie
end

module ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def dom_class(record_or_class, prefix=T.unsafe(nil)); end

  def dom_id(record, prefix=T.unsafe(nil)); end
  JOIN = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
end

module ActionView::RecordIdentifier
  extend ::ActionView::RecordIdentifier
  extend ::ActionView::ModelNaming
end

class ActionView::Renderer
  def cache_hits(); end

  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_partial_to_object(context, options, &block); end

  def render_template(context, options); end

  def render_template_to_object(context, options); end

  def render_to_object(context, options); end
end

class ActionView::Renderer
end

module ActionView::Rendering
  def initialize(); end

  def process(*_); end

  def render_to_body(options=T.unsafe(nil)); end

  def rendered_format(); end

  def view_context(); end

  def view_context_class(); end

  def view_renderer(); end
end

module ActionView::Rendering
  extend ::ActiveSupport::Concern
end

class ActionView::Resolver
  def caching(); end

  def caching=(obj); end

  def caching?(*args, &block); end

  def clear_cache(); end

  def find_all(name, prefix=T.unsafe(nil), partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end

  def find_all_anywhere(*args, &block); end

  def find_all_with_query(query); end
end

class ActionView::Resolver::Cache
  def cache(key, name, prefix, partial, locals); end

  def cache_query(query); end

  def clear(); end

  def size(); end
  KEY_BLOCK = ::T.let(nil, ::T.untyped)
  NAME_BLOCK = ::T.let(nil, ::T.untyped)
  NO_TEMPLATES = ::T.let(nil, ::T.untyped)
  PARTIAL_BLOCK = ::T.let(nil, ::T.untyped)
  PREFIX_BLOCK = ::T.let(nil, ::T.untyped)
end

class ActionView::Resolver::Cache::SmallCache
  def initialize(options=T.unsafe(nil)); end
end

class ActionView::Resolver::Cache::SmallCache
end

class ActionView::Resolver::Cache
end

class ActionView::Resolver::Path
  def initialize(name, prefix, partial, virtual); end

  def name(); end

  def partial(); end

  def partial?(); end

  def prefix(); end

  def to_str(); end

  def virtual(); end
end

class ActionView::Resolver::Path
  def self.build(name, prefix, partial); end
end

class ActionView::Resolver
  def self.caching(); end

  def self.caching=(obj); end

  def self.caching?(); end
end

module ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def default_url_options=(obj); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionView::RoutingUrlFor
  def self.default_url_options=(obj); end
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
  def render_template(view, template, layout_name=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::StreamingTemplateRenderer::Body
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::SyntaxErrorInTemplate
  def initialize(template, offending_code_string); end
end

class ActionView::Template
  def encode!(); end

  def format(); end

  def formats(*args, &block); end

  def formats=(*args, &block); end

  def handler(); end

  def identifier(); end

  def initialize(source, identifier, handler, format: T.unsafe(nil), variant: T.unsafe(nil), locals: T.unsafe(nil), virtual_path: T.unsafe(nil), updated_at: T.unsafe(nil)); end

  def locals(); end

  def locals=(*args, &block); end

  def marshal_dump(); end

  def marshal_load(array); end

  def original_encoding(*args, &block); end

  def refresh(*args, &block); end

  def render(view, locals, buffer=T.unsafe(nil), &block); end

  def short_identifier(); end

  def source(); end

  def supports_streaming?(); end

  def type(); end

  def updated_at(*args, &block); end

  def variable(); end

  def variant(); end

  def variants(*args, &block); end

  def variants=(*args, &block); end

  def virtual_path(); end

  def virtual_path=(*args, &block); end
end

class ActionView::Template::Error
  def annotated_source_code(); end

  def file_name(); end

  def initialize(template); end

  def line_number(); end

  def source_extract(indentation=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::HTML
  def format(); end

  def formats(*args, &block); end

  def identifier(); end

  def initialize(string, type=T.unsafe(nil)); end

  def render(*args); end

  def to_str(); end

  def type(); end
end

class ActionView::Template::HTML
end

module ActionView::Template::Handlers
  def handler_for_extension(extension); end

  def register_default_template_handler(extension, klass); end

  def register_template_handler(*extensions, handler); end

  def registered_template_handler(extension); end

  def template_handler_extensions(); end

  def unregister_template_handler(*extensions); end
end

class ActionView::Template::Handlers::Builder
  def call(template, source); end

  def default_format(); end

  def default_format=(val); end

  def default_format?(); end
end

class ActionView::Template::Handlers::Builder
  def self.default_format(); end

  def self.default_format=(val); end

  def self.default_format?(); end
end

class ActionView::Template::Handlers::ERB
  def call(template, source); end

  def erb_implementation(); end

  def erb_implementation=(val); end

  def erb_implementation?(); end

  def erb_trim_mode(); end

  def erb_trim_mode=(val); end

  def erb_trim_mode?(); end

  def escape_ignore_list(); end

  def escape_ignore_list=(val); end

  def escape_ignore_list?(); end

  def escape_whitelist(*args, &block); end

  def escape_whitelist=(*args, &block); end

  def handles_encoding?(); end

  def supports_streaming?(); end
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  def evaluate(action_view_erb_handler_context); end
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
end

class ActionView::Template::Handlers::ERB
  def self.call(template, source); end

  def self.erb_implementation(); end

  def self.erb_implementation=(val); end

  def self.erb_implementation?(); end

  def self.erb_trim_mode(); end

  def self.erb_trim_mode=(val); end

  def self.erb_trim_mode?(); end

  def self.escape_ignore_list(); end

  def self.escape_ignore_list=(val); end

  def self.escape_ignore_list?(); end

  def self.escape_whitelist(*args, &block); end

  def self.escape_whitelist=(*args, &block); end
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::LegacyHandlerWrapper
  def call(view, source); end
end

class ActionView::Template::Handlers::LegacyHandlerWrapper
end

class ActionView::Template::Handlers::Raw
  def call(template, source); end
end

class ActionView::Template::Handlers::Raw
end

module ActionView::Template::Handlers
  def self.extended(base); end

  def self.extensions(); end
end

class ActionView::Template::Inline
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Inline
end

class ActionView::Template::LegacyTemplate
  def initialize(template, source); end

  def source(); end
end

class ActionView::Template::LegacyTemplate
end

class ActionView::Template::RawFile
  def format(); end

  def format=(format); end

  def formats(*args, &block); end

  def identifier(); end

  def initialize(filename); end

  def render(*args); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::RawFile
end

module ActionView::Template::Sources
end

class ActionView::Template::Sources::File
  def initialize(filename); end
end

class ActionView::Template::Sources::File
end

module ActionView::Template::Sources
  extend ::ActiveSupport::Autoload
end

class ActionView::Template::Text
  def format(); end

  def formats(*args, &block); end

  def identifier(); end

  def initialize(string); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Text
end

class ActionView::Template::Types
  def type_klass(); end

  def type_klass=(obj); end
end

class ActionView::Template::Types::Type
  def ==(type); end

  def initialize(symbol); end

  def ref(); end

  def symbol(); end

  def to_str(); end

  def to_sym(); end
  SET = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Types::Type
  def self.[](type); end
end

class ActionView::Template::Types
  def self.[](type); end

  def self.delegate_to(klass); end

  def self.symbols(); end

  def self.type_klass(); end

  def self.type_klass=(obj); end
end

class ActionView::Template
  extend ::ActiveSupport::Autoload
  extend ::ActionView::Template::Handlers
  def self.finalize_compiled_template_methods(); end

  def self.finalize_compiled_template_methods=(_); end
end

class ActionView::TemplateRenderer
  def render(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::TestCase
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  include ::AbstractController::Helpers
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def config(); end

  def controller(); end

  def controller=(controller); end

  def lookup_context(*args, &block); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def rendered(); end

  def rendered=(rendered); end

  def rendered_views(); end

  def setup_with_controller(); end
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::TestCase::Behavior::ClassMethods
  def determine_default_helper_class(name); end

  def helper_class(); end

  def helper_class=(helper_class); end

  def helper_method(*methods); end

  def new(*_); end

  def tests(helper_class); end
end

module ActionView::TestCase::Behavior::ClassMethods
end

module ActionView::TestCase::Behavior::Locals
  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil)); end

  def rendered_views(); end

  def rendered_views=(rendered_views); end
end

module ActionView::TestCase::Behavior::Locals
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
  def add(view, locals); end

  def locals_for(view); end

  def rendered_views(); end

  def view_rendered?(view, expected_locals); end
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
end

module ActionView::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionView::TestCase::TestController
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def controller_path=(path); end

  def initialize(); end

  def params=(params); end
end

class ActionView::TestCase::TestController
  def self.controller_path=(controller_path); end
end

class ActionView::TestCase
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionView::TestCase::Behavior::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end
end

class ActionView::UnboundTemplate
  def bind_locals(locals); end

  def initialize(source, identifer, handler, options); end
end

class ActionView::UnboundTemplate
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView::VERSION
end

module ActionView::ViewPaths
  def _prefixes(); end

  def any_templates?(*args, &block); end

  def append_view_path(path); end

  def details_for_lookup(); end

  def formats(*args, &block); end

  def formats=(arg); end

  def locale(*args, &block); end

  def locale=(arg); end

  def lookup_context(); end

  def prepend_view_path(path); end

  def template_exists?(*args, &block); end

  def view_paths(*args, &block); end
end

module ActionView::ViewPaths
  extend ::ActiveSupport::Concern
  def self.all_view_paths(); end

  def self.get_view_paths(klass); end

  def self.set_view_paths(klass, paths); end
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

module ActionView
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveJob
end

module ActiveJob::Arguments
  def deserialize(arguments); end

  def serialize(arguments); end
  OBJECT_SERIALIZER_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Arguments
  extend ::ActiveJob::Arguments
end

class ActiveJob::Base
  include ::ActiveJob::Core
  include ::ActiveJob::QueueAdapter
  include ::ActiveJob::QueueName
  include ::ActiveJob::QueuePriority
  include ::ActiveJob::Enqueuing
  include ::ActiveSupport::Rescuable
  include ::ActiveJob::Execution
  include ::ActiveSupport::Callbacks
  include ::ActiveJob::Callbacks
  include ::ActiveJob::Exceptions
  include ::ActiveJob::Logging
  include ::ActiveJob::Timezones
  include ::ActiveJob::Translation
  include ::Sidekiq::Worker::Options
  include ::ActiveJob::TestHelper::TestQueueAdapter
  def __callbacks(); end

  def __callbacks?(); end

  def _enqueue_callbacks(); end

  def _perform_callbacks(); end

  def _run_enqueue_callbacks(&block); end

  def _run_perform_callbacks(&block); end

  def logger(); end

  def logger=(obj); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ActiveJob::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._enqueue_callbacks(); end

  def self._enqueue_callbacks=(value); end

  def self._perform_callbacks(); end

  def self._perform_callbacks=(value); end

  def self._queue_adapter(); end

  def self._queue_adapter=(val); end

  def self._queue_adapter_name(); end

  def self._queue_adapter_name=(val); end

  def self._test_adapter(); end

  def self._test_adapter=(val); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.priority(); end

  def self.priority=(val); end

  def self.priority?(); end

  def self.queue_name(); end

  def self.queue_name=(val); end

  def self.queue_name?(); end

  def self.queue_name_delimiter(); end

  def self.queue_name_delimiter=(val); end

  def self.queue_name_delimiter?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.return_false_on_aborted_enqueue(); end

  def self.return_false_on_aborted_enqueue=(val); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

module ActiveJob::Callbacks
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Callbacks
  def self.__callbacks(); end

  def self.__callbacks?(); end

  def self._execute_callbacks(); end

  def self._run_execute_callbacks(&block); end
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_later(*args); end

  def perform_now(*args); end
end

class ActiveJob::ConfiguredJob
end

module ActiveJob::Core
  def arguments(); end

  def arguments=(arguments); end

  def deserialize(job_data); end

  def enqueued_at(); end

  def enqueued_at=(enqueued_at); end

  def exception_executions(); end

  def exception_executions=(exception_executions); end

  def executions(); end

  def executions=(executions); end

  def initialize(*arguments); end

  def job_id(); end

  def job_id=(job_id); end

  def locale(); end

  def locale=(locale); end

  def priority=(priority); end

  def provider_job_id(); end

  def provider_job_id=(provider_job_id); end

  def queue_name=(queue_name); end

  def scheduled_at(); end

  def scheduled_at=(scheduled_at); end

  def serialize(); end

  def serialized_arguments=(serialized_arguments); end

  def timezone(); end

  def timezone=(timezone); end
end

module ActiveJob::Core
  extend ::ActiveSupport::Concern
end

class ActiveJob::DeserializationError
  def initialize(); end
end

class ActiveJob::DeserializationError
end

module ActiveJob::Enqueuing
  def enqueue(options=T.unsafe(nil)); end
end

module ActiveJob::Enqueuing
  extend ::ActiveSupport::Concern
end

module ActiveJob::Exceptions
  def retry_job(options=T.unsafe(nil)); end
end

module ActiveJob::Exceptions
  extend ::ActiveSupport::Concern
end

module ActiveJob::Execution
  def perform(*_); end

  def perform_now(); end
end

module ActiveJob::Execution
  extend ::ActiveSupport::Concern
end

module ActiveJob::Logging
end

module ActiveJob::Logging
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueueAdapter
end

module ActiveJob::QueueAdapter
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueueAdapters
end

class ActiveJob::QueueAdapters::AsyncAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def immediate=(immediate); end

  def initialize(**executor_options); end

  def shutdown(wait: T.unsafe(nil)); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
  def initialize(job); end

  def perform(); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
  def enqueue(job, queue_name:); end

  def enqueue_at(job, timestamp, queue_name:); end

  def executor(); end

  def immediate(); end

  def immediate=(immediate); end

  def initialize(**options); end

  def shutdown(wait: T.unsafe(nil)); end
  DEFAULT_EXECUTOR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
end

class ActiveJob::QueueAdapters::AsyncAdapter
end

class ActiveJob::QueueAdapters::InlineAdapter
  def enqueue(job); end

  def enqueue_at(*_); end
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::SidekiqAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end
end

class ActiveJob::QueueAdapters::SidekiqAdapter::JobWrapper
  include ::Sidekiq::Worker
  include ::Sidekiq::Worker::Options
  def perform(job_data); end

  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ActiveJob::QueueAdapters::SidekiqAdapter::JobWrapper
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class ActiveJob::QueueAdapters::SidekiqAdapter
end

class ActiveJob::QueueAdapters::TestAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def filter(); end

  def filter=(filter); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end

  def queue(); end

  def queue=(queue); end

  def reject(); end

  def reject=(reject); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

module ActiveJob::QueueAdapters
  extend ::ActiveSupport::Autoload
  def self.lookup(name); end
end

module ActiveJob::QueueName
  def queue_name(); end
end

module ActiveJob::QueueName
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueuePriority
  def priority(); end
end

module ActiveJob::QueuePriority
  extend ::ActiveSupport::Concern
end

class ActiveJob::Railtie
end

class ActiveJob::Railtie
end

class ActiveJob::SerializationError
end

class ActiveJob::SerializationError
end

module ActiveJob::Serializers
  def _additional_serializers(); end

  def _additional_serializers=(obj); end
end

class ActiveJob::Serializers::DateSerializer
  def deserialize(hash); end

  def serialize(date); end
end

class ActiveJob::Serializers::DateSerializer
end

class ActiveJob::Serializers::DateTimeSerializer
  def deserialize(hash); end

  def serialize(time); end
end

class ActiveJob::Serializers::DateTimeSerializer
end

class ActiveJob::Serializers::DurationSerializer
  def deserialize(hash); end

  def serialize(duration); end
end

class ActiveJob::Serializers::DurationSerializer
end

class ActiveJob::Serializers::ObjectSerializer
  include ::Singleton
  def deserialize(_argument); end

  def serialize(hash); end

  def serialize?(argument); end
end

class ActiveJob::Serializers::ObjectSerializer
  extend ::Singleton::SingletonClassMethods
  def self.deserialize(*args, &block); end

  def self.instance(); end

  def self.serialize(*args, &block); end

  def self.serialize?(*args, &block); end
end

class ActiveJob::Serializers::SymbolSerializer
  def deserialize(argument); end

  def serialize(argument); end
end

class ActiveJob::Serializers::SymbolSerializer
end

class ActiveJob::Serializers::TimeSerializer
  def deserialize(hash); end

  def serialize(time); end
end

class ActiveJob::Serializers::TimeSerializer
end

class ActiveJob::Serializers::TimeWithZoneSerializer
  def deserialize(hash); end

  def serialize(time); end
end

class ActiveJob::Serializers::TimeWithZoneSerializer
end

module ActiveJob::Serializers
  extend ::ActiveSupport::Autoload
  def self._additional_serializers(); end

  def self._additional_serializers=(obj); end

  def self.add_serializers(*new_serializers); end

  def self.deserialize(argument); end

  def self.serialize(argument); end

  def self.serializers(); end
end

class ActiveJob::TestCase
  include ::ActiveJob::TestHelper
end

class ActiveJob::TestCase
end

module ActiveJob::TestHelper
  def after_teardown(); end

  def assert_enqueued_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil)); end

  def assert_enqueued_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil)); end

  def assert_no_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_no_performed_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def before_setup(); end

  def enqueued_jobs(*args, &block); end

  def enqueued_jobs=(arg); end

  def perform_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil)); end

  def performed_jobs(*args, &block); end

  def performed_jobs=(arg); end

  def queue_adapter(); end

  def queue_adapter_for_test(); end
end

module ActiveJob::TestHelper::TestQueueAdapter
end

module ActiveJob::TestHelper::TestQueueAdapter
  extend ::ActiveSupport::Concern
end

module ActiveJob::TestHelper
end

module ActiveJob::Timezones
end

module ActiveJob::Timezones
  extend ::ActiveSupport::Concern
end

module ActiveJob::Translation
end

module ActiveJob::Translation
  extend ::ActiveSupport::Concern
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::VERSION
end

module ActiveJob
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

class ActiveModel::Attribute
  def ==(other); end

  def came_from_user?(); end

  def changed?(); end

  def changed_in_place?(); end

  def encode_with(coder); end

  def eql?(other); end

  def forgetting_assignment(); end

  def has_been_read?(); end

  def init_with(coder); end

  def initialize(name, value_before_type_cast, type, original_attribute=T.unsafe(nil)); end

  def initialized?(); end

  def name(); end

  def original_value(); end

  def original_value_for_database(); end

  def type(); end

  def type_cast(*_); end

  def value(); end

  def value_before_type_cast(); end

  def value_for_database(); end

  def with_cast_value(value); end

  def with_type(type); end

  def with_value_from_database(value); end

  def with_value_from_user(value); end
end

class ActiveModel::Attribute::FromUser
  def type_cast(value); end
end

class ActiveModel::Attribute::FromUser
end

class ActiveModel::Attribute::UserProvidedDefault
  def initialize(name, value, type, database_default); end

  def marshal_dump(); end

  def marshal_load(values); end
end

class ActiveModel::Attribute::UserProvidedDefault
end

class ActiveModel::Attribute
  def self.from_database(name, value, type); end

  def self.from_user(name, value, type, original_attribute=T.unsafe(nil)); end

  def self.null(name); end

  def self.uninitialized(name, type); end

  def self.with_cast_value(name, value, type); end
end

module ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def assign_attributes(new_attributes); end

  def attributes=(new_attributes); end
end

module ActiveModel::AttributeAssignment
end

module ActiveModel::AttributeMethods
  def attribute_missing(match, *args, &block); end

  def method_missing(method, *args, &block); end

  def respond_to?(method, include_private_methods=T.unsafe(nil)); end

  def respond_to_without_attributes?(*_); end
  CALL_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
  NAME_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActiveModel::AttributeMethods
  extend ::ActiveSupport::Concern
end

class ActiveModel::AttributeMutationTracker
  def any_changes?(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, from: T.unsafe(nil), to: T.unsafe(nil)); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def force_change(attr_name); end

  def forget_change(attr_name); end

  def initialize(attributes, forced_changes=T.unsafe(nil)); end

  def original_value(attr_name); end
  OPTION_NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

class ActiveModel::AttributeMutationTracker
end

class ActiveModel::AttributeSet
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def accessed(); end

  def attributes(); end

  def each_value(*args, &block); end

  def except(*args, &block); end

  def fetch(*args, &block); end

  def fetch_value(name, &block); end

  def initialize(attributes); end

  def key?(name); end

  def keys(); end

  def map(&block); end

  def reset(key); end

  def to_h(); end

  def to_hash(); end

  def values_before_type_cast(); end

  def write_cast_value(name, value); end

  def write_from_database(name, value); end

  def write_from_user(name, value); end
end

class ActiveModel::AttributeSet::Builder
  def build_from_database(values=T.unsafe(nil), additional_types=T.unsafe(nil)); end

  def default_attributes(); end

  def initialize(types, default_attributes=T.unsafe(nil)); end

  def types(); end
end

class ActiveModel::AttributeSet::Builder
end

class ActiveModel::AttributeSet::YAMLEncoder
  def decode(coder); end

  def encode(attribute_set, coder); end

  def initialize(default_types); end
end

class ActiveModel::AttributeSet::YAMLEncoder
end

class ActiveModel::AttributeSet
end

module ActiveModel::Attributes
  def attribute_names(); end

  def attributes(); end

  def initialize(*_); end
end

module ActiveModel::Attributes::ClassMethods
  def attribute(name, type=T.unsafe(nil), **options); end

  def attribute_names(); end
end

module ActiveModel::Attributes::ClassMethods
end

module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
end

class ActiveModel::BlockValidator
  def initialize(options, &block); end
end

class ActiveModel::BlockValidator
end

module ActiveModel::Callbacks
  def define_model_callbacks(*callbacks); end
end

module ActiveModel::Callbacks
  def self.extended(base); end
end

module ActiveModel::Conversion
  def to_key(); end

  def to_model(); end

  def to_param(); end

  def to_partial_path(); end
end

module ActiveModel::Conversion
  extend ::ActiveSupport::Concern
end

module ActiveModel::Dirty
  def attribute_was(attr_name); end

  def changed(); end

  def changed_attributes(); end

  def changes(); end

  def changes_applied(); end

  def clear_attribute_changes(attr_names); end

  def clear_changes_information(); end

  def previous_changes(); end

  def restore_attributes(attr_names=T.unsafe(nil)); end
end

module ActiveModel::Dirty
  extend ::ActiveSupport::Concern
end

class ActiveModel::EachValidator
  def attributes(); end

  def check_validity!(); end

  def initialize(options); end

  def validate_each(record, attribute, value); end
end

class ActiveModel::EachValidator
end

class ActiveModel::Errors
  include ::Enumerable
  def [](attribute); end

  def clear(); end

  def copy!(other); end

  def count(); end

  def delete(key); end

  def details(); end

  def each(&blk); end

  def empty?(); end

  def full_message(attribute, message); end

  def full_messages_for(attribute); end

  def generate_message(attribute, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def has_key?(attribute); end

  def include?(attribute); end

  def init_with(coder); end

  def initialize(base); end

  def key?(attribute); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(array); end

  def merge!(other); end

  def messages(); end

  def size(); end

  def slice!(*keys); end

  def to_a(); end

  def to_hash(full_messages=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def values(); end
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
  MESSAGE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Errors
  def self.i18n_customize_full_message(); end

  def self.i18n_customize_full_message=(i18n_customize_full_message); end
end

class ActiveModel::ForbiddenAttributesError
end

class ActiveModel::ForbiddenAttributesError
end

module ActiveModel::ForbiddenAttributesProtection
end

module ActiveModel::ForbiddenAttributesProtection
end

class ActiveModel::ForcedMutationTracker
  def finalize_changes(); end
end

class ActiveModel::ForcedMutationTracker
end

class ActiveModel::LazyAttributeHash
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def each_key(*args, &block); end

  def each_value(*args, &block); end

  def except(*args, &block); end

  def fetch(*args, &block); end

  def initialize(types, values, additional_types, default_attributes, delegate_hash=T.unsafe(nil)); end

  def key?(key); end

  def marshal_dump(); end

  def marshal_load(values); end

  def materialize(); end

  def select(); end

  def transform_values(*args, &block); end
end

class ActiveModel::LazyAttributeHash
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
end

module ActiveModel::Lint
end

class ActiveModel::MissingAttributeError
end

class ActiveModel::MissingAttributeError
end

module ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(attributes=T.unsafe(nil)); end

  def persisted?(); end
end

module ActiveModel::Model
  extend ::ActiveSupport::Concern
end

class ActiveModel::Name
  include ::Comparable
  def !~(*args, &block); end

  def ==(arg); end

  def ===(arg); end

  def =~(*args, &block); end

  def as_json(*args, &block); end

  def cache_key(); end

  def collection(); end

  def element(); end

  def eql?(*args, &block); end

  def human(options=T.unsafe(nil)); end

  def i18n_key(); end

  def initialize(klass, namespace=T.unsafe(nil), name=T.unsafe(nil)); end

  def match?(*args, &block); end

  def name(); end

  def param_key(); end

  def plural(); end

  def route_key(); end

  def singular(); end

  def singular_route_key(); end

  def to_s(*args, &block); end

  def to_str(*args, &block); end
end

class ActiveModel::Name
end

module ActiveModel::Naming
  def model_name(); end
end

module ActiveModel::Naming
  def self.extended(base); end

  def self.param_key(record_or_class); end

  def self.plural(record_or_class); end

  def self.route_key(record_or_class); end

  def self.singular(record_or_class); end

  def self.singular_route_key(record_or_class); end

  def self.uncountable?(record_or_class); end
end

class ActiveModel::NullMutationTracker
  include ::Singleton
  def any_changes?(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, **_); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def original_value(attr_name); end
end

class ActiveModel::NullMutationTracker
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class ActiveModel::Railtie
end

class ActiveModel::Railtie
end

class ActiveModel::RangeError
end

class ActiveModel::RangeError
end

module ActiveModel::SecurePassword
  MAX_PASSWORD_LENGTH_ALLOWED = ::T.let(nil, ::T.untyped)
end

module ActiveModel::SecurePassword
  extend ::ActiveSupport::Concern
  def self.min_cost(); end

  def self.min_cost=(min_cost); end
end

module ActiveModel::Serialization
  def read_attribute_for_serialization(*_); end

  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveModel::Serialization
end

module ActiveModel::Serializers
end

module ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  def as_json(options=T.unsafe(nil)); end

  def from_json(json, include_root=T.unsafe(nil)); end
end

module ActiveModel::Serializers::JSON
  extend ::ActiveSupport::Concern
end

module ActiveModel::Serializers
  extend ::ActiveSupport::Autoload
end

class ActiveModel::StrictValidationFailed
end

class ActiveModel::StrictValidationFailed
end

module ActiveModel::Translation
  include ::ActiveModel::Naming
  def human_attribute_name(attribute, options=T.unsafe(nil)); end

  def i18n_scope(); end

  def lookup_ancestors(); end
end

module ActiveModel::Translation
end

class ActiveModel::Type::BigInteger
end

class ActiveModel::Type::BigInteger
end

class ActiveModel::Type::Binary
  def changed_in_place?(raw_old_value, value); end
end

class ActiveModel::Type::Binary::Data
  def ==(other); end

  def hex(); end

  def initialize(value); end

  def to_str(); end
end

class ActiveModel::Type::Binary::Data
end

class ActiveModel::Type::Binary
end

class ActiveModel::Type::Boolean
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
  include ::ActiveModel::Type::Helpers::Timezone
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
end

class ActiveModel::Type::DateTime
  include ::ActiveModel::Type::Helpers::Timezone
  include ::ActiveModel::Type::Helpers::TimeValue
end

class ActiveModel::Type::DateTime
end

class ActiveModel::Type::Decimal
  include ::ActiveModel::Type::Helpers::Numeric
  BIGDECIMAL_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Decimal
end

class ActiveModel::Type::Float
  include ::ActiveModel::Type::Helpers::Numeric
end

class ActiveModel::Type::Float
end

module ActiveModel::Type::Helpers
end

class ActiveModel::Type::Helpers::AcceptsMultiparameterTime
  def initialize(defaults: T.unsafe(nil)); end
end

class ActiveModel::Type::Helpers::AcceptsMultiparameterTime
end

module ActiveModel::Type::Helpers::Mutable
  def cast(value); end

  def changed_in_place?(raw_old_value, new_value); end
end

module ActiveModel::Type::Helpers::Mutable
end

module ActiveModel::Type::Helpers::Numeric
  def cast(value); end

  def changed?(old_value, _new_value, new_value_before_type_cast); end

  def serialize(value); end
end

module ActiveModel::Type::Helpers::Numeric
end

module ActiveModel::Type::Helpers::TimeValue
  def apply_seconds_precision(value); end

  def serialize(value); end

  def type_cast_for_schema(value); end

  def user_input_in_time_zone(value); end
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::TimeValue
end

module ActiveModel::Type::Helpers::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

module ActiveModel::Type::Helpers::Timezone
end

module ActiveModel::Type::Helpers
end

class ActiveModel::Type::Integer
  include ::ActiveModel::Type::Helpers::Numeric
  def initialize(*_, **_1); end
  DEFAULT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Integer
end

class ActiveModel::Type::Registration
  def call(_registry, *args, **kwargs); end

  def initialize(name, block, **_); end

  def matches?(type_name, *args, **kwargs); end
end

class ActiveModel::Type::Registration
end

class ActiveModel::Type::Registry
  def lookup(symbol, *args, **kwargs); end

  def register(type_name, klass=T.unsafe(nil), **options, &block); end
end

class ActiveModel::Type::Registry
end

class ActiveModel::Type::Time
  include ::ActiveModel::Type::Helpers::Timezone
  include ::ActiveModel::Type::Helpers::TimeValue
end

class ActiveModel::Type::Time
end

class ActiveModel::Type::Value
  def ==(other); end

  def assert_valid_value(*_); end

  def binary?(); end

  def changed?(old_value, new_value, _new_value_before_type_cast); end

  def changed_in_place?(raw_old_value, new_value); end

  def deserialize(value); end

  def eql?(other); end

  def force_equality?(_value); end

  def limit(); end

  def map(value); end

  def precision(); end

  def scale(); end

  def serialize(value); end

  def type(); end

  def type_cast_for_schema(value); end

  def value_constructed_by_mass_assignment?(_value); end
end

module ActiveModel::Type
  def self.default_value(); end

  def self.lookup(*args, **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

class ActiveModel::UnknownAttributeError
  def attribute(); end

  def initialize(record, attribute); end

  def record(); end
end

class ActiveModel::UnknownAttributeError
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::VERSION
end

class ActiveModel::ValidationError
  def initialize(model); end

  def model(); end
end

class ActiveModel::ValidationError
end

module ActiveModel::Validations
  def invalid?(context=T.unsafe(nil)); end

  def read_attribute_for_validation(*_); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end

  def validate!(context=T.unsafe(nil)); end

  def validates_with(*args, &block); end
end

module ActiveModel::Validations::Callbacks
end

module ActiveModel::Validations::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveModel::Validations::HelperMethods
  def validates_absence_of(*attr_names); end

  def validates_acceptance_of(*attr_names); end

  def validates_confirmation_of(*attr_names); end

  def validates_exclusion_of(*attr_names); end

  def validates_format_of(*attr_names); end

  def validates_inclusion_of(*attr_names); end

  def validates_length_of(*attr_names); end

  def validates_numericality_of(*attr_names); end

  def validates_presence_of(*attr_names); end

  def validates_size_of(*attr_names); end
end

module ActiveModel::Validations
  extend ::ActiveSupport::Concern
end

class ActiveModel::Validator
  def initialize(options=T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def validate(record); end
end

class ActiveModel::Validator
  def self.kind(); end
end

module ActiveModel
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

class ActiveRecord::AdvisoryLockBase
  include ::ActiveRecord::AdvisoryLockBase::GeneratedAttributeMethods
  include ::ActiveRecord::AdvisoryLockBase::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
end

module ActiveRecord::AdvisoryLockBase::GeneratedAssociationMethods
end

module ActiveRecord::AdvisoryLockBase::GeneratedAssociationMethods
end

module ActiveRecord::AdvisoryLockBase::GeneratedAttributeMethods
end

module ActiveRecord::AdvisoryLockBase::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::AdvisoryLockBase
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.page(num=T.unsafe(nil)); end
end

module ActiveRecord::Aggregations
  def reload(*_); end
end

module ActiveRecord::Aggregations::ClassMethods
  def composed_of(part_id, options=T.unsafe(nil)); end
end

module ActiveRecord::Aggregations::ClassMethods
end

module ActiveRecord::Aggregations
end

class ActiveRecord::AmbiguousSourceReflectionForThroughAssociation
  def initialize(klass, macro, association_name, options, possible_sources); end
end

class ActiveRecord::AssociationNotFoundError
  def initialize(record=T.unsafe(nil), association_name=T.unsafe(nil)); end
end

class ActiveRecord::AssociationRelation
  def initialize(klass, association, **_); end

  def proxy_association(); end
end

class ActiveRecord::AssociationRelation
end

module ActiveRecord::Associations
  def association(name); end

  def association_cached?(name); end

  def reload(*_); end
end

module ActiveRecord::Associations
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeAssignment
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
end

module ActiveRecord::AttributeAssignment
end

class ActiveRecord::AttributeAssignmentError
  def attribute(); end

  def exception(); end

  def initialize(message=T.unsafe(nil), exception=T.unsafe(nil), attribute=T.unsafe(nil)); end
end

module ActiveRecord::AttributeDecorators
end

module ActiveRecord::AttributeDecorators
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  def [](attr_name); end

  def []=(attr_name, value); end

  def accessed_fields(); end

  def attribute_for_inspect(attr_name); end

  def attribute_names(); end

  def attribute_present?(attribute); end

  def attributes(); end

  def has_attribute?(attr_name); end

  def respond_to?(name, include_private=T.unsafe(nil)); end
  RESTRICTED_CLASS_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  def attributes_before_type_cast(); end

  def read_attribute_before_type_cast(attr_name); end
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Dirty
  def attribute_before_last_save(attr_name); end

  def attribute_change_to_be_saved(attr_name); end

  def attribute_in_database(attr_name); end

  def attributes_in_database(); end

  def changed_attribute_names_to_save(); end

  def changes_to_save(); end

  def has_changes_to_save?(); end

  def reload(*_); end

  def saved_change_to_attribute(attr_name); end

  def saved_changes(); end

  def saved_changes?(); end

  def will_save_change_to_attribute?(attr_name, **options); end
end

module ActiveRecord::AttributeMethods::Dirty
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::PrimaryKey
  def id(); end

  def id=(value); end

  def id?(); end

  def id_before_type_cast(); end

  def id_in_database(); end

  def id_was(); end

  def to_key(); end
end

module ActiveRecord::AttributeMethods::PrimaryKey
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Query
  def query_attribute(attr_name); end
end

module ActiveRecord::AttributeMethods::Query
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Read
  def _read_attribute(attr_name, &block); end

  def read_attribute(attr_name, &block); end
end

module ActiveRecord::AttributeMethods::Read
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Write
  def _write_attribute(attr_name, value); end

  def write_attribute(attr_name, value); end
end

module ActiveRecord::AttributeMethods::Write
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::Attributes
end

module ActiveRecord::Attributes
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AutosaveAssociation
  def changed_for_autosave?(); end

  def destroyed_by_association(); end

  def destroyed_by_association=(reflection); end

  def mark_for_destruction(); end

  def marked_for_destruction?(); end

  def reload(options=T.unsafe(nil)); end
end

module ActiveRecord::AutosaveAssociation
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Base
  include ::ActiveRecord::ReadonlyAttributes
  include ::ActiveRecord::AttributeAssignment
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::Conversion
  include ::ActiveRecord::Integration
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::Validations
  include ::ActiveRecord::CounterCache
  include ::ActiveRecord::Attributes
  include ::ActiveRecord::AttributeDecorators
  include ::ActiveRecord::Locking::Optimistic
  include ::ActiveRecord::DefineCallbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::Base::GeneratedAttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::Callbacks
  include ::ActiveRecord::Timestamp
  include ::ActiveModel::SecurePassword
  include ::ActiveRecord::AutosaveAssociation
  include ::ActiveRecord::TouchLater
  include ::ActiveRecord::NoTouching
  include ::ActiveRecord::Reflection
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  include ::ActiveRecord::Serialization
  include ::ActiveRecord::Store
  include ::ActiveRecord::SecureToken
  include ::ActiveRecord::Suppressor
  include ::ActiveStorageValidations
  include ::Kaminari::ActiveRecordExtension
  include ::Bugsnag::Rails::ActiveRecordRescue
  include ::GlobalID::Identification
  include ::ActiveStorage::Attached::Model
  include ::ActiveStorage::Reflection::ActiveRecordExtensions
  include ::ActionText::Attribute
  def __callbacks(); end

  def __callbacks?(); end

  def _before_commit_callbacks(); end

  def _before_commit_without_transaction_enrollment_callbacks(); end

  def _commit_callbacks(); end

  def _commit_without_transaction_enrollment_callbacks(); end

  def _create_callbacks(); end

  def _destroy_callbacks(); end

  def _find_callbacks(); end

  def _initialize_callbacks(); end

  def _reflections(); end

  def _reflections?(); end

  def _rollback_callbacks(); end

  def _rollback_without_transaction_enrollment_callbacks(); end

  def _run_before_commit_callbacks(&block); end

  def _run_before_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_commit_callbacks(&block); end

  def _run_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_rollback_callbacks(&block); end

  def _run_rollback_without_transaction_enrollment_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _touch_callbacks(); end

  def _update_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def aggregate_reflections(); end

  def aggregate_reflections?(); end

  def allow_unsafe_raw_sql(); end

  def attachment_reflections(); end

  def attachment_reflections?(); end

  def attribute_aliases(); end

  def attribute_aliases?(); end

  def attribute_method_matchers(); end

  def attribute_method_matchers?(); end

  def cache_timestamp_format(); end

  def cache_timestamp_format?(); end

  def cache_versioning(); end

  def cache_versioning?(); end

  def collection_cache_versioning(); end

  def collection_cache_versioning?(); end

  def column_for_attribute(*args, &block); end

  def default_connection_handler(); end

  def default_connection_handler?(); end

  def default_scope_override(); end

  def default_scopes(); end

  def default_timezone(); end

  def defined_enums(); end

  def defined_enums?(); end

  def dump_schema_after_migration(); end

  def dump_schemas(); end

  def error_on_ignored_order(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def index_nested_attribute_errors(); end

  def lock_optimistically(); end

  def lock_optimistically?(); end

  def logger(); end

  def model_name(*args, &block); end

  def nested_attributes_options(); end

  def nested_attributes_options?(); end

  def partial_writes(); end

  def partial_writes?(); end

  def pluralize_table_names(); end

  def pluralize_table_names?(); end

  def primary_key_prefix_type(); end

  def record_timestamps(); end

  def record_timestamps=(val); end

  def record_timestamps?(); end

  def schema_format(); end

  def skip_time_zone_conversion_for_attributes(); end

  def skip_time_zone_conversion_for_attributes?(); end

  def store_full_sti_class(); end

  def store_full_sti_class?(); end

  def table_name_prefix(); end

  def table_name_prefix?(); end

  def table_name_suffix(); end

  def table_name_suffix?(); end

  def time_zone_aware_attributes(); end

  def time_zone_aware_types(); end

  def time_zone_aware_types?(); end

  def timestamped_migrations(); end

  def type_for_attribute(*args, &block); end

  def validation_context(); end

  def verbose_query_logs(); end

  def warn_on_records_fetched_greater_than(); end
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::Base
  extend ::ActiveSupport::Benchmarkable
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveRecord::ConnectionHandling
  extend ::ActiveRecord::QueryCache::ClassMethods
  extend ::ActiveRecord::Querying
  extend ::ActiveRecord::Translation
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveRecord::DynamicMatchers
  extend ::ActiveRecord::Explain
  extend ::ActiveRecord::Enum
  extend ::ActiveRecord::Delegation::DelegateCache
  extend ::ActiveRecord::Aggregations::ClassMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveModel::Validations::HelperMethods
  extend ::OrmAdapter::ToAdapter
  extend ::Devise::Models
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._attr_readonly(); end

  def self._attr_readonly=(val); end

  def self._attr_readonly?(); end

  def self._before_commit_callbacks(); end

  def self._before_commit_callbacks=(value); end

  def self._before_commit_without_transaction_enrollment_callbacks(); end

  def self._before_commit_without_transaction_enrollment_callbacks=(value); end

  def self._commit_callbacks(); end

  def self._commit_callbacks=(value); end

  def self._commit_without_transaction_enrollment_callbacks(); end

  def self._commit_without_transaction_enrollment_callbacks=(value); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._reflections(); end

  def self._reflections=(val); end

  def self._reflections?(); end

  def self._rollback_callbacks(); end

  def self._rollback_callbacks=(value); end

  def self._rollback_without_transaction_enrollment_callbacks(); end

  def self._rollback_without_transaction_enrollment_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.after_find(*args, **options, &block); end

  def self.after_initialize(*args, **options, &block); end

  def self.after_touch(*args, **options, &block); end

  def self.aggregate_reflections(); end

  def self.aggregate_reflections=(val); end

  def self.aggregate_reflections?(); end

  def self.allow_unsafe_raw_sql(); end

  def self.allow_unsafe_raw_sql=(obj); end

  def self.attachment_reflections(); end

  def self.attachment_reflections=(val); end

  def self.attachment_reflections?(); end

  def self.attribute_aliases(); end

  def self.attribute_aliases=(val); end

  def self.attribute_aliases?(); end

  def self.attribute_method_matchers(); end

  def self.attribute_method_matchers=(val); end

  def self.attribute_method_matchers?(); end

  def self.attribute_type_decorations(); end

  def self.attribute_type_decorations=(val); end

  def self.attribute_type_decorations?(); end

  def self.attributes_to_define_after_schema_loads(); end

  def self.attributes_to_define_after_schema_loads=(val); end

  def self.attributes_to_define_after_schema_loads?(); end

  def self.belongs_to_required_by_default(); end

  def self.belongs_to_required_by_default=(obj); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(val); end

  def self.cache_timestamp_format?(); end

  def self.cache_versioning(); end

  def self.cache_versioning=(val); end

  def self.cache_versioning?(); end

  def self.collection_cache_versioning(); end

  def self.collection_cache_versioning=(val); end

  def self.collection_cache_versioning?(); end

  def self.configurations(); end

  def self.configurations=(config); end

  def self.connection_handler(); end

  def self.connection_handler=(handler); end

  def self.connection_handlers(); end

  def self.connection_handlers=(obj); end

  def self.default_connection_handler(); end

  def self.default_connection_handler=(val); end

  def self.default_connection_handler?(); end

  def self.default_scope_override(); end

  def self.default_scope_override=(val); end

  def self.default_scopes(); end

  def self.default_scopes=(val); end

  def self.default_timezone(); end

  def self.default_timezone=(obj); end

  def self.defined_enums(); end

  def self.defined_enums=(val); end

  def self.defined_enums?(); end

  def self.dump_schema_after_migration(); end

  def self.dump_schema_after_migration=(obj); end

  def self.dump_schemas(); end

  def self.dump_schemas=(obj); end

  def self.error_on_ignored_order(); end

  def self.error_on_ignored_order=(obj); end

  def self.implicit_order_column(); end

  def self.implicit_order_column=(val); end

  def self.implicit_order_column?(); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(val); end

  def self.include_root_in_json?(); end

  def self.index_nested_attribute_errors(); end

  def self.index_nested_attribute_errors=(obj); end

  def self.internal_metadata_table_name(); end

  def self.internal_metadata_table_name=(val); end

  def self.internal_metadata_table_name?(); end

  def self.local_stored_attributes(); end

  def self.local_stored_attributes=(local_stored_attributes); end

  def self.lock_optimistically(); end

  def self.lock_optimistically=(val); end

  def self.lock_optimistically?(); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.maintain_test_schema(); end

  def self.maintain_test_schema=(obj); end

  def self.nested_attributes_options(); end

  def self.nested_attributes_options=(val); end

  def self.nested_attributes_options?(); end

  def self.partial_writes(); end

  def self.partial_writes=(val); end

  def self.partial_writes?(); end

  def self.pluralize_table_names(); end

  def self.pluralize_table_names=(val); end

  def self.pluralize_table_names?(); end

  def self.primary_key_prefix_type(); end

  def self.primary_key_prefix_type=(obj); end

  def self.reading_role(); end

  def self.reading_role=(obj); end

  def self.record_timestamps(); end

  def self.record_timestamps=(val); end

  def self.record_timestamps?(); end

  def self.schema_format(); end

  def self.schema_format=(obj); end

  def self.schema_migrations_table_name(); end

  def self.schema_migrations_table_name=(val); end

  def self.schema_migrations_table_name?(); end

  def self.skip_time_zone_conversion_for_attributes(); end

  def self.skip_time_zone_conversion_for_attributes=(val); end

  def self.skip_time_zone_conversion_for_attributes?(); end

  def self.store_full_sti_class(); end

  def self.store_full_sti_class=(val); end

  def self.store_full_sti_class?(); end

  def self.table_name_prefix(); end

  def self.table_name_prefix=(val); end

  def self.table_name_prefix?(); end

  def self.table_name_suffix(); end

  def self.table_name_suffix=(val); end

  def self.table_name_suffix?(); end

  def self.time_zone_aware_attributes(); end

  def self.time_zone_aware_attributes=(obj); end

  def self.time_zone_aware_types(); end

  def self.time_zone_aware_types=(val); end

  def self.time_zone_aware_types?(); end

  def self.timestamped_migrations(); end

  def self.timestamped_migrations=(obj); end

  def self.verbose_query_logs(); end

  def self.verbose_query_logs=(obj); end

  def self.warn_on_records_fetched_greater_than(); end

  def self.warn_on_records_fetched_greater_than=(obj); end

  def self.writing_role(); end

  def self.writing_role=(obj); end
end

module ActiveRecord::Batches
  def find_each(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  def find_in_batches(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  def in_batches(of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), load: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Batches::BatchEnumerator
  include ::Enumerable
  def delete_all(*args, &block); end

  def destroy_all(*args, &block); end

  def each(&blk); end

  def each_record(); end

  def initialize(relation:, of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil)); end

  def update_all(*args, &block); end
end

module ActiveRecord::Calculations
  def average(column_name); end

  def calculate(operation, column_name); end

  def count(column_name=T.unsafe(nil)); end

  def ids(); end

  def maximum(column_name); end

  def minimum(column_name); end

  def pick(*column_names); end

  def pluck(*column_names); end

  def sum(column_name=T.unsafe(nil)); end
end

module ActiveRecord::Calculations
end

module ActiveRecord::Callbacks
  def destroy(); end

  def increment!(attribute, by=T.unsafe(nil), touch: T.unsafe(nil)); end

  def touch(*_, **_1); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Coders
end

class ActiveRecord::Coders::JSON
end

class ActiveRecord::Coders::JSON
  def self.dump(obj); end

  def self.load(json); end
end

class ActiveRecord::Coders::YAMLColumn
  def assert_valid_value(obj, action:); end

  def dump(obj); end

  def initialize(attr_name, object_class=T.unsafe(nil)); end

  def load(yaml); end

  def object_class(); end

  def object_class=(object_class); end
end

class ActiveRecord::Coders::YAMLColumn
end

module ActiveRecord::Coders
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  def __callbacks(); end

  def __callbacks?(); end

  def _checkin_callbacks(); end

  def _checkout_callbacks(); end

  def _run_checkin_callbacks(&block); end

  def _run_checkout_callbacks(&block); end

  def active?(); end

  def adapter_name(); end

  def advisory_locks_enabled?(); end

  def build_insert_sql(insert); end

  def case_insensitive_comparison(attribute, value); end

  def case_sensitive_comparison(attribute, value); end

  def check_version(); end

  def clear_cache!(); end

  def close(); end

  def column_name_for_operation(operation, node); end

  def database_version(); end

  def default_index_type?(index); end

  def default_uniqueness_comparison(attribute, value, klass); end

  def delete(*_); end

  def disable_extension(name); end

  def disable_referential_integrity(); end

  def discard!(); end

  def disconnect!(); end

  def enable_extension(name); end

  def exec_insert_all(*_); end

  def expire(); end

  def extensions(); end

  def get_advisory_lock(lock_id); end

  def get_database_version(); end

  def in_use?(); end

  def index_algorithms(); end

  def initialize(connection, logger=T.unsafe(nil), config=T.unsafe(nil)); end

  def insert(*_); end

  def lease(); end

  def lock(); end

  def logger(); end

  def migration_context(); end

  def migrations_paths(); end

  def owner(); end

  def pool(); end

  def pool=(pool); end

  def prefetch_primary_key?(table_name=T.unsafe(nil)); end

  def prepared_statements(); end

  def prepared_statements_disabled_cache(); end

  def preventing_writes?(); end

  def raw_connection(); end

  def reconnect!(); end

  def release_advisory_lock(lock_id); end

  def replica?(); end

  def requires_reloading?(); end

  def reset!(); end

  def rollback_db_transaction(*_); end

  def rollback_to_savepoint(*_); end

  def schema_cache(); end

  def schema_cache=(cache); end

  def schema_migration(); end

  def seconds_idle(); end

  def steal!(); end

  def supports_advisory_locks?(); end

  def supports_bulk_alter?(); end

  def supports_comments?(); end

  def supports_comments_in_create?(); end

  def supports_common_table_expressions?(); end

  def supports_datetime_with_precision?(); end

  def supports_ddl_transactions?(); end

  def supports_explain?(); end

  def supports_expression_index?(); end

  def supports_extensions?(); end

  def supports_foreign_keys?(); end

  def supports_foreign_keys_in_create?(*args, &block); end

  def supports_foreign_tables?(); end

  def supports_index_sort_order?(); end

  def supports_indexes_in_create?(); end

  def supports_insert_conflict_target?(); end

  def supports_insert_on_duplicate_skip?(); end

  def supports_insert_on_duplicate_update?(); end

  def supports_insert_returning?(); end

  def supports_json?(); end

  def supports_lazy_transactions?(); end

  def supports_materialized_views?(); end

  def supports_multi_insert?(*args, &block); end

  def supports_optimizer_hints?(); end

  def supports_partial_index?(); end

  def supports_partitioned_indexes?(); end

  def supports_savepoints?(); end

  def supports_transaction_isolation?(); end

  def supports_validate_constraints?(); end

  def supports_views?(); end

  def supports_virtual_columns?(); end

  def truncate(*_); end

  def truncate_tables(*_); end

  def unprepared_statement(); end

  def update(*_); end

  def valid_type?(type); end

  def verify!(); end

  def visitor(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  COMMENT_REGEX = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
  def accept(o); end

  def initialize(conn); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable
  def full_version_string(); end

  def initialize(version_string, full_version_string=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._checkin_callbacks(); end

  def self._checkin_callbacks=(value); end

  def self._checkout_callbacks(); end

  def self._checkout_callbacks=(value); end

  def self.build_read_query_regexp(*parts); end

  def self.database_exists?(config); end

  def self.quoted_column_names(); end

  def self.quoted_table_names(); end

  def self.type_cast_config_to_boolean(config); end

  def self.type_cast_config_to_integer(config); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
  def get_schema_cache(connection); end

  def set_schema_cache(cache); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def column(); end

  def column=(_); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
  def add_column(name, type, **options); end

  def add_foreign_key(to_table, options); end

  def adds(); end

  def drop_foreign_key(name); end

  def foreign_key_adds(); end

  def foreign_key_drops(); end

  def initialize(td); end

  def name(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def column(); end

  def column=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::Column
  def ==(other); end

  def bigint?(); end

  def collation(); end

  def comment(); end

  def default(); end

  def default_function(); end

  def encode_with(coder); end

  def eql?(other); end

  def has_default?(); end

  def human_name(); end

  def init_with(coder); end

  def initialize(name, default, sql_type_metadata=T.unsafe(nil), null=T.unsafe(nil), default_function=T.unsafe(nil), collation: T.unsafe(nil), comment: T.unsafe(nil), **_); end

  def limit(*args, &block); end

  def name(); end

  def null(); end

  def precision(*args, &block); end

  def scale(*args, &block); end

  def sql_type(*args, &block); end

  def sql_type_metadata(); end

  def type(*args, &block); end
end

class ActiveRecord::ConnectionAdapters::Column
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def collation(); end

  def collation=(value); end

  def comment(); end

  def comment=(value); end

  def default(); end

  def default=(value); end

  def limit(); end

  def limit=(value); end

  def name(); end

  def name=(_); end

  def null(); end

  def null=(value); end

  def options(); end

  def options=(_); end

  def precision(); end

  def precision=(value); end

  def primary_key?(); end

  def scale(); end

  def scale=(value); end

  def sql_type(); end

  def sql_type=(_); end

  def type(); end

  def type=(_); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def active_connections?(); end

  def clear_active_connections!(); end

  def clear_all_connections!(); end

  def clear_reloadable_connections!(); end

  def connected?(spec_name); end

  def connection_pool_list(); end

  def connection_pools(); end

  def establish_connection(config); end

  def flush_idle_connections!(); end

  def prevent_writes(); end

  def prevent_writes=(prevent_writes); end

  def remove_connection(spec_name); end

  def retrieve_connection(spec_name); end

  def retrieve_connection_pool(spec_name); end

  def while_preventing_writes(enabled=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def self.create_owner_to_pool(); end

  def self.discard_unowned_pools(pid_map); end

  def self.unowned_pool_finalizer(pid_map); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
  include ::MonitorMixin
  include ::ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  include ::ActiveRecord::ConnectionAdapters::AbstractPool
  def active_connection?(); end

  def automatic_reconnect(); end

  def automatic_reconnect=(automatic_reconnect); end

  def checkin(conn); end

  def checkout(checkout_timeout=T.unsafe(nil)); end

  def checkout_timeout(); end

  def checkout_timeout=(checkout_timeout); end

  def clear_reloadable_connections(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def clear_reloadable_connections!(); end

  def connected?(); end

  def connection(); end

  def connections(); end

  def discard!(); end

  def disconnect(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def disconnect!(); end

  def flush(minimum_idle=T.unsafe(nil)); end

  def flush!(); end

  def initialize(spec); end

  def lock_thread=(lock_thread); end

  def num_waiting_in_queue(); end

  def reap(); end

  def reaper(); end

  def release_connection(owner_thread=T.unsafe(nil)); end

  def remove(conn); end

  def schema_cache(); end

  def schema_cache=(schema_cache); end

  def size(); end

  def spec(); end

  def stat(); end

  def with_connection(); end
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  def with_a_bias_for(thread); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  def broadcast(); end

  def broadcast_on_biased(); end

  def initialize(lock, other_cond, preferred_thread); end

  def signal(); end

  def wait(timeout); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
  include ::ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  def add(element); end

  def any_waiting?(); end

  def clear(); end

  def delete(element); end

  def initialize(lock=T.unsafe(nil)); end

  def num_waiting(); end

  def poll(timeout=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def frequency(); end

  def initialize(pool, frequency); end

  def pool(); end

  def run(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def self.register_pool(pool, frequency); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
  def adapter_method(); end

  def config(); end

  def initialize(name, config, adapter_method); end

  def name(); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
  def initialize(url); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
  def configurations(); end

  def initialize(configurations); end

  def resolve(config_or_env, pool_name=T.unsafe(nil)); end

  def spec(config); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  def allowed_index_name_length(); end

  def column_name_length(*args, &block); end

  def columns_per_multicolumn_index(*args, &block); end

  def columns_per_table(*args, &block); end

  def in_clause_length(); end

  def index_name_length(); end

  def indexes_per_table(*args, &block); end

  def joins_per_query(*args, &block); end

  def max_identifier_length(); end

  def sql_query_length(*args, &block); end

  def table_alias_length(); end

  def table_name_length(*args, &block); end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def add_transaction_record(record); end

  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*args, &block); end

  def cacheable_query(klass, arel); end

  def commit_db_transaction(); end

  def commit_transaction(*args, &block); end

  def create(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def current_transaction(*args, &block); end

  def default_sequence_name(table, column); end

  def delete(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def disable_lazy_transactions!(*args, &block); end

  def empty_insert_statement_value(primary_key=T.unsafe(nil)); end

  def enable_lazy_transactions!(*args, &block); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_insert_all(sql, name); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def initialize(); end

  def insert(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def insert_fixture(fixture, table_name); end

  def insert_fixtures_set(fixture_set, tables_to_delete=T.unsafe(nil)); end

  def materialize_transactions(*args, &block); end

  def open_transactions(*args, &block); end

  def query(sql, name=T.unsafe(nil)); end

  def query_value(sql, name=T.unsafe(nil)); end

  def query_values(sql, name=T.unsafe(nil)); end

  def reset_sequence!(table, column, sequence=T.unsafe(nil)); end

  def reset_transaction(); end

  def rollback_db_transaction(); end

  def rollback_to_savepoint(name=T.unsafe(nil)); end

  def rollback_transaction(*args, &block); end

  def sanitize_limit(limit); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def select_one(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_rows(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_value(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_values(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def to_sql(arel_or_sql_string, binds=T.unsafe(nil)); end

  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end

  def transaction_isolation_levels(); end

  def transaction_manager(); end

  def transaction_open?(); end

  def transaction_state(); end

  def truncate(table_name, name=T.unsafe(nil)); end

  def truncate_tables(*table_names); end

  def update(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def with_yaml_fallback(value); end

  def within_new_transaction(*args, &block); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
  def accept(object, collector); end

  def preparable(); end

  def preparable=(preparable); end

  def visit_Arel_Nodes_In(o, collector); end

  def visit_Arel_Nodes_NotIn(o, collector); end

  def visit_Arel_Nodes_SqlLiteral(o, collector); end
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def column(); end

  def custom_primary_key?(); end

  def defined_for?(to_table: T.unsafe(nil), **options); end

  def export_name_on_schema_dump?(); end

  def from_table(); end

  def from_table=(_); end

  def name(); end

  def on_delete(); end

  def on_update(); end

  def options(); end

  def options=(_); end

  def primary_key(); end

  def to_table(); end

  def to_table=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
  def columns(); end

  def comment(); end

  def initialize(table, name, unique=T.unsafe(nil), columns=T.unsafe(nil), lengths: T.unsafe(nil), orders: T.unsafe(nil), opclasses: T.unsafe(nil), where: T.unsafe(nil), type: T.unsafe(nil), using: T.unsafe(nil), comment: T.unsafe(nil)); end

  def lengths(); end

  def name(); end

  def opclasses(); end

  def orders(); end

  def table(); end

  def type(); end

  def unique(); end

  def using(); end

  def where(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
end

class ActiveRecord::ConnectionAdapters::NullColumn
  def initialize(name); end
end

class ActiveRecord::ConnectionAdapters::NullColumn
end

class ActiveRecord::ConnectionAdapters::NullPool
  include ::ActiveRecord::ConnectionAdapters::AbstractPool
end

class ActiveRecord::ConnectionAdapters::NullPool
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  def add_record(record); end

  def closed?(); end

  def joinable?(); end

  def open?(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
end

module ActiveRecord::ConnectionAdapters::PostgreSQL
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable
  def constraint_validations(); end

  def validate_constraint(name); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Column
  def array(); end

  def array?(); end

  def fmod(*args, &block); end

  def initialize(*_, serial: T.unsafe(nil), **_1); end

  def oid(*args, &block); end

  def serial?(); end

  def sql_type(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Column
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def primary_key(name, type=T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  extend ::ActiveSupport::Concern
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def commit_db_transaction(); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def explain(arel, binds=T.unsafe(nil)); end

  def query(sql, name=T.unsafe(nil)); end

  def result_as_array(res); end

  def write_query?(sql); end
  BYTEA_COLUMN_TYPE_OID = ::T.let(nil, ::T.untyped)
  MONEY_COLUMN_TYPE_OID = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
  def pp(result); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
  def ==(o); end

  def eql?(o); end

  def identifier(); end

  def initialize(schema, identifier); end

  def parts(); end

  def quoted(); end

  def schema(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::OID
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array
  include ::ActiveModel::Type::Helpers::Mutable
  def delimiter(); end

  def force_equality?(value); end

  def initialize(subtype, delimiter=T.unsafe(nil)); end

  def limit(*args, &block); end

  def map(value, &block); end

  def precision(*args, &block); end

  def scale(*args, &block); end

  def subtype(); end

  def type(*args, &block); end

  def user_input_in_time_zone(*args, &block); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def encoder(); end

  def encoder=(_); end

  def values=(_); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
  def binary?(); end

  def hex?(); end

  def initialize(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::BitVarying
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::BitVarying
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bytea
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bytea
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Cidr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Cidr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Date
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Date
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal
  def infinity(options=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Enum
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Enum
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end
  HstorePair = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Inet
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Inet
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Jsonb
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Jsonb
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::LegacyPoint
  include ::ActiveModel::Type::Helpers::Mutable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::LegacyPoint
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Money
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Money
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Oid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Oid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Point
  include ::ActiveModel::Type::Helpers::Mutable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Point
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range
  def force_equality?(value); end

  def initialize(subtype, type=T.unsafe(nil)); end

  def subtype(); end

  def user_input_in_time_zone(*args, &block); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString
  def initialize(type, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
  def initialize(store); end

  def query_conditions_for_initial_load(); end

  def run(records); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
  ACCEPTABLE_UUID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector
  def delim(); end

  def initialize(delim, subtype); end

  def subtype(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
  def initialize(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::OID
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def escape_bytea(value); end

  def lookup_cast_type_from_column(column); end

  def quote_column_name(name); end

  def quote_default_expression(value, column); end

  def quote_schema_name(name); end

  def quote_string(s); end

  def quote_table_name(name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def unescape_bytea(value); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  def disable_referential_integrity(); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaDumper
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  def add_column(table_name, column_name, type, **options); end

  def add_index(table_name, column_name, options=T.unsafe(nil)); end

  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table_comment(table_name, comment_or_changes); end

  def client_min_messages(); end

  def client_min_messages=(level); end

  def collation(); end

  def columns_for_distinct(columns, orders); end

  def create_database(name, options=T.unsafe(nil)); end

  def create_schema(schema_name); end

  def create_schema_dumper(options); end

  def ctype(); end

  def current_database(); end

  def current_schema(); end

  def default_sequence_name(table_name, pk=T.unsafe(nil)); end

  def drop_database(name); end

  def drop_schema(schema_name, options=T.unsafe(nil)); end

  def drop_table(table_name, options=T.unsafe(nil)); end

  def encoding(); end

  def foreign_keys(table_name); end

  def foreign_table_exists?(table_name); end

  def foreign_tables(); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def pk_and_sequence_for(table); end

  def primary_keys(table_name); end

  def recreate_database(name, options=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def reset_pk_sequence!(table, pk=T.unsafe(nil), sequence=T.unsafe(nil)); end

  def schema_exists?(name); end

  def schema_names(); end

  def schema_search_path(); end

  def schema_search_path=(schema_csv); end

  def serial_sequence(table, column); end

  def set_pk_sequence!(table, value); end

  def table_comment(table_name); end

  def table_options(table_name); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), array: T.unsafe(nil), **_); end

  def update_table_definition(table_name, base); end

  def validate_constraint(table_name, constraint_name); end

  def validate_foreign_key(from_table, to_table=T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def serial(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def initialize(*_, **_1); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def serial(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def unlogged(); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
  def ==(other); end

  def eql?(other); end

  def fmod(); end

  def hash(); end

  def initialize(type_metadata, oid: T.unsafe(nil), fmod: T.unsafe(nil)); end

  def oid(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  def extract_schema_qualified_name(string); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  extend ::ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
end

module ActiveRecord::ConnectionAdapters::PostgreSQL
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def create_unlogged_tables(); end

  def create_unlogged_tables=(val); end

  def create_unlogged_tables?(); end

  def extension_available?(name); end

  def extension_enabled?(name); end

  def initialize(connection, logger, connection_parameters, config); end

  def postgresql_version(); end

  def session_auth=(user); end

  def set_standard_conforming_strings(); end

  def supports_insert_on_conflict?(); end

  def supports_pgcrypto_uuid?(); end

  def supports_ranges?(*args, &block); end

  def use_insert_returning?(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  CACHED_PLAN_HEURISTIC = ::T.let(nil, ::T.untyped)
  DEADLOCK_DETECTED = ::T.let(nil, ::T.untyped)
  FEATURE_NOT_SUPPORTED = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_VIOLATION = ::T.let(nil, ::T.untyped)
  LOCK_NOT_AVAILABLE = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
  NOT_NULL_VIOLATION = ::T.let(nil, ::T.untyped)
  NUMERIC_VALUE_OUT_OF_RANGE = ::T.let(nil, ::T.untyped)
  OPERATION_ALIASES = ::T.let(nil, ::T.untyped)
  QUERY_CANCELED = ::T.let(nil, ::T.untyped)
  SERIALIZATION_FAILURE = ::T.let(nil, ::T.untyped)
  UNIQUE_VIOLATION = ::T.let(nil, ::T.untyped)
  VALUE_LIMIT_VIOLATION = ::T.let(nil, ::T.untyped)
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID = ActiveRecord::ConnectionAdapters::PostgreSQL::OID

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
  def []=(sql, key); end

  def initialize(connection, max); end

  def next_key(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  def self.create_unlogged_tables(); end

  def self.create_unlogged_tables=(val); end

  def self.create_unlogged_tables?(); end
end

ActiveRecord::ConnectionAdapters::PostgreSQLColumn = ActiveRecord::ConnectionAdapters::PostgreSQL::Column

ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata = ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def cache(); end

  def clear_query_cache(); end

  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache(); end

  def query_cache_enabled(); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def uncached(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache_enabled(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def self.dirties_query_cache(base, *method_names); end

  def self.included(base); end
end

module ActiveRecord::ConnectionAdapters::Quoting
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_column_name(column_name); end

  def quote_default_expression(value, column); end

  def quote_string(s); end

  def quote_table_name(table_name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def quoted_false(); end

  def quoted_time(value); end

  def quoted_true(); end

  def sanitize_as_sql_comment(value); end

  def type_cast(value, column=T.unsafe(nil)); end

  def type_cast_from_column(column, value); end

  def unquoted_false(); end

  def unquoted_true(); end
end

module ActiveRecord::ConnectionAdapters::Quoting
end

class ActiveRecord::ConnectionAdapters::RealTransaction
  def commit(); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::RealTransaction
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  def add_to(table); end

  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
  def commit(); end

  def initialize(connection, savepoint_name, parent_transaction, *args, **options); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
end

module ActiveRecord::ConnectionAdapters::Savepoints
  def create_savepoint(name=T.unsafe(nil)); end

  def current_savepoint_name(); end

  def exec_rollback_to_savepoint(name=T.unsafe(nil)); end

  def release_savepoint(name=T.unsafe(nil)); end
end

module ActiveRecord::ConnectionAdapters::Savepoints
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def add(table_name); end

  def clear!(); end

  def clear_data_source_cache!(name); end

  def columns(table_name); end

  def columns_hash(table_name); end

  def columns_hash?(table_name); end

  def connection(); end

  def connection=(connection); end

  def data_source_exists?(name); end

  def data_sources(name); end

  def database_version(); end

  def encode_with(coder); end

  def indexes(table_name); end

  def init_with(coder); end

  def initialize(conn); end

  def marshal_dump(); end

  def marshal_load(array); end

  def primary_keys(table_name); end

  def size(); end

  def version(); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
end

ActiveRecord::ConnectionAdapters::SchemaCreation = ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation

class ActiveRecord::ConnectionAdapters::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  def self.create(connection, options); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, **options); end

  def add_foreign_key(from_table, to_table, **options); end

  def add_index(table_name, column_name, options=T.unsafe(nil)); end

  def add_index_options(table_name, column_name, comment: T.unsafe(nil), **options); end

  def add_reference(table_name, ref_name, **options); end

  def add_timestamps(table_name, **options); end

  def assume_migrated_upto_version(version, migrations_paths=T.unsafe(nil)); end

  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table(table_name, **options); end

  def change_table_comment(table_name, comment_or_changes); end

  def column_exists?(table_name, column_name, type=T.unsafe(nil), **options); end

  def columns(table_name); end

  def columns_for_distinct(columns, orders); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end

  def create_schema_dumper(options); end

  def create_table(table_name, **options); end

  def data_source_exists?(name); end

  def data_sources(); end

  def drop_join_table(table_1, table_2, **options); end

  def drop_table(table_name, **options); end

  def dump_schema_information(); end

  def foreign_key_column_for(table_name); end

  def foreign_key_exists?(from_table, to_table=T.unsafe(nil), **options); end

  def foreign_key_options(from_table, to_table, options); end

  def foreign_keys(table_name); end

  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def index_name(table_name, options); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def internal_string_options_for_primary_key(); end

  def native_database_types(); end

  def options_include_default?(options); end

  def primary_key(table_name); end

  def remove_belongs_to(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_column(table_name, column_name, type=T.unsafe(nil), **options); end

  def remove_columns(table_name, *column_names); end

  def remove_foreign_key(from_table, to_table=T.unsafe(nil), **options); end

  def remove_index(table_name, options=T.unsafe(nil)); end

  def remove_reference(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_timestamps(table_name, **options); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def table_alias_for(table_name); end

  def table_comment(table_name); end

  def table_exists?(table_name); end

  def table_options(table_name); end

  def tables(); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), **_); end

  def update_table_definition(table_name, base); end

  def view_exists?(view_name); end

  def views(); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  def ==(other); end

  def eql?(other); end

  def initialize(sql_type: T.unsafe(nil), type: T.unsafe(nil), limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  def limit(); end

  def precision(); end

  def scale(); end

  def sql_type(); end

  def type(); end
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
end

class ActiveRecord::ConnectionAdapters::StatementPool
  include ::Enumerable
  def [](key); end

  def []=(sql, stmt); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def initialize(statement_limit=T.unsafe(nil)); end

  def key?(key); end

  def length(); end
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::StatementPool
end

class ActiveRecord::ConnectionAdapters::Table
  def bigint(*names, **options); end

  def binary(*names, **options); end

  def boolean(*names, **options); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def initialize(table_name, base); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def numeric(*names, **options); end

  def string(*names, **options); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::Table
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  def as(); end

  def bigint(*names, **options); end

  def binary(*names, **options); end

  def boolean(*names, **options); end

  def comment(); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def foreign_key(table_name, **options); end

  def foreign_keys(); end

  def if_not_exists(); end

  def indexes(); end

  def initialize(conn, name, temporary: T.unsafe(nil), if_not_exists: T.unsafe(nil), options: T.unsafe(nil), as: T.unsafe(nil), comment: T.unsafe(nil), **_); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def new_column_definition(name, type, **options); end

  def numeric(*names, **options); end

  def options(); end

  def primary_keys(name=T.unsafe(nil)); end

  def string(*names, **options); end

  def temporary(); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

class ActiveRecord::ConnectionAdapters::Transaction
  def add_record(record); end

  def before_commit_records(); end

  def closed?(); end

  def commit_records(); end

  def connection(); end

  def full_rollback?(); end

  def initialize(connection, options, run_commit_callbacks: T.unsafe(nil)); end

  def isolation_level(); end

  def joinable?(); end

  def materialize!(); end

  def materialized?(); end

  def open?(); end

  def records(); end

  def rollback_records(); end

  def savepoint_name(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::Transaction
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  def begin_transaction(options=T.unsafe(nil)); end

  def commit_transaction(); end

  def current_transaction(); end

  def disable_lazy_transactions!(); end

  def enable_lazy_transactions!(); end

  def initialize(connection); end

  def lazy_transactions_enabled?(); end

  def materialize_transactions(); end

  def open_transactions(); end

  def rollback_transaction(transaction=T.unsafe(nil)); end

  def within_new_transaction(options=T.unsafe(nil)); end
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionManager
end

class ActiveRecord::ConnectionAdapters::TransactionState
  def add_child(state); end

  def commit!(); end

  def committed?(); end

  def completed?(); end

  def finalized?(); end

  def full_commit!(); end

  def full_rollback!(); end

  def fully_committed?(); end

  def fully_completed?(); end

  def fully_rolledback?(); end

  def initialize(state=T.unsafe(nil)); end

  def nullify!(); end

  def rollback!(); end

  def rolledback?(); end
end

class ActiveRecord::ConnectionAdapters::TransactionState
end

module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::ConnectionHandling
  def clear_active_connections!(*args, &block); end

  def clear_all_connections!(*args, &block); end

  def clear_cache!(); end

  def clear_query_caches_for_current_thread(); end

  def clear_reloadable_connections!(*args, &block); end

  def connected?(); end

  def connected_to(database: T.unsafe(nil), role: T.unsafe(nil), prevent_writes: T.unsafe(nil), &blk); end

  def connected_to?(role:); end

  def connection(); end

  def connection_config(); end

  def connection_pool(); end

  def connection_specification_name(); end

  def connection_specification_name=(connection_specification_name); end

  def connects_to(database: T.unsafe(nil)); end

  def current_role(); end

  def establish_connection(config_or_env=T.unsafe(nil)); end

  def flush_idle_connections!(*args, &block); end

  def lookup_connection_handler(handler_key); end

  def postgresql_connection(config); end

  def primary_class?(); end

  def remove_connection(name=T.unsafe(nil)); end

  def resolve_config_for_connection(config_or_env); end

  def retrieve_connection(); end

  def with_handler(handler_key, &blk); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionHandling
end

module ActiveRecord::Core
  def ==(comparison_object); end

  def connection_handler(); end

  def encode_with(coder); end

  def eql?(comparison_object); end

  def freeze(); end

  def frozen?(); end

  def hash(); end

  def init_with(coder, &block); end

  def init_with_attributes(attributes, new_record=T.unsafe(nil)); end

  def initialize(attributes=T.unsafe(nil)); end

  def inspect(); end

  def pretty_print(pp); end

  def readonly!(); end

  def readonly?(); end

  def slice(*methods); end
end

module ActiveRecord::Core
  extend ::ActiveSupport::Concern
end

module ActiveRecord::CounterCache
end

module ActiveRecord::CounterCache
  extend ::ActiveSupport::Concern
end

class ActiveRecord::DatabaseConfigurations
  def [](env=T.unsafe(nil)); end

  def any?(*args, &block); end

  def configs_for(env_name: T.unsafe(nil), spec_name: T.unsafe(nil), include_replicas: T.unsafe(nil)); end

  def configurations(); end

  def default_hash(env=T.unsafe(nil)); end

  def each(&blk); end

  def empty?(); end

  def find_db_config(env); end

  def first(); end

  def initialize(configurations=T.unsafe(nil)); end

  def to_h(); end
end

class ActiveRecord::DatabaseConfigurations::DatabaseConfig
  def env_name(); end

  def for_current_env?(); end

  def initialize(env_name, spec_name); end

  def migrations_paths(); end

  def replica?(); end

  def spec_name(); end

  def to_legacy_hash(); end

  def url_config?(); end
end

class ActiveRecord::DatabaseConfigurations::DatabaseConfig
end

class ActiveRecord::DatabaseConfigurations::HashConfig
  def config(); end

  def initialize(env_name, spec_name, config); end
end

class ActiveRecord::DatabaseConfigurations::HashConfig
end

class ActiveRecord::DatabaseConfigurations::InvalidConfigurationError
end

class ActiveRecord::DatabaseConfigurations::InvalidConfigurationError
end

class ActiveRecord::DatabaseConfigurations::UrlConfig
  def config(); end

  def initialize(env_name, spec_name, url, config=T.unsafe(nil)); end

  def url(); end
end

class ActiveRecord::DatabaseConfigurations::UrlConfig
end

class ActiveRecord::DatabaseConfigurations
end

module ActiveRecord::DefineCallbacks
end

module ActiveRecord::DefineCallbacks
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Delegation
  def &(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def [](*args, &block); end

  def as_json(*args, &block); end

  def compact(*args, &block); end

  def connection(*args, &block); end

  def each(*args, &block); end

  def encode_with(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def index(*args, &block); end

  def join(*args, &block); end

  def length(*args, &block); end

  def primary_key(*args, &block); end

  def reverse(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def sample(*args, &block); end

  def shuffle(*args, &block); end

  def slice(*args, &block); end

  def split(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_sentence(*args, &block); end

  def to_xml(*args, &block); end

  def |(*args, &block); end
end

module ActiveRecord::Delegation::ClassMethods
  def create(klass, *args, **kwargs); end
end

module ActiveRecord::Delegation::ClassMethods
end

module ActiveRecord::Delegation::ClassSpecificRelation
end

module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  def name(); end
end

module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Delegation::DelegateCache
  def generate_relation_method(method); end

  def include_relation_methods(delegate); end

  def inherited(child_class); end

  def initialize_relation_delegate_cache(); end

  def relation_delegate_class(klass); end
end

module ActiveRecord::Delegation::DelegateCache
end

module ActiveRecord::Delegation
  extend ::ActiveSupport::Concern
end

class ActiveRecord::DeleteRestrictionError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

module ActiveRecord::DynamicMatchers
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::Method
  def attribute_names(); end

  def define(); end

  def initialize(model, method_name); end

  def model(); end

  def name(); end

  def valid?(); end
end

class ActiveRecord::DynamicMatchers::Method
  def self.match(model, name); end

  def self.matchers(); end

  def self.pattern(); end

  def self.prefix(); end

  def self.suffix(); end
end

module ActiveRecord::DynamicMatchers
end

class ActiveRecord::EagerLoadPolymorphicError
  def initialize(reflection=T.unsafe(nil)); end
end

module ActiveRecord::Enum
  def enum(definitions); end

  def inherited(base); end
end

class ActiveRecord::Enum::EnumType
  def assert_valid_value(value); end

  def initialize(name, mapping, subtype); end

  def type(*args, &block); end
end

class ActiveRecord::Enum::EnumType
end

module ActiveRecord::Enum
  def self.extended(base); end
end

class ActiveRecord::EnvironmentMismatchError
  def initialize(current: T.unsafe(nil), stored: T.unsafe(nil)); end
end

module ActiveRecord::Explain
  def collecting_queries_for_explain(); end

  def exec_explain(queries); end
end

module ActiveRecord::Explain
end

class ActiveRecord::ExplainRegistry
  def collect(); end

  def collect=(collect); end

  def collect?(); end

  def queries(); end

  def queries=(queries); end

  def reset(); end
end

class ActiveRecord::ExplainRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.collect?(*args, &block); end
end

class ActiveRecord::ExplainSubscriber
  def finish(name, id, payload); end

  def ignore_payload?(payload); end

  def start(name, id, payload); end
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ExplainSubscriber
end

module ActiveRecord::FinderMethods
  def exists?(conditions=T.unsafe(nil)); end

  def fifth(); end

  def fifth!(); end

  def find(*args); end

  def find_by(arg, *args); end

  def find_by!(arg, *args); end

  def first(limit=T.unsafe(nil)); end

  def first!(); end

  def forty_two(); end

  def forty_two!(); end

  def fourth(); end

  def fourth!(); end

  def last(limit=T.unsafe(nil)); end

  def last!(); end

  def raise_record_not_found_exception!(ids=T.unsafe(nil), result_size=T.unsafe(nil), expected_size=T.unsafe(nil), key=T.unsafe(nil), not_found_ids=T.unsafe(nil)); end

  def second(); end

  def second!(); end

  def second_to_last(); end

  def second_to_last!(); end

  def take(limit=T.unsafe(nil)); end

  def take!(); end

  def third(); end

  def third!(); end

  def third_to_last(); end

  def third_to_last!(); end
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
end

class ActiveRecord::HasManyThroughAssociationNotFoundError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughOrderError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughSourceAssociationNotFoundError
  def initialize(reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughCollection
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::IllegalMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InsertAll
  def connection(); end

  def execute(); end

  def initialize(model, inserts, on_duplicate:, returning: T.unsafe(nil), unique_by: T.unsafe(nil)); end

  def inserts(); end

  def keys(); end

  def map_key_with_value(); end

  def model(); end

  def on_duplicate(); end

  def primary_keys(); end

  def returning(); end

  def skip_duplicates?(); end

  def unique_by(); end

  def updatable_columns(); end

  def update_duplicates?(); end
end

class ActiveRecord::InsertAll::Builder
  def conflict_target(); end

  def initialize(insert_all); end

  def into(); end

  def keys(*args, &block); end

  def model(); end

  def returning(); end

  def skip_duplicates?(*args, &block); end

  def updatable_columns(); end

  def update_duplicates?(*args, &block); end

  def values_list(); end
end

class ActiveRecord::InsertAll::Builder
end

class ActiveRecord::InsertAll
end

module ActiveRecord::Integration
  def cache_key(); end

  def cache_key_with_version(); end

  def cache_version(); end

  def to_param(); end
end

module ActiveRecord::Integration
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InternalMetadata
  include ::ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  include ::ActiveRecord::InternalMetadata::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::InternalMetadata
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.[](key); end

  def self.[]=(key, value); end

  def self.create_table(); end

  def self.drop_table(); end

  def self.page(num=T.unsafe(nil)); end
end

class ActiveRecord::InverseOfAssociationNotFoundError
  def initialize(reflection=T.unsafe(nil), associated_class=T.unsafe(nil)); end
end

module ActiveRecord::LegacyYamlAdapter
end

module ActiveRecord::LegacyYamlAdapter::Rails41
end

module ActiveRecord::LegacyYamlAdapter::Rails41
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter::Rails420
end

module ActiveRecord::LegacyYamlAdapter::Rails420
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter
  def self.convert(klass, coder); end
end

class ActiveRecord::Locking::LockingType
  def deserialize(value); end

  def encode_with(coder); end

  def init_with(coder); end

  def serialize(value); end
end

class ActiveRecord::Locking::LockingType
end

module ActiveRecord::Locking::Optimistic
  def locking_enabled?(); end
end

module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Locking::Pessimistic
  def lock!(lock=T.unsafe(nil)); end
end

module ActiveRecord::Locking
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::LogSubscriber
  def backtrace_cleaner(); end

  def backtrace_cleaner=(val); end

  def backtrace_cleaner?(); end

  def sql(event); end
  IGNORE_PAYLOAD_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::LogSubscriber
  def self.backtrace_cleaner(); end

  def self.backtrace_cleaner=(val); end

  def self.backtrace_cleaner?(); end

  def self.reset_runtime(); end

  def self.runtime(); end

  def self.runtime=(value); end
end

module ActiveRecord::Middleware
end

class ActiveRecord::Middleware::DatabaseSelector
  def call(env); end

  def context_klass(); end

  def initialize(app, resolver_klass=T.unsafe(nil), context_klass=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def resolver_klass(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def context(); end

  def delay(); end

  def initialize(context, options=T.unsafe(nil)); end

  def instrumenter(); end

  def read(&blk); end

  def write(&blk); end
  SEND_TO_REPLICA_DELAY = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def initialize(session); end

  def last_write_timestamp(); end

  def session(); end

  def update_last_write_timestamp(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def self.call(request); end

  def self.convert_time_to_timestamp(time); end

  def self.convert_timestamp_to_time(timestamp); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def self.call(context, options=T.unsafe(nil)); end
end

class ActiveRecord::Middleware::DatabaseSelector
end

module ActiveRecord::Middleware
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Migration
  def announce(message); end

  def connection(); end

  def copy(destination, sources, options=T.unsafe(nil)); end

  def disable_ddl_transaction(); end

  def down(); end

  def exec_migration(conn, direction); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def method_missing(method, *arguments, &block); end

  def migrate(direction); end

  def name(); end

  def name=(name); end

  def next_migration_number(number); end

  def proper_table_name(name, options=T.unsafe(nil)); end

  def reversible(); end

  def revert(*migration_classes); end

  def reverting?(); end

  def run(*migration_classes); end

  def say(message, subitem=T.unsafe(nil)); end

  def say_with_time(message); end

  def suppress_messages(); end

  def table_name_options(config=T.unsafe(nil)); end

  def up(); end

  def up_only(); end

  def verbose(); end

  def verbose=(obj); end

  def version(); end

  def version=(version); end

  def write(text=T.unsafe(nil)); end
  MigrationFilenameRegexp = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migration::CheckPending
  def call(env); end

  def initialize(app); end
end

class ActiveRecord::Migration::CheckPending
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, &block); end

  def add_column(*args, &block); end

  def add_foreign_key(*args, &block); end

  def add_index(*args, &block); end

  def add_reference(*args, &block); end

  def add_timestamps(*args, &block); end

  def change_column(*args, &block); end

  def change_column_comment(*args, &block); end

  def change_column_default(*args, &block); end

  def change_column_null(*args, &block); end

  def change_table(table_name, **options); end

  def change_table_comment(*args, &block); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, &block); end

  def create_table(*args, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, &block); end

  def drop_join_table(*args, &block); end

  def drop_table(*args, &block); end

  def enable_extension(*args, &block); end

  def execute(*args, &block); end

  def execute_block(*args, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end

  def remove_column(*args, &block); end

  def remove_columns(*args, &block); end

  def remove_foreign_key(*args, &block); end

  def remove_index(*args, &block); end

  def remove_reference(*args, &block); end

  def remove_timestamps(*args, &block); end

  def rename_column(*args, &block); end

  def rename_index(*args, &block); end

  def rename_table(*args, &block); end

  def replay(migration); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end

  def invert_add_foreign_key(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_foreign_key(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migration::Compatibility::V4_2
  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*_, **options); end

  def references(*_, **options); end

  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V4_2
end

class ActiveRecord::Migration::Compatibility::V5_0
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, **options); end

  def add_reference(table_name, ref_name, **options); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V5_0
end

class ActiveRecord::Migration::Compatibility::V5_1
  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end
end

class ActiveRecord::Migration::Compatibility::V5_2
  def add_timestamps(table_name, **options); end

  def change_table(table_name, **options); end

  def create_join_table(table_1, table_2, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
  def invert_change_column_comment(args); end

  def invert_change_table_comment(args); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
end

module ActiveRecord::Migration::Compatibility
  def self.find(version); end
end

module ActiveRecord::Migration::JoinTable
end

module ActiveRecord::Migration::JoinTable
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def down(); end

  def reverting(); end

  def reverting=(_); end

  def up(); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Migration
  def self.[](version); end

  def self.check_pending!(connection=T.unsafe(nil)); end

  def self.current_version(); end

  def self.delegate(); end

  def self.delegate=(delegate); end

  def self.disable_ddl_transaction(); end

  def self.disable_ddl_transaction!(); end

  def self.disable_ddl_transaction=(disable_ddl_transaction); end

  def self.inherited(subclass); end

  def self.load_schema_if_pending!(); end

  def self.maintain_test_schema!(); end

  def self.method_missing(name, *args, &block); end

  def self.migrate(direction); end

  def self.nearest_delegate(); end

  def self.verbose(); end

  def self.verbose=(obj); end
end

class ActiveRecord::MigrationContext
  def any_migrations?(); end

  def current_environment(); end

  def current_version(); end

  def down(target_version=T.unsafe(nil)); end

  def forward(steps=T.unsafe(nil)); end

  def get_all_versions(); end

  def initialize(migrations_paths, schema_migration); end

  def last_migration(); end

  def last_stored_environment(); end

  def migrate(target_version=T.unsafe(nil), &block); end

  def migrations(); end

  def migrations_paths(); end

  def migrations_status(); end

  def needs_migration?(); end

  def open(); end

  def protected_environment?(); end

  def rollback(steps=T.unsafe(nil)); end

  def run(direction, target_version); end

  def schema_migration(); end

  def up(target_version=T.unsafe(nil)); end
end

class ActiveRecord::MigrationContext
end

class ActiveRecord::MigrationError
  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::MigrationProxy
  def announce(*args, &block); end

  def basename(); end

  def disable_ddl_transaction(*args, &block); end

  def filename(); end

  def filename=(_); end

  def initialize(name, version, filename, scope); end

  def migrate(*args, &block); end

  def mtime(); end

  def name(); end

  def name=(_); end

  def scope(); end

  def scope=(_); end

  def version(); end

  def version=(_); end

  def write(*args, &block); end
end

class ActiveRecord::MigrationProxy
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Migrator
  def current(); end

  def current_migration(); end

  def current_version(); end

  def initialize(direction, migrations, schema_migration, target_version=T.unsafe(nil)); end

  def load_migrated(); end

  def migrate(); end

  def migrated(); end

  def migrations(); end

  def pending_migrations(); end

  def run(); end

  def runnable(); end
  MIGRATOR_SALT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migrator
  def self.current_version(); end

  def self.migrations_paths(); end

  def self.migrations_paths=(migrations_paths); end
end

class ActiveRecord::MismatchedForeignKey
  def initialize(message: T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil), table: T.unsafe(nil), foreign_key: T.unsafe(nil), target_table: T.unsafe(nil), primary_key: T.unsafe(nil), primary_key_column: T.unsafe(nil)); end
end

module ActiveRecord::ModelSchema
  extend ::ActiveSupport::Concern
  def self.derive_join_table_name(first_table, second_table); end
end

class ActiveRecord::MultiparameterAssignmentErrors
  def errors(); end

  def initialize(errors=T.unsafe(nil)); end
end

module ActiveRecord::NestedAttributes
  def _destroy(); end
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::NoEnvironmentInSchemaError
  def initialize(); end
end

module ActiveRecord::NoTouching
  def no_touching?(); end

  def touch(*_, **_1); end

  def touch_later(*_, **_1); end
end

module ActiveRecord::NoTouching
  extend ::ActiveSupport::Concern
  def self.applied_to?(klass); end

  def self.apply_to(klass); end
end

class ActiveRecord::NullMigration
  def initialize(); end
end

class ActiveRecord::NullMigration
end

module ActiveRecord::NullRelation
  def any?(); end

  def calculate(operation, _column_name); end

  def delete(_id_or_array); end

  def delete_all(); end

  def empty?(); end

  def exists?(_conditions=T.unsafe(nil)); end

  def many?(); end

  def none?(); end

  def one?(); end

  def or(other); end

  def pluck(*column_names); end

  def to_sql(); end

  def update_all(_updates); end
end

module ActiveRecord::NullRelation
end

class ActiveRecord::PendingMigrationError
  include ::ActiveSupport::ActionableError
  def _actions(); end

  def _actions=(val); end

  def _actions?(); end
end

class ActiveRecord::PendingMigrationError
  def self._actions(); end

  def self._actions=(val); end

  def self._actions?(); end
end

module ActiveRecord::Persistence
  def delete(); end

  def destroy(); end

  def destroy!(); end
end

module ActiveRecord::Persistence
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Point
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class ActiveRecord::Point
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder
  def build(attribute, value); end

  def build_bind_attribute(column_name, value); end

  def build_from_hash(attributes); end

  def expand_from_hash(attributes); end

  def initialize(table); end

  def register_handler(klass, handler); end

  def resolve_column_aliases(*args, &block); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  def self.or(other); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
  def initialize(associated_table, value); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
end

class ActiveRecord::PredicateBuilder::BaseHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::BaseHandler
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  def initialize(associated_table, values); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
end

class ActiveRecord::PredicateBuilder::RangeHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def begin(); end

  def begin=(_); end

  def end(); end

  def end=(_); end

  def exclude_end?(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

class ActiveRecord::PredicateBuilder::RelationHandler
end

class ActiveRecord::PredicateBuilder
  def self.references(attributes); end
end

class ActiveRecord::ProtectedEnvironmentError
  def initialize(env=T.unsafe(nil)); end
end

class ActiveRecord::QueryCache
end

module ActiveRecord::QueryCache::ClassMethods
  def cache(&block); end

  def uncached(&block); end
end

module ActiveRecord::QueryCache::ClassMethods
end

class ActiveRecord::QueryCache
  def self.complete(pools); end

  def self.install_executor_hooks(executor=T.unsafe(nil)); end

  def self.run(); end
end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  def _select!(*fields); end

  def annotate(*args); end

  def annotate!(*args); end

  def annotate_values(); end

  def annotate_values=(value); end

  def arel(aliases=T.unsafe(nil)); end

  def build_subquery(subquery_alias, select_value); end

  def construct_join_dependency(associations, join_type); end

  def create_with(value); end

  def create_with!(value); end

  def create_with_value(); end

  def create_with_value=(value); end

  def distinct(value=T.unsafe(nil)); end

  def distinct!(value=T.unsafe(nil)); end

  def distinct_value(); end

  def distinct_value=(value); end

  def eager_load(*args); end

  def eager_load!(*args); end

  def eager_load_values(); end

  def eager_load_values=(value); end

  def extending(*modules, &block); end

  def extending!(*modules, &block); end

  def extending_values(); end

  def extending_values=(value); end

  def extensions(); end

  def extract_associated(association); end

  def from(value, subquery_name=T.unsafe(nil)); end

  def from!(value, subquery_name=T.unsafe(nil)); end

  def from_clause(); end

  def from_clause=(value); end

  def group(*args); end

  def group!(*args); end

  def group_values(); end

  def group_values=(value); end

  def having(opts, *rest); end

  def having!(opts, *rest); end

  def having_clause(); end

  def having_clause=(value); end

  def includes(*args); end

  def includes!(*args); end

  def includes_values(); end

  def includes_values=(value); end

  def joins(*args); end

  def joins!(*args); end

  def joins_values(); end

  def joins_values=(value); end

  def left_joins(*args); end

  def left_outer_joins(*args); end

  def left_outer_joins!(*args); end

  def left_outer_joins_values(); end

  def left_outer_joins_values=(value); end

  def limit(value); end

  def limit!(value); end

  def limit_value(); end

  def limit_value=(value); end

  def lock(locks=T.unsafe(nil)); end

  def lock!(locks=T.unsafe(nil)); end

  def lock_value(); end

  def lock_value=(value); end

  def none(); end

  def none!(); end

  def offset(value); end

  def offset!(value); end

  def offset_value(); end

  def offset_value=(value); end

  def optimizer_hints(*args); end

  def optimizer_hints!(*args); end

  def optimizer_hints_values(); end

  def optimizer_hints_values=(value); end

  def or(other); end

  def or!(other); end

  def order(*args); end

  def order!(*args); end

  def order_values(); end

  def order_values=(value); end

  def preload(*args); end

  def preload!(*args); end

  def preload_values(); end

  def preload_values=(value); end

  def readonly(value=T.unsafe(nil)); end

  def readonly!(value=T.unsafe(nil)); end

  def readonly_value(); end

  def readonly_value=(value); end

  def references(*table_names); end

  def references!(*table_names); end

  def references_values(); end

  def references_values=(value); end

  def reorder(*args); end

  def reorder!(*args); end

  def reordering_value(); end

  def reordering_value=(value); end

  def reselect(*args); end

  def reselect!(*args); end

  def reverse_order(); end

  def reverse_order!(); end

  def reverse_order_value(); end

  def reverse_order_value=(value); end

  def rewhere(conditions); end

  def select(*fields); end

  def select_values(); end

  def select_values=(value); end

  def skip_preloading!(); end

  def skip_query_cache!(value=T.unsafe(nil)); end

  def skip_query_cache_value(); end

  def skip_query_cache_value=(value); end

  def unscope(*args); end

  def unscope!(*args); end

  def unscope_values(); end

  def unscope_values=(value); end

  def where(opts=T.unsafe(nil), *rest); end

  def where!(opts, *rest); end

  def where_clause(); end

  def where_clause=(value); end
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_OR_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::QueryMethods::WhereChain
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(scope); end

  def not(opts, *rest); end
end

class ActiveRecord::QueryMethods::WhereChain
end

module ActiveRecord::QueryMethods
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Querying
  def annotate(*args, &block); end

  def any?(*args, &block); end

  def average(*args, &block); end

  def calculate(*args, &block); end

  def count(*args, &block); end

  def count_by_sql(sql); end

  def create_or_find_by(*args, &block); end

  def create_or_find_by!(*args, &block); end

  def create_with(*args, &block); end

  def delete_all(*args, &block); end

  def delete_by(*args, &block); end

  def destroy_all(*args, &block); end

  def destroy_by(*args, &block); end

  def distinct(*args, &block); end

  def eager_load(*args, &block); end

  def except(*args, &block); end

  def exists?(*args, &block); end

  def extending(*args, &block); end

  def extract_associated(*args, &block); end

  def fifth(*args, &block); end

  def fifth!(*args, &block); end

  def find(*args, &block); end

  def find_by(*args, &block); end

  def find_by!(*args, &block); end

  def find_by_sql(sql, binds=T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  def find_each(*args, &block); end

  def find_in_batches(*args, &block); end

  def find_or_create_by(*args, &block); end

  def find_or_create_by!(*args, &block); end

  def find_or_initialize_by(*args, &block); end

  def first(*args, &block); end

  def first!(*args, &block); end

  def first_or_create(*args, &block); end

  def first_or_create!(*args, &block); end

  def first_or_initialize(*args, &block); end

  def forty_two(*args, &block); end

  def forty_two!(*args, &block); end

  def fourth(*args, &block); end

  def fourth!(*args, &block); end

  def from(*args, &block); end

  def group(*args, &block); end

  def having(*args, &block); end

  def ids(*args, &block); end

  def in_batches(*args, &block); end

  def includes(*args, &block); end

  def joins(*args, &block); end

  def last(*args, &block); end

  def last!(*args, &block); end

  def left_joins(*args, &block); end

  def left_outer_joins(*args, &block); end

  def limit(*args, &block); end

  def lock(*args, &block); end

  def many?(*args, &block); end

  def maximum(*args, &block); end

  def merge(*args, &block); end

  def minimum(*args, &block); end

  def none(*args, &block); end

  def none?(*args, &block); end

  def offset(*args, &block); end

  def one?(*args, &block); end

  def only(*args, &block); end

  def optimizer_hints(*args, &block); end

  def or(*args, &block); end

  def order(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def preload(*args, &block); end

  def readonly(*args, &block); end

  def references(*args, &block); end

  def reorder(*args, &block); end

  def reselect(*args, &block); end

  def rewhere(*args, &block); end

  def second(*args, &block); end

  def second!(*args, &block); end

  def second_to_last(*args, &block); end

  def second_to_last!(*args, &block); end

  def select(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take!(*args, &block); end

  def third(*args, &block); end

  def third!(*args, &block); end

  def third_to_last(*args, &block); end

  def third_to_last!(*args, &block); end

  def touch_all(*args, &block); end

  def unscope(*args, &block); end

  def update_all(*args, &block); end

  def where(*args, &block); end
  QUERYING_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Querying
end

class ActiveRecord::Railtie
end

class ActiveRecord::Railtie
end

module ActiveRecord::Railties
end

module ActiveRecord::Railties::CollectionCacheAssociationLoading
  def collection_with_template(*_); end

  def collection_without_template(*_); end

  def relation_from_options(cached: T.unsafe(nil), partial: T.unsafe(nil), collection: T.unsafe(nil), **_); end

  def setup(context, options, as, block); end
end

module ActiveRecord::Railties::CollectionCacheAssociationLoading
end

module ActiveRecord::Railties::ControllerRuntime
  def db_runtime(); end

  def db_runtime=(db_runtime); end
end

module ActiveRecord::Railties::ControllerRuntime
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Railties
end

class ActiveRecord::ReadOnlyError
end

class ActiveRecord::ReadOnlyError
end

module ActiveRecord::ReadonlyAttributes
end

module ActiveRecord::ReadonlyAttributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::RecordInvalid
  def initialize(record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotDestroyed
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotFound
  def id(); end

  def initialize(message=T.unsafe(nil), model=T.unsafe(nil), primary_key=T.unsafe(nil), id=T.unsafe(nil)); end

  def model(); end

  def primary_key(); end
end

class ActiveRecord::RecordNotSaved
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

module ActiveRecord::Reflection
end

class ActiveRecord::Reflection::AbstractReflection
  def actual_source_reflection(); end

  def alias_candidate(name); end

  def build_association(attributes, &block); end

  def build_scope(table, predicate_builder=T.unsafe(nil)); end

  def chain(); end

  def check_validity_of_inverse!(); end

  def class_name(); end

  def constraints(); end

  def counter_cache_column(); end

  def counter_must_be_updated_by_has_many?(); end

  def get_join_keys(association_klass); end

  def has_cached_counter?(); end

  def inverse_of(); end

  def inverse_updates_counter_cache?(); end

  def inverse_updates_counter_in_memory?(); end

  def inverse_which_updates_counter_cache(); end

  def join_foreign_key(); end

  def join_keys(); end

  def join_primary_key(*_); end

  def join_scope(table, foreign_table, foreign_klass); end

  def join_scopes(table, predicate_builder); end

  def klass_join_scope(table, predicate_builder); end

  def scopes(); end

  def table_name(); end

  def through_reflection?(); end
end

class ActiveRecord::Reflection::AbstractReflection
end

class ActiveRecord::Reflection::MacroReflection
  def ==(other_aggregation); end

  def active_record(); end

  def autosave=(autosave); end

  def compute_class(name); end

  def initialize(name, scope, options, active_record); end

  def klass(); end

  def name(); end

  def options(); end

  def plural_name(); end

  def scope(); end

  def scope_for(relation, owner=T.unsafe(nil)); end
end

class ActiveRecord::Reflection::MacroReflection
end

module ActiveRecord::Reflection
  extend ::ActiveSupport::Concern
  extend ::ActiveStorage::Reflection::ReflectionExtension
  def self.add_aggregate_reflection(ar, name, reflection); end

  def self.add_reflection(ar, name, reflection); end

  def self.create(macro, name, scope, options, ar); end
end

class ActiveRecord::Relation
  include ::Enumerable
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::FinderMethods
  def ==(other); end

  def _deprecated_scope_source(); end

  def _deprecated_scope_source=(_deprecated_scope_source); end

  def _exec_scope(name, *args, &block); end

  def alias_tracker(joins=T.unsafe(nil), aliases=T.unsafe(nil)); end

  def arel_attribute(name); end

  def bind_attribute(name, value); end

  def build(attributes=T.unsafe(nil), &block); end

  def cache_key(timestamp_column=T.unsafe(nil)); end

  def cache_key_with_version(); end

  def cache_version(timestamp_column=T.unsafe(nil)); end

  def create(attributes=T.unsafe(nil), &block); end

  def create!(attributes=T.unsafe(nil), &block); end

  def create_or_find_by(attributes, &block); end

  def create_or_find_by!(attributes, &block); end

  def delete_by(*args); end

  def destroy_all(); end

  def destroy_by(*args); end

  def eager_loading?(); end

  def empty_scope?(); end

  def encode_with(coder); end

  def explain(); end

  def find_or_create_by(attributes, &block); end

  def find_or_create_by!(attributes, &block); end

  def find_or_initialize_by(attributes, &block); end

  def first_or_create(attributes=T.unsafe(nil), &block); end

  def first_or_create!(attributes=T.unsafe(nil), &block); end

  def first_or_initialize(attributes=T.unsafe(nil), &block); end

  def has_limit_or_offset?(); end

  def initialize(klass, table: T.unsafe(nil), predicate_builder: T.unsafe(nil), values: T.unsafe(nil)); end

  def joined_includes_values(); end

  def klass(); end

  def load(&block); end

  def load_records(records); end

  def loaded(); end

  def loaded?(); end

  def locked?(); end

  def model(); end

  def new(attributes=T.unsafe(nil), &block); end

  def null_relation?(); end

  def predicate_builder(); end

  def preload_associations(records); end

  def records(); end

  def reload(); end

  def reset(); end

  def scope_for_create(); end

  def scoping(); end

  def skip_preloading_value(); end

  def skip_preloading_value=(skip_preloading_value); end

  def table(); end

  def to_a(); end

  def to_ary(); end

  def to_sql(); end

  def touch_all(*names, time: T.unsafe(nil)); end

  def update(id=T.unsafe(nil), attributes); end

  def update_all(updates); end

  def update_counters(counters); end

  def values(); end

  def where_values_hash(relation_table_name=T.unsafe(nil)); end
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::FromClause
  def ==(other); end

  def empty?(); end

  def initialize(value, name); end

  def merge(other); end

  def name(); end

  def value(); end
end

class ActiveRecord::Relation::FromClause
  def self.empty(); end
end

class ActiveRecord::Relation::HashMerger
  def initialize(relation, hash); end

  def merge(); end

  def other(); end

  def relation(); end
end

class ActiveRecord::Relation::HashMerger
end

class ActiveRecord::Relation::Merger
  def initialize(relation, other); end

  def merge(); end

  def normal_values(); end

  def other(); end

  def relation(); end

  def values(); end
  NORMAL_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::Merger
end

class ActiveRecord::Relation::QueryAttribute
  def infinite?(); end

  def type_cast(value); end

  def unboundable?(); end
end

class ActiveRecord::Relation::QueryAttribute
end

class ActiveRecord::Relation::WhereClause
  def +(other); end

  def -(other); end

  def ==(other); end

  def any?(*args, &block); end

  def ast(); end

  def empty?(*args, &block); end

  def except(*columns); end

  def initialize(predicates); end

  def invert(as=T.unsafe(nil)); end

  def merge(other); end

  def or(other); end

  def predicates(); end

  def referenced_columns(); end

  def to_h(table_name=T.unsafe(nil)); end
  ARRAY_WITH_EMPTY_STRING = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::WhereClause
  def self.empty(); end
end

class ActiveRecord::Relation::WhereClauseFactory
  def build(opts, other); end

  def initialize(klass, predicate_builder); end
end

class ActiveRecord::Relation::WhereClauseFactory
end

class ActiveRecord::Relation
  extend ::ActiveRecord::Delegation::ClassMethods
end

class ActiveRecord::Result
  include ::Enumerable
  def [](idx); end

  def cast_values(type_overrides=T.unsafe(nil)); end

  def collect!(); end

  def column_types(); end

  def columns(); end

  def each(&blk); end

  def empty?(); end

  def first(); end

  def includes_column?(name); end

  def initialize(columns, rows, column_types=T.unsafe(nil)); end

  def last(); end

  def length(); end

  def map!(); end

  def rows(); end

  def to_a(); end

  def to_ary(); end

  def to_hash(); end
end

class ActiveRecord::RuntimeRegistry
  def connection_handler(); end

  def connection_handler=(connection_handler); end

  def sql_runtime(); end

  def sql_runtime=(sql_runtime); end
end

class ActiveRecord::RuntimeRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.connection_handler(); end

  def self.connection_handler=(x); end

  def self.sql_runtime(); end

  def self.sql_runtime=(x); end
end

module ActiveRecord::Sanitization
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Schema
  def define(info, &block); end
end

class ActiveRecord::SchemaDumper
  def dump(stream); end

  def fk_ignore_pattern(); end

  def fk_ignore_pattern=(obj); end

  def ignore_tables(); end

  def ignore_tables=(obj); end

  def initialize(connection, options=T.unsafe(nil)); end
end

class ActiveRecord::SchemaDumper
  def self.dump(connection=T.unsafe(nil), stream=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.fk_ignore_pattern(); end

  def self.fk_ignore_pattern=(obj); end

  def self.ignore_tables(); end

  def self.ignore_tables=(obj); end
end

class ActiveRecord::SchemaMigration
  include ::ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  include ::ActiveRecord::SchemaMigration::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  def version(); end
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::SchemaMigration
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.all_versions(); end

  def self.create_table(); end

  def self.drop_table(); end

  def self.normalize_migration_number(number); end

  def self.normalized_versions(); end

  def self.page(num=T.unsafe(nil)); end
end

module ActiveRecord::Scoping
  def initialize_internals_callback(); end

  def populate_with_current_scope_attributes(); end
end

module ActiveRecord::Scoping::Default
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Scoping::Named
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::SecureToken
end

module ActiveRecord::SecureToken
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Serialization
  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveRecord::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::SpawnMethods
  def except(*skips); end

  def merge(other); end

  def merge!(other); end

  def only(*onlies); end

  def spawn(); end
end

module ActiveRecord::SpawnMethods
end

class ActiveRecord::StaleObjectError
  def attempted_action(); end

  def initialize(record=T.unsafe(nil), attempted_action=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::StatementCache
  def execute(params, connection, &block); end

  def initialize(query_builder, bind_map, klass); end
end

class ActiveRecord::StatementCache::BindMap
  def bind(values); end

  def initialize(bound_attributes); end
end

class ActiveRecord::StatementCache::BindMap
end

class ActiveRecord::StatementCache::Params
  def bind(); end
end

class ActiveRecord::StatementCache::Params
end

class ActiveRecord::StatementCache::PartialQuery
  def initialize(values); end
end

class ActiveRecord::StatementCache::PartialQuery
end

class ActiveRecord::StatementCache::PartialQueryCollector
  def <<(str); end

  def add_bind(obj); end

  def value(); end
end

class ActiveRecord::StatementCache::PartialQueryCollector
end

class ActiveRecord::StatementCache::Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::Query
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache
  def self.create(connection, callable=T.unsafe(nil), &block); end

  def self.partial_query(values); end

  def self.partial_query_collector(); end

  def self.query(sql); end

  def self.unsupported_value?(value); end
end

class ActiveRecord::StatementInvalid
  def binds(); end

  def initialize(message=T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil)); end

  def sql(); end
end

module ActiveRecord::Store
end

module ActiveRecord::Store
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Suppressor
  def save(*_, **_1); end

  def save!(*_, **_1); end
end

module ActiveRecord::Suppressor
  extend ::ActiveSupport::Concern
end

class ActiveRecord::SuppressorRegistry
  def suppressed(); end
end

class ActiveRecord::SuppressorRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.suppressed(*args, &block); end
end

class ActiveRecord::TableMetadata
  def aggregated_with?(aggregation_name); end

  def arel_attribute(column_name); end

  def associated_predicate_builder(table_name); end

  def associated_table(table_name); end

  def associated_with?(association_name); end

  def association_foreign_key(*args, &block); end

  def association_foreign_type(*args, &block); end

  def association_join_foreign_key(*args, &block); end

  def association_join_primary_key(*args, &block); end

  def has_column?(column_name); end

  def initialize(klass, arel_table, association=T.unsafe(nil), types=T.unsafe(nil)); end

  def polymorphic_association?(); end

  def predicate_builder(); end

  def reflect_on_aggregation(aggregation_name); end

  def resolve_column_aliases(hash); end

  def type(column_name); end
end

class ActiveRecord::TableMetadata
end

module ActiveRecord::Tasks
end

module ActiveRecord::Tasks::DatabaseTasks
  def cache_dump_filename(namespace); end

  def charset(*arguments); end

  def charset_current(environment=T.unsafe(nil), specification_name=T.unsafe(nil)); end

  def check_protected_environments!(); end

  def check_schema_file(filename); end

  def check_target_version(); end

  def collation(*arguments); end

  def collation_current(environment=T.unsafe(nil), specification_name=T.unsafe(nil)); end

  def create(*arguments); end

  def create_all(); end

  def create_current(environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def current_config(options=T.unsafe(nil)); end

  def current_config=(current_config); end

  def database_configuration(); end

  def database_configuration=(database_configuration); end

  def db_dir(); end

  def db_dir=(db_dir); end

  def drop(*arguments); end

  def drop_all(); end

  def drop_current(environment=T.unsafe(nil)); end

  def dump_filename(namespace, format=T.unsafe(nil)); end

  def dump_schema(configuration, format=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def dump_schema_cache(conn, filename); end

  def env(); end

  def env=(env); end

  def fixtures_path(); end

  def fixtures_path=(fixtures_path); end

  def for_each(databases); end

  def load_schema(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def load_schema_current(format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_seed(); end

  def migrate(); end

  def migrate_status(); end

  def migrations_paths(); end

  def migrations_paths=(migrations_paths); end

  def purge(configuration); end

  def purge_all(); end

  def purge_current(environment=T.unsafe(nil)); end

  def raise_for_multi_db(environment=T.unsafe(nil), command:); end

  def reconstruct_from_schema(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def register_task(pattern, task); end

  def root(); end

  def root=(root); end

  def schema_file(format=T.unsafe(nil)); end

  def schema_file_type(format=T.unsafe(nil)); end

  def schema_up_to_date?(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def seed_loader(); end

  def seed_loader=(seed_loader); end

  def setup_initial_database_yaml(); end

  def spec(); end

  def structure_dump(*arguments); end

  def structure_load(*arguments); end

  def target_version(); end

  def truncate_all(environment=T.unsafe(nil)); end
  LOCAL_HOSTS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Tasks::DatabaseTasks
  extend ::ActiveRecord::Tasks::DatabaseTasks
  def self.structure_dump_flags(); end

  def self.structure_dump_flags=(obj); end

  def self.structure_load_flags(); end

  def self.structure_load_flags=(obj); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  ER_DB_CREATE_EXISTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*args, &block); end

  def collation(); end

  def connection(*args, &block); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
end

module ActiveRecord::Tasks
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::TestDatabases
end

module ActiveRecord::TestDatabases
  def self.create_and_load_schema(i, env_name:); end
end

module ActiveRecord::TestFixtures
  def after_teardown(); end

  def before_setup(); end

  def enlist_fixture_connections(); end

  def run_in_transaction?(); end

  def setup_fixtures(config=T.unsafe(nil)); end

  def teardown_fixtures(); end
end

module ActiveRecord::TestFixtures::ClassMethods
  def fixtures(*fixture_set_names); end

  def set_fixture_class(class_names=T.unsafe(nil)); end

  def setup_fixture_accessors(fixture_set_names=T.unsafe(nil)); end

  def uses_transaction(*methods); end

  def uses_transaction?(method); end
end

module ActiveRecord::TestFixtures::ClassMethods
end

module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::ThroughNestedAssociationsAreReadonly
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

module ActiveRecord::Timestamp
end

module ActiveRecord::Timestamp
  extend ::ActiveSupport::Concern
end

module ActiveRecord::TouchLater
  def touch(*names, time: T.unsafe(nil)); end

  def touch_later(*names, **_); end
end

module ActiveRecord::TouchLater
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Transactions
  def before_committed!(); end

  def committed!(should_run_callbacks: T.unsafe(nil)); end

  def destroy(); end

  def rolledback!(force_restore_state: T.unsafe(nil), should_run_callbacks: T.unsafe(nil)); end

  def save(*_, **_1); end

  def save!(*_, **_1); end

  def touch(*_, **_1); end

  def transaction(options=T.unsafe(nil), &block); end

  def trigger_transactional_callbacks?(); end

  def with_transaction_returning_status(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Transactions
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Translation
  include ::ActiveModel::Translation
  include ::ActiveModel::Naming
  def i18n_scope(); end

  def lookup_ancestors(); end
end

module ActiveRecord::Translation
end

class ActiveRecord::Type::AdapterSpecificRegistry
  def add_modifier(options, klass, **args); end
end

class ActiveRecord::Type::AdapterSpecificRegistry
end

ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger

ActiveRecord::Type::Binary = ActiveModel::Type::Binary

class ActiveRecord::Type::Date
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Date
end

class ActiveRecord::Type::DateTime
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::DateTime
end

ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecorationRegistration
  def call(registry, *args, **kwargs); end

  def initialize(options, klass, adapter: T.unsafe(nil)); end

  def matches?(*args, **kwargs); end
end

class ActiveRecord::Type::DecorationRegistration
end

ActiveRecord::Type::Float = ActiveModel::Type::Float

class ActiveRecord::Type::HashLookupTypeMap
  def alias_type(type, alias_type); end

  def key?(key); end

  def keys(); end
end

class ActiveRecord::Type::HashLookupTypeMap
end

ActiveRecord::Type::Integer = ActiveModel::Type::Integer

module ActiveRecord::Type::Internal
end

module ActiveRecord::Type::Internal::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

module ActiveRecord::Type::Internal::Timezone
end

module ActiveRecord::Type::Internal
end

class ActiveRecord::Type::Json
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end
end

class ActiveRecord::Type::Json
end

class ActiveRecord::Type::Registration
  def adapter(); end

  def block(); end

  def call(_registry, *args, adapter: T.unsafe(nil), **kwargs); end

  def initialize(name, block, adapter: T.unsafe(nil), override: T.unsafe(nil)); end

  def matches?(type_name, *args, **kwargs); end

  def name(); end

  def override(); end

  def priority(); end

  def priority_except_adapter(); end
end

class ActiveRecord::Type::Registration
end

class ActiveRecord::Type::Serialized
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end

  def assert_valid_value(value); end

  def changed_in_place?(raw_old_value, value); end

  def coder(); end

  def deserialize(value); end

  def force_equality?(value); end

  def initialize(subtype, coder); end

  def inspect(); end

  def serialize(value); end

  def subtype(); end
end

class ActiveRecord::Type::Serialized
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Time
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time
end

class ActiveRecord::Type::TypeMap
  def alias_type(key, target_key); end

  def clear(); end

  def fetch(lookup_key, *args, &block); end

  def lookup(lookup_key, *args); end

  def register_type(key, value=T.unsafe(nil), &block); end
end

class ActiveRecord::Type::TypeMap
end

class ActiveRecord::Type::UnsignedInteger
end

class ActiveRecord::Type::UnsignedInteger
end

module ActiveRecord::Type
  def self.add_modifier(*args, &block); end

  def self.default_value(); end

  def self.lookup(*args, adapter: T.unsafe(nil), **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

module ActiveRecord::TypeCaster
end

class ActiveRecord::TypeCaster::Connection
  def initialize(klass, table_name); end

  def type_cast_for_database(attr_name, value); end

  def type_for_attribute(attr_name); end
end

class ActiveRecord::TypeCaster::Connection
end

class ActiveRecord::TypeCaster::Map
  def initialize(types); end

  def type_cast_for_database(attr_name, value); end
end

class ActiveRecord::TypeCaster::Map
end

module ActiveRecord::TypeCaster
end

class ActiveRecord::UnknownMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

class ActiveRecord::UnknownPrimaryKey
  def initialize(model=T.unsafe(nil), description=T.unsafe(nil)); end

  def model(); end
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
end

module ActiveRecord::Validations
  def save(**options); end

  def save!(**options); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end
end

module ActiveRecord::Validations
  extend ::ActiveSupport::Concern
end

module ActiveRecord
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveStorage
  def analyzers(); end

  def analyzers=(obj); end

  def binary_content_type(); end

  def binary_content_type=(obj); end

  def content_types_allowed_inline(); end

  def content_types_allowed_inline=(obj); end

  def content_types_to_serve_as_binary(); end

  def content_types_to_serve_as_binary=(obj); end

  def logger(); end

  def logger=(obj); end

  def paths(); end

  def paths=(obj); end

  def previewers(); end

  def previewers=(obj); end

  def queues(); end

  def queues=(obj); end

  def replace_on_assign_to_many(); end

  def replace_on_assign_to_many=(obj); end

  def routes_prefix(); end

  def routes_prefix=(obj); end

  def service_urls_expire_in(); end

  def service_urls_expire_in=(obj); end

  def variable_content_types(); end

  def variable_content_types=(obj); end

  def variant_processor(); end

  def variant_processor=(obj); end

  def verifier(); end

  def verifier=(obj); end
end

class ActiveStorage::AnalyzeJob
  def perform(blob); end
end

class ActiveStorage::AnalyzeJob
end

class ActiveStorage::Analyzer
  def blob(); end

  def initialize(blob); end

  def metadata(); end
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::NullAnalyzer
end

class ActiveStorage::Analyzer::NullAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer
  def self.accept?(blob); end
end

class ActiveStorage::Attached
  def initialize(name, record); end

  def name(); end

  def record(); end
end

module ActiveStorage::Attached::Changes
end

class ActiveStorage::Attached::Changes::CreateMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record, attachables); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateMany
end

class ActiveStorage::Attached::Changes::CreateOne
  def attachable(); end

  def attachment(); end

  def blob(); end

  def initialize(name, record, attachable); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateOne
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::DeleteMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteMany
end

class ActiveStorage::Attached::Changes::DeleteOne
  def attachment(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteOne
end

module ActiveStorage::Attached::Changes
  extend ::ActiveSupport::Autoload
end

class ActiveStorage::Attached::Many
  def method_missing(method, *args, &block); end
end

module ActiveStorage::Attached::Model
  def attachment_changes(); end

  def changed_for_autosave?(); end

  def reload(*_); end
end

module ActiveStorage::Attached::Model
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Attached::One
  def method_missing(method, *args, &block); end
end

class ActiveStorage::Attachment
  include ::ActiveStorage::Attachment::GeneratedAttributeMethods
  include ::ActiveStorage::Attachment::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  def autosave_associated_records_for_blob(*args); end

  def autosave_associated_records_for_record(*args); end

  def purge(); end

  def purge_later(); end
end

module ActiveStorage::Attachment::GeneratedAssociationMethods
  def blob(); end

  def blob=(value); end

  def build_blob(*args, &block); end

  def create_blob(*args, &block); end

  def create_blob!(*args, &block); end

  def record(); end

  def record=(value); end

  def reload_blob(); end

  def reload_record(); end
end

module ActiveStorage::Attachment::GeneratedAssociationMethods
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveStorage::Attachment
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.page(num=T.unsafe(nil)); end
end

class ActiveStorage::BaseController
  include ::ActiveStorage::SetCurrent
end

class ActiveStorage::BaseController
end

class ActiveStorage::BaseJob
end

class ActiveStorage::BaseJob
end

class ActiveStorage::Blob
  include ::ActiveStorage::Blob::GeneratedAttributeMethods
  include ::ActiveStorage::Blob::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  include ::ActiveStorage::Blob::Analyzable
  include ::ActiveStorage::Blob::Identifiable
  include ::ActionText::Attachable
  def after_add_for_attachments(); end

  def after_add_for_attachments=(val); end

  def after_add_for_attachments?(); end

  def after_remove_for_attachments(); end

  def after_remove_for_attachments=(val); end

  def after_remove_for_attachments?(); end

  def attachable_plain_text_representation(caption=T.unsafe(nil)); end

  def audio?(); end

  def autosave_associated_records_for_attachments(*args); end

  def autosave_associated_records_for_preview_image_attachment(); end

  def autosave_associated_records_for_preview_image_blob(); end

  def before_add_for_attachments(); end

  def before_add_for_attachments=(val); end

  def before_add_for_attachments?(); end

  def before_remove_for_attachments(); end

  def before_remove_for_attachments=(val); end

  def before_remove_for_attachments?(); end

  def download(&block); end

  def filename(); end

  def image?(); end

  def key(); end

  def open(tmpdir: T.unsafe(nil), &block); end

  def purge(); end

  def purge_later(); end

  def regenerate_key(); end

  def service(); end

  def service=(val); end

  def service?(); end

  def service_headers_for_direct_upload(); end

  def service_url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil), filename: T.unsafe(nil), **options); end

  def service_url_for_direct_upload(expires_in: T.unsafe(nil)); end

  def signed_id(); end

  def text?(); end

  def unfurl(io, identify: T.unsafe(nil)); end

  def upload(io, identify: T.unsafe(nil)); end

  def upload_without_unfurling(io); end

  def validate_associated_records_for_attachments(*args); end

  def video?(); end
end

module ActiveStorage::Blob::Analyzable
  def analyze(); end

  def analyze_later(); end

  def analyzed?(); end
end

module ActiveStorage::Blob::Analyzable
end

module ActiveStorage::Blob::GeneratedAssociationMethods
  def attachment_ids(); end

  def attachment_ids=(ids); end

  def attachments(); end

  def attachments=(value); end

  def build_preview_image_attachment(*args, &block); end

  def create_preview_image_attachment(*args, &block); end

  def create_preview_image_attachment!(*args, &block); end

  def preview_image(); end

  def preview_image=(attachable); end

  def preview_image_attachment(); end

  def preview_image_attachment=(value); end

  def preview_image_blob(); end

  def preview_image_blob=(value); end

  def reload_preview_image_attachment(); end

  def reload_preview_image_blob(); end
end

module ActiveStorage::Blob::GeneratedAssociationMethods
end

module ActiveStorage::Blob::GeneratedAttributeMethods
end

module ActiveStorage::Blob::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::Identifiable
  def identified?(); end

  def identify(); end
end

module ActiveStorage::Blob::Identifiable
end

module ActiveStorage::Blob::Representable
  def preview(transformations); end

  def previewable?(); end

  def representable?(); end

  def representation(transformations); end

  def variable?(); end
end

module ActiveStorage::Blob::Representable
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Blob
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  extend ::ActionText::Attachable::ClassMethods
  def self.after_add_for_attachments(); end

  def self.after_add_for_attachments=(val); end

  def self.after_add_for_attachments?(); end

  def self.after_remove_for_attachments(); end

  def self.after_remove_for_attachments=(val); end

  def self.after_remove_for_attachments?(); end

  def self.before_add_for_attachments(); end

  def self.before_add_for_attachments=(val); end

  def self.before_add_for_attachments?(); end

  def self.before_remove_for_attachments(); end

  def self.before_remove_for_attachments=(val); end

  def self.before_remove_for_attachments?(); end

  def self.build_after_unfurling(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil)); end

  def self.build_after_upload(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil)); end

  def self.create_after_unfurling!(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_after_upload!(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_and_upload!(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_before_direct_upload!(filename:, byte_size:, checksum:, content_type: T.unsafe(nil), metadata: T.unsafe(nil)); end

  def self.find_signed(id); end

  def self.page(num=T.unsafe(nil)); end

  def self.service(); end

  def self.service=(val); end

  def self.service?(); end

  def self.unattached(*args); end

  def self.with_attached_preview_image(*args); end
end

class ActiveStorage::BlobsController
  include ::ActiveStorage::SetBlob
  def show(); end
end

class ActiveStorage::BlobsController
end

class ActiveStorage::Current
end

class ActiveStorage::Current
  def self.host(); end

  def self.host=(attribute); end
end

class ActiveStorage::DirectUploadsController
  def create(); end
end

class ActiveStorage::DirectUploadsController
end

class ActiveStorage::DiskController
  def show(); end

  def update(); end
end

class ActiveStorage::DiskController
end

class ActiveStorage::Downloader
  def initialize(service); end

  def open(key, checksum:, name: T.unsafe(nil), tmpdir: T.unsafe(nil)); end

  def service(); end
end

class ActiveStorage::Downloader
end

class ActiveStorage::Engine
end

class ActiveStorage::Engine
end

class ActiveStorage::Error
end

class ActiveStorage::Error
end

class ActiveStorage::FileNotFoundError
end

class ActiveStorage::FileNotFoundError
end

class ActiveStorage::Filename
  include ::Comparable
  def as_json(*_); end

  def base(); end

  def extension(); end

  def extension_with_delimiter(); end

  def extension_without_delimiter(); end

  def initialize(filename); end

  def sanitized(); end

  def to_json(); end
end

class ActiveStorage::Filename
  def self.wrap(filename); end
end

class ActiveStorage::IntegrityError
end

class ActiveStorage::IntegrityError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::LogSubscriber
  def service_delete(event); end

  def service_delete_prefixed(event); end

  def service_download(event); end

  def service_exist(event); end

  def service_streaming_download(event); end

  def service_upload(event); end

  def service_url(event); end
end

class ActiveStorage::LogSubscriber
end

class ActiveStorage::Preview
  def blob(); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def processed(); end

  def service_url(**options); end

  def variation(); end
end

class ActiveStorage::Preview::UnprocessedError
end

class ActiveStorage::Preview::UnprocessedError
end

class ActiveStorage::Preview
end

class ActiveStorage::Previewer
  def blob(); end

  def initialize(blob); end

  def preview(); end
end

class ActiveStorage::Previewer::MuPDFPreviewer
end

class ActiveStorage::Previewer::MuPDFPreviewer
  def self.mutool_exists?(); end

  def self.mutool_path(); end
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
  def self.pdftoppm_exists?(); end

  def self.pdftoppm_path(); end
end

class ActiveStorage::Previewer::VideoPreviewer
end

class ActiveStorage::Previewer::VideoPreviewer
  def self.ffmpeg_exists?(); end

  def self.ffmpeg_path(); end
end

class ActiveStorage::Previewer
  def self.accept?(blob); end
end

class ActiveStorage::PurgeJob
  def perform(blob); end
end

class ActiveStorage::PurgeJob
end

module ActiveStorage::Reflection
end

module ActiveStorage::Reflection::ActiveRecordExtensions
end

module ActiveStorage::Reflection::ActiveRecordExtensions
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Reflection::HasManyAttachedReflection
  def macro(); end
end

class ActiveStorage::Reflection::HasManyAttachedReflection
end

class ActiveStorage::Reflection::HasOneAttachedReflection
  def macro(); end
end

class ActiveStorage::Reflection::HasOneAttachedReflection
end

module ActiveStorage::Reflection::ReflectionExtension
  def add_attachment_reflection(model, name, reflection); end
end

module ActiveStorage::Reflection::ReflectionExtension
end

module ActiveStorage::Reflection
end

class ActiveStorage::RepresentationsController
  include ::ActiveStorage::SetBlob
  def show(); end
end

class ActiveStorage::RepresentationsController
end

class ActiveStorage::Service
  def delete(key); end

  def delete_prefixed(prefix); end

  def download(key); end

  def download_chunk(key, range); end

  def exist?(key); end

  def headers_for_direct_upload(key, filename:, content_type:, content_length:, checksum:); end

  def open(*args, **options, &block); end

  def update_metadata(key, **metadata); end

  def upload(key, io, checksum: T.unsafe(nil), **options); end

  def url(key, expires_in:, disposition:, filename:, content_type:); end

  def url_for_direct_upload(key, expires_in:, content_type:, content_length:, checksum:); end
end

class ActiveStorage::Service::Configurator
  def build(service_name); end

  def configurations(); end

  def initialize(configurations); end
end

class ActiveStorage::Service::Configurator
  def self.build(service_name, configurations); end
end

class ActiveStorage::Service::S3Service
  def bucket(); end

  def client(); end

  def download(key, &block); end

  def headers_for_direct_upload(key, content_type:, checksum:, **_); end

  def initialize(bucket:, upload: T.unsafe(nil), **options); end

  def upload(key, io, checksum: T.unsafe(nil), content_type: T.unsafe(nil), **_); end

  def upload_options(); end

  def url(key, expires_in:, filename:, disposition:, content_type:); end
end

class ActiveStorage::Service::S3Service
end

class ActiveStorage::Service
  extend ::ActiveSupport::Autoload
  def self.build(configurator:, service: T.unsafe(nil), **service_config); end

  def self.configure(service_name, configurations); end
end

module ActiveStorage::SetBlob
end

module ActiveStorage::SetBlob
  extend ::ActiveSupport::Concern
end

module ActiveStorage::SetCurrent
end

module ActiveStorage::SetCurrent
  extend ::ActiveSupport::Concern
end

module ActiveStorage::Transformers
end

class ActiveStorage::Transformers::Transformer
  def initialize(transformations); end

  def transform(file, format:); end

  def transformations(); end
end

class ActiveStorage::Transformers::Transformer
end

module ActiveStorage::Transformers
  extend ::ActiveSupport::Autoload
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnrepresentableError
end

class ActiveStorage::UnrepresentableError
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::VERSION
end

class ActiveStorage::Variant
  def blob(); end

  def content_type(*args, &block); end

  def filename(*args, &block); end

  def format(*args, &block); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def key(); end

  def processed(); end

  def service(*args, &block); end

  def service_url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil)); end

  def variation(); end
  WEB_IMAGE_CONTENT_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Variant::Specification
end

class ActiveStorage::Variant::Specification
end

class ActiveStorage::Variant
end

class ActiveStorage::Variation
  def initialize(transformations); end

  def key(); end

  def transform(file, format: T.unsafe(nil), &block); end

  def transformations(); end
end

class ActiveStorage::Variation
  def self.decode(key); end

  def self.encode(transformations); end

  def self.wrap(variator); end
end

module ActiveStorage
  extend ::ActiveSupport::Autoload
  def self.analyzers(); end

  def self.analyzers=(obj); end

  def self.binary_content_type(); end

  def self.binary_content_type=(obj); end

  def self.content_types_allowed_inline(); end

  def self.content_types_allowed_inline=(obj); end

  def self.content_types_to_serve_as_binary(); end

  def self.content_types_to_serve_as_binary=(obj); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.paths(); end

  def self.paths=(obj); end

  def self.previewers(); end

  def self.previewers=(obj); end

  def self.queues(); end

  def self.queues=(obj); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.replace_on_assign_to_many(); end

  def self.replace_on_assign_to_many=(obj); end

  def self.routes_prefix(); end

  def self.routes_prefix=(obj); end

  def self.service_urls_expire_in(); end

  def self.service_urls_expire_in=(obj); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end

  def self.variable_content_types(); end

  def self.variable_content_types=(obj); end

  def self.variant_processor(); end

  def self.variant_processor=(obj); end

  def self.verifier(); end

  def self.verifier=(obj); end
end

module ActiveStorageValidations
end

class ActiveStorageValidations::AspectRatioValidator
  def validate_each(record, attribute, _value); end
  AVAILABLE_CHECKS = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::AspectRatioValidator
end

class ActiveStorageValidations::AttachedValidator
  def validate_each(record, attribute, _value); end
end

class ActiveStorageValidations::AttachedValidator
end

class ActiveStorageValidations::ContentTypeValidator
  def content_type(file); end

  def is_valid?(file); end

  def types(); end

  def types_to_human_format(); end

  def validate_each(record, attribute, _value); end
end

class ActiveStorageValidations::ContentTypeValidator
end

class ActiveStorageValidations::DimensionValidator
  def add_error(record, attribute, type, *attrs); end

  def is_valid?(record, attribute, file_metadata); end

  def validate_each(record, attribute, _value); end
  AVAILABLE_CHECKS = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::DimensionValidator
end

class ActiveStorageValidations::Engine
end

class ActiveStorageValidations::Engine
end

class ActiveStorageValidations::LimitValidator
  def files_count_valid?(count); end

  def validate_each(record, attribute, _); end
  AVAILABLE_CHECKS = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::LimitValidator
end

class ActiveStorageValidations::Metadata
  def file(); end

  def initialize(file); end

  def metadata(); end
end

class ActiveStorageValidations::Metadata
end

class ActiveStorageValidations::Railtie
end

class ActiveStorageValidations::Railtie
end

class ActiveStorageValidations::SizeValidator
  def content_size_valid?(file_size); end

  def number_to_human_size(*args, &block); end

  def validate_each(record, attribute, _value); end
  AVAILABLE_CHECKS = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::SizeValidator
end

module ActiveStorageValidations
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(obj); end

  def test_order(); end

  def test_order=(obj); end
end

module ActiveSupport::ActionableError
end

module ActiveSupport::ActionableError
  extend ::ActiveSupport::Concern
  def self.actions(error); end

  def self.dispatch(error, name); end
end

class ActiveSupport::ArrayInquirer
  def any?(*candidates); end
end

class ActiveSupport::ArrayInquirer
end

module ActiveSupport::Autoload
  def autoload(const_name, path=T.unsafe(nil)); end

  def autoload_at(path); end

  def autoload_under(path); end

  def autoloads(); end

  def eager_autoload(); end

  def eager_load!(); end
end

module ActiveSupport::Autoload
  def self.extended(base); end
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean(backtrace, kind=T.unsafe(nil)); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::BacktraceCleaner
end

module ActiveSupport::Benchmarkable
  def benchmark(message=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActiveSupport::Benchmarkable
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format=T.unsafe(nil)); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::ConnectionPoolLike
  def with(); end
end

module ActiveSupport::Cache::ConnectionPoolLike
end

class ActiveSupport::Cache::Entry
  def dup_value!(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(value); end

  def initialize(value, compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), version: T.unsafe(nil), expires_in: T.unsafe(nil), **_); end

  def mismatched?(version); end

  def size(); end

  def value(); end

  def version(); end
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
end

class ActiveSupport::Cache::FileStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  def cache_path(); end

  def initialize(cache_path, options=T.unsafe(nil)); end
  DIR_FORMATTER = ::T.let(nil, ::T.untyped)
  FILENAME_MAX_SIZE = ::T.let(nil, ::T.untyped)
  FILEPATH_MAX_SIZE = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::MemoryStore
  def prune(target_size, max_time=T.unsafe(nil)); end

  def pruning?(); end

  def synchronize(&block); end
  PER_ENTRY_OVERHEAD = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::MemoryStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::RedisCacheStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  include ::ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
  def initialize(namespace: T.unsafe(nil), compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), expires_in: T.unsafe(nil), race_condition_ttl: T.unsafe(nil), error_handler: T.unsafe(nil), **redis_options); end

  def max_key_bytesize(); end

  def mget_capable?(); end

  def mset_capable?(); end

  def redis(); end

  def redis_options(); end
  DEFAULT_ERROR_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_REDIS_OPTIONS = ::T.let(nil, ::T.untyped)
  MAX_KEY_BYTESIZE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
end

module ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
end

class ActiveSupport::Cache::RedisCacheStore
  def self.build_redis(redis: T.unsafe(nil), url: T.unsafe(nil), **redis_options); end

  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::Store
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(name, options=T.unsafe(nil)); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def fetch(name, options=T.unsafe(nil)); end

  def fetch_multi(*names); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def logger=(obj); end

  def mute(); end

  def options(); end

  def read(name, options=T.unsafe(nil)); end

  def read_multi(*names); end

  def silence(); end

  def silence!(); end

  def silence?(); end

  def write(name, value, options=T.unsafe(nil)); end

  def write_multi(hash, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::Store
  def self.logger(); end

  def self.logger=(obj); end
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(**options); end

  def clear(**options); end

  def decrement(name, amount=T.unsafe(nil), **options); end

  def increment(name, amount=T.unsafe(nil), **options); end

  def middleware(); end

  def with_local_cache(); end
end

module ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.lookup_store(store=T.unsafe(nil), *parameters); end
end

class ActiveSupport::CachingKeyGenerator
  def generate_key(*args); end

  def initialize(key_generator); end
end

class ActiveSupport::CachingKeyGenerator
end

module ActiveSupport::Callbacks
  def run_callbacks(kind); end
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveSupport::CompareWithRange
  def ===(value); end

  def cover?(value); end

  def include?(value); end
end

module ActiveSupport::CompareWithRange
end

module ActiveSupport::Concern
  def append_features(base); end

  def class_methods(&class_methods_module_definition); end

  def included(base=T.unsafe(nil), &block); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
  def initialize(); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
end

module ActiveSupport::Concern
  def self.extended(base); end
end

module ActiveSupport::Concurrency
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
end

class ActiveSupport::Concurrency::ShareLock
  include ::MonitorMixin
  def exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), after_compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def initialize(); end

  def raw_state(); end

  def sharing(); end

  def start_exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def start_sharing(); end

  def stop_exclusive(compatible: T.unsafe(nil)); end

  def stop_sharing(); end

  def yield_shares(purpose: T.unsafe(nil), compatible: T.unsafe(nil), block_share: T.unsafe(nil)); end
end

class ActiveSupport::Concurrency::ShareLock
end

module ActiveSupport::Concurrency
end

module ActiveSupport::Configurable
  def config(); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::CurrentAttributes
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def reset(); end

  def set(set_attributes); end
end

class ActiveSupport::CurrentAttributes
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.after_reset(&block); end

  def self.attribute(*names); end

  def self.before_reset(&block); end

  def self.clear_all(); end

  def self.instance(); end

  def self.reset(*args, &block); end

  def self.reset_all(); end

  def self.resets(&block); end

  def self.set(*args, &block); end
end

module ActiveSupport::Dependencies
  def _eager_load_paths(); end

  def _eager_load_paths=(obj); end

  def autoload_module!(into, const_name, qualified_name, path_suffix); end

  def autoload_once_paths(); end

  def autoload_once_paths=(obj); end

  def autoload_paths(); end

  def autoload_paths=(obj); end

  def autoloadable_module?(path_suffix); end

  def autoloaded?(desc); end

  def autoloaded_constants(); end

  def autoloaded_constants=(obj); end

  def clear(); end

  def constant_watch_stack(); end

  def constant_watch_stack=(obj); end

  def constantize(name); end

  def depend_on(file_name, message=T.unsafe(nil)); end

  def explicitly_unloadable_constants(); end

  def explicitly_unloadable_constants=(obj); end

  def history(); end

  def history=(obj); end

  def hook!(); end

  def interlock(); end

  def interlock=(obj); end

  def load?(); end

  def load_file(path, const_paths=T.unsafe(nil)); end

  def load_missing_constant(from_mod, const_name); end

  def load_once_path?(path); end

  def loadable_constants_for_path(path, bases=T.unsafe(nil)); end

  def loaded(); end

  def loaded=(obj); end

  def loading(); end

  def loading=(obj); end

  def log(message); end

  def logger(); end

  def logger=(obj); end

  def mark_for_unload(const_desc); end

  def mechanism(); end

  def mechanism=(obj); end

  def new_constants_in(*descs); end

  def qualified_const_defined?(path); end

  def qualified_name_for(mod, name); end

  def reference(klass); end

  def remove_constant(const); end

  def remove_unloadable_constants!(); end

  def require_or_load(file_name, const_path=T.unsafe(nil)); end

  def safe_constantize(name); end

  def search_for_file(path_suffix); end

  def to_constant_name(desc); end

  def unhook!(); end

  def verbose(); end

  def verbose=(obj); end

  def warnings_on_first_load(); end

  def warnings_on_first_load=(obj); end

  def will_unload?(const_desc); end
  Reference = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies::Blamable
  def blame_file!(file); end

  def blamed_files(); end

  def copy_blame!(exc); end

  def describe_blame(); end
end

module ActiveSupport::Dependencies::Blamable
end

class ActiveSupport::Dependencies::ClassCache
  def [](key); end

  def clear!(); end

  def empty?(); end

  def get(key); end

  def key?(key); end

  def safe_get(key); end

  def store(klass); end
end

class ActiveSupport::Dependencies::ClassCache
end

class ActiveSupport::Dependencies::Interlock
  def done_running(); end

  def done_unloading(); end

  def loading(); end

  def permit_concurrent_loads(); end

  def raw_state(&block); end

  def running(); end

  def start_running(); end

  def start_unloading(); end

  def unloading(); end
end

class ActiveSupport::Dependencies::Interlock
end

module ActiveSupport::Dependencies::Loadable
  def load_dependency(file); end

  def require_dependency(file_name, message=T.unsafe(nil)); end

  def require_or_load(file_name); end

  def unloadable(const_desc); end
end

module ActiveSupport::Dependencies::Loadable
  def self.exclude_from(base); end

  def self.include_into(base); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def const_missing(const_name); end

  def guess_for_anonymous(const_name); end

  def unloadable(const_desc=T.unsafe(nil)); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def self.append_features(base); end

  def self.exclude_from(base); end

  def self.include_into(base); end
end

class ActiveSupport::Dependencies::WatchStack
  include ::Enumerable
  def each(&block); end

  def new_constants(); end

  def watch_namespaces(namespaces); end

  def watching(); end

  def watching?(); end
end

class ActiveSupport::Dependencies::WatchStack
end

module ActiveSupport::Dependencies::ZeitwerkIntegration
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
  def autoloaded?(object); end

  def autoloaded_constants(); end

  def clear(); end

  def constantize(cpath); end

  def safe_constantize(cpath); end

  def unhook!(); end

  def verbose=(verbose); end
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Inflector
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Inflector
  def self.camelize(basename, _abspath); end

  def self.inflect(overrides); end
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
  def require_dependency(filename); end
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
end

module ActiveSupport::Dependencies::ZeitwerkIntegration
  def self.take_over(enable_reloading:); end
end

module ActiveSupport::Dependencies
  extend ::ActiveSupport::Dependencies
  extend ::Bootsnap::LoadPathCache::CoreExt::ActiveSupport::ClassMethods
  extend ::ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
  def self.autoload_paths=(obj); end

  def self.load_interlock(); end

  def self.run_interlock(); end

  def self.unload_interlock(); end

  def self.verbose=(obj); end
end

class ActiveSupport::Deprecation
  include ::Singleton
  include ::ActiveSupport::Deprecation::InstanceDelegator
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::MethodWrapper
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Behavior
  def behavior(); end

  def behavior=(behavior); end

  def debug(); end

  def debug=(debug); end
end

module ActiveSupport::Deprecation::Behavior
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  def self.included(base); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def hash(*args, &block); end

  def initialize(old_const, new_const, deprecator=T.unsafe(nil), message: T.unsafe(nil)); end

  def instance_methods(*args, &block); end

  def name(*args, &block); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def self.new(*args, **kwargs, &block); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
  def initialize(instance, method, var=T.unsafe(nil), deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
  def initialize(object, message, deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
  def self.new(*args, &block); end
end

module ActiveSupport::Deprecation::InstanceDelegator
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  def include(included_module); end

  def method_added(method_name); end
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
end

module ActiveSupport::Deprecation::InstanceDelegator
  def self.included(base); end
end

module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end

module ActiveSupport::Deprecation::MethodWrapper
end

module ActiveSupport::Deprecation::Reporting
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def silence(); end

  def silenced(); end

  def silenced=(silenced); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
  RAILS_GEM_ROOT = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Reporting
end

class ActiveSupport::Deprecation
  extend ::Singleton::SingletonClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def self.behavior(*args, &block); end

  def self.behavior=(arg); end

  def self.debug(*args, &block); end

  def self.debug=(arg); end

  def self.deprecate_methods(*args, &block); end

  def self.deprecation_horizon(*args, &block); end

  def self.deprecation_horizon=(arg); end

  def self.deprecation_warning(*args, &block); end

  def self.gem_name(*args, &block); end

  def self.gem_name=(arg); end

  def self.initialize(*args, &block); end

  def self.instance(); end

  def self.silence(*args, &block); end

  def self.silenced(*args, &block); end

  def self.silenced=(arg); end

  def self.warn(*args, &block); end
end

class ActiveSupport::DeprecationException
end

class ActiveSupport::DeprecationException
end

module ActiveSupport::DescendantsTracker
  def descendants(); end

  def direct_descendants(); end

  def inherited(base); end
end

class ActiveSupport::DescendantsTracker::DescendantsArray
  include ::Enumerable
  def <<(klass); end

  def cleanup!(); end

  def each(&blk); end

  def refs_size(); end

  def reject!(); end
end

class ActiveSupport::DescendantsTracker::DescendantsArray
end

module ActiveSupport::DescendantsTracker
  def self.clear(); end

  def self.descendants(klass); end

  def self.direct_descendants(klass); end

  def self.store_inherited(klass, descendant); end
end

class ActiveSupport::Digest
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  def -@(); end

  def after(time=T.unsafe(nil)); end

  def before(time=T.unsafe(nil)); end

  def coerce(other); end

  def encode_with(coder); end

  def init_with(coder); end

  def initialize(value, parts); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def parts(); end

  def parts=(parts); end

  def since(time=T.unsafe(nil)); end

  def until(time=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
end

class ActiveSupport::Duration::ISO8601Serializer
end

class ActiveSupport::Duration::Scalar
  def %(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def coerce(other); end

  def initialize(value); end

  def to_f(*args, &block); end

  def to_i(*args, &block); end

  def to_s(*args, &block); end

  def value(); end
end

class ActiveSupport::Duration::Scalar
end

class ActiveSupport::Duration
  def self.===(other); end

  def self.days(value); end

  def self.hours(value); end

  def self.minutes(value); end

  def self.months(value); end

  def self.seconds(value); end

  def self.weeks(value); end

  def self.years(value); end
end

module ActiveSupport::EachTimeWithZone
  def each(&block); end

  def step(n=T.unsafe(nil), &block); end
end

module ActiveSupport::EachTimeWithZone
end

class ActiveSupport::EncryptedConfiguration
  def [](*args, &block); end

  def config(); end

  def fetch(*args, &block); end

  def initialize(config_path:, key_path:, env_key:, raise_if_missing_key:); end

  def method_missing(method, *args, &block); end
end

class ActiveSupport::EncryptedConfiguration
end

class ActiveSupport::EncryptedFile
  def change(&block); end

  def content_path(); end

  def env_key(); end

  def initialize(content_path:, key_path:, env_key:, raise_if_missing_key:); end

  def key(); end

  def key_path(); end

  def raise_if_missing_key(); end

  def read(); end

  def write(contents); end
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EncryptedFile::MissingContentError
  def initialize(content_path); end
end

class ActiveSupport::EncryptedFile::MissingContentError
end

class ActiveSupport::EncryptedFile::MissingKeyError
  def initialize(key_path:, env_key:); end
end

class ActiveSupport::EncryptedFile::MissingKeyError
end

class ActiveSupport::EncryptedFile
  def self.generate_key(); end
end

class ActiveSupport::EventedFileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
  def existing_parent(dir); end

  def filter_out_descendants(dirs); end

  def longest_common_subpath(paths); end

  def normalize_extension(ext); end

  def xpath(path); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
end

class ActiveSupport::EventedFileUpdateChecker
end

class ActiveSupport::ExecutionWrapper
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _complete_callbacks(); end

  def _run_callbacks(); end

  def _run_complete_callbacks(&block); end

  def _run_run_callbacks(&block); end

  def complete!(); end

  def run!(); end
  Null = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def after(target); end

  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._complete_callbacks(); end

  def self._complete_callbacks=(value); end

  def self._run_callbacks(); end

  def self._run_callbacks=(value); end

  def self.active(); end

  def self.active=(active); end

  def self.active?(); end

  def self.inherited(other); end

  def self.register_hook(hook, outer: T.unsafe(nil)); end

  def self.run!(); end

  def self.to_complete(*args, &block); end

  def self.to_run(*args, &block); end

  def self.wrap(); end
end

class ActiveSupport::Executor
end

class ActiveSupport::Executor
end

class ActiveSupport::FileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::FileUpdateChecker
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

class ActiveSupport::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def assoc(key); end

  def default(*args); end

  def delete(key); end

  def dig(*args); end

  def fetch(key, *extras); end

  def fetch_values(*indices, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash, &block); end

  def merge!(other_hash); end

  def regular_update(*_); end

  def regular_writer(_, _1); end

  def reject(*args, &block); end

  def replace(other_hash); end

  def select(*args, &block); end

  def slice(*keys); end

  def store(key, value); end

  def transform_keys(*args, &block); end

  def transform_values(*args, &block); end

  def update(other_hash); end

  def values_at(*keys); end

  def without(*keys); end
end

class ActiveSupport::HashWithIndifferentAccess
  def self.[](*args); end
end

module ActiveSupport::IncludeTimeWithZone
  def include?(value); end
end

module ActiveSupport::IncludeTimeWithZone
end

class ActiveSupport::Inflector::Inflections
  def acronym(word); end

  def acronyms(); end

  def acronyms_camelize_regex(); end

  def acronyms_underscore_regex(); end

  def clear(scope=T.unsafe(nil)); end

  def human(rule, replacement); end

  def humans(); end

  def irregular(singular, plural); end

  def plural(rule, replacement); end

  def plurals(); end

  def singular(rule, replacement); end

  def singulars(); end

  def uncountable(*words); end

  def uncountables(); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
  def <<(*word); end

  def add(words); end

  def delete(entry); end

  def initialize(); end

  def uncountable?(str); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
end

class ActiveSupport::Inflector::Inflections
  def self.instance(locale=T.unsafe(nil)); end
end

module ActiveSupport::Inflector
  extend ::ActiveSupport::Inflector
end

class ActiveSupport::InheritableOptions
  def inheritable_copy(); end

  def initialize(parent=T.unsafe(nil)); end
end

class ActiveSupport::InheritableOptions
end

module ActiveSupport::JSON
  DATETIME_REGEX = ::T.let(nil, ::T.untyped)
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.parse_error(); end
end

class ActiveSupport::KeyGenerator
  def generate_key(salt, key_size=T.unsafe(nil)); end

  def initialize(secret, options=T.unsafe(nil)); end
end

class ActiveSupport::KeyGenerator
end

module ActiveSupport::LazyLoadHooks
  def on_load(name, options=T.unsafe(nil), &block); end

  def run_load_hooks(name, base=T.unsafe(nil)); end
end

module ActiveSupport::LazyLoadHooks
  def self.extended(base); end
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(obj); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def self.colorize_logging(); end

  def self.colorize_logging=(obj); end

  def self.flush_all!(); end

  def self.log_subscribers(); end

  def self.logger(); end

  def self.logger=(logger); end
end

class ActiveSupport::Logger
  include ::ActiveSupport::LoggerSilence
  include ::ActiveSupport::LoggerThreadSafeLevel
  def initialize(*args, **kwargs); end

  def silencer(); end

  def silencer=(obj); end
end

class ActiveSupport::Logger::SimpleFormatter
  def call(severity, timestamp, progname, msg); end
end

class ActiveSupport::Logger::SimpleFormatter
end

class ActiveSupport::Logger
  def self.broadcast(logger); end

  def self.local_levels(); end

  def self.local_levels=(obj); end

  def self.logger_outputs_to?(logger, *sources); end

  def self.silencer(); end

  def self.silencer=(obj); end
end

module ActiveSupport::LoggerSilence
  def silence(temporary_level=T.unsafe(nil)); end
end

module ActiveSupport::LoggerSilence
  extend ::ActiveSupport::Concern
end

module ActiveSupport::LoggerThreadSafeLevel
  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def after_initialize(); end

  def debug?(); end

  def error?(); end

  def fatal?(); end

  def info?(); end

  def level(); end

  def local_level(); end

  def local_level=(level); end

  def local_log_id(); end

  def unknown?(); end

  def warn?(); end
end

module ActiveSupport::LoggerThreadSafeLevel
  extend ::ActiveSupport::Concern
end

module ActiveSupport::MarshalWithAutoloading
  def load(source, proc=T.unsafe(nil)); end
end

module ActiveSupport::MarshalWithAutoloading
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
  def encrypt_and_sign(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

module ActiveSupport::MessageEncryptor::NullSerializer
end

module ActiveSupport::MessageEncryptor::NullSerializer
  def self.dump(value); end

  def self.load(value); end
end

module ActiveSupport::MessageEncryptor::NullVerifier
end

module ActiveSupport::MessageEncryptor::NullVerifier
  def self.generate(value); end

  def self.verify(value); end
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageEncryptor
  def self.default_cipher(); end

  def self.key_len(cipher=T.unsafe(nil)); end

  def self.use_authenticated_message_encryption(); end

  def self.use_authenticated_message_encryption=(obj); end
end

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  def generate(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def valid_message?(signed_message); end

  def verify(*args, **options); end
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier
end

module ActiveSupport::Messages
end

class ActiveSupport::Messages::Metadata
  def initialize(message, expires_at=T.unsafe(nil), purpose=T.unsafe(nil)); end

  def verify(purpose); end
end

class ActiveSupport::Messages::Metadata
  def self.verify(message, purpose); end

  def self.wrap(message, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

class ActiveSupport::Messages::RotationConfiguration
  def encrypted(); end

  def rotate(kind, *args); end

  def signed(); end
end

class ActiveSupport::Messages::RotationConfiguration
end

module ActiveSupport::Messages::Rotator
  def initialize(*_, **options); end

  def rotate(*secrets, **options); end
end

module ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
  def decrypt_and_verify(*args, on_rotation: T.unsafe(nil), **options); end
end

module ActiveSupport::Messages::Rotator::Encryptor
end

module ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  def verified(*args, on_rotation: T.unsafe(nil), **options); end
end

module ActiveSupport::Messages::Rotator::Verifier
end

module ActiveSupport::Messages::Rotator
end

module ActiveSupport::Messages
end

module ActiveSupport::Multibyte
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*args, &block); end

  def acts_like_string?(*args, &block); end

  def compose(); end

  def decompose(); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
  def self.consumes?(string); end
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def downcase(string); end

  def normalize(string, form=T.unsafe(nil)); end

  def pack_graphemes(unpacked); end

  def swapcase(string); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def unpack_graphemes(string); end

  def upcase(string); end
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORM_ALIASES = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
end

module ActiveSupport::Multibyte
  def self.proxy_class(); end

  def self.proxy_class=(klass); end
end

module ActiveSupport::Notifications
end

class ActiveSupport::Notifications::Event
  def <<(event); end

  def allocations(); end

  def children(); end

  def cpu_time(); end

  def duration(); end

  def end(); end

  def end=(ending); end

  def finish!(); end

  def idle_time(); end

  def initialize(name, start, ending, transaction_id, payload); end

  def name(); end

  def parent_of?(event); end

  def payload(); end

  def start!(); end

  def time(); end

  def transaction_id(); end
end

class ActiveSupport::Notifications::Event
end

class ActiveSupport::Notifications::Fanout
  include ::Mutex_m
  def finish(name, id, payload, listeners=T.unsafe(nil)); end

  def initialize(); end

  def listeners_for(name); end

  def listening?(name); end

  def lock(); end

  def locked?(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribe(pattern=T.unsafe(nil), callable=T.unsafe(nil), &block); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end

  def unsubscribe(subscriber_or_name); end

  def wait(); end
end

module ActiveSupport::Notifications::Fanout::Subscribers
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
  def finish(name, id, payload); end

  def initialize(delegate); end

  def matches?(_); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end

  def unsubscribe!(*_); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def finish(name, id, payload); end

  def initialize(pattern, delegate); end

  def matches?(name); end

  def pattern(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def ===(name); end

  def exclusions(); end

  def initialize(pattern); end

  def pattern(); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def self.wrap(pattern); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

module ActiveSupport::Notifications::Fanout::Subscribers
  def self.event_object_subscriber(pattern, block); end

  def self.new(pattern, listener); end

  def self.wrap_all(pattern, subscriber); end
end

class ActiveSupport::Notifications::Fanout
end

class ActiveSupport::Notifications::InstrumentationRegistry
  def instrumenter_for(notifier); end
end

class ActiveSupport::Notifications::InstrumentationRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

class ActiveSupport::Notifications::Instrumenter
  def finish(name, payload); end

  def finish_with_state(listeners_state, name, payload); end

  def id(); end

  def initialize(notifier); end

  def instrument(name, payload=T.unsafe(nil)); end

  def start(name, payload); end
end

class ActiveSupport::Notifications::Instrumenter
end

module ActiveSupport::Notifications
  def self.instrument(name, payload=T.unsafe(nil)); end

  def self.instrumenter(); end

  def self.notifier(); end

  def self.notifier=(notifier); end

  def self.publish(name, *args); end

  def self.subscribe(*args, &block); end

  def self.subscribed(callback, *args, &block); end

  def self.unsubscribe(subscriber_or_name); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(val); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(val); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(val); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(val); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::NumberHelper
end

module ActiveSupport::NumericWithFormat
  def to_s(format=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActiveSupport::NumericWithFormat
end

class ActiveSupport::OptionMerger
  def initialize(context, options); end
end

class ActiveSupport::OptionMerger
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedHash
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def _get(_); end

  def method_missing(name, *args); end
end

class ActiveSupport::OrderedOptions
end

class ActiveSupport::ParameterFilter
  def filter(params); end

  def filter_param(key, value); end

  def initialize(filters=T.unsafe(nil), mask: T.unsafe(nil)); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ParameterFilter::CompiledFilter
  def blocks(); end

  def call(params, parents=T.unsafe(nil), original_params=T.unsafe(nil)); end

  def deep_regexps(); end

  def initialize(regexps, deep_regexps, blocks, mask:); end

  def regexps(); end

  def value_for_key(key, value, parents=T.unsafe(nil), original_params=T.unsafe(nil)); end
end

class ActiveSupport::ParameterFilter::CompiledFilter
  def self.compile(filters, mask:); end
end

class ActiveSupport::ParameterFilter
end

module ActiveSupport::PerThreadRegistry
  def instance(); end
end

module ActiveSupport::PerThreadRegistry
  def self.extended(object); end
end

class ActiveSupport::ProxyObject
  def raise(*args); end
end

class ActiveSupport::ProxyObject
end

class ActiveSupport::Railtie
end

class ActiveSupport::Railtie
end

module ActiveSupport::RangeWithFormat
  def to_default_s(format=T.unsafe(nil)); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def to_s(format=T.unsafe(nil)); end
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::RangeWithFormat
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def check(); end

  def check=(val); end

  def check?(); end

  def class_unload!(&block); end

  def executor(); end

  def executor=(val); end

  def executor?(); end

  def release_unload_lock!(); end

  def require_unload_lock!(); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end

  def self.after_class_unload(*args, &block); end

  def self.before_class_unload(*args, &block); end

  def self.check(); end

  def self.check!(); end

  def self.check=(val); end

  def self.check?(); end

  def self.executor(); end

  def self.executor=(val); end

  def self.executor?(); end

  def self.prepare!(); end

  def self.reload!(); end

  def self.reloaded!(); end

  def self.to_prepare(*args, &block); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def *(*_); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def []=(*args); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def clone_empty(); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def delete_prefix(*args, &block); end

  def delete_prefix!(*args); end

  def delete_suffix(*args, &block); end

  def delete_suffix!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args, &block); end

  def initialize(str=T.unsafe(nil)); end

  def insert(index, value); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def replace(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def slice(*args, &block); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args, &block); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def unicode_normalize(*args, &block); end

  def unicode_normalize!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
  UNSAFE_STRING_METHODS_WITH_BACKREF = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SafeBuffer
end

module ActiveSupport::SecurityUtils
end

module ActiveSupport::SecurityUtils
  def self.fixed_length_secure_compare(a, b); end

  def self.secure_compare(a, b); end
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def start(name, id, payload); end
end

class ActiveSupport::Subscriber
  def self.attach_to(namespace, subscriber=T.unsafe(nil), notifier=T.unsafe(nil)); end

  def self.detach_from(namespace, notifier=T.unsafe(nil)); end

  def self.method_added(event); end

  def self.subscribers(); end
end

class ActiveSupport::SubscriberQueueRegistry
  def get_queue(queue_key); end
end

class ActiveSupport::SubscriberQueueRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

module ActiveSupport::TaggedLogging
  include ::Lumberjack::TaggedLogging
  def clear_tags!(*args, &block); end

  def flush(); end

  def pop_tags(*args, &block); end

  def push_tags(*args, &block); end

  def tagged(*tags); end
end

module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end

  def clear_tags!(); end

  def current_tags(); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tagged(*tags); end

  def tags_text(); end
end

module ActiveSupport::TaggedLogging::Formatter
end

module ActiveSupport::TaggedLogging
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_raise(*exp); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def method_name(); end
end

class ActiveSupport::TestCase
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveSupport::Testing::Declarative
  extend ::Rails::LineFiltering
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(val); end

  def self.file_fixture_path?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.test_order=(new_order); end
end

module ActiveSupport::Testing
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Assertions
end

module ActiveSupport::Testing::ConstantLookup
end

module ActiveSupport::Testing::ConstantLookup
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end

module ActiveSupport::Testing::Declarative
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator=T.unsafe(nil), &block); end

  def collect_deprecations(deprecator=T.unsafe(nil)); end
end

module ActiveSupport::Testing::Deprecation
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::Isolation
  include ::ActiveSupport::Testing::Isolation::Forking
  def run(); end
end

module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end

module ActiveSupport::Testing::Isolation::Forking
end

module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation::Subprocess
end

module ActiveSupport::Testing::Isolation
  def self.forking_env?(); end

  def self.included(klass); end
end

class ActiveSupport::Testing::Parallelization
  def <<(work); end

  def after_fork(worker); end

  def after_fork_hooks(); end

  def initialize(queue_size); end

  def run_cleanup(worker); end

  def run_cleanup_hooks(); end

  def shutdown(); end

  def start(); end
end

class ActiveSupport::Testing::Parallelization::Server
  include ::DRb::DRbUndumped
  def <<(o); end

  def length(); end

  def pop(); end

  def record(reporter, result); end
end

class ActiveSupport::Testing::Parallelization::Server
end

class ActiveSupport::Testing::Parallelization
  def self.after_fork_hook(&blk); end

  def self.after_fork_hooks(); end

  def self.run_cleanup_hook(&blk); end

  def self.run_cleanup_hooks(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

class ActiveSupport::Testing::SimpleStubs
  def stub_object(object, method_name, &block); end

  def stubbing(object, method_name); end

  def unstub_all!(); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def method_name(); end

  def method_name=(_); end

  def object(); end

  def object=(_); end

  def original_method(); end

  def original_method=(_); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::Testing::SimpleStubs
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TaggedLogging
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(&block); end

  def travel(duration, &block); end

  def travel_back(); end

  def travel_to(date_or_time); end

  def unfreeze_time(); end
end

module ActiveSupport::Testing::TimeHelpers
end

module ActiveSupport::Testing
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  include ::Comparable
  def acts_like_time?(); end

  def after?(_); end

  def before?(_); end

  def change(options); end

  def comparable_time(); end

  def encode_with(coder); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmt?(); end

  def gmt_offset(); end

  def gmtime(); end

  def gmtoff(); end

  def in(other); end

  def init_with(coder); end

  def initialize(utc_time, time_zone, local_time=T.unsafe(nil), period=T.unsafe(nil)); end

  def is_a?(klass); end

  def isdst(); end

  def iso8601(fraction_digits=T.unsafe(nil)); end

  def kind_of?(klass); end

  def marshal_dump(); end

  def marshal_load(variables); end

  def method_missing(sym, *args, &block); end

  def respond_to?(sym, include_priv=T.unsafe(nil)); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def rfc822(); end

  def since(other); end

  def time_zone(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def tv_sec(); end
  PRECISIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  include ::Comparable
  def =~(re); end

  def at(*args); end

  def encode_with(coder); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(name, utc_offset=T.unsafe(nil), tzinfo=T.unsafe(nil)); end

  def iso8601(str); end

  def local_to_utc(time, dst=T.unsafe(nil)); end

  def name(); end

  def parse(str, now=T.unsafe(nil)); end

  def period_for_local(time, dst=T.unsafe(nil)); end

  def period_for_utc(time); end

  def periods_for_local(time); end

  def rfc3339(str); end

  def strptime(str, format, now=T.unsafe(nil)); end

  def tzinfo(); end

  def utc_offset(); end

  def utc_to_local(time); end
  MAPPING = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  def self.clear(); end

  def self.create(*_); end

  def self.find_tzinfo(name); end

  def self.new(name); end

  def self.seconds_to_utc_offset(seconds, colon=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
end

module ActiveSupport::Tryable
  def try(method_name=T.unsafe(nil), *args, &b); end

  def try!(method_name=T.unsafe(nil), *args, &b); end
end

module ActiveSupport::Tryable
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
end

class ActiveSupport::XMLConverter
  def initialize(xml, disallowed_types=T.unsafe(nil)); end

  def to_h(); end
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter::DisallowedType
  def initialize(type); end
end

class ActiveSupport::XMLConverter::DisallowedType
end

class ActiveSupport::XMLConverter
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*args, &block); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini::FileLike
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
end

module ActiveSupport::XmlMini_REXML
  def parse(data); end
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  extend ::ActiveSupport::XmlMini_REXML
end

module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks
  extend ::ActiveSupport::Autoload
  def self.escape_html_entities_in_json(*args, &block); end

  def self.escape_html_entities_in_json=(arg); end

  def self.gem_version(); end

  def self.json_encoder(*args, &block); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(obj); end

  def self.test_order(); end

  def self.test_order=(obj); end

  def self.time_precision(*args, &block); end

  def self.time_precision=(arg); end

  def self.to_time_preserves_timezone(); end

  def self.to_time_preserves_timezone=(value); end

  def self.use_standard_json_time_format(*args, &block); end

  def self.use_standard_json_time_format=(arg); end

  def self.version(); end
end

module Addressable
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeOverflow
end

class Addressable::IDNA::PunycodeOverflow
end

module Addressable::IDNA
  def self.to_ascii(input); end

  def self.to_unicode(input); end

  def self.unicode_normalize_kc(input); end
end

class Addressable::Template
  def ==(template); end

  def eql?(template); end

  def expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def extract(uri, processor=T.unsafe(nil)); end

  def generate(params=T.unsafe(nil), recall=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(pattern); end

  def keys(); end

  def match(uri, processor=T.unsafe(nil)); end

  def named_captures(); end

  def names(); end

  def partial_expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def pattern(); end

  def source(); end

  def to_regexp(); end

  def variable_defaults(); end

  def variables(); end
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::MatchData
  def [](key, len=T.unsafe(nil)); end

  def captures(); end

  def initialize(uri, template, mapping); end

  def keys(); end

  def mapping(); end

  def names(); end

  def post_match(); end

  def pre_match(); end

  def string(); end

  def template(); end

  def to_a(); end

  def uri(); end

  def values(); end

  def values_at(*indexes); end

  def variables(); end
end

class Addressable::Template::MatchData
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template
end

class Addressable::URI
  def +(uri); end

  def ==(uri); end

  def ===(uri); end

  def absolute?(); end

  def authority(); end

  def authority=(new_authority); end

  def basename(); end

  def default_port(); end

  def defer_validation(); end

  def display_uri(); end

  def domain(); end

  def empty?(); end

  def eql?(uri); end

  def extname(); end

  def fragment(); end

  def fragment=(new_fragment); end

  def host(); end

  def host=(new_host); end

  def hostname(); end

  def hostname=(new_hostname); end

  def inferred_port(); end

  def initialize(options=T.unsafe(nil)); end

  def ip_based?(); end

  def join(uri); end

  def join!(uri); end

  def merge(hash); end

  def merge!(uri); end

  def normalize(); end

  def normalize!(); end

  def normalized_authority(); end

  def normalized_fragment(); end

  def normalized_host(); end

  def normalized_password(); end

  def normalized_path(); end

  def normalized_port(); end

  def normalized_query(*flags); end

  def normalized_scheme(); end

  def normalized_site(); end

  def normalized_user(); end

  def normalized_userinfo(); end

  def omit(*components); end

  def omit!(*components); end

  def origin(); end

  def origin=(new_origin); end

  def password(); end

  def password=(new_password); end

  def path(); end

  def path=(new_path); end

  def port(); end

  def port=(new_port); end

  def query(); end

  def query=(new_query); end

  def query_values(return_type=T.unsafe(nil)); end

  def query_values=(new_query_values); end

  def relative?(); end

  def remove_composite_values(); end

  def replace_self(uri); end

  def request_uri(); end

  def request_uri=(new_request_uri); end

  def route_from(uri); end

  def route_to(uri); end

  def scheme(); end

  def scheme=(new_scheme); end

  def site(); end

  def site=(new_site); end

  def split_path(path); end

  def tld(); end

  def tld=(new_tld); end

  def to_hash(); end

  def to_str(); end

  def user(); end

  def user=(new_user); end

  def userinfo(); end

  def userinfo=(new_userinfo); end

  def validate(); end
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI
  def self.convert_path(path); end

  def self.encode(uri, return_type=T.unsafe(nil)); end

  def self.encode_component(component, character_class=T.unsafe(nil), upcase_encoded=T.unsafe(nil)); end

  def self.escape(uri, return_type=T.unsafe(nil)); end

  def self.form_encode(form_values, sort=T.unsafe(nil)); end

  def self.form_unencode(encoded_value); end

  def self.heuristic_parse(uri, hints=T.unsafe(nil)); end

  def self.ip_based_schemes(); end

  def self.join(*uris); end

  def self.normalize_component(component, character_class=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.normalize_path(path); end

  def self.normalized_encode(uri, return_type=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.port_mapping(); end

  def self.unencode(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unencode_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
end

module Addressable
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class ApplicationCable::Channel
end

class ApplicationCable::Connection
end

class ApplicationJob
end

class ApplicationRecord
  include ::ApplicationRecord::GeneratedAttributeMethods
  include ::ApplicationRecord::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAttributeMethods
end

module ApplicationRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ApplicationRecord
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.page(num=T.unsafe(nil)); end
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Arel::AliasPredication
  def as(other); end
end

module Arel::AliasPredication
end

class Arel::ArelError
end

class Arel::ArelError
end

Arel::Attribute = Arel::Attributes::Attribute

module Arel::Attributes
end

class Arel::Attributes::Attribute
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
  def able_to_type_cast?(); end

  def lower(); end

  def type_cast_for_database(value); end
end

class Arel::Attributes::Attribute
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Float
end

class Arel::Attributes::Float
end

class Arel::Attributes::Integer
end

class Arel::Attributes::Integer
end

class Arel::Attributes::String
end

class Arel::Attributes::String
end

class Arel::Attributes::Time
end

class Arel::Attributes::Time
end

class Arel::Attributes::Undefined
end

class Arel::Attributes::Undefined
end

module Arel::Attributes
  def self.for(column); end
end

module Arel::Collectors
end

class Arel::Collectors::Bind
  def <<(str); end

  def add_bind(bind); end

  def value(); end
end

class Arel::Collectors::Bind
end

class Arel::Collectors::Composite
  def <<(str); end

  def add_bind(bind, &block); end

  def initialize(left, right); end

  def value(); end
end

class Arel::Collectors::Composite
end

class Arel::Collectors::PlainString
  def <<(str); end

  def value(); end
end

class Arel::Collectors::PlainString
end

class Arel::Collectors::SQLString
  def add_bind(bind); end

  def initialize(*_); end
end

class Arel::Collectors::SQLString
end

class Arel::Collectors::SubstituteBinds
  def <<(str); end

  def add_bind(bind); end

  def initialize(quoter, delegate_collector); end

  def value(); end
end

class Arel::Collectors::SubstituteBinds
end

module Arel::Collectors
end

module Arel::Crud
  def compile_delete(); end

  def compile_insert(values); end

  def compile_update(values, pk); end

  def create_insert(); end
end

module Arel::Crud
end

class Arel::DeleteManager
  include ::Arel::TreeManager::StatementMethods
  def from(relation); end
end

class Arel::DeleteManager
end

class Arel::EmptyJoinError
end

class Arel::EmptyJoinError
end

module Arel::Expressions
  def average(); end

  def count(distinct=T.unsafe(nil)); end

  def extract(field); end

  def maximum(); end

  def minimum(); end

  def sum(); end
end

module Arel::Expressions
end

module Arel::FactoryMethods
  def coalesce(*exprs); end

  def create_and(clauses); end

  def create_false(); end

  def create_join(to, constraint=T.unsafe(nil), klass=T.unsafe(nil)); end

  def create_on(expr); end

  def create_string_join(to); end

  def create_table_alias(relation, name); end

  def create_true(); end

  def grouping(expr); end

  def lower(column); end
end

module Arel::FactoryMethods
end

class Arel::InsertManager
  def columns(); end

  def create_values(values); end

  def create_values_list(rows); end

  def insert(fields); end

  def into(table); end

  def select(select); end

  def values=(val); end
end

class Arel::InsertManager
end

module Arel::Math
  def &(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def <<(other); end

  def >>(other); end

  def ^(other); end

  def |(other); end

  def ~(); end
end

module Arel::Math
end

Arel::Node = Arel::Nodes::Node

module Arel::Nodes
end

class Arel::Nodes::Addition
  def initialize(left, right); end
end

class Arel::Nodes::Addition
end

class Arel::Nodes::And
  def ==(other); end

  def children(); end

  def eql?(other); end

  def initialize(children); end

  def left(); end

  def right(); end
end

class Arel::Nodes::And
end

class Arel::Nodes::As
end

class Arel::Nodes::As
end

class Arel::Nodes::Ascending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Ascending
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Between
end

class Arel::Nodes::Between
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Binary
  def ==(other); end

  def eql?(other); end

  def initialize(left, right); end

  def left(); end

  def left=(left); end

  def right(); end

  def right=(right); end
end

class Arel::Nodes::Binary
end

class Arel::Nodes::BindParam
  def ==(other); end

  def eql?(other); end

  def infinite?(); end

  def initialize(value); end

  def unboundable?(); end

  def value(); end
end

class Arel::Nodes::BindParam
end

class Arel::Nodes::BitwiseAnd
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseAnd
end

class Arel::Nodes::BitwiseNot
  def initialize(operand); end
end

class Arel::Nodes::BitwiseNot
end

class Arel::Nodes::BitwiseOr
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseOr
end

class Arel::Nodes::BitwiseShiftLeft
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftLeft
end

class Arel::Nodes::BitwiseShiftRight
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftRight
end

class Arel::Nodes::BitwiseXor
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseXor
end

class Arel::Nodes::Case
  def ==(other); end

  def case(); end

  def case=(_); end

  def conditions(); end

  def conditions=(conditions); end

  def default(); end

  def default=(default); end

  def else(expression); end

  def eql?(other); end

  def initialize(expression=T.unsafe(nil), default=T.unsafe(nil)); end

  def then(expression); end

  def when(condition, expression=T.unsafe(nil)); end
end

class Arel::Nodes::Case
end

class Arel::Nodes::Casted
  def ==(other); end

  def attribute(); end

  def eql?(other); end

  def initialize(val, attribute); end

  def val(); end
end

class Arel::Nodes::Casted
end

class Arel::Nodes::Comment
  def ==(other); end

  def eql?(other); end

  def initialize(values); end

  def values(); end
end

class Arel::Nodes::Comment
end

class Arel::Nodes::Concat
  def initialize(left, right); end
end

class Arel::Nodes::Concat
end

class Arel::Nodes::Count
  def initialize(expr, distinct=T.unsafe(nil), aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Count
end

class Arel::Nodes::Cube
end

class Arel::Nodes::Cube
end

class Arel::Nodes::CurrentRow
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::CurrentRow
end

class Arel::Nodes::DeleteStatement
  def ==(other); end

  def eql?(other); end

  def initialize(relation=T.unsafe(nil), wheres=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def left(); end

  def left=(left); end

  def limit(); end

  def limit=(limit); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def right(); end

  def right=(right); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::DeleteStatement
end

class Arel::Nodes::Descending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Descending
end

class Arel::Nodes::Distinct
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::Distinct
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::Division
  def initialize(left, right); end
end

class Arel::Nodes::Division
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::Else
end

class Arel::Nodes::Else
end

class Arel::Nodes::Equality
  def operand1(); end

  def operand2(); end

  def operator(); end
end

class Arel::Nodes::Equality
end

class Arel::Nodes::Except
end

class Arel::Nodes::Except
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Extract
  def field(); end

  def field=(field); end

  def initialize(expr, field); end
end

class Arel::Nodes::Extract
end

class Arel::Nodes::False
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::False
end

class Arel::Nodes::Following
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Following
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::Function
  include ::Arel::WindowPredications
  def ==(other); end

  def alias(); end

  def alias=(_); end

  def as(aliaz); end

  def distinct(); end

  def distinct=(distinct); end

  def eql?(other); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(expr, aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Function
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::Group
end

class Arel::Nodes::Group
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::In
end

class Arel::Nodes::In
end

class Arel::Nodes::InfixOperation
  def initialize(operator, left, right); end

  def operator(); end
end

class Arel::Nodes::InfixOperation
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InsertStatement
  def ==(other); end

  def columns(); end

  def columns=(columns); end

  def eql?(other); end

  def relation(); end

  def relation=(relation); end

  def select=(select); end

  def values(); end

  def values=(values); end
end

class Arel::Nodes::InsertStatement
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::Join
end

class Arel::Nodes::Join
end

class Arel::Nodes::JoinSource
  def empty?(); end

  def initialize(single_source, joinop=T.unsafe(nil)); end
end

class Arel::Nodes::JoinSource
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Matches
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def escape(); end

  def initialize(left, right, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Matches
end

class Arel::Nodes::Max
end

class Arel::Nodes::Max
end

class Arel::Nodes::Min
end

class Arel::Nodes::Min
end

class Arel::Nodes::Multiplication
  def initialize(left, right); end
end

class Arel::Nodes::Multiplication
end

class Arel::Nodes::NamedFunction
  def initialize(name, expr, aliaz=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedFunction
end

class Arel::Nodes::NamedWindow
  def initialize(name); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedWindow
end

class Arel::Nodes::Node
  include ::Arel::FactoryMethods
  include ::Enumerable
  def and(right); end

  def each(&block); end

  def not(); end

  def or(right); end

  def to_sql(engine=T.unsafe(nil)); end
end

class Arel::Nodes::Node
end

class Arel::Nodes::NodeExpression
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
end

class Arel::Nodes::NodeExpression
end

class Arel::Nodes::Not
end

class Arel::Nodes::Not
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::Offset
end

class Arel::Nodes::Offset
end

class Arel::Nodes::On
end

class Arel::Nodes::On
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::Or
end

class Arel::Nodes::Or
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::Over
  def initialize(left, right=T.unsafe(nil)); end

  def operator(); end
end

class Arel::Nodes::Over
end

class Arel::Nodes::Preceding
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Preceding
end

class Arel::Nodes::Quoted
  def infinite?(); end

  def val(); end
end

class Arel::Nodes::Quoted
end

class Arel::Nodes::Range
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Range
end

class Arel::Nodes::Regexp
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def initialize(left, right, case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Regexp
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::Rows
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Rows
end

class Arel::Nodes::SelectCore
  def ==(other); end

  def comment(); end

  def comment=(comment); end

  def eql?(other); end

  def from(); end

  def from=(value); end

  def froms(); end

  def froms=(value); end

  def groups(); end

  def groups=(groups); end

  def havings(); end

  def havings=(havings); end

  def optimizer_hints(); end

  def optimizer_hints=(optimizer_hints); end

  def projections(); end

  def projections=(projections); end

  def set_quantifier(); end

  def set_quantifier=(set_quantifier); end

  def source(); end

  def source=(source); end

  def wheres(); end

  def wheres=(wheres); end

  def windows(); end

  def windows=(windows); end
end

class Arel::Nodes::SelectCore
end

class Arel::Nodes::SelectStatement
  def ==(other); end

  def cores(); end

  def eql?(other); end

  def initialize(cores=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(); end

  def lock=(lock); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def with(); end

  def with=(with); end
end

class Arel::Nodes::SelectStatement
end

class Arel::Nodes::SqlLiteral
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  def encode_with(coder); end
end

class Arel::Nodes::SqlLiteral
end

class Arel::Nodes::StringJoin
  def initialize(left, right=T.unsafe(nil)); end
end

class Arel::Nodes::StringJoin
end

class Arel::Nodes::Subtraction
  def initialize(left, right); end
end

class Arel::Nodes::Subtraction
end

class Arel::Nodes::Sum
end

class Arel::Nodes::Sum
end

class Arel::Nodes::TableAlias
  def [](name); end

  def able_to_type_cast?(); end

  def name(); end

  def relation(); end

  def table_alias(); end

  def table_name(); end

  def type_cast_for_database(*args); end
end

class Arel::Nodes::TableAlias
end

class Arel::Nodes::True
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::True
end

class Arel::Nodes::Unary
  def ==(other); end

  def eql?(other); end

  def expr(); end

  def expr=(expr); end

  def initialize(expr); end

  def value(); end
end

class Arel::Nodes::Unary
end

class Arel::Nodes::UnaryOperation
  def initialize(operator, operand); end

  def operator(); end
end

class Arel::Nodes::UnaryOperation
end

class Arel::Nodes::Union
end

class Arel::Nodes::Union
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnqualifiedColumn
  def attribute(); end

  def attribute=(attribute); end

  def column(); end

  def name(); end

  def relation(); end
end

class Arel::Nodes::UnqualifiedColumn
end

class Arel::Nodes::UpdateStatement
  def ==(other); end

  def eql?(other); end

  def key(); end

  def key=(key); end

  def limit(); end

  def limit=(limit); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def values(); end

  def values=(values); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::UpdateStatement
end

class Arel::Nodes::ValuesList
  def rows(); end
end

class Arel::Nodes::ValuesList
end

class Arel::Nodes::When
end

class Arel::Nodes::When
end

class Arel::Nodes::Window
  def ==(other); end

  def eql?(other); end

  def frame(expr); end

  def framing(); end

  def framing=(framing); end

  def order(*expr); end

  def orders(); end

  def orders=(orders); end

  def partition(*expr); end

  def partitions(); end

  def partitions=(partitions); end

  def range(expr=T.unsafe(nil)); end

  def rows(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Window
end

class Arel::Nodes::With
  def children(); end
end

class Arel::Nodes::With
end

class Arel::Nodes::WithRecursive
end

class Arel::Nodes::WithRecursive
end

module Arel::Nodes
  def self.build_quoted(other, attribute=T.unsafe(nil)); end
end

module Arel::OrderPredications
  def asc(); end

  def desc(); end
end

module Arel::OrderPredications
end

module Arel::Predications
  def between(other); end

  def concat(other); end

  def does_not_match(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def does_not_match_all(others, escape=T.unsafe(nil)); end

  def does_not_match_any(others, escape=T.unsafe(nil)); end

  def does_not_match_regexp(other, case_sensitive=T.unsafe(nil)); end

  def eq(other); end

  def eq_all(others); end

  def eq_any(others); end

  def gt(right); end

  def gt_all(others); end

  def gt_any(others); end

  def gteq(right); end

  def gteq_all(others); end

  def gteq_any(others); end

  def in(other); end

  def in_all(others); end

  def in_any(others); end

  def is_distinct_from(other); end

  def is_not_distinct_from(other); end

  def lt(right); end

  def lt_all(others); end

  def lt_any(others); end

  def lteq(right); end

  def lteq_all(others); end

  def lteq_any(others); end

  def matches(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_all(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_any(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_regexp(other, case_sensitive=T.unsafe(nil)); end

  def not_between(other); end

  def not_eq(other); end

  def not_eq_all(others); end

  def not_eq_any(others); end

  def not_in(other); end

  def not_in_all(others); end

  def not_in_any(others); end

  def when(right); end
end

module Arel::Predications
end

class Arel::SelectManager
  include ::Arel::Crud
  def as(other); end

  def comment(*values); end

  def constraints(); end

  def distinct(value=T.unsafe(nil)); end

  def distinct_on(value); end

  def except(other); end

  def exists(); end

  def from(table); end

  def froms(); end

  def group(*columns); end

  def having(expr); end

  def initialize(table=T.unsafe(nil)); end

  def intersect(other); end

  def join(relation, klass=T.unsafe(nil)); end

  def join_sources(); end

  def lateral(table_name=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(locking=T.unsafe(nil)); end

  def locked(); end

  def minus(other); end

  def offset(); end

  def offset=(amount); end

  def on(*exprs); end

  def optimizer_hints(*hints); end

  def order(*expr); end

  def orders(); end

  def outer_join(relation); end

  def project(*projections); end

  def projections(); end

  def projections=(projections); end

  def skip(amount); end

  def source(); end

  def take(limit); end

  def taken(); end

  def union(operation, other=T.unsafe(nil)); end

  def where_sql(engine=T.unsafe(nil)); end

  def window(name); end

  def with(*subqueries); end
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class Arel::SelectManager
end

class Arel::Table
  include ::Arel::Crud
  include ::Arel::FactoryMethods
  def ==(other); end

  def [](name); end

  def able_to_type_cast?(); end

  def alias(name=T.unsafe(nil)); end

  def eql?(other); end

  def from(); end

  def group(*columns); end

  def having(expr); end

  def initialize(name, as: T.unsafe(nil), type_caster: T.unsafe(nil)); end

  def join(relation, klass=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def order(*expr); end

  def outer_join(relation); end

  def project(*things); end

  def skip(amount); end

  def table_alias(); end

  def table_alias=(table_alias); end

  def table_name(); end

  def take(amount); end

  def type_cast_for_database(attribute_name, value); end

  def where(condition); end
end

class Arel::Table
  def self.engine(); end

  def self.engine=(engine); end
end

class Arel::TreeManager
  include ::Arel::FactoryMethods
  def ast(); end

  def to_dot(); end

  def to_sql(engine=T.unsafe(nil)); end

  def where(expr); end
end

module Arel::TreeManager::StatementMethods
  def key(); end

  def key=(key); end

  def offset(offset); end

  def order(*expr); end

  def take(limit); end

  def where(expr); end

  def wheres=(exprs); end
end

module Arel::TreeManager::StatementMethods
end

class Arel::TreeManager
end

class Arel::UpdateManager
  include ::Arel::TreeManager::StatementMethods
  def set(values); end

  def table(table); end
end

class Arel::UpdateManager
end

module Arel::Visitors
end

class Arel::Visitors::DepthFirst
  def initialize(block=T.unsafe(nil)); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::DepthFirst
end

class Arel::Visitors::Dot
  def accept(object, collector); end
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Node
  def fields(); end

  def fields=(fields); end

  def id(); end

  def id=(id); end

  def initialize(name, id, fields=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Visitors::Dot::Node
end

class Arel::Visitors::Dot
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::Informix
end

class Arel::Visitors::Informix
end

class Arel::Visitors::MSSQL
  def initialize(*_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def children(); end

  def children=(_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def self.[](*_); end

  def self.members(); end
end

class Arel::Visitors::MSSQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::ToSql
  def compile(node, collector=T.unsafe(nil)); end

  def initialize(connection); end
end

class Arel::Visitors::ToSql
end

class Arel::Visitors::UnsupportedVisitError
  def initialize(object); end
end

class Arel::Visitors::UnsupportedVisitError
end

class Arel::Visitors::Visitor
  def accept(object, collector=T.unsafe(nil)); end
end

class Arel::Visitors::Visitor
  def self.dispatch_cache(); end
end

class Arel::Visitors::WhereSql
  def initialize(inner_visitor, *args, &block); end
end

class Arel::Visitors::WhereSql
end

module Arel::Visitors
end

module Arel::WindowPredications
  def over(expr=T.unsafe(nil)); end
end

module Arel::WindowPredications
end

module Arel
  def self.arel_node?(value); end

  def self.fetch_attribute(value); end

  def self.sql(raw_sql); end

  def self.star(); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::MessagePack::CoreExt
  def shelljoin(); end

  def to_csv(**options); end

  def to_default_s(); end

  def to_h(); end

end

class Array
  def self.try_convert(_); end

  def self.wrap(object); end
end

module Aws
  CORE_GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::ARN
  def account_id(); end

  def initialize(options=T.unsafe(nil)); end

  def partition(); end

  def region(); end

  def resource(); end

  def service(); end

  def valid?(); end
end

class Aws::ARN
end

module Aws::ARNParser
end

module Aws::ARNParser
  def self.arn?(str); end

  def self.parse(arn_str); end
end

class Aws::AssumeRoleCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials
  def client(); end
end

class Aws::AssumeRoleCredentials
  def self.assume_role_options(); end
end

class Aws::AssumeRoleWebIdentityCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials
  def client(); end
end

class Aws::AssumeRoleWebIdentityCredentials
  def self.assume_role_web_identity_options(); end
end

module Aws::AsyncClientStubs
  include ::Aws::ClientStubs
  def send_events(); end

  def setup_stubbing(); end
end

class Aws::AsyncClientStubs::StubStream
  def close(); end

  def closed?(); end

  def data(bytes, options=T.unsafe(nil)); end

  def send_events(); end

  def send_events=(send_events); end

  def state(); end
end

class Aws::AsyncClientStubs::StubStream
end

module Aws::AsyncClientStubs
end

module Aws::Binary
end

class Aws::Binary::DecodeHandler
end

class Aws::Binary::DecodeHandler
end

class Aws::Binary::EncodeHandler
end

class Aws::Binary::EncodeHandler
end

class Aws::Binary::EventBuilder
  include ::Seahorse::Model::Shapes
  def apply(event_type, params); end

  def initialize(serializer_class, rules); end
end

class Aws::Binary::EventBuilder
end

class Aws::Binary::EventParser
  include ::Seahorse::Model::Shapes
  def apply(raw_event); end

  def initialize(parser_class, rules, error_refs, output_ref); end
end

class Aws::Binary::EventParser
end

class Aws::Binary::EventStreamDecoder
  def events(); end

  def initialize(protocol, rules, output_ref, error_refs, io, event_stream_handler=T.unsafe(nil)); end

  def write(chunk); end
end

class Aws::Binary::EventStreamDecoder
end

class Aws::Binary::EventStreamEncoder
  def encode(event_type, params); end

  def initialize(protocol, rules, input_ref, signer); end

  def prior_signature(); end

  def prior_signature=(prior_signature); end

  def rules(); end
end

class Aws::Binary::EventStreamEncoder
end

module Aws::Binary
end

module Aws::ClientSideMonitoring
end

class Aws::ClientSideMonitoring::Publisher
  def agent_host(); end

  def agent_host=(value); end

  def agent_port(); end

  def agent_port=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def publish(request_metrics); end

  def send_datagram(msg); end
end

class Aws::ClientSideMonitoring::Publisher
end

class Aws::ClientSideMonitoring::RequestMetrics
  def add_call_attempt(attempt); end

  def api_call(); end

  def api_call_attempts(); end

  def build_call_attempt(opts=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end
  FIELD_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class Aws::ClientSideMonitoring::RequestMetrics::ApiCall
  def api(); end

  def attempt_count(); end

  def client_id(); end

  def complete(opts=T.unsafe(nil)); end

  def final_aws_exception(); end

  def final_aws_exception_message(); end

  def final_http_status_code(); end

  def final_sdk_exception(); end

  def final_sdk_exception_message(); end

  def initialize(service, api, client_id, version, timestamp, region); end

  def latency(); end

  def max_retries_exceeded(); end

  def region(); end

  def service(); end

  def timestamp(); end

  def to_json(*a); end

  def user_agent(); end

  def version(); end
end

class Aws::ClientSideMonitoring::RequestMetrics::ApiCall
end

class Aws::ClientSideMonitoring::RequestMetrics::ApiCallAttempt
  def access_key(); end

  def api(); end

  def aws_exception(); end

  def aws_exception=(aws_exception); end

  def aws_exception_msg(); end

  def aws_exception_msg=(aws_exception_msg); end

  def client_id(); end

  def fqdn(); end

  def fqdn=(fqdn); end

  def http_status_code(); end

  def http_status_code=(http_status_code); end

  def initialize(service, api, client_id, version, timestamp, fqdn, region, user_agent, access_key, session_token); end

  def region(); end

  def region=(region); end

  def request_latency(); end

  def request_latency=(request_latency); end

  def sdk_exception(); end

  def sdk_exception=(sdk_exception); end

  def sdk_exception_msg(); end

  def sdk_exception_msg=(sdk_exception_msg); end

  def service(); end

  def session_token(); end

  def timestamp(); end

  def to_json(*a); end

  def user_agent(); end

  def version(); end

  def x_amz_id_2(); end

  def x_amz_id_2=(x_amz_id_2); end

  def x_amz_request_id(); end

  def x_amz_request_id=(x_amz_request_id); end

  def x_amzn_request_id(); end

  def x_amzn_request_id=(x_amzn_request_id); end
end

class Aws::ClientSideMonitoring::RequestMetrics::ApiCallAttempt
end

class Aws::ClientSideMonitoring::RequestMetrics
end

module Aws::ClientSideMonitoring
end

module Aws::ClientStubs
  def api_requests(options=T.unsafe(nil)); end

  def next_stub(context); end

  def setup_stubbing(); end

  def stub_data(operation_name, data=T.unsafe(nil)); end

  def stub_responses(operation_name, *stubs); end
end

module Aws::ClientStubs
end

module Aws::CredentialProvider
  def credentials(); end

  def set?(); end
end

module Aws::CredentialProvider
end

class Aws::CredentialProviderChain
  def initialize(config=T.unsafe(nil)); end

  def resolve(); end
end

class Aws::CredentialProviderChain
end

class Aws::Credentials
  def access_key_id(); end

  def credentials(); end

  def initialize(access_key_id, secret_access_key, session_token=T.unsafe(nil)); end

  def secret_access_key(); end

  def session_token(); end

  def set?(); end
end

class Aws::Credentials
end

module Aws::Deprecations
  def deprecated(method, options=T.unsafe(nil)); end
end

module Aws::Deprecations
end

module Aws::EC2
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::ClassicAddress
  def allocation_id(); end

  def associate(options=T.unsafe(nil)); end

  def association_id(); end

  def client(); end

  def customer_owned_ip(); end

  def customer_owned_ipv_4_pool(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def disassociate(options=T.unsafe(nil)); end

  def domain(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def instance_id(); end

  def load(); end

  def network_border_group(); end

  def network_interface_id(); end

  def network_interface_owner_id(); end

  def private_ip_address(); end

  def public_ip(); end

  def public_ipv_4_pool(); end

  def release(options=T.unsafe(nil)); end

  def reload(); end

  def tags(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::ClassicAddress::Collection
end

class Aws::EC2::ClassicAddress::Collection
end

class Aws::EC2::ClassicAddress
  extend ::Aws::Deprecations
end

class Aws::EC2::Client
  include ::Aws::ClientStubs
  def accept_reserved_instances_exchange_quote(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def accept_transit_gateway_peering_attachment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def accept_transit_gateway_vpc_attachment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def accept_vpc_endpoint_connections(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def accept_vpc_peering_connection(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def advertise_byoip_cidr(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def allocate_address(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def allocate_hosts(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def apply_security_groups_to_client_vpn_target_network(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def assign_ipv_6_addresses(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def assign_private_ip_addresses(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def associate_address(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def associate_client_vpn_target_network(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def associate_dhcp_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def associate_iam_instance_profile(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def associate_route_table(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def associate_subnet_cidr_block(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def associate_transit_gateway_multicast_domain(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def associate_transit_gateway_route_table(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def associate_vpc_cidr_block(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def attach_classic_link_vpc(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def attach_internet_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def attach_network_interface(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def attach_volume(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def attach_vpn_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def authorize_client_vpn_ingress(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def authorize_security_group_egress(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def authorize_security_group_ingress(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def bundle_instance(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def cancel_bundle_task(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def cancel_capacity_reservation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def cancel_conversion_task(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def cancel_export_task(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def cancel_import_task(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def cancel_reserved_instances_listing(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def cancel_spot_fleet_requests(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def cancel_spot_instance_requests(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def confirm_product_instance(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def copy_fpga_image(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def copy_image(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def copy_snapshot(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_capacity_reservation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_client_vpn_endpoint(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_client_vpn_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_customer_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_default_subnet(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_default_vpc(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_dhcp_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_egress_only_internet_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_fleet(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_flow_logs(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_fpga_image(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_image(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_instance_export_task(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_internet_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_key_pair(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_launch_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_launch_template_version(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_local_gateway_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_local_gateway_route_table_vpc_association(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_managed_prefix_list(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_nat_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_network_acl(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_network_acl_entry(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_network_interface(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_network_interface_permission(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_placement_group(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_reserved_instances_listing(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_route_table(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_security_group(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_snapshot(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_snapshots(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_spot_datafeed_subscription(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_subnet(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_tags(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_traffic_mirror_filter(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_traffic_mirror_filter_rule(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_traffic_mirror_session(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_traffic_mirror_target(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_transit_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_transit_gateway_multicast_domain(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_transit_gateway_peering_attachment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_transit_gateway_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_transit_gateway_route_table(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_transit_gateway_vpc_attachment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_volume(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_vpc(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_vpc_endpoint(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_vpc_endpoint_connection_notification(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_vpc_endpoint_service_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_vpc_peering_connection(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_vpn_connection(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_vpn_connection_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_vpn_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_client_vpn_endpoint(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_client_vpn_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_customer_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_dhcp_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_egress_only_internet_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_fleets(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_flow_logs(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_fpga_image(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_internet_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_key_pair(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_launch_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_launch_template_versions(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_local_gateway_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_local_gateway_route_table_vpc_association(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_managed_prefix_list(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_nat_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_network_acl(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_network_acl_entry(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_network_interface(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_network_interface_permission(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_placement_group(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_queued_reserved_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_route_table(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_security_group(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_snapshot(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_spot_datafeed_subscription(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_subnet(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_tags(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_traffic_mirror_filter(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_traffic_mirror_filter_rule(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_traffic_mirror_session(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_traffic_mirror_target(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_transit_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_transit_gateway_multicast_domain(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_transit_gateway_peering_attachment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_transit_gateway_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_transit_gateway_route_table(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_transit_gateway_vpc_attachment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_volume(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_vpc(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_vpc_endpoint_connection_notifications(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_vpc_endpoint_service_configurations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_vpc_endpoints(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_vpc_peering_connection(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_vpn_connection(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_vpn_connection_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_vpn_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def deprovision_byoip_cidr(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def deregister_image(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def deregister_instance_event_notification_attributes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def deregister_transit_gateway_multicast_group_members(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def deregister_transit_gateway_multicast_group_sources(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_account_attributes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_addresses(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_aggregate_id_format(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_availability_zones(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_bundle_tasks(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_byoip_cidrs(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_capacity_reservations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_classic_link_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_client_vpn_authorization_rules(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_client_vpn_connections(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_client_vpn_endpoints(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_client_vpn_routes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_client_vpn_target_networks(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_coip_pools(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_conversion_tasks(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_customer_gateways(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_dhcp_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_egress_only_internet_gateways(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_elastic_gpus(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_export_image_tasks(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_export_tasks(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_fast_snapshot_restores(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_fleet_history(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_fleet_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_fleets(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_flow_logs(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_fpga_image_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_fpga_images(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_host_reservation_offerings(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_host_reservations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_hosts(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_iam_instance_profile_associations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_id_format(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_identity_id_format(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_image_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_images(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_import_image_tasks(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_import_snapshot_tasks(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_instance_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_instance_credit_specifications(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_instance_event_notification_attributes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_instance_status(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_instance_type_offerings(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_instance_types(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_internet_gateways(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_ipv_6_pools(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_key_pairs(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_launch_template_versions(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_launch_templates(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_local_gateway_route_table_virtual_interface_group_associations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_local_gateway_route_table_vpc_associations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_local_gateway_route_tables(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_local_gateway_virtual_interface_groups(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_local_gateway_virtual_interfaces(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_local_gateways(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_managed_prefix_lists(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_moving_addresses(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_nat_gateways(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_network_acls(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_network_interface_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_network_interface_permissions(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_network_interfaces(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_placement_groups(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_prefix_lists(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_principal_id_format(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_public_ipv_4_pools(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_regions(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_reserved_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_reserved_instances_listings(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_reserved_instances_modifications(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_reserved_instances_offerings(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_route_tables(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_scheduled_instance_availability(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_scheduled_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_security_group_references(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_security_groups(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_snapshot_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_snapshots(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_spot_datafeed_subscription(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_spot_fleet_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_spot_fleet_request_history(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_spot_fleet_requests(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_spot_instance_requests(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_spot_price_history(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_stale_security_groups(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_subnets(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_tags(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_traffic_mirror_filters(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_traffic_mirror_sessions(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_traffic_mirror_targets(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_transit_gateway_attachments(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_transit_gateway_multicast_domains(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_transit_gateway_peering_attachments(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_transit_gateway_route_tables(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_transit_gateway_vpc_attachments(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_transit_gateways(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_volume_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_volume_status(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_volumes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_volumes_modifications(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpc_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpc_classic_link(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpc_classic_link_dns_support(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpc_endpoint_connection_notifications(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpc_endpoint_connections(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpc_endpoint_service_configurations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpc_endpoint_service_permissions(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpc_endpoint_services(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpc_endpoints(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpc_peering_connections(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpcs(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpn_connections(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_vpn_gateways(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def detach_classic_link_vpc(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def detach_internet_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def detach_network_interface(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def detach_volume(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def detach_vpn_gateway(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disable_ebs_encryption_by_default(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disable_fast_snapshot_restores(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disable_transit_gateway_route_table_propagation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disable_vgw_route_propagation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disable_vpc_classic_link(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disable_vpc_classic_link_dns_support(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disassociate_address(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disassociate_client_vpn_target_network(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disassociate_iam_instance_profile(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disassociate_route_table(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disassociate_subnet_cidr_block(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disassociate_transit_gateway_multicast_domain(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disassociate_transit_gateway_route_table(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disassociate_vpc_cidr_block(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_ebs_encryption_by_default(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_fast_snapshot_restores(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_transit_gateway_route_table_propagation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_vgw_route_propagation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_volume_io(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_vpc_classic_link(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_vpc_classic_link_dns_support(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def export_client_vpn_client_certificate_revocation_list(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def export_client_vpn_client_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def export_image(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def export_transit_gateway_routes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_associated_ipv_6_pool_cidrs(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_capacity_reservation_usage(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_coip_pool_usage(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_console_output(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_console_screenshot(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_default_credit_specification(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_ebs_default_kms_key_id(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_ebs_encryption_by_default(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_host_reservation_purchase_preview(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_launch_template_data(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_managed_prefix_list_associations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_managed_prefix_list_entries(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_password_data(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_reserved_instances_exchange_quote(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_transit_gateway_attachment_propagations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_transit_gateway_multicast_domain_associations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_transit_gateway_route_table_associations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_transit_gateway_route_table_propagations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def import_client_vpn_client_certificate_revocation_list(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def import_image(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def import_instance(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def import_key_pair(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def import_snapshot(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def import_volume(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(*args); end

  def modify_availability_zone_group(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_capacity_reservation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_client_vpn_endpoint(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_default_credit_specification(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_ebs_default_kms_key_id(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_fleet(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_fpga_image_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_hosts(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_id_format(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_identity_id_format(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_image_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_instance_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_instance_capacity_reservation_attributes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_instance_credit_specification(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_instance_event_start_time(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_instance_metadata_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_instance_placement(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_launch_template(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_managed_prefix_list(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_network_interface_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_reserved_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_snapshot_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_spot_fleet_request(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_subnet_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_traffic_mirror_filter_network_services(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_traffic_mirror_filter_rule(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_traffic_mirror_session(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_transit_gateway_vpc_attachment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_volume(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_volume_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_vpc_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_vpc_endpoint(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_vpc_endpoint_connection_notification(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_vpc_endpoint_service_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_vpc_endpoint_service_permissions(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_vpc_peering_connection_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_vpc_tenancy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_vpn_connection(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_vpn_tunnel_certificate(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def modify_vpn_tunnel_options(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def monitor_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def move_address_to_vpc(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def provision_byoip_cidr(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def purchase_host_reservation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def purchase_reserved_instances_offering(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def purchase_scheduled_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reboot_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def register_image(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def register_instance_event_notification_attributes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def register_transit_gateway_multicast_group_members(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def register_transit_gateway_multicast_group_sources(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reject_transit_gateway_peering_attachment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reject_transit_gateway_vpc_attachment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reject_vpc_endpoint_connections(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reject_vpc_peering_connection(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def release_address(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def release_hosts(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def replace_iam_instance_profile_association(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def replace_network_acl_association(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def replace_network_acl_entry(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def replace_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def replace_route_table_association(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def replace_transit_gateway_route(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def report_instance_status(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def request_spot_fleet(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def request_spot_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reset_ebs_default_kms_key_id(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reset_fpga_image_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reset_image_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reset_instance_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reset_network_interface_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def reset_snapshot_attribute(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def restore_address_to_classic(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def restore_managed_prefix_list_version(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def revoke_client_vpn_ingress(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def revoke_security_group_egress(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def revoke_security_group_ingress(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def run_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def run_scheduled_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_local_gateway_routes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_transit_gateway_multicast_groups(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_transit_gateway_routes(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def send_diagnostic_interrupt(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def start_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def start_vpc_endpoint_service_private_dns_verification(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def stop_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def terminate_client_vpn_connections(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def terminate_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def unassign_ipv_6_addresses(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def unassign_private_ip_addresses(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def unmonitor_instances(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_security_group_rule_descriptions_egress(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_security_group_rule_descriptions_ingress(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def wait_until(waiter_name, params=T.unsafe(nil), options=T.unsafe(nil)); end

  def waiter_names(); end

  def withdraw_byoip_cidr(params=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Aws::EC2::Client
  def self.errors_module(); end

  def self.identifier(); end
end

module Aws::EC2::ClientApi
  include ::Seahorse::Model
  API = ::T.let(nil, ::T.untyped)
  AcceptReservedInstancesExchangeQuoteRequest = ::T.let(nil, ::T.untyped)
  AcceptReservedInstancesExchangeQuoteResult = ::T.let(nil, ::T.untyped)
  AcceptTransitGatewayPeeringAttachmentRequest = ::T.let(nil, ::T.untyped)
  AcceptTransitGatewayPeeringAttachmentResult = ::T.let(nil, ::T.untyped)
  AcceptTransitGatewayVpcAttachmentRequest = ::T.let(nil, ::T.untyped)
  AcceptTransitGatewayVpcAttachmentResult = ::T.let(nil, ::T.untyped)
  AcceptVpcEndpointConnectionsRequest = ::T.let(nil, ::T.untyped)
  AcceptVpcEndpointConnectionsResult = ::T.let(nil, ::T.untyped)
  AcceptVpcPeeringConnectionRequest = ::T.let(nil, ::T.untyped)
  AcceptVpcPeeringConnectionResult = ::T.let(nil, ::T.untyped)
  AccountAttribute = ::T.let(nil, ::T.untyped)
  AccountAttributeList = ::T.let(nil, ::T.untyped)
  AccountAttributeName = ::T.let(nil, ::T.untyped)
  AccountAttributeNameStringList = ::T.let(nil, ::T.untyped)
  AccountAttributeValue = ::T.let(nil, ::T.untyped)
  AccountAttributeValueList = ::T.let(nil, ::T.untyped)
  ActiveInstance = ::T.let(nil, ::T.untyped)
  ActiveInstanceSet = ::T.let(nil, ::T.untyped)
  ActivityStatus = ::T.let(nil, ::T.untyped)
  AddPrefixListEntries = ::T.let(nil, ::T.untyped)
  AddPrefixListEntry = ::T.let(nil, ::T.untyped)
  Address = ::T.let(nil, ::T.untyped)
  AddressList = ::T.let(nil, ::T.untyped)
  AdvertiseByoipCidrRequest = ::T.let(nil, ::T.untyped)
  AdvertiseByoipCidrResult = ::T.let(nil, ::T.untyped)
  Affinity = ::T.let(nil, ::T.untyped)
  AllocateAddressRequest = ::T.let(nil, ::T.untyped)
  AllocateAddressResult = ::T.let(nil, ::T.untyped)
  AllocateHostsRequest = ::T.let(nil, ::T.untyped)
  AllocateHostsResult = ::T.let(nil, ::T.untyped)
  AllocationId = ::T.let(nil, ::T.untyped)
  AllocationIdList = ::T.let(nil, ::T.untyped)
  AllocationState = ::T.let(nil, ::T.untyped)
  AllocationStrategy = ::T.let(nil, ::T.untyped)
  AllowedPrincipal = ::T.let(nil, ::T.untyped)
  AllowedPrincipalSet = ::T.let(nil, ::T.untyped)
  AllowsMultipleInstanceTypes = ::T.let(nil, ::T.untyped)
  ApplySecurityGroupsToClientVpnTargetNetworkRequest = ::T.let(nil, ::T.untyped)
  ApplySecurityGroupsToClientVpnTargetNetworkResult = ::T.let(nil, ::T.untyped)
  ArchitectureType = ::T.let(nil, ::T.untyped)
  ArchitectureTypeList = ::T.let(nil, ::T.untyped)
  ArchitectureValues = ::T.let(nil, ::T.untyped)
  AssignIpv6AddressesRequest = ::T.let(nil, ::T.untyped)
  AssignIpv6AddressesResult = ::T.let(nil, ::T.untyped)
  AssignPrivateIpAddressesRequest = ::T.let(nil, ::T.untyped)
  AssignPrivateIpAddressesResult = ::T.let(nil, ::T.untyped)
  AssignedPrivateIpAddress = ::T.let(nil, ::T.untyped)
  AssignedPrivateIpAddressList = ::T.let(nil, ::T.untyped)
  AssociateAddressRequest = ::T.let(nil, ::T.untyped)
  AssociateAddressResult = ::T.let(nil, ::T.untyped)
  AssociateClientVpnTargetNetworkRequest = ::T.let(nil, ::T.untyped)
  AssociateClientVpnTargetNetworkResult = ::T.let(nil, ::T.untyped)
  AssociateDhcpOptionsRequest = ::T.let(nil, ::T.untyped)
  AssociateIamInstanceProfileRequest = ::T.let(nil, ::T.untyped)
  AssociateIamInstanceProfileResult = ::T.let(nil, ::T.untyped)
  AssociateRouteTableRequest = ::T.let(nil, ::T.untyped)
  AssociateRouteTableResult = ::T.let(nil, ::T.untyped)
  AssociateSubnetCidrBlockRequest = ::T.let(nil, ::T.untyped)
  AssociateSubnetCidrBlockResult = ::T.let(nil, ::T.untyped)
  AssociateTransitGatewayMulticastDomainRequest = ::T.let(nil, ::T.untyped)
  AssociateTransitGatewayMulticastDomainResult = ::T.let(nil, ::T.untyped)
  AssociateTransitGatewayRouteTableRequest = ::T.let(nil, ::T.untyped)
  AssociateTransitGatewayRouteTableResult = ::T.let(nil, ::T.untyped)
  AssociateVpcCidrBlockRequest = ::T.let(nil, ::T.untyped)
  AssociateVpcCidrBlockResult = ::T.let(nil, ::T.untyped)
  AssociatedNetworkType = ::T.let(nil, ::T.untyped)
  AssociatedTargetNetwork = ::T.let(nil, ::T.untyped)
  AssociatedTargetNetworkSet = ::T.let(nil, ::T.untyped)
  AssociationIdList = ::T.let(nil, ::T.untyped)
  AssociationStatus = ::T.let(nil, ::T.untyped)
  AssociationStatusCode = ::T.let(nil, ::T.untyped)
  AttachClassicLinkVpcRequest = ::T.let(nil, ::T.untyped)
  AttachClassicLinkVpcResult = ::T.let(nil, ::T.untyped)
  AttachInternetGatewayRequest = ::T.let(nil, ::T.untyped)
  AttachNetworkInterfaceRequest = ::T.let(nil, ::T.untyped)
  AttachNetworkInterfaceResult = ::T.let(nil, ::T.untyped)
  AttachVolumeRequest = ::T.let(nil, ::T.untyped)
  AttachVpnGatewayRequest = ::T.let(nil, ::T.untyped)
  AttachVpnGatewayResult = ::T.let(nil, ::T.untyped)
  AttachmentStatus = ::T.let(nil, ::T.untyped)
  AttributeBooleanValue = ::T.let(nil, ::T.untyped)
  AttributeValue = ::T.let(nil, ::T.untyped)
  AuthorizationRule = ::T.let(nil, ::T.untyped)
  AuthorizationRuleSet = ::T.let(nil, ::T.untyped)
  AuthorizeClientVpnIngressRequest = ::T.let(nil, ::T.untyped)
  AuthorizeClientVpnIngressResult = ::T.let(nil, ::T.untyped)
  AuthorizeSecurityGroupEgressRequest = ::T.let(nil, ::T.untyped)
  AuthorizeSecurityGroupIngressRequest = ::T.let(nil, ::T.untyped)
  AutoAcceptSharedAttachmentsValue = ::T.let(nil, ::T.untyped)
  AutoPlacement = ::T.let(nil, ::T.untyped)
  AutoRecoveryFlag = ::T.let(nil, ::T.untyped)
  AvailabilityZone = ::T.let(nil, ::T.untyped)
  AvailabilityZoneList = ::T.let(nil, ::T.untyped)
  AvailabilityZoneMessage = ::T.let(nil, ::T.untyped)
  AvailabilityZoneMessageList = ::T.let(nil, ::T.untyped)
  AvailabilityZoneOptInStatus = ::T.let(nil, ::T.untyped)
  AvailabilityZoneState = ::T.let(nil, ::T.untyped)
  AvailabilityZoneStringList = ::T.let(nil, ::T.untyped)
  AvailableCapacity = ::T.let(nil, ::T.untyped)
  AvailableInstanceCapacityList = ::T.let(nil, ::T.untyped)
  BareMetalFlag = ::T.let(nil, ::T.untyped)
  BaselineBandwidthInMbps = ::T.let(nil, ::T.untyped)
  BaselineIops = ::T.let(nil, ::T.untyped)
  BaselineThroughputInMBps = ::T.let(nil, ::T.untyped)
  BatchState = ::T.let(nil, ::T.untyped)
  BillingProductList = ::T.let(nil, ::T.untyped)
  Blob = ::T.let(nil, ::T.untyped)
  BlobAttributeValue = ::T.let(nil, ::T.untyped)
  BlockDeviceMapping = ::T.let(nil, ::T.untyped)
  BlockDeviceMappingList = ::T.let(nil, ::T.untyped)
  BlockDeviceMappingRequestList = ::T.let(nil, ::T.untyped)
  Boolean = ::T.let(nil, ::T.untyped)
  BundleId = ::T.let(nil, ::T.untyped)
  BundleIdStringList = ::T.let(nil, ::T.untyped)
  BundleInstanceRequest = ::T.let(nil, ::T.untyped)
  BundleInstanceResult = ::T.let(nil, ::T.untyped)
  BundleTask = ::T.let(nil, ::T.untyped)
  BundleTaskError = ::T.let(nil, ::T.untyped)
  BundleTaskList = ::T.let(nil, ::T.untyped)
  BundleTaskState = ::T.let(nil, ::T.untyped)
  BurstablePerformanceFlag = ::T.let(nil, ::T.untyped)
  ByoipCidr = ::T.let(nil, ::T.untyped)
  ByoipCidrSet = ::T.let(nil, ::T.untyped)
  ByoipCidrState = ::T.let(nil, ::T.untyped)
  CancelBatchErrorCode = ::T.let(nil, ::T.untyped)
  CancelBundleTaskRequest = ::T.let(nil, ::T.untyped)
  CancelBundleTaskResult = ::T.let(nil, ::T.untyped)
  CancelCapacityReservationRequest = ::T.let(nil, ::T.untyped)
  CancelCapacityReservationResult = ::T.let(nil, ::T.untyped)
  CancelConversionRequest = ::T.let(nil, ::T.untyped)
  CancelExportTaskRequest = ::T.let(nil, ::T.untyped)
  CancelImportTaskRequest = ::T.let(nil, ::T.untyped)
  CancelImportTaskResult = ::T.let(nil, ::T.untyped)
  CancelReservedInstancesListingRequest = ::T.let(nil, ::T.untyped)
  CancelReservedInstancesListingResult = ::T.let(nil, ::T.untyped)
  CancelSpotFleetRequestsError = ::T.let(nil, ::T.untyped)
  CancelSpotFleetRequestsErrorItem = ::T.let(nil, ::T.untyped)
  CancelSpotFleetRequestsErrorSet = ::T.let(nil, ::T.untyped)
  CancelSpotFleetRequestsRequest = ::T.let(nil, ::T.untyped)
  CancelSpotFleetRequestsResponse = ::T.let(nil, ::T.untyped)
  CancelSpotFleetRequestsSuccessItem = ::T.let(nil, ::T.untyped)
  CancelSpotFleetRequestsSuccessSet = ::T.let(nil, ::T.untyped)
  CancelSpotInstanceRequestState = ::T.let(nil, ::T.untyped)
  CancelSpotInstanceRequestsRequest = ::T.let(nil, ::T.untyped)
  CancelSpotInstanceRequestsResult = ::T.let(nil, ::T.untyped)
  CancelledSpotInstanceRequest = ::T.let(nil, ::T.untyped)
  CancelledSpotInstanceRequestList = ::T.let(nil, ::T.untyped)
  CapacityReservation = ::T.let(nil, ::T.untyped)
  CapacityReservationId = ::T.let(nil, ::T.untyped)
  CapacityReservationIdSet = ::T.let(nil, ::T.untyped)
  CapacityReservationInstancePlatform = ::T.let(nil, ::T.untyped)
  CapacityReservationOptions = ::T.let(nil, ::T.untyped)
  CapacityReservationOptionsRequest = ::T.let(nil, ::T.untyped)
  CapacityReservationPreference = ::T.let(nil, ::T.untyped)
  CapacityReservationSet = ::T.let(nil, ::T.untyped)
  CapacityReservationSpecification = ::T.let(nil, ::T.untyped)
  CapacityReservationSpecificationResponse = ::T.let(nil, ::T.untyped)
  CapacityReservationState = ::T.let(nil, ::T.untyped)
  CapacityReservationTarget = ::T.let(nil, ::T.untyped)
  CapacityReservationTargetResponse = ::T.let(nil, ::T.untyped)
  CapacityReservationTenancy = ::T.let(nil, ::T.untyped)
  CertificateAuthentication = ::T.let(nil, ::T.untyped)
  CertificateAuthenticationRequest = ::T.let(nil, ::T.untyped)
  CidrAuthorizationContext = ::T.let(nil, ::T.untyped)
  CidrBlock = ::T.let(nil, ::T.untyped)
  CidrBlockSet = ::T.let(nil, ::T.untyped)
  ClassicLinkDnsSupport = ::T.let(nil, ::T.untyped)
  ClassicLinkDnsSupportList = ::T.let(nil, ::T.untyped)
  ClassicLinkInstance = ::T.let(nil, ::T.untyped)
  ClassicLinkInstanceList = ::T.let(nil, ::T.untyped)
  ClassicLoadBalancer = ::T.let(nil, ::T.untyped)
  ClassicLoadBalancers = ::T.let(nil, ::T.untyped)
  ClassicLoadBalancersConfig = ::T.let(nil, ::T.untyped)
  ClientCertificateRevocationListStatus = ::T.let(nil, ::T.untyped)
  ClientCertificateRevocationListStatusCode = ::T.let(nil, ::T.untyped)
  ClientData = ::T.let(nil, ::T.untyped)
  ClientVpnAssociationId = ::T.let(nil, ::T.untyped)
  ClientVpnAuthentication = ::T.let(nil, ::T.untyped)
  ClientVpnAuthenticationList = ::T.let(nil, ::T.untyped)
  ClientVpnAuthenticationRequest = ::T.let(nil, ::T.untyped)
  ClientVpnAuthenticationRequestList = ::T.let(nil, ::T.untyped)
  ClientVpnAuthenticationType = ::T.let(nil, ::T.untyped)
  ClientVpnAuthorizationRuleStatus = ::T.let(nil, ::T.untyped)
  ClientVpnAuthorizationRuleStatusCode = ::T.let(nil, ::T.untyped)
  ClientVpnConnection = ::T.let(nil, ::T.untyped)
  ClientVpnConnectionSet = ::T.let(nil, ::T.untyped)
  ClientVpnConnectionStatus = ::T.let(nil, ::T.untyped)
  ClientVpnConnectionStatusCode = ::T.let(nil, ::T.untyped)
  ClientVpnEndpoint = ::T.let(nil, ::T.untyped)
  ClientVpnEndpointId = ::T.let(nil, ::T.untyped)
  ClientVpnEndpointIdList = ::T.let(nil, ::T.untyped)
  ClientVpnEndpointStatus = ::T.let(nil, ::T.untyped)
  ClientVpnEndpointStatusCode = ::T.let(nil, ::T.untyped)
  ClientVpnRoute = ::T.let(nil, ::T.untyped)
  ClientVpnRouteSet = ::T.let(nil, ::T.untyped)
  ClientVpnRouteStatus = ::T.let(nil, ::T.untyped)
  ClientVpnRouteStatusCode = ::T.let(nil, ::T.untyped)
  ClientVpnSecurityGroupIdSet = ::T.let(nil, ::T.untyped)
  CoipAddressUsage = ::T.let(nil, ::T.untyped)
  CoipAddressUsageSet = ::T.let(nil, ::T.untyped)
  CoipPool = ::T.let(nil, ::T.untyped)
  CoipPoolId = ::T.let(nil, ::T.untyped)
  CoipPoolIdSet = ::T.let(nil, ::T.untyped)
  CoipPoolMaxResults = ::T.let(nil, ::T.untyped)
  CoipPoolSet = ::T.let(nil, ::T.untyped)
  ConfirmProductInstanceRequest = ::T.let(nil, ::T.untyped)
  ConfirmProductInstanceResult = ::T.let(nil, ::T.untyped)
  ConnectionLogOptions = ::T.let(nil, ::T.untyped)
  ConnectionLogResponseOptions = ::T.let(nil, ::T.untyped)
  ConnectionNotification = ::T.let(nil, ::T.untyped)
  ConnectionNotificationId = ::T.let(nil, ::T.untyped)
  ConnectionNotificationSet = ::T.let(nil, ::T.untyped)
  ConnectionNotificationState = ::T.let(nil, ::T.untyped)
  ConnectionNotificationType = ::T.let(nil, ::T.untyped)
  ContainerFormat = ::T.let(nil, ::T.untyped)
  ConversionIdStringList = ::T.let(nil, ::T.untyped)
  ConversionTask = ::T.let(nil, ::T.untyped)
  ConversionTaskId = ::T.let(nil, ::T.untyped)
  ConversionTaskState = ::T.let(nil, ::T.untyped)
  CopyFpgaImageRequest = ::T.let(nil, ::T.untyped)
  CopyFpgaImageResult = ::T.let(nil, ::T.untyped)
  CopyImageRequest = ::T.let(nil, ::T.untyped)
  CopyImageResult = ::T.let(nil, ::T.untyped)
  CopySnapshotRequest = ::T.let(nil, ::T.untyped)
  CopySnapshotResult = ::T.let(nil, ::T.untyped)
  CopyTagsFromSource = ::T.let(nil, ::T.untyped)
  CoreCount = ::T.let(nil, ::T.untyped)
  CoreCountList = ::T.let(nil, ::T.untyped)
  CpuOptions = ::T.let(nil, ::T.untyped)
  CpuOptionsRequest = ::T.let(nil, ::T.untyped)
  CreateCapacityReservationRequest = ::T.let(nil, ::T.untyped)
  CreateCapacityReservationResult = ::T.let(nil, ::T.untyped)
  CreateClientVpnEndpointRequest = ::T.let(nil, ::T.untyped)
  CreateClientVpnEndpointResult = ::T.let(nil, ::T.untyped)
  CreateClientVpnRouteRequest = ::T.let(nil, ::T.untyped)
  CreateClientVpnRouteResult = ::T.let(nil, ::T.untyped)
  CreateCustomerGatewayRequest = ::T.let(nil, ::T.untyped)
  CreateCustomerGatewayResult = ::T.let(nil, ::T.untyped)
  CreateDefaultSubnetRequest = ::T.let(nil, ::T.untyped)
  CreateDefaultSubnetResult = ::T.let(nil, ::T.untyped)
  CreateDefaultVpcRequest = ::T.let(nil, ::T.untyped)
  CreateDefaultVpcResult = ::T.let(nil, ::T.untyped)
  CreateDhcpOptionsRequest = ::T.let(nil, ::T.untyped)
  CreateDhcpOptionsResult = ::T.let(nil, ::T.untyped)
  CreateEgressOnlyInternetGatewayRequest = ::T.let(nil, ::T.untyped)
  CreateEgressOnlyInternetGatewayResult = ::T.let(nil, ::T.untyped)
  CreateFleetError = ::T.let(nil, ::T.untyped)
  CreateFleetErrorsSet = ::T.let(nil, ::T.untyped)
  CreateFleetInstance = ::T.let(nil, ::T.untyped)
  CreateFleetInstancesSet = ::T.let(nil, ::T.untyped)
  CreateFleetRequest = ::T.let(nil, ::T.untyped)
  CreateFleetResult = ::T.let(nil, ::T.untyped)
  CreateFlowLogsRequest = ::T.let(nil, ::T.untyped)
  CreateFlowLogsResult = ::T.let(nil, ::T.untyped)
  CreateFpgaImageRequest = ::T.let(nil, ::T.untyped)
  CreateFpgaImageResult = ::T.let(nil, ::T.untyped)
  CreateImageRequest = ::T.let(nil, ::T.untyped)
  CreateImageResult = ::T.let(nil, ::T.untyped)
  CreateInstanceExportTaskRequest = ::T.let(nil, ::T.untyped)
  CreateInstanceExportTaskResult = ::T.let(nil, ::T.untyped)
  CreateInternetGatewayRequest = ::T.let(nil, ::T.untyped)
  CreateInternetGatewayResult = ::T.let(nil, ::T.untyped)
  CreateKeyPairRequest = ::T.let(nil, ::T.untyped)
  CreateLaunchTemplateRequest = ::T.let(nil, ::T.untyped)
  CreateLaunchTemplateResult = ::T.let(nil, ::T.untyped)
  CreateLaunchTemplateVersionRequest = ::T.let(nil, ::T.untyped)
  CreateLaunchTemplateVersionResult = ::T.let(nil, ::T.untyped)
  CreateLocalGatewayRouteRequest = ::T.let(nil, ::T.untyped)
  CreateLocalGatewayRouteResult = ::T.let(nil, ::T.untyped)
  CreateLocalGatewayRouteTableVpcAssociationRequest = ::T.let(nil, ::T.untyped)
  CreateLocalGatewayRouteTableVpcAssociationResult = ::T.let(nil, ::T.untyped)
  CreateManagedPrefixListRequest = ::T.let(nil, ::T.untyped)
  CreateManagedPrefixListResult = ::T.let(nil, ::T.untyped)
  CreateNatGatewayRequest = ::T.let(nil, ::T.untyped)
  CreateNatGatewayResult = ::T.let(nil, ::T.untyped)
  CreateNetworkAclEntryRequest = ::T.let(nil, ::T.untyped)
  CreateNetworkAclRequest = ::T.let(nil, ::T.untyped)
  CreateNetworkAclResult = ::T.let(nil, ::T.untyped)
  CreateNetworkInterfacePermissionRequest = ::T.let(nil, ::T.untyped)
  CreateNetworkInterfacePermissionResult = ::T.let(nil, ::T.untyped)
  CreateNetworkInterfaceRequest = ::T.let(nil, ::T.untyped)
  CreateNetworkInterfaceResult = ::T.let(nil, ::T.untyped)
  CreatePlacementGroupRequest = ::T.let(nil, ::T.untyped)
  CreatePlacementGroupResult = ::T.let(nil, ::T.untyped)
  CreateReservedInstancesListingRequest = ::T.let(nil, ::T.untyped)
  CreateReservedInstancesListingResult = ::T.let(nil, ::T.untyped)
  CreateRouteRequest = ::T.let(nil, ::T.untyped)
  CreateRouteResult = ::T.let(nil, ::T.untyped)
  CreateRouteTableRequest = ::T.let(nil, ::T.untyped)
  CreateRouteTableResult = ::T.let(nil, ::T.untyped)
  CreateSecurityGroupRequest = ::T.let(nil, ::T.untyped)
  CreateSecurityGroupResult = ::T.let(nil, ::T.untyped)
  CreateSnapshotRequest = ::T.let(nil, ::T.untyped)
  CreateSnapshotsRequest = ::T.let(nil, ::T.untyped)
  CreateSnapshotsResult = ::T.let(nil, ::T.untyped)
  CreateSpotDatafeedSubscriptionRequest = ::T.let(nil, ::T.untyped)
  CreateSpotDatafeedSubscriptionResult = ::T.let(nil, ::T.untyped)
  CreateSubnetRequest = ::T.let(nil, ::T.untyped)
  CreateSubnetResult = ::T.let(nil, ::T.untyped)
  CreateTagsRequest = ::T.let(nil, ::T.untyped)
  CreateTrafficMirrorFilterRequest = ::T.let(nil, ::T.untyped)
  CreateTrafficMirrorFilterResult = ::T.let(nil, ::T.untyped)
  CreateTrafficMirrorFilterRuleRequest = ::T.let(nil, ::T.untyped)
  CreateTrafficMirrorFilterRuleResult = ::T.let(nil, ::T.untyped)
  CreateTrafficMirrorSessionRequest = ::T.let(nil, ::T.untyped)
  CreateTrafficMirrorSessionResult = ::T.let(nil, ::T.untyped)
  CreateTrafficMirrorTargetRequest = ::T.let(nil, ::T.untyped)
  CreateTrafficMirrorTargetResult = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayMulticastDomainRequest = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayMulticastDomainResult = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayPeeringAttachmentRequest = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayPeeringAttachmentResult = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayRequest = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayResult = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayRouteRequest = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayRouteResult = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayRouteTableRequest = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayRouteTableResult = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayVpcAttachmentRequest = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayVpcAttachmentRequestOptions = ::T.let(nil, ::T.untyped)
  CreateTransitGatewayVpcAttachmentResult = ::T.let(nil, ::T.untyped)
  CreateVolumePermission = ::T.let(nil, ::T.untyped)
  CreateVolumePermissionList = ::T.let(nil, ::T.untyped)
  CreateVolumePermissionModifications = ::T.let(nil, ::T.untyped)
  CreateVolumeRequest = ::T.let(nil, ::T.untyped)
  CreateVpcEndpointConnectionNotificationRequest = ::T.let(nil, ::T.untyped)
  CreateVpcEndpointConnectionNotificationResult = ::T.let(nil, ::T.untyped)
  CreateVpcEndpointRequest = ::T.let(nil, ::T.untyped)
  CreateVpcEndpointResult = ::T.let(nil, ::T.untyped)
  CreateVpcEndpointServiceConfigurationRequest = ::T.let(nil, ::T.untyped)
  CreateVpcEndpointServiceConfigurationResult = ::T.let(nil, ::T.untyped)
  CreateVpcPeeringConnectionRequest = ::T.let(nil, ::T.untyped)
  CreateVpcPeeringConnectionResult = ::T.let(nil, ::T.untyped)
  CreateVpcRequest = ::T.let(nil, ::T.untyped)
  CreateVpcResult = ::T.let(nil, ::T.untyped)
  CreateVpnConnectionRequest = ::T.let(nil, ::T.untyped)
  CreateVpnConnectionResult = ::T.let(nil, ::T.untyped)
  CreateVpnConnectionRouteRequest = ::T.let(nil, ::T.untyped)
  CreateVpnGatewayRequest = ::T.let(nil, ::T.untyped)
  CreateVpnGatewayResult = ::T.let(nil, ::T.untyped)
  CreditSpecification = ::T.let(nil, ::T.untyped)
  CreditSpecificationRequest = ::T.let(nil, ::T.untyped)
  CurrencyCodeValues = ::T.let(nil, ::T.untyped)
  CurrentGenerationFlag = ::T.let(nil, ::T.untyped)
  CustomerGateway = ::T.let(nil, ::T.untyped)
  CustomerGatewayId = ::T.let(nil, ::T.untyped)
  CustomerGatewayIdStringList = ::T.let(nil, ::T.untyped)
  CustomerGatewayList = ::T.let(nil, ::T.untyped)
  DITMaxResults = ::T.let(nil, ::T.untyped)
  DITOMaxResults = ::T.let(nil, ::T.untyped)
  DatafeedSubscriptionState = ::T.let(nil, ::T.untyped)
  DateTime = ::T.let(nil, ::T.untyped)
  DedicatedHostFlag = ::T.let(nil, ::T.untyped)
  DedicatedHostId = ::T.let(nil, ::T.untyped)
  DefaultRouteTableAssociationValue = ::T.let(nil, ::T.untyped)
  DefaultRouteTablePropagationValue = ::T.let(nil, ::T.untyped)
  DefaultTargetCapacityType = ::T.let(nil, ::T.untyped)
  DefaultingDhcpOptionsId = ::T.let(nil, ::T.untyped)
  DeleteClientVpnEndpointRequest = ::T.let(nil, ::T.untyped)
  DeleteClientVpnEndpointResult = ::T.let(nil, ::T.untyped)
  DeleteClientVpnRouteRequest = ::T.let(nil, ::T.untyped)
  DeleteClientVpnRouteResult = ::T.let(nil, ::T.untyped)
  DeleteCustomerGatewayRequest = ::T.let(nil, ::T.untyped)
  DeleteDhcpOptionsRequest = ::T.let(nil, ::T.untyped)
  DeleteEgressOnlyInternetGatewayRequest = ::T.let(nil, ::T.untyped)
  DeleteEgressOnlyInternetGatewayResult = ::T.let(nil, ::T.untyped)
  DeleteFleetError = ::T.let(nil, ::T.untyped)
  DeleteFleetErrorCode = ::T.let(nil, ::T.untyped)
  DeleteFleetErrorItem = ::T.let(nil, ::T.untyped)
  DeleteFleetErrorSet = ::T.let(nil, ::T.untyped)
  DeleteFleetSuccessItem = ::T.let(nil, ::T.untyped)
  DeleteFleetSuccessSet = ::T.let(nil, ::T.untyped)
  DeleteFleetsRequest = ::T.let(nil, ::T.untyped)
  DeleteFleetsResult = ::T.let(nil, ::T.untyped)
  DeleteFlowLogsRequest = ::T.let(nil, ::T.untyped)
  DeleteFlowLogsResult = ::T.let(nil, ::T.untyped)
  DeleteFpgaImageRequest = ::T.let(nil, ::T.untyped)
  DeleteFpgaImageResult = ::T.let(nil, ::T.untyped)
  DeleteInternetGatewayRequest = ::T.let(nil, ::T.untyped)
  DeleteKeyPairRequest = ::T.let(nil, ::T.untyped)
  DeleteLaunchTemplateRequest = ::T.let(nil, ::T.untyped)
  DeleteLaunchTemplateResult = ::T.let(nil, ::T.untyped)
  DeleteLaunchTemplateVersionsRequest = ::T.let(nil, ::T.untyped)
  DeleteLaunchTemplateVersionsResponseErrorItem = ::T.let(nil, ::T.untyped)
  DeleteLaunchTemplateVersionsResponseErrorSet = ::T.let(nil, ::T.untyped)
  DeleteLaunchTemplateVersionsResponseSuccessItem = ::T.let(nil, ::T.untyped)
  DeleteLaunchTemplateVersionsResponseSuccessSet = ::T.let(nil, ::T.untyped)
  DeleteLaunchTemplateVersionsResult = ::T.let(nil, ::T.untyped)
  DeleteLocalGatewayRouteRequest = ::T.let(nil, ::T.untyped)
  DeleteLocalGatewayRouteResult = ::T.let(nil, ::T.untyped)
  DeleteLocalGatewayRouteTableVpcAssociationRequest = ::T.let(nil, ::T.untyped)
  DeleteLocalGatewayRouteTableVpcAssociationResult = ::T.let(nil, ::T.untyped)
  DeleteManagedPrefixListRequest = ::T.let(nil, ::T.untyped)
  DeleteManagedPrefixListResult = ::T.let(nil, ::T.untyped)
  DeleteNatGatewayRequest = ::T.let(nil, ::T.untyped)
  DeleteNatGatewayResult = ::T.let(nil, ::T.untyped)
  DeleteNetworkAclEntryRequest = ::T.let(nil, ::T.untyped)
  DeleteNetworkAclRequest = ::T.let(nil, ::T.untyped)
  DeleteNetworkInterfacePermissionRequest = ::T.let(nil, ::T.untyped)
  DeleteNetworkInterfacePermissionResult = ::T.let(nil, ::T.untyped)
  DeleteNetworkInterfaceRequest = ::T.let(nil, ::T.untyped)
  DeletePlacementGroupRequest = ::T.let(nil, ::T.untyped)
  DeleteQueuedReservedInstancesError = ::T.let(nil, ::T.untyped)
  DeleteQueuedReservedInstancesErrorCode = ::T.let(nil, ::T.untyped)
  DeleteQueuedReservedInstancesIdList = ::T.let(nil, ::T.untyped)
  DeleteQueuedReservedInstancesRequest = ::T.let(nil, ::T.untyped)
  DeleteQueuedReservedInstancesResult = ::T.let(nil, ::T.untyped)
  DeleteRouteRequest = ::T.let(nil, ::T.untyped)
  DeleteRouteTableRequest = ::T.let(nil, ::T.untyped)
  DeleteSecurityGroupRequest = ::T.let(nil, ::T.untyped)
  DeleteSnapshotRequest = ::T.let(nil, ::T.untyped)
  DeleteSpotDatafeedSubscriptionRequest = ::T.let(nil, ::T.untyped)
  DeleteSubnetRequest = ::T.let(nil, ::T.untyped)
  DeleteTagsRequest = ::T.let(nil, ::T.untyped)
  DeleteTrafficMirrorFilterRequest = ::T.let(nil, ::T.untyped)
  DeleteTrafficMirrorFilterResult = ::T.let(nil, ::T.untyped)
  DeleteTrafficMirrorFilterRuleRequest = ::T.let(nil, ::T.untyped)
  DeleteTrafficMirrorFilterRuleResult = ::T.let(nil, ::T.untyped)
  DeleteTrafficMirrorSessionRequest = ::T.let(nil, ::T.untyped)
  DeleteTrafficMirrorSessionResult = ::T.let(nil, ::T.untyped)
  DeleteTrafficMirrorTargetRequest = ::T.let(nil, ::T.untyped)
  DeleteTrafficMirrorTargetResult = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayMulticastDomainRequest = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayMulticastDomainResult = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayPeeringAttachmentRequest = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayPeeringAttachmentResult = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayRequest = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayResult = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayRouteRequest = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayRouteResult = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayRouteTableRequest = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayRouteTableResult = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayVpcAttachmentRequest = ::T.let(nil, ::T.untyped)
  DeleteTransitGatewayVpcAttachmentResult = ::T.let(nil, ::T.untyped)
  DeleteVolumeRequest = ::T.let(nil, ::T.untyped)
  DeleteVpcEndpointConnectionNotificationsRequest = ::T.let(nil, ::T.untyped)
  DeleteVpcEndpointConnectionNotificationsResult = ::T.let(nil, ::T.untyped)
  DeleteVpcEndpointServiceConfigurationsRequest = ::T.let(nil, ::T.untyped)
  DeleteVpcEndpointServiceConfigurationsResult = ::T.let(nil, ::T.untyped)
  DeleteVpcEndpointsRequest = ::T.let(nil, ::T.untyped)
  DeleteVpcEndpointsResult = ::T.let(nil, ::T.untyped)
  DeleteVpcPeeringConnectionRequest = ::T.let(nil, ::T.untyped)
  DeleteVpcPeeringConnectionResult = ::T.let(nil, ::T.untyped)
  DeleteVpcRequest = ::T.let(nil, ::T.untyped)
  DeleteVpnConnectionRequest = ::T.let(nil, ::T.untyped)
  DeleteVpnConnectionRouteRequest = ::T.let(nil, ::T.untyped)
  DeleteVpnGatewayRequest = ::T.let(nil, ::T.untyped)
  DeprovisionByoipCidrRequest = ::T.let(nil, ::T.untyped)
  DeprovisionByoipCidrResult = ::T.let(nil, ::T.untyped)
  DeregisterImageRequest = ::T.let(nil, ::T.untyped)
  DeregisterInstanceEventNotificationAttributesRequest = ::T.let(nil, ::T.untyped)
  DeregisterInstanceEventNotificationAttributesResult = ::T.let(nil, ::T.untyped)
  DeregisterInstanceTagAttributeRequest = ::T.let(nil, ::T.untyped)
  DeregisterTransitGatewayMulticastGroupMembersRequest = ::T.let(nil, ::T.untyped)
  DeregisterTransitGatewayMulticastGroupMembersResult = ::T.let(nil, ::T.untyped)
  DeregisterTransitGatewayMulticastGroupSourcesRequest = ::T.let(nil, ::T.untyped)
  DeregisterTransitGatewayMulticastGroupSourcesResult = ::T.let(nil, ::T.untyped)
  DescribeAccountAttributesRequest = ::T.let(nil, ::T.untyped)
  DescribeAccountAttributesResult = ::T.let(nil, ::T.untyped)
  DescribeAddressesRequest = ::T.let(nil, ::T.untyped)
  DescribeAddressesResult = ::T.let(nil, ::T.untyped)
  DescribeAggregateIdFormatRequest = ::T.let(nil, ::T.untyped)
  DescribeAggregateIdFormatResult = ::T.let(nil, ::T.untyped)
  DescribeAvailabilityZonesRequest = ::T.let(nil, ::T.untyped)
  DescribeAvailabilityZonesResult = ::T.let(nil, ::T.untyped)
  DescribeBundleTasksRequest = ::T.let(nil, ::T.untyped)
  DescribeBundleTasksResult = ::T.let(nil, ::T.untyped)
  DescribeByoipCidrsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeByoipCidrsRequest = ::T.let(nil, ::T.untyped)
  DescribeByoipCidrsResult = ::T.let(nil, ::T.untyped)
  DescribeCapacityReservationsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeCapacityReservationsRequest = ::T.let(nil, ::T.untyped)
  DescribeCapacityReservationsResult = ::T.let(nil, ::T.untyped)
  DescribeClassicLinkInstancesMaxResults = ::T.let(nil, ::T.untyped)
  DescribeClassicLinkInstancesRequest = ::T.let(nil, ::T.untyped)
  DescribeClassicLinkInstancesResult = ::T.let(nil, ::T.untyped)
  DescribeClientVpnAuthorizationRulesMaxResults = ::T.let(nil, ::T.untyped)
  DescribeClientVpnAuthorizationRulesRequest = ::T.let(nil, ::T.untyped)
  DescribeClientVpnAuthorizationRulesResult = ::T.let(nil, ::T.untyped)
  DescribeClientVpnConnectionsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeClientVpnConnectionsRequest = ::T.let(nil, ::T.untyped)
  DescribeClientVpnConnectionsResult = ::T.let(nil, ::T.untyped)
  DescribeClientVpnEndpointMaxResults = ::T.let(nil, ::T.untyped)
  DescribeClientVpnEndpointsRequest = ::T.let(nil, ::T.untyped)
  DescribeClientVpnEndpointsResult = ::T.let(nil, ::T.untyped)
  DescribeClientVpnRoutesMaxResults = ::T.let(nil, ::T.untyped)
  DescribeClientVpnRoutesRequest = ::T.let(nil, ::T.untyped)
  DescribeClientVpnRoutesResult = ::T.let(nil, ::T.untyped)
  DescribeClientVpnTargetNetworksMaxResults = ::T.let(nil, ::T.untyped)
  DescribeClientVpnTargetNetworksRequest = ::T.let(nil, ::T.untyped)
  DescribeClientVpnTargetNetworksResult = ::T.let(nil, ::T.untyped)
  DescribeCoipPoolsRequest = ::T.let(nil, ::T.untyped)
  DescribeCoipPoolsResult = ::T.let(nil, ::T.untyped)
  DescribeConversionTaskList = ::T.let(nil, ::T.untyped)
  DescribeConversionTasksRequest = ::T.let(nil, ::T.untyped)
  DescribeConversionTasksResult = ::T.let(nil, ::T.untyped)
  DescribeCustomerGatewaysRequest = ::T.let(nil, ::T.untyped)
  DescribeCustomerGatewaysResult = ::T.let(nil, ::T.untyped)
  DescribeDhcpOptionsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeDhcpOptionsRequest = ::T.let(nil, ::T.untyped)
  DescribeDhcpOptionsResult = ::T.let(nil, ::T.untyped)
  DescribeEgressOnlyInternetGatewaysMaxResults = ::T.let(nil, ::T.untyped)
  DescribeEgressOnlyInternetGatewaysRequest = ::T.let(nil, ::T.untyped)
  DescribeEgressOnlyInternetGatewaysResult = ::T.let(nil, ::T.untyped)
  DescribeElasticGpusMaxResults = ::T.let(nil, ::T.untyped)
  DescribeElasticGpusRequest = ::T.let(nil, ::T.untyped)
  DescribeElasticGpusResult = ::T.let(nil, ::T.untyped)
  DescribeExportImageTasksMaxResults = ::T.let(nil, ::T.untyped)
  DescribeExportImageTasksRequest = ::T.let(nil, ::T.untyped)
  DescribeExportImageTasksResult = ::T.let(nil, ::T.untyped)
  DescribeExportTasksRequest = ::T.let(nil, ::T.untyped)
  DescribeExportTasksResult = ::T.let(nil, ::T.untyped)
  DescribeFastSnapshotRestoreSuccessItem = ::T.let(nil, ::T.untyped)
  DescribeFastSnapshotRestoreSuccessSet = ::T.let(nil, ::T.untyped)
  DescribeFastSnapshotRestoresMaxResults = ::T.let(nil, ::T.untyped)
  DescribeFastSnapshotRestoresRequest = ::T.let(nil, ::T.untyped)
  DescribeFastSnapshotRestoresResult = ::T.let(nil, ::T.untyped)
  DescribeFleetError = ::T.let(nil, ::T.untyped)
  DescribeFleetHistoryRequest = ::T.let(nil, ::T.untyped)
  DescribeFleetHistoryResult = ::T.let(nil, ::T.untyped)
  DescribeFleetInstancesRequest = ::T.let(nil, ::T.untyped)
  DescribeFleetInstancesResult = ::T.let(nil, ::T.untyped)
  DescribeFleetsErrorSet = ::T.let(nil, ::T.untyped)
  DescribeFleetsInstances = ::T.let(nil, ::T.untyped)
  DescribeFleetsInstancesSet = ::T.let(nil, ::T.untyped)
  DescribeFleetsRequest = ::T.let(nil, ::T.untyped)
  DescribeFleetsResult = ::T.let(nil, ::T.untyped)
  DescribeFlowLogsRequest = ::T.let(nil, ::T.untyped)
  DescribeFlowLogsResult = ::T.let(nil, ::T.untyped)
  DescribeFpgaImageAttributeRequest = ::T.let(nil, ::T.untyped)
  DescribeFpgaImageAttributeResult = ::T.let(nil, ::T.untyped)
  DescribeFpgaImagesMaxResults = ::T.let(nil, ::T.untyped)
  DescribeFpgaImagesRequest = ::T.let(nil, ::T.untyped)
  DescribeFpgaImagesResult = ::T.let(nil, ::T.untyped)
  DescribeHostReservationOfferingsRequest = ::T.let(nil, ::T.untyped)
  DescribeHostReservationOfferingsResult = ::T.let(nil, ::T.untyped)
  DescribeHostReservationsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeHostReservationsRequest = ::T.let(nil, ::T.untyped)
  DescribeHostReservationsResult = ::T.let(nil, ::T.untyped)
  DescribeHostsRequest = ::T.let(nil, ::T.untyped)
  DescribeHostsResult = ::T.let(nil, ::T.untyped)
  DescribeIamInstanceProfileAssociationsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeIamInstanceProfileAssociationsRequest = ::T.let(nil, ::T.untyped)
  DescribeIamInstanceProfileAssociationsResult = ::T.let(nil, ::T.untyped)
  DescribeIdFormatRequest = ::T.let(nil, ::T.untyped)
  DescribeIdFormatResult = ::T.let(nil, ::T.untyped)
  DescribeIdentityIdFormatRequest = ::T.let(nil, ::T.untyped)
  DescribeIdentityIdFormatResult = ::T.let(nil, ::T.untyped)
  DescribeImageAttributeRequest = ::T.let(nil, ::T.untyped)
  DescribeImagesRequest = ::T.let(nil, ::T.untyped)
  DescribeImagesResult = ::T.let(nil, ::T.untyped)
  DescribeImportImageTasksRequest = ::T.let(nil, ::T.untyped)
  DescribeImportImageTasksResult = ::T.let(nil, ::T.untyped)
  DescribeImportSnapshotTasksRequest = ::T.let(nil, ::T.untyped)
  DescribeImportSnapshotTasksResult = ::T.let(nil, ::T.untyped)
  DescribeInstanceAttributeRequest = ::T.let(nil, ::T.untyped)
  DescribeInstanceCreditSpecificationsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeInstanceCreditSpecificationsRequest = ::T.let(nil, ::T.untyped)
  DescribeInstanceCreditSpecificationsResult = ::T.let(nil, ::T.untyped)
  DescribeInstanceEventNotificationAttributesRequest = ::T.let(nil, ::T.untyped)
  DescribeInstanceEventNotificationAttributesResult = ::T.let(nil, ::T.untyped)
  DescribeInstanceStatusRequest = ::T.let(nil, ::T.untyped)
  DescribeInstanceStatusResult = ::T.let(nil, ::T.untyped)
  DescribeInstanceTypeOfferingsRequest = ::T.let(nil, ::T.untyped)
  DescribeInstanceTypeOfferingsResult = ::T.let(nil, ::T.untyped)
  DescribeInstanceTypesRequest = ::T.let(nil, ::T.untyped)
  DescribeInstanceTypesResult = ::T.let(nil, ::T.untyped)
  DescribeInstancesRequest = ::T.let(nil, ::T.untyped)
  DescribeInstancesResult = ::T.let(nil, ::T.untyped)
  DescribeInternetGatewaysMaxResults = ::T.let(nil, ::T.untyped)
  DescribeInternetGatewaysRequest = ::T.let(nil, ::T.untyped)
  DescribeInternetGatewaysResult = ::T.let(nil, ::T.untyped)
  DescribeIpv6PoolsRequest = ::T.let(nil, ::T.untyped)
  DescribeIpv6PoolsResult = ::T.let(nil, ::T.untyped)
  DescribeKeyPairsRequest = ::T.let(nil, ::T.untyped)
  DescribeKeyPairsResult = ::T.let(nil, ::T.untyped)
  DescribeLaunchTemplateVersionsRequest = ::T.let(nil, ::T.untyped)
  DescribeLaunchTemplateVersionsResult = ::T.let(nil, ::T.untyped)
  DescribeLaunchTemplatesMaxResults = ::T.let(nil, ::T.untyped)
  DescribeLaunchTemplatesRequest = ::T.let(nil, ::T.untyped)
  DescribeLaunchTemplatesResult = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewayRouteTableVpcAssociationsRequest = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewayRouteTableVpcAssociationsResult = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewayRouteTablesRequest = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewayRouteTablesResult = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewayVirtualInterfaceGroupsRequest = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewayVirtualInterfaceGroupsResult = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewayVirtualInterfacesRequest = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewayVirtualInterfacesResult = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewaysRequest = ::T.let(nil, ::T.untyped)
  DescribeLocalGatewaysResult = ::T.let(nil, ::T.untyped)
  DescribeManagedPrefixListsRequest = ::T.let(nil, ::T.untyped)
  DescribeManagedPrefixListsResult = ::T.let(nil, ::T.untyped)
  DescribeMovingAddressesMaxResults = ::T.let(nil, ::T.untyped)
  DescribeMovingAddressesRequest = ::T.let(nil, ::T.untyped)
  DescribeMovingAddressesResult = ::T.let(nil, ::T.untyped)
  DescribeNatGatewaysMaxResults = ::T.let(nil, ::T.untyped)
  DescribeNatGatewaysRequest = ::T.let(nil, ::T.untyped)
  DescribeNatGatewaysResult = ::T.let(nil, ::T.untyped)
  DescribeNetworkAclsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeNetworkAclsRequest = ::T.let(nil, ::T.untyped)
  DescribeNetworkAclsResult = ::T.let(nil, ::T.untyped)
  DescribeNetworkInterfaceAttributeRequest = ::T.let(nil, ::T.untyped)
  DescribeNetworkInterfaceAttributeResult = ::T.let(nil, ::T.untyped)
  DescribeNetworkInterfacePermissionsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeNetworkInterfacePermissionsRequest = ::T.let(nil, ::T.untyped)
  DescribeNetworkInterfacePermissionsResult = ::T.let(nil, ::T.untyped)
  DescribeNetworkInterfacesMaxResults = ::T.let(nil, ::T.untyped)
  DescribeNetworkInterfacesRequest = ::T.let(nil, ::T.untyped)
  DescribeNetworkInterfacesResult = ::T.let(nil, ::T.untyped)
  DescribePlacementGroupsRequest = ::T.let(nil, ::T.untyped)
  DescribePlacementGroupsResult = ::T.let(nil, ::T.untyped)
  DescribePrefixListsRequest = ::T.let(nil, ::T.untyped)
  DescribePrefixListsResult = ::T.let(nil, ::T.untyped)
  DescribePrincipalIdFormatMaxResults = ::T.let(nil, ::T.untyped)
  DescribePrincipalIdFormatRequest = ::T.let(nil, ::T.untyped)
  DescribePrincipalIdFormatResult = ::T.let(nil, ::T.untyped)
  DescribePublicIpv4PoolsRequest = ::T.let(nil, ::T.untyped)
  DescribePublicIpv4PoolsResult = ::T.let(nil, ::T.untyped)
  DescribeRegionsRequest = ::T.let(nil, ::T.untyped)
  DescribeRegionsResult = ::T.let(nil, ::T.untyped)
  DescribeReservedInstancesListingsRequest = ::T.let(nil, ::T.untyped)
  DescribeReservedInstancesListingsResult = ::T.let(nil, ::T.untyped)
  DescribeReservedInstancesModificationsRequest = ::T.let(nil, ::T.untyped)
  DescribeReservedInstancesModificationsResult = ::T.let(nil, ::T.untyped)
  DescribeReservedInstancesOfferingsRequest = ::T.let(nil, ::T.untyped)
  DescribeReservedInstancesOfferingsResult = ::T.let(nil, ::T.untyped)
  DescribeReservedInstancesRequest = ::T.let(nil, ::T.untyped)
  DescribeReservedInstancesResult = ::T.let(nil, ::T.untyped)
  DescribeRouteTablesMaxResults = ::T.let(nil, ::T.untyped)
  DescribeRouteTablesRequest = ::T.let(nil, ::T.untyped)
  DescribeRouteTablesResult = ::T.let(nil, ::T.untyped)
  DescribeScheduledInstanceAvailabilityMaxResults = ::T.let(nil, ::T.untyped)
  DescribeScheduledInstanceAvailabilityRequest = ::T.let(nil, ::T.untyped)
  DescribeScheduledInstanceAvailabilityResult = ::T.let(nil, ::T.untyped)
  DescribeScheduledInstancesRequest = ::T.let(nil, ::T.untyped)
  DescribeScheduledInstancesResult = ::T.let(nil, ::T.untyped)
  DescribeSecurityGroupReferencesRequest = ::T.let(nil, ::T.untyped)
  DescribeSecurityGroupReferencesResult = ::T.let(nil, ::T.untyped)
  DescribeSecurityGroupsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeSecurityGroupsRequest = ::T.let(nil, ::T.untyped)
  DescribeSecurityGroupsResult = ::T.let(nil, ::T.untyped)
  DescribeSnapshotAttributeRequest = ::T.let(nil, ::T.untyped)
  DescribeSnapshotAttributeResult = ::T.let(nil, ::T.untyped)
  DescribeSnapshotsRequest = ::T.let(nil, ::T.untyped)
  DescribeSnapshotsResult = ::T.let(nil, ::T.untyped)
  DescribeSpotDatafeedSubscriptionRequest = ::T.let(nil, ::T.untyped)
  DescribeSpotDatafeedSubscriptionResult = ::T.let(nil, ::T.untyped)
  DescribeSpotFleetInstancesMaxResults = ::T.let(nil, ::T.untyped)
  DescribeSpotFleetInstancesRequest = ::T.let(nil, ::T.untyped)
  DescribeSpotFleetInstancesResponse = ::T.let(nil, ::T.untyped)
  DescribeSpotFleetRequestHistoryMaxResults = ::T.let(nil, ::T.untyped)
  DescribeSpotFleetRequestHistoryRequest = ::T.let(nil, ::T.untyped)
  DescribeSpotFleetRequestHistoryResponse = ::T.let(nil, ::T.untyped)
  DescribeSpotFleetRequestsRequest = ::T.let(nil, ::T.untyped)
  DescribeSpotFleetRequestsResponse = ::T.let(nil, ::T.untyped)
  DescribeSpotInstanceRequestsRequest = ::T.let(nil, ::T.untyped)
  DescribeSpotInstanceRequestsResult = ::T.let(nil, ::T.untyped)
  DescribeSpotPriceHistoryRequest = ::T.let(nil, ::T.untyped)
  DescribeSpotPriceHistoryResult = ::T.let(nil, ::T.untyped)
  DescribeStaleSecurityGroupsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeStaleSecurityGroupsNextToken = ::T.let(nil, ::T.untyped)
  DescribeStaleSecurityGroupsRequest = ::T.let(nil, ::T.untyped)
  DescribeStaleSecurityGroupsResult = ::T.let(nil, ::T.untyped)
  DescribeSubnetsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeSubnetsRequest = ::T.let(nil, ::T.untyped)
  DescribeSubnetsResult = ::T.let(nil, ::T.untyped)
  DescribeTagsRequest = ::T.let(nil, ::T.untyped)
  DescribeTagsResult = ::T.let(nil, ::T.untyped)
  DescribeTrafficMirrorFiltersRequest = ::T.let(nil, ::T.untyped)
  DescribeTrafficMirrorFiltersResult = ::T.let(nil, ::T.untyped)
  DescribeTrafficMirrorSessionsRequest = ::T.let(nil, ::T.untyped)
  DescribeTrafficMirrorSessionsResult = ::T.let(nil, ::T.untyped)
  DescribeTrafficMirrorTargetsRequest = ::T.let(nil, ::T.untyped)
  DescribeTrafficMirrorTargetsResult = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewayAttachmentsRequest = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewayAttachmentsResult = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewayMulticastDomainsRequest = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewayMulticastDomainsResult = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewayPeeringAttachmentsRequest = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewayPeeringAttachmentsResult = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewayRouteTablesRequest = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewayRouteTablesResult = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewayVpcAttachmentsRequest = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewayVpcAttachmentsResult = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewaysRequest = ::T.let(nil, ::T.untyped)
  DescribeTransitGatewaysResult = ::T.let(nil, ::T.untyped)
  DescribeVolumeAttributeRequest = ::T.let(nil, ::T.untyped)
  DescribeVolumeAttributeResult = ::T.let(nil, ::T.untyped)
  DescribeVolumeStatusRequest = ::T.let(nil, ::T.untyped)
  DescribeVolumeStatusResult = ::T.let(nil, ::T.untyped)
  DescribeVolumesModificationsRequest = ::T.let(nil, ::T.untyped)
  DescribeVolumesModificationsResult = ::T.let(nil, ::T.untyped)
  DescribeVolumesRequest = ::T.let(nil, ::T.untyped)
  DescribeVolumesResult = ::T.let(nil, ::T.untyped)
  DescribeVpcAttributeRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcAttributeResult = ::T.let(nil, ::T.untyped)
  DescribeVpcClassicLinkDnsSupportMaxResults = ::T.let(nil, ::T.untyped)
  DescribeVpcClassicLinkDnsSupportNextToken = ::T.let(nil, ::T.untyped)
  DescribeVpcClassicLinkDnsSupportRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcClassicLinkDnsSupportResult = ::T.let(nil, ::T.untyped)
  DescribeVpcClassicLinkRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcClassicLinkResult = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointConnectionNotificationsRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointConnectionNotificationsResult = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointConnectionsRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointConnectionsResult = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointServiceConfigurationsRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointServiceConfigurationsResult = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointServicePermissionsRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointServicePermissionsResult = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointServicesRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointServicesResult = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointsRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcEndpointsResult = ::T.let(nil, ::T.untyped)
  DescribeVpcPeeringConnectionsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeVpcPeeringConnectionsRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcPeeringConnectionsResult = ::T.let(nil, ::T.untyped)
  DescribeVpcsMaxResults = ::T.let(nil, ::T.untyped)
  DescribeVpcsRequest = ::T.let(nil, ::T.untyped)
  DescribeVpcsResult = ::T.let(nil, ::T.untyped)
  DescribeVpnConnectionsRequest = ::T.let(nil, ::T.untyped)
  DescribeVpnConnectionsResult = ::T.let(nil, ::T.untyped)
  DescribeVpnGatewaysRequest = ::T.let(nil, ::T.untyped)
  DescribeVpnGatewaysResult = ::T.let(nil, ::T.untyped)
  DetachClassicLinkVpcRequest = ::T.let(nil, ::T.untyped)
  DetachClassicLinkVpcResult = ::T.let(nil, ::T.untyped)
  DetachInternetGatewayRequest = ::T.let(nil, ::T.untyped)
  DetachNetworkInterfaceRequest = ::T.let(nil, ::T.untyped)
  DetachVolumeRequest = ::T.let(nil, ::T.untyped)
  DetachVpnGatewayRequest = ::T.let(nil, ::T.untyped)
  DeviceType = ::T.let(nil, ::T.untyped)
  DhcpConfiguration = ::T.let(nil, ::T.untyped)
  DhcpConfigurationList = ::T.let(nil, ::T.untyped)
  DhcpConfigurationValueList = ::T.let(nil, ::T.untyped)
  DhcpOptions = ::T.let(nil, ::T.untyped)
  DhcpOptionsId = ::T.let(nil, ::T.untyped)
  DhcpOptionsIdStringList = ::T.let(nil, ::T.untyped)
  DhcpOptionsList = ::T.let(nil, ::T.untyped)
  DirectoryServiceAuthentication = ::T.let(nil, ::T.untyped)
  DirectoryServiceAuthenticationRequest = ::T.let(nil, ::T.untyped)
  DisableEbsEncryptionByDefaultRequest = ::T.let(nil, ::T.untyped)
  DisableEbsEncryptionByDefaultResult = ::T.let(nil, ::T.untyped)
  DisableFastSnapshotRestoreErrorItem = ::T.let(nil, ::T.untyped)
  DisableFastSnapshotRestoreErrorSet = ::T.let(nil, ::T.untyped)
  DisableFastSnapshotRestoreStateError = ::T.let(nil, ::T.untyped)
  DisableFastSnapshotRestoreStateErrorItem = ::T.let(nil, ::T.untyped)
  DisableFastSnapshotRestoreStateErrorSet = ::T.let(nil, ::T.untyped)
  DisableFastSnapshotRestoreSuccessItem = ::T.let(nil, ::T.untyped)
  DisableFastSnapshotRestoreSuccessSet = ::T.let(nil, ::T.untyped)
  DisableFastSnapshotRestoresRequest = ::T.let(nil, ::T.untyped)
  DisableFastSnapshotRestoresResult = ::T.let(nil, ::T.untyped)
  DisableTransitGatewayRouteTablePropagationRequest = ::T.let(nil, ::T.untyped)
  DisableTransitGatewayRouteTablePropagationResult = ::T.let(nil, ::T.untyped)
  DisableVgwRoutePropagationRequest = ::T.let(nil, ::T.untyped)
  DisableVpcClassicLinkDnsSupportRequest = ::T.let(nil, ::T.untyped)
  DisableVpcClassicLinkDnsSupportResult = ::T.let(nil, ::T.untyped)
  DisableVpcClassicLinkRequest = ::T.let(nil, ::T.untyped)
  DisableVpcClassicLinkResult = ::T.let(nil, ::T.untyped)
  DisassociateAddressRequest = ::T.let(nil, ::T.untyped)
  DisassociateClientVpnTargetNetworkRequest = ::T.let(nil, ::T.untyped)
  DisassociateClientVpnTargetNetworkResult = ::T.let(nil, ::T.untyped)
  DisassociateIamInstanceProfileRequest = ::T.let(nil, ::T.untyped)
  DisassociateIamInstanceProfileResult = ::T.let(nil, ::T.untyped)
  DisassociateRouteTableRequest = ::T.let(nil, ::T.untyped)
  DisassociateSubnetCidrBlockRequest = ::T.let(nil, ::T.untyped)
  DisassociateSubnetCidrBlockResult = ::T.let(nil, ::T.untyped)
  DisassociateTransitGatewayMulticastDomainRequest = ::T.let(nil, ::T.untyped)
  DisassociateTransitGatewayMulticastDomainResult = ::T.let(nil, ::T.untyped)
  DisassociateTransitGatewayRouteTableRequest = ::T.let(nil, ::T.untyped)
  DisassociateTransitGatewayRouteTableResult = ::T.let(nil, ::T.untyped)
  DisassociateVpcCidrBlockRequest = ::T.let(nil, ::T.untyped)
  DisassociateVpcCidrBlockResult = ::T.let(nil, ::T.untyped)
  DiskCount = ::T.let(nil, ::T.untyped)
  DiskImage = ::T.let(nil, ::T.untyped)
  DiskImageDescription = ::T.let(nil, ::T.untyped)
  DiskImageDetail = ::T.let(nil, ::T.untyped)
  DiskImageFormat = ::T.let(nil, ::T.untyped)
  DiskImageList = ::T.let(nil, ::T.untyped)
  DiskImageVolumeDescription = ::T.let(nil, ::T.untyped)
  DiskInfo = ::T.let(nil, ::T.untyped)
  DiskInfoList = ::T.let(nil, ::T.untyped)
  DiskSize = ::T.let(nil, ::T.untyped)
  DiskType = ::T.let(nil, ::T.untyped)
  DnsEntry = ::T.let(nil, ::T.untyped)
  DnsEntrySet = ::T.let(nil, ::T.untyped)
  DnsNameState = ::T.let(nil, ::T.untyped)
  DnsServersOptionsModifyStructure = ::T.let(nil, ::T.untyped)
  DnsSupportValue = ::T.let(nil, ::T.untyped)
  DomainType = ::T.let(nil, ::T.untyped)
  Double = ::T.let(nil, ::T.untyped)
  EbsBlockDevice = ::T.let(nil, ::T.untyped)
  EbsEncryptionSupport = ::T.let(nil, ::T.untyped)
  EbsInfo = ::T.let(nil, ::T.untyped)
  EbsInstanceBlockDevice = ::T.let(nil, ::T.untyped)
  EbsInstanceBlockDeviceSpecification = ::T.let(nil, ::T.untyped)
  EbsNvmeSupport = ::T.let(nil, ::T.untyped)
  EbsOptimizedInfo = ::T.let(nil, ::T.untyped)
  EbsOptimizedSupport = ::T.let(nil, ::T.untyped)
  EfaSupportedFlag = ::T.let(nil, ::T.untyped)
  EgressOnlyInternetGateway = ::T.let(nil, ::T.untyped)
  EgressOnlyInternetGatewayId = ::T.let(nil, ::T.untyped)
  EgressOnlyInternetGatewayIdList = ::T.let(nil, ::T.untyped)
  EgressOnlyInternetGatewayList = ::T.let(nil, ::T.untyped)
  ElasticGpuAssociation = ::T.let(nil, ::T.untyped)
  ElasticGpuAssociationList = ::T.let(nil, ::T.untyped)
  ElasticGpuHealth = ::T.let(nil, ::T.untyped)
  ElasticGpuId = ::T.let(nil, ::T.untyped)
  ElasticGpuIdSet = ::T.let(nil, ::T.untyped)
  ElasticGpuSet = ::T.let(nil, ::T.untyped)
  ElasticGpuSpecification = ::T.let(nil, ::T.untyped)
  ElasticGpuSpecificationList = ::T.let(nil, ::T.untyped)
  ElasticGpuSpecificationResponse = ::T.let(nil, ::T.untyped)
  ElasticGpuSpecificationResponseList = ::T.let(nil, ::T.untyped)
  ElasticGpuSpecifications = ::T.let(nil, ::T.untyped)
  ElasticGpuState = ::T.let(nil, ::T.untyped)
  ElasticGpuStatus = ::T.let(nil, ::T.untyped)
  ElasticGpus = ::T.let(nil, ::T.untyped)
  ElasticInferenceAccelerator = ::T.let(nil, ::T.untyped)
  ElasticInferenceAcceleratorAssociation = ::T.let(nil, ::T.untyped)
  ElasticInferenceAcceleratorAssociationList = ::T.let(nil, ::T.untyped)
  ElasticInferenceAcceleratorCount = ::T.let(nil, ::T.untyped)
  ElasticInferenceAccelerators = ::T.let(nil, ::T.untyped)
  ElasticIpAssociationId = ::T.let(nil, ::T.untyped)
  EnaSupport = ::T.let(nil, ::T.untyped)
  EnableEbsEncryptionByDefaultRequest = ::T.let(nil, ::T.untyped)
  EnableEbsEncryptionByDefaultResult = ::T.let(nil, ::T.untyped)
  EnableFastSnapshotRestoreErrorItem = ::T.let(nil, ::T.untyped)
  EnableFastSnapshotRestoreErrorSet = ::T.let(nil, ::T.untyped)
  EnableFastSnapshotRestoreStateError = ::T.let(nil, ::T.untyped)
  EnableFastSnapshotRestoreStateErrorItem = ::T.let(nil, ::T.untyped)
  EnableFastSnapshotRestoreStateErrorSet = ::T.let(nil, ::T.untyped)
  EnableFastSnapshotRestoreSuccessItem = ::T.let(nil, ::T.untyped)
  EnableFastSnapshotRestoreSuccessSet = ::T.let(nil, ::T.untyped)
  EnableFastSnapshotRestoresRequest = ::T.let(nil, ::T.untyped)
  EnableFastSnapshotRestoresResult = ::T.let(nil, ::T.untyped)
  EnableTransitGatewayRouteTablePropagationRequest = ::T.let(nil, ::T.untyped)
  EnableTransitGatewayRouteTablePropagationResult = ::T.let(nil, ::T.untyped)
  EnableVgwRoutePropagationRequest = ::T.let(nil, ::T.untyped)
  EnableVolumeIORequest = ::T.let(nil, ::T.untyped)
  EnableVpcClassicLinkDnsSupportRequest = ::T.let(nil, ::T.untyped)
  EnableVpcClassicLinkDnsSupportResult = ::T.let(nil, ::T.untyped)
  EnableVpcClassicLinkRequest = ::T.let(nil, ::T.untyped)
  EnableVpcClassicLinkResult = ::T.let(nil, ::T.untyped)
  EndDateType = ::T.let(nil, ::T.untyped)
  EndpointSet = ::T.let(nil, ::T.untyped)
  ErrorSet = ::T.let(nil, ::T.untyped)
  EventCode = ::T.let(nil, ::T.untyped)
  EventInformation = ::T.let(nil, ::T.untyped)
  EventType = ::T.let(nil, ::T.untyped)
  ExcessCapacityTerminationPolicy = ::T.let(nil, ::T.untyped)
  ExecutableByStringList = ::T.let(nil, ::T.untyped)
  ExportClientVpnClientCertificateRevocationListRequest = ::T.let(nil, ::T.untyped)
  ExportClientVpnClientCertificateRevocationListResult = ::T.let(nil, ::T.untyped)
  ExportClientVpnClientConfigurationRequest = ::T.let(nil, ::T.untyped)
  ExportClientVpnClientConfigurationResult = ::T.let(nil, ::T.untyped)
  ExportEnvironment = ::T.let(nil, ::T.untyped)
  ExportImageRequest = ::T.let(nil, ::T.untyped)
  ExportImageResult = ::T.let(nil, ::T.untyped)
  ExportImageTask = ::T.let(nil, ::T.untyped)
  ExportImageTaskId = ::T.let(nil, ::T.untyped)
  ExportImageTaskIdList = ::T.let(nil, ::T.untyped)
  ExportImageTaskList = ::T.let(nil, ::T.untyped)
  ExportTask = ::T.let(nil, ::T.untyped)
  ExportTaskId = ::T.let(nil, ::T.untyped)
  ExportTaskIdStringList = ::T.let(nil, ::T.untyped)
  ExportTaskList = ::T.let(nil, ::T.untyped)
  ExportTaskS3Location = ::T.let(nil, ::T.untyped)
  ExportTaskS3LocationRequest = ::T.let(nil, ::T.untyped)
  ExportTaskState = ::T.let(nil, ::T.untyped)
  ExportToS3Task = ::T.let(nil, ::T.untyped)
  ExportToS3TaskSpecification = ::T.let(nil, ::T.untyped)
  ExportTransitGatewayRoutesRequest = ::T.let(nil, ::T.untyped)
  ExportTransitGatewayRoutesResult = ::T.let(nil, ::T.untyped)
  ExportVmTaskId = ::T.let(nil, ::T.untyped)
  FailedQueuedPurchaseDeletion = ::T.let(nil, ::T.untyped)
  FailedQueuedPurchaseDeletionSet = ::T.let(nil, ::T.untyped)
  FastSnapshotRestoreStateCode = ::T.let(nil, ::T.untyped)
  FederatedAuthentication = ::T.let(nil, ::T.untyped)
  FederatedAuthenticationRequest = ::T.let(nil, ::T.untyped)
  Filter = ::T.let(nil, ::T.untyped)
  FilterList = ::T.let(nil, ::T.untyped)
  FleetActivityStatus = ::T.let(nil, ::T.untyped)
  FleetCapacityReservationUsageStrategy = ::T.let(nil, ::T.untyped)
  FleetData = ::T.let(nil, ::T.untyped)
  FleetEventType = ::T.let(nil, ::T.untyped)
  FleetExcessCapacityTerminationPolicy = ::T.let(nil, ::T.untyped)
  FleetId = ::T.let(nil, ::T.untyped)
  FleetIdSet = ::T.let(nil, ::T.untyped)
  FleetLaunchTemplateConfig = ::T.let(nil, ::T.untyped)
  FleetLaunchTemplateConfigList = ::T.let(nil, ::T.untyped)
  FleetLaunchTemplateConfigListRequest = ::T.let(nil, ::T.untyped)
  FleetLaunchTemplateConfigRequest = ::T.let(nil, ::T.untyped)
  FleetLaunchTemplateOverrides = ::T.let(nil, ::T.untyped)
  FleetLaunchTemplateOverridesList = ::T.let(nil, ::T.untyped)
  FleetLaunchTemplateOverridesListRequest = ::T.let(nil, ::T.untyped)
  FleetLaunchTemplateOverridesRequest = ::T.let(nil, ::T.untyped)
  FleetLaunchTemplateSpecification = ::T.let(nil, ::T.untyped)
  FleetLaunchTemplateSpecificationRequest = ::T.let(nil, ::T.untyped)
  FleetOnDemandAllocationStrategy = ::T.let(nil, ::T.untyped)
  FleetSet = ::T.let(nil, ::T.untyped)
  FleetStateCode = ::T.let(nil, ::T.untyped)
  FleetType = ::T.let(nil, ::T.untyped)
  Float = ::T.let(nil, ::T.untyped)
  FlowLog = ::T.let(nil, ::T.untyped)
  FlowLogIdList = ::T.let(nil, ::T.untyped)
  FlowLogResourceId = ::T.let(nil, ::T.untyped)
  FlowLogResourceIds = ::T.let(nil, ::T.untyped)
  FlowLogSet = ::T.let(nil, ::T.untyped)
  FlowLogsResourceType = ::T.let(nil, ::T.untyped)
  FpgaDeviceCount = ::T.let(nil, ::T.untyped)
  FpgaDeviceInfo = ::T.let(nil, ::T.untyped)
  FpgaDeviceInfoList = ::T.let(nil, ::T.untyped)
  FpgaDeviceManufacturerName = ::T.let(nil, ::T.untyped)
  FpgaDeviceMemoryInfo = ::T.let(nil, ::T.untyped)
  FpgaDeviceMemorySize = ::T.let(nil, ::T.untyped)
  FpgaDeviceName = ::T.let(nil, ::T.untyped)
  FpgaImage = ::T.let(nil, ::T.untyped)
  FpgaImageAttribute = ::T.let(nil, ::T.untyped)
  FpgaImageAttributeName = ::T.let(nil, ::T.untyped)
  FpgaImageId = ::T.let(nil, ::T.untyped)
  FpgaImageIdList = ::T.let(nil, ::T.untyped)
  FpgaImageList = ::T.let(nil, ::T.untyped)
  FpgaImageState = ::T.let(nil, ::T.untyped)
  FpgaImageStateCode = ::T.let(nil, ::T.untyped)
  FpgaInfo = ::T.let(nil, ::T.untyped)
  FreeTierEligibleFlag = ::T.let(nil, ::T.untyped)
  GatewayType = ::T.let(nil, ::T.untyped)
  GetAssociatedIpv6PoolCidrsRequest = ::T.let(nil, ::T.untyped)
  GetAssociatedIpv6PoolCidrsResult = ::T.let(nil, ::T.untyped)
  GetCapacityReservationUsageRequest = ::T.let(nil, ::T.untyped)
  GetCapacityReservationUsageRequestMaxResults = ::T.let(nil, ::T.untyped)
  GetCapacityReservationUsageResult = ::T.let(nil, ::T.untyped)
  GetCoipPoolUsageRequest = ::T.let(nil, ::T.untyped)
  GetCoipPoolUsageResult = ::T.let(nil, ::T.untyped)
  GetConsoleOutputRequest = ::T.let(nil, ::T.untyped)
  GetConsoleOutputResult = ::T.let(nil, ::T.untyped)
  GetConsoleScreenshotRequest = ::T.let(nil, ::T.untyped)
  GetConsoleScreenshotResult = ::T.let(nil, ::T.untyped)
  GetDefaultCreditSpecificationRequest = ::T.let(nil, ::T.untyped)
  GetDefaultCreditSpecificationResult = ::T.let(nil, ::T.untyped)
  GetEbsDefaultKmsKeyIdRequest = ::T.let(nil, ::T.untyped)
  GetEbsDefaultKmsKeyIdResult = ::T.let(nil, ::T.untyped)
  GetEbsEncryptionByDefaultRequest = ::T.let(nil, ::T.untyped)
  GetEbsEncryptionByDefaultResult = ::T.let(nil, ::T.untyped)
  GetHostReservationPurchasePreviewRequest = ::T.let(nil, ::T.untyped)
  GetHostReservationPurchasePreviewResult = ::T.let(nil, ::T.untyped)
  GetLaunchTemplateDataRequest = ::T.let(nil, ::T.untyped)
  GetLaunchTemplateDataResult = ::T.let(nil, ::T.untyped)
  GetManagedPrefixListAssociationsMaxResults = ::T.let(nil, ::T.untyped)
  GetManagedPrefixListAssociationsRequest = ::T.let(nil, ::T.untyped)
  GetManagedPrefixListAssociationsResult = ::T.let(nil, ::T.untyped)
  GetManagedPrefixListEntriesRequest = ::T.let(nil, ::T.untyped)
  GetManagedPrefixListEntriesResult = ::T.let(nil, ::T.untyped)
  GetPasswordDataRequest = ::T.let(nil, ::T.untyped)
  GetPasswordDataResult = ::T.let(nil, ::T.untyped)
  GetReservedInstancesExchangeQuoteRequest = ::T.let(nil, ::T.untyped)
  GetReservedInstancesExchangeQuoteResult = ::T.let(nil, ::T.untyped)
  GetTransitGatewayAttachmentPropagationsRequest = ::T.let(nil, ::T.untyped)
  GetTransitGatewayAttachmentPropagationsResult = ::T.let(nil, ::T.untyped)
  GetTransitGatewayMulticastDomainAssociationsRequest = ::T.let(nil, ::T.untyped)
  GetTransitGatewayMulticastDomainAssociationsResult = ::T.let(nil, ::T.untyped)
  GetTransitGatewayRouteTableAssociationsRequest = ::T.let(nil, ::T.untyped)
  GetTransitGatewayRouteTableAssociationsResult = ::T.let(nil, ::T.untyped)
  GetTransitGatewayRouteTablePropagationsRequest = ::T.let(nil, ::T.untyped)
  GetTransitGatewayRouteTablePropagationsResult = ::T.let(nil, ::T.untyped)
  GpuDeviceCount = ::T.let(nil, ::T.untyped)
  GpuDeviceInfo = ::T.let(nil, ::T.untyped)
  GpuDeviceInfoList = ::T.let(nil, ::T.untyped)
  GpuDeviceManufacturerName = ::T.let(nil, ::T.untyped)
  GpuDeviceMemoryInfo = ::T.let(nil, ::T.untyped)
  GpuDeviceMemorySize = ::T.let(nil, ::T.untyped)
  GpuDeviceName = ::T.let(nil, ::T.untyped)
  GpuInfo = ::T.let(nil, ::T.untyped)
  GroupIdStringList = ::T.let(nil, ::T.untyped)
  GroupIdentifier = ::T.let(nil, ::T.untyped)
  GroupIdentifierList = ::T.let(nil, ::T.untyped)
  GroupIdentifierSet = ::T.let(nil, ::T.untyped)
  GroupIds = ::T.let(nil, ::T.untyped)
  GroupNameStringList = ::T.let(nil, ::T.untyped)
  HibernationFlag = ::T.let(nil, ::T.untyped)
  HibernationOptions = ::T.let(nil, ::T.untyped)
  HibernationOptionsRequest = ::T.let(nil, ::T.untyped)
  HistoryRecord = ::T.let(nil, ::T.untyped)
  HistoryRecordEntry = ::T.let(nil, ::T.untyped)
  HistoryRecordSet = ::T.let(nil, ::T.untyped)
  HistoryRecords = ::T.let(nil, ::T.untyped)
  Host = ::T.let(nil, ::T.untyped)
  HostInstance = ::T.let(nil, ::T.untyped)
  HostInstanceList = ::T.let(nil, ::T.untyped)
  HostList = ::T.let(nil, ::T.untyped)
  HostOffering = ::T.let(nil, ::T.untyped)
  HostOfferingSet = ::T.let(nil, ::T.untyped)
  HostProperties = ::T.let(nil, ::T.untyped)
  HostRecovery = ::T.let(nil, ::T.untyped)
  HostReservation = ::T.let(nil, ::T.untyped)
  HostReservationId = ::T.let(nil, ::T.untyped)
  HostReservationIdSet = ::T.let(nil, ::T.untyped)
  HostReservationSet = ::T.let(nil, ::T.untyped)
  HostTenancy = ::T.let(nil, ::T.untyped)
  HttpTokensState = ::T.let(nil, ::T.untyped)
  HypervisorType = ::T.let(nil, ::T.untyped)
  IKEVersionsList = ::T.let(nil, ::T.untyped)
  IKEVersionsListValue = ::T.let(nil, ::T.untyped)
  IKEVersionsRequestList = ::T.let(nil, ::T.untyped)
  IKEVersionsRequestListValue = ::T.let(nil, ::T.untyped)
  IamInstanceProfile = ::T.let(nil, ::T.untyped)
  IamInstanceProfileAssociation = ::T.let(nil, ::T.untyped)
  IamInstanceProfileAssociationId = ::T.let(nil, ::T.untyped)
  IamInstanceProfileAssociationSet = ::T.let(nil, ::T.untyped)
  IamInstanceProfileAssociationState = ::T.let(nil, ::T.untyped)
  IamInstanceProfileSpecification = ::T.let(nil, ::T.untyped)
  IcmpTypeCode = ::T.let(nil, ::T.untyped)
  IdFormat = ::T.let(nil, ::T.untyped)
  IdFormatList = ::T.let(nil, ::T.untyped)
  Image = ::T.let(nil, ::T.untyped)
  ImageAttribute = ::T.let(nil, ::T.untyped)
  ImageAttributeName = ::T.let(nil, ::T.untyped)
  ImageDiskContainer = ::T.let(nil, ::T.untyped)
  ImageDiskContainerList = ::T.let(nil, ::T.untyped)
  ImageId = ::T.let(nil, ::T.untyped)
  ImageIdStringList = ::T.let(nil, ::T.untyped)
  ImageList = ::T.let(nil, ::T.untyped)
  ImageState = ::T.let(nil, ::T.untyped)
  ImageTypeValues = ::T.let(nil, ::T.untyped)
  ImportClientVpnClientCertificateRevocationListRequest = ::T.let(nil, ::T.untyped)
  ImportClientVpnClientCertificateRevocationListResult = ::T.let(nil, ::T.untyped)
  ImportImageLicenseConfigurationRequest = ::T.let(nil, ::T.untyped)
  ImportImageLicenseConfigurationResponse = ::T.let(nil, ::T.untyped)
  ImportImageLicenseSpecificationListRequest = ::T.let(nil, ::T.untyped)
  ImportImageLicenseSpecificationListResponse = ::T.let(nil, ::T.untyped)
  ImportImageRequest = ::T.let(nil, ::T.untyped)
  ImportImageResult = ::T.let(nil, ::T.untyped)
  ImportImageTask = ::T.let(nil, ::T.untyped)
  ImportImageTaskId = ::T.let(nil, ::T.untyped)
  ImportImageTaskList = ::T.let(nil, ::T.untyped)
  ImportInstanceLaunchSpecification = ::T.let(nil, ::T.untyped)
  ImportInstanceRequest = ::T.let(nil, ::T.untyped)
  ImportInstanceResult = ::T.let(nil, ::T.untyped)
  ImportInstanceTaskDetails = ::T.let(nil, ::T.untyped)
  ImportInstanceVolumeDetailItem = ::T.let(nil, ::T.untyped)
  ImportInstanceVolumeDetailSet = ::T.let(nil, ::T.untyped)
  ImportKeyPairRequest = ::T.let(nil, ::T.untyped)
  ImportKeyPairResult = ::T.let(nil, ::T.untyped)
  ImportSnapshotRequest = ::T.let(nil, ::T.untyped)
  ImportSnapshotResult = ::T.let(nil, ::T.untyped)
  ImportSnapshotTask = ::T.let(nil, ::T.untyped)
  ImportSnapshotTaskId = ::T.let(nil, ::T.untyped)
  ImportSnapshotTaskIdList = ::T.let(nil, ::T.untyped)
  ImportSnapshotTaskList = ::T.let(nil, ::T.untyped)
  ImportTaskId = ::T.let(nil, ::T.untyped)
  ImportTaskIdList = ::T.let(nil, ::T.untyped)
  ImportVolumeRequest = ::T.let(nil, ::T.untyped)
  ImportVolumeResult = ::T.let(nil, ::T.untyped)
  ImportVolumeTaskDetails = ::T.let(nil, ::T.untyped)
  InferenceAcceleratorInfo = ::T.let(nil, ::T.untyped)
  InferenceDeviceCount = ::T.let(nil, ::T.untyped)
  InferenceDeviceInfo = ::T.let(nil, ::T.untyped)
  InferenceDeviceInfoList = ::T.let(nil, ::T.untyped)
  InferenceDeviceManufacturerName = ::T.let(nil, ::T.untyped)
  InferenceDeviceName = ::T.let(nil, ::T.untyped)
  Instance = ::T.let(nil, ::T.untyped)
  InstanceAttribute = ::T.let(nil, ::T.untyped)
  InstanceAttributeName = ::T.let(nil, ::T.untyped)
  InstanceBlockDeviceMapping = ::T.let(nil, ::T.untyped)
  InstanceBlockDeviceMappingList = ::T.let(nil, ::T.untyped)
  InstanceBlockDeviceMappingSpecification = ::T.let(nil, ::T.untyped)
  InstanceBlockDeviceMappingSpecificationList = ::T.let(nil, ::T.untyped)
  InstanceCapacity = ::T.let(nil, ::T.untyped)
  InstanceCount = ::T.let(nil, ::T.untyped)
  InstanceCountList = ::T.let(nil, ::T.untyped)
  InstanceCreditSpecification = ::T.let(nil, ::T.untyped)
  InstanceCreditSpecificationList = ::T.let(nil, ::T.untyped)
  InstanceCreditSpecificationListRequest = ::T.let(nil, ::T.untyped)
  InstanceCreditSpecificationRequest = ::T.let(nil, ::T.untyped)
  InstanceEventId = ::T.let(nil, ::T.untyped)
  InstanceExportDetails = ::T.let(nil, ::T.untyped)
  InstanceFamilyCreditSpecification = ::T.let(nil, ::T.untyped)
  InstanceHealthStatus = ::T.let(nil, ::T.untyped)
  InstanceId = ::T.let(nil, ::T.untyped)
  InstanceIdSet = ::T.let(nil, ::T.untyped)
  InstanceIdStringList = ::T.let(nil, ::T.untyped)
  InstanceIdsSet = ::T.let(nil, ::T.untyped)
  InstanceInterruptionBehavior = ::T.let(nil, ::T.untyped)
  InstanceIpv6Address = ::T.let(nil, ::T.untyped)
  InstanceIpv6AddressList = ::T.let(nil, ::T.untyped)
  InstanceIpv6AddressListRequest = ::T.let(nil, ::T.untyped)
  InstanceIpv6AddressRequest = ::T.let(nil, ::T.untyped)
  InstanceLifecycle = ::T.let(nil, ::T.untyped)
  InstanceLifecycleType = ::T.let(nil, ::T.untyped)
  InstanceList = ::T.let(nil, ::T.untyped)
  InstanceMarketOptionsRequest = ::T.let(nil, ::T.untyped)
  InstanceMatchCriteria = ::T.let(nil, ::T.untyped)
  InstanceMetadataEndpointState = ::T.let(nil, ::T.untyped)
  InstanceMetadataOptionsRequest = ::T.let(nil, ::T.untyped)
  InstanceMetadataOptionsResponse = ::T.let(nil, ::T.untyped)
  InstanceMetadataOptionsState = ::T.let(nil, ::T.untyped)
  InstanceMonitoring = ::T.let(nil, ::T.untyped)
  InstanceMonitoringList = ::T.let(nil, ::T.untyped)
  InstanceNetworkInterface = ::T.let(nil, ::T.untyped)
  InstanceNetworkInterfaceAssociation = ::T.let(nil, ::T.untyped)
  InstanceNetworkInterfaceAttachment = ::T.let(nil, ::T.untyped)
  InstanceNetworkInterfaceList = ::T.let(nil, ::T.untyped)
  InstanceNetworkInterfaceSpecification = ::T.let(nil, ::T.untyped)
  InstanceNetworkInterfaceSpecificationList = ::T.let(nil, ::T.untyped)
  InstancePrivateIpAddress = ::T.let(nil, ::T.untyped)
  InstancePrivateIpAddressList = ::T.let(nil, ::T.untyped)
  InstanceSpecification = ::T.let(nil, ::T.untyped)
  InstanceState = ::T.let(nil, ::T.untyped)
  InstanceStateChange = ::T.let(nil, ::T.untyped)
  InstanceStateChangeList = ::T.let(nil, ::T.untyped)
  InstanceStateName = ::T.let(nil, ::T.untyped)
  InstanceStatus = ::T.let(nil, ::T.untyped)
  InstanceStatusDetails = ::T.let(nil, ::T.untyped)
  InstanceStatusDetailsList = ::T.let(nil, ::T.untyped)
  InstanceStatusEvent = ::T.let(nil, ::T.untyped)
  InstanceStatusEventList = ::T.let(nil, ::T.untyped)
  InstanceStatusList = ::T.let(nil, ::T.untyped)
  InstanceStatusSummary = ::T.let(nil, ::T.untyped)
  InstanceStorageFlag = ::T.let(nil, ::T.untyped)
  InstanceStorageInfo = ::T.let(nil, ::T.untyped)
  InstanceTagKeySet = ::T.let(nil, ::T.untyped)
  InstanceTagNotificationAttribute = ::T.let(nil, ::T.untyped)
  InstanceType = ::T.let(nil, ::T.untyped)
  InstanceTypeHypervisor = ::T.let(nil, ::T.untyped)
  InstanceTypeInfo = ::T.let(nil, ::T.untyped)
  InstanceTypeInfoList = ::T.let(nil, ::T.untyped)
  InstanceTypeList = ::T.let(nil, ::T.untyped)
  InstanceTypeOffering = ::T.let(nil, ::T.untyped)
  InstanceTypeOfferingsList = ::T.let(nil, ::T.untyped)
  InstanceUsage = ::T.let(nil, ::T.untyped)
  InstanceUsageSet = ::T.let(nil, ::T.untyped)
  Integer = ::T.let(nil, ::T.untyped)
  InterfacePermissionType = ::T.let(nil, ::T.untyped)
  InternetGateway = ::T.let(nil, ::T.untyped)
  InternetGatewayAttachment = ::T.let(nil, ::T.untyped)
  InternetGatewayAttachmentList = ::T.let(nil, ::T.untyped)
  InternetGatewayId = ::T.let(nil, ::T.untyped)
  InternetGatewayIdList = ::T.let(nil, ::T.untyped)
  InternetGatewayList = ::T.let(nil, ::T.untyped)
  IpPermission = ::T.let(nil, ::T.untyped)
  IpPermissionList = ::T.let(nil, ::T.untyped)
  IpRange = ::T.let(nil, ::T.untyped)
  IpRangeList = ::T.let(nil, ::T.untyped)
  IpRanges = ::T.let(nil, ::T.untyped)
  Ipv4PoolEc2Id = ::T.let(nil, ::T.untyped)
  Ipv6Address = ::T.let(nil, ::T.untyped)
  Ipv6AddressList = ::T.let(nil, ::T.untyped)
  Ipv6CidrAssociation = ::T.let(nil, ::T.untyped)
  Ipv6CidrAssociationSet = ::T.let(nil, ::T.untyped)
  Ipv6CidrBlock = ::T.let(nil, ::T.untyped)
  Ipv6CidrBlockSet = ::T.let(nil, ::T.untyped)
  Ipv6Flag = ::T.let(nil, ::T.untyped)
  Ipv6Pool = ::T.let(nil, ::T.untyped)
  Ipv6PoolEc2Id = ::T.let(nil, ::T.untyped)
  Ipv6PoolIdList = ::T.let(nil, ::T.untyped)
  Ipv6PoolMaxResults = ::T.let(nil, ::T.untyped)
  Ipv6PoolSet = ::T.let(nil, ::T.untyped)
  Ipv6Range = ::T.let(nil, ::T.untyped)
  Ipv6RangeList = ::T.let(nil, ::T.untyped)
  Ipv6SupportValue = ::T.let(nil, ::T.untyped)
  KernelId = ::T.let(nil, ::T.untyped)
  KeyNameStringList = ::T.let(nil, ::T.untyped)
  KeyPair = ::T.let(nil, ::T.untyped)
  KeyPairId = ::T.let(nil, ::T.untyped)
  KeyPairIdStringList = ::T.let(nil, ::T.untyped)
  KeyPairInfo = ::T.let(nil, ::T.untyped)
  KeyPairList = ::T.let(nil, ::T.untyped)
  KeyPairName = ::T.let(nil, ::T.untyped)
  KmsKeyId = ::T.let(nil, ::T.untyped)
  LastError = ::T.let(nil, ::T.untyped)
  LaunchPermission = ::T.let(nil, ::T.untyped)
  LaunchPermissionList = ::T.let(nil, ::T.untyped)
  LaunchPermissionModifications = ::T.let(nil, ::T.untyped)
  LaunchSpecification = ::T.let(nil, ::T.untyped)
  LaunchSpecsList = ::T.let(nil, ::T.untyped)
  LaunchTemplate = ::T.let(nil, ::T.untyped)
  LaunchTemplateAndOverridesResponse = ::T.let(nil, ::T.untyped)
  LaunchTemplateBlockDeviceMapping = ::T.let(nil, ::T.untyped)
  LaunchTemplateBlockDeviceMappingList = ::T.let(nil, ::T.untyped)
  LaunchTemplateBlockDeviceMappingRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateBlockDeviceMappingRequestList = ::T.let(nil, ::T.untyped)
  LaunchTemplateCapacityReservationSpecificationRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateCapacityReservationSpecificationResponse = ::T.let(nil, ::T.untyped)
  LaunchTemplateConfig = ::T.let(nil, ::T.untyped)
  LaunchTemplateConfigList = ::T.let(nil, ::T.untyped)
  LaunchTemplateCpuOptions = ::T.let(nil, ::T.untyped)
  LaunchTemplateCpuOptionsRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateEbsBlockDevice = ::T.let(nil, ::T.untyped)
  LaunchTemplateEbsBlockDeviceRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateElasticInferenceAccelerator = ::T.let(nil, ::T.untyped)
  LaunchTemplateElasticInferenceAcceleratorCount = ::T.let(nil, ::T.untyped)
  LaunchTemplateElasticInferenceAcceleratorList = ::T.let(nil, ::T.untyped)
  LaunchTemplateElasticInferenceAcceleratorResponse = ::T.let(nil, ::T.untyped)
  LaunchTemplateElasticInferenceAcceleratorResponseList = ::T.let(nil, ::T.untyped)
  LaunchTemplateErrorCode = ::T.let(nil, ::T.untyped)
  LaunchTemplateHibernationOptions = ::T.let(nil, ::T.untyped)
  LaunchTemplateHibernationOptionsRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateHttpTokensState = ::T.let(nil, ::T.untyped)
  LaunchTemplateIamInstanceProfileSpecification = ::T.let(nil, ::T.untyped)
  LaunchTemplateIamInstanceProfileSpecificationRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateId = ::T.let(nil, ::T.untyped)
  LaunchTemplateIdStringList = ::T.let(nil, ::T.untyped)
  LaunchTemplateInstanceMarketOptions = ::T.let(nil, ::T.untyped)
  LaunchTemplateInstanceMarketOptionsRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateInstanceMetadataEndpointState = ::T.let(nil, ::T.untyped)
  LaunchTemplateInstanceMetadataOptions = ::T.let(nil, ::T.untyped)
  LaunchTemplateInstanceMetadataOptionsRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateInstanceMetadataOptionsState = ::T.let(nil, ::T.untyped)
  LaunchTemplateInstanceNetworkInterfaceSpecification = ::T.let(nil, ::T.untyped)
  LaunchTemplateInstanceNetworkInterfaceSpecificationList = ::T.let(nil, ::T.untyped)
  LaunchTemplateInstanceNetworkInterfaceSpecificationRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList = ::T.let(nil, ::T.untyped)
  LaunchTemplateLicenseConfiguration = ::T.let(nil, ::T.untyped)
  LaunchTemplateLicenseConfigurationRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateLicenseList = ::T.let(nil, ::T.untyped)
  LaunchTemplateLicenseSpecificationListRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateName = ::T.let(nil, ::T.untyped)
  LaunchTemplateNameStringList = ::T.let(nil, ::T.untyped)
  LaunchTemplateOverrides = ::T.let(nil, ::T.untyped)
  LaunchTemplateOverridesList = ::T.let(nil, ::T.untyped)
  LaunchTemplatePlacement = ::T.let(nil, ::T.untyped)
  LaunchTemplatePlacementRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateSet = ::T.let(nil, ::T.untyped)
  LaunchTemplateSpecification = ::T.let(nil, ::T.untyped)
  LaunchTemplateSpotMarketOptions = ::T.let(nil, ::T.untyped)
  LaunchTemplateSpotMarketOptionsRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateTagSpecification = ::T.let(nil, ::T.untyped)
  LaunchTemplateTagSpecificationList = ::T.let(nil, ::T.untyped)
  LaunchTemplateTagSpecificationRequest = ::T.let(nil, ::T.untyped)
  LaunchTemplateTagSpecificationRequestList = ::T.let(nil, ::T.untyped)
  LaunchTemplateVersion = ::T.let(nil, ::T.untyped)
  LaunchTemplateVersionSet = ::T.let(nil, ::T.untyped)
  LaunchTemplatesMonitoring = ::T.let(nil, ::T.untyped)
  LaunchTemplatesMonitoringRequest = ::T.let(nil, ::T.untyped)
  LicenseConfiguration = ::T.let(nil, ::T.untyped)
  LicenseConfigurationRequest = ::T.let(nil, ::T.untyped)
  LicenseList = ::T.let(nil, ::T.untyped)
  LicenseSpecificationListRequest = ::T.let(nil, ::T.untyped)
  ListingState = ::T.let(nil, ::T.untyped)
  ListingStatus = ::T.let(nil, ::T.untyped)
  LoadBalancersConfig = ::T.let(nil, ::T.untyped)
  LoadPermission = ::T.let(nil, ::T.untyped)
  LoadPermissionList = ::T.let(nil, ::T.untyped)
  LoadPermissionListRequest = ::T.let(nil, ::T.untyped)
  LoadPermissionModifications = ::T.let(nil, ::T.untyped)
  LoadPermissionRequest = ::T.let(nil, ::T.untyped)
  LocalGateway = ::T.let(nil, ::T.untyped)
  LocalGatewayId = ::T.let(nil, ::T.untyped)
  LocalGatewayIdSet = ::T.let(nil, ::T.untyped)
  LocalGatewayMaxResults = ::T.let(nil, ::T.untyped)
  LocalGatewayRoute = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteList = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteState = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTable = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTableIdSet = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTableSet = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTableVirtualInterfaceGroupAssociation = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTableVirtualInterfaceGroupAssociationId = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTableVpcAssociation = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTableVpcAssociationId = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTableVpcAssociationIdSet = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteTableVpcAssociationSet = ::T.let(nil, ::T.untyped)
  LocalGatewayRouteType = ::T.let(nil, ::T.untyped)
  LocalGatewayRoutetableId = ::T.let(nil, ::T.untyped)
  LocalGatewaySet = ::T.let(nil, ::T.untyped)
  LocalGatewayVirtualInterface = ::T.let(nil, ::T.untyped)
  LocalGatewayVirtualInterfaceGroup = ::T.let(nil, ::T.untyped)
  LocalGatewayVirtualInterfaceGroupId = ::T.let(nil, ::T.untyped)
  LocalGatewayVirtualInterfaceGroupIdSet = ::T.let(nil, ::T.untyped)
  LocalGatewayVirtualInterfaceGroupSet = ::T.let(nil, ::T.untyped)
  LocalGatewayVirtualInterfaceId = ::T.let(nil, ::T.untyped)
  LocalGatewayVirtualInterfaceIdSet = ::T.let(nil, ::T.untyped)
  LocalGatewayVirtualInterfaceSet = ::T.let(nil, ::T.untyped)
  Location = ::T.let(nil, ::T.untyped)
  LocationType = ::T.let(nil, ::T.untyped)
  LogDestinationType = ::T.let(nil, ::T.untyped)
  Long = ::T.let(nil, ::T.untyped)
  ManagedPrefixList = ::T.let(nil, ::T.untyped)
  ManagedPrefixListSet = ::T.let(nil, ::T.untyped)
  MarketType = ::T.let(nil, ::T.untyped)
  MaxIpv4AddrPerInterface = ::T.let(nil, ::T.untyped)
  MaxIpv6AddrPerInterface = ::T.let(nil, ::T.untyped)
  MaxNetworkInterfaces = ::T.let(nil, ::T.untyped)
  MaxResults = ::T.let(nil, ::T.untyped)
  MaximumBandwidthInMbps = ::T.let(nil, ::T.untyped)
  MaximumIops = ::T.let(nil, ::T.untyped)
  MaximumThroughputInMBps = ::T.let(nil, ::T.untyped)
  MembershipType = ::T.let(nil, ::T.untyped)
  MemoryInfo = ::T.let(nil, ::T.untyped)
  MemorySize = ::T.let(nil, ::T.untyped)
  MillisecondDateTime = ::T.let(nil, ::T.untyped)
  ModifyAvailabilityZoneGroupRequest = ::T.let(nil, ::T.untyped)
  ModifyAvailabilityZoneGroupResult = ::T.let(nil, ::T.untyped)
  ModifyAvailabilityZoneOptInStatus = ::T.let(nil, ::T.untyped)
  ModifyCapacityReservationRequest = ::T.let(nil, ::T.untyped)
  ModifyCapacityReservationResult = ::T.let(nil, ::T.untyped)
  ModifyClientVpnEndpointRequest = ::T.let(nil, ::T.untyped)
  ModifyClientVpnEndpointResult = ::T.let(nil, ::T.untyped)
  ModifyDefaultCreditSpecificationRequest = ::T.let(nil, ::T.untyped)
  ModifyDefaultCreditSpecificationResult = ::T.let(nil, ::T.untyped)
  ModifyEbsDefaultKmsKeyIdRequest = ::T.let(nil, ::T.untyped)
  ModifyEbsDefaultKmsKeyIdResult = ::T.let(nil, ::T.untyped)
  ModifyFleetRequest = ::T.let(nil, ::T.untyped)
  ModifyFleetResult = ::T.let(nil, ::T.untyped)
  ModifyFpgaImageAttributeRequest = ::T.let(nil, ::T.untyped)
  ModifyFpgaImageAttributeResult = ::T.let(nil, ::T.untyped)
  ModifyHostsRequest = ::T.let(nil, ::T.untyped)
  ModifyHostsResult = ::T.let(nil, ::T.untyped)
  ModifyIdFormatRequest = ::T.let(nil, ::T.untyped)
  ModifyIdentityIdFormatRequest = ::T.let(nil, ::T.untyped)
  ModifyImageAttributeRequest = ::T.let(nil, ::T.untyped)
  ModifyInstanceAttributeRequest = ::T.let(nil, ::T.untyped)
  ModifyInstanceCapacityReservationAttributesRequest = ::T.let(nil, ::T.untyped)
  ModifyInstanceCapacityReservationAttributesResult = ::T.let(nil, ::T.untyped)
  ModifyInstanceCreditSpecificationRequest = ::T.let(nil, ::T.untyped)
  ModifyInstanceCreditSpecificationResult = ::T.let(nil, ::T.untyped)
  ModifyInstanceEventStartTimeRequest = ::T.let(nil, ::T.untyped)
  ModifyInstanceEventStartTimeResult = ::T.let(nil, ::T.untyped)
  ModifyInstanceMetadataOptionsRequest = ::T.let(nil, ::T.untyped)
  ModifyInstanceMetadataOptionsResult = ::T.let(nil, ::T.untyped)
  ModifyInstancePlacementRequest = ::T.let(nil, ::T.untyped)
  ModifyInstancePlacementResult = ::T.let(nil, ::T.untyped)
  ModifyLaunchTemplateRequest = ::T.let(nil, ::T.untyped)
  ModifyLaunchTemplateResult = ::T.let(nil, ::T.untyped)
  ModifyManagedPrefixListRequest = ::T.let(nil, ::T.untyped)
  ModifyManagedPrefixListResult = ::T.let(nil, ::T.untyped)
  ModifyNetworkInterfaceAttributeRequest = ::T.let(nil, ::T.untyped)
  ModifyReservedInstancesRequest = ::T.let(nil, ::T.untyped)
  ModifyReservedInstancesResult = ::T.let(nil, ::T.untyped)
  ModifySnapshotAttributeRequest = ::T.let(nil, ::T.untyped)
  ModifySpotFleetRequestRequest = ::T.let(nil, ::T.untyped)
  ModifySpotFleetRequestResponse = ::T.let(nil, ::T.untyped)
  ModifySubnetAttributeRequest = ::T.let(nil, ::T.untyped)
  ModifyTrafficMirrorFilterNetworkServicesRequest = ::T.let(nil, ::T.untyped)
  ModifyTrafficMirrorFilterNetworkServicesResult = ::T.let(nil, ::T.untyped)
  ModifyTrafficMirrorFilterRuleRequest = ::T.let(nil, ::T.untyped)
  ModifyTrafficMirrorFilterRuleResult = ::T.let(nil, ::T.untyped)
  ModifyTrafficMirrorSessionRequest = ::T.let(nil, ::T.untyped)
  ModifyTrafficMirrorSessionResult = ::T.let(nil, ::T.untyped)
  ModifyTransitGatewayVpcAttachmentRequest = ::T.let(nil, ::T.untyped)
  ModifyTransitGatewayVpcAttachmentRequestOptions = ::T.let(nil, ::T.untyped)
  ModifyTransitGatewayVpcAttachmentResult = ::T.let(nil, ::T.untyped)
  ModifyVolumeAttributeRequest = ::T.let(nil, ::T.untyped)
  ModifyVolumeRequest = ::T.let(nil, ::T.untyped)
  ModifyVolumeResult = ::T.let(nil, ::T.untyped)
  ModifyVpcAttributeRequest = ::T.let(nil, ::T.untyped)
  ModifyVpcEndpointConnectionNotificationRequest = ::T.let(nil, ::T.untyped)
  ModifyVpcEndpointConnectionNotificationResult = ::T.let(nil, ::T.untyped)
  ModifyVpcEndpointRequest = ::T.let(nil, ::T.untyped)
  ModifyVpcEndpointResult = ::T.let(nil, ::T.untyped)
  ModifyVpcEndpointServiceConfigurationRequest = ::T.let(nil, ::T.untyped)
  ModifyVpcEndpointServiceConfigurationResult = ::T.let(nil, ::T.untyped)
  ModifyVpcEndpointServicePermissionsRequest = ::T.let(nil, ::T.untyped)
  ModifyVpcEndpointServicePermissionsResult = ::T.let(nil, ::T.untyped)
  ModifyVpcPeeringConnectionOptionsRequest = ::T.let(nil, ::T.untyped)
  ModifyVpcPeeringConnectionOptionsResult = ::T.let(nil, ::T.untyped)
  ModifyVpcTenancyRequest = ::T.let(nil, ::T.untyped)
  ModifyVpcTenancyResult = ::T.let(nil, ::T.untyped)
  ModifyVpnConnectionRequest = ::T.let(nil, ::T.untyped)
  ModifyVpnConnectionResult = ::T.let(nil, ::T.untyped)
  ModifyVpnTunnelCertificateRequest = ::T.let(nil, ::T.untyped)
  ModifyVpnTunnelCertificateResult = ::T.let(nil, ::T.untyped)
  ModifyVpnTunnelOptionsRequest = ::T.let(nil, ::T.untyped)
  ModifyVpnTunnelOptionsResult = ::T.let(nil, ::T.untyped)
  ModifyVpnTunnelOptionsSpecification = ::T.let(nil, ::T.untyped)
  MonitorInstancesRequest = ::T.let(nil, ::T.untyped)
  MonitorInstancesResult = ::T.let(nil, ::T.untyped)
  Monitoring = ::T.let(nil, ::T.untyped)
  MonitoringState = ::T.let(nil, ::T.untyped)
  MoveAddressToVpcRequest = ::T.let(nil, ::T.untyped)
  MoveAddressToVpcResult = ::T.let(nil, ::T.untyped)
  MoveStatus = ::T.let(nil, ::T.untyped)
  MovingAddressStatus = ::T.let(nil, ::T.untyped)
  MovingAddressStatusSet = ::T.let(nil, ::T.untyped)
  MulticastSupportValue = ::T.let(nil, ::T.untyped)
  NatGateway = ::T.let(nil, ::T.untyped)
  NatGatewayAddress = ::T.let(nil, ::T.untyped)
  NatGatewayAddressList = ::T.let(nil, ::T.untyped)
  NatGatewayId = ::T.let(nil, ::T.untyped)
  NatGatewayIdStringList = ::T.let(nil, ::T.untyped)
  NatGatewayList = ::T.let(nil, ::T.untyped)
  NatGatewayState = ::T.let(nil, ::T.untyped)
  NetworkAcl = ::T.let(nil, ::T.untyped)
  NetworkAclAssociation = ::T.let(nil, ::T.untyped)
  NetworkAclAssociationId = ::T.let(nil, ::T.untyped)
  NetworkAclAssociationList = ::T.let(nil, ::T.untyped)
  NetworkAclEntry = ::T.let(nil, ::T.untyped)
  NetworkAclEntryList = ::T.let(nil, ::T.untyped)
  NetworkAclId = ::T.let(nil, ::T.untyped)
  NetworkAclIdStringList = ::T.let(nil, ::T.untyped)
  NetworkAclList = ::T.let(nil, ::T.untyped)
  NetworkInfo = ::T.let(nil, ::T.untyped)
  NetworkInterface = ::T.let(nil, ::T.untyped)
  NetworkInterfaceAssociation = ::T.let(nil, ::T.untyped)
  NetworkInterfaceAttachment = ::T.let(nil, ::T.untyped)
  NetworkInterfaceAttachmentChanges = ::T.let(nil, ::T.untyped)
  NetworkInterfaceAttachmentId = ::T.let(nil, ::T.untyped)
  NetworkInterfaceAttribute = ::T.let(nil, ::T.untyped)
  NetworkInterfaceCreationType = ::T.let(nil, ::T.untyped)
  NetworkInterfaceId = ::T.let(nil, ::T.untyped)
  NetworkInterfaceIdList = ::T.let(nil, ::T.untyped)
  NetworkInterfaceIpv6Address = ::T.let(nil, ::T.untyped)
  NetworkInterfaceIpv6AddressesList = ::T.let(nil, ::T.untyped)
  NetworkInterfaceList = ::T.let(nil, ::T.untyped)
  NetworkInterfacePermission = ::T.let(nil, ::T.untyped)
  NetworkInterfacePermissionId = ::T.let(nil, ::T.untyped)
  NetworkInterfacePermissionIdList = ::T.let(nil, ::T.untyped)
  NetworkInterfacePermissionList = ::T.let(nil, ::T.untyped)
  NetworkInterfacePermissionState = ::T.let(nil, ::T.untyped)
  NetworkInterfacePermissionStateCode = ::T.let(nil, ::T.untyped)
  NetworkInterfacePrivateIpAddress = ::T.let(nil, ::T.untyped)
  NetworkInterfacePrivateIpAddressList = ::T.let(nil, ::T.untyped)
  NetworkInterfaceStatus = ::T.let(nil, ::T.untyped)
  NetworkInterfaceType = ::T.let(nil, ::T.untyped)
  NetworkPerformance = ::T.let(nil, ::T.untyped)
  NewDhcpConfiguration = ::T.let(nil, ::T.untyped)
  NewDhcpConfigurationList = ::T.let(nil, ::T.untyped)
  NextToken = ::T.let(nil, ::T.untyped)
  OccurrenceDayRequestSet = ::T.let(nil, ::T.untyped)
  OccurrenceDaySet = ::T.let(nil, ::T.untyped)
  OfferingClassType = ::T.let(nil, ::T.untyped)
  OfferingId = ::T.let(nil, ::T.untyped)
  OfferingTypeValues = ::T.let(nil, ::T.untyped)
  OnDemandAllocationStrategy = ::T.let(nil, ::T.untyped)
  OnDemandOptions = ::T.let(nil, ::T.untyped)
  OnDemandOptionsRequest = ::T.let(nil, ::T.untyped)
  OperationType = ::T.let(nil, ::T.untyped)
  OwnerStringList = ::T.let(nil, ::T.untyped)
  PaymentOption = ::T.let(nil, ::T.untyped)
  PciId = ::T.let(nil, ::T.untyped)
  PeeringAttachmentStatus = ::T.let(nil, ::T.untyped)
  PeeringConnectionOptions = ::T.let(nil, ::T.untyped)
  PeeringConnectionOptionsRequest = ::T.let(nil, ::T.untyped)
  PeeringTgwInfo = ::T.let(nil, ::T.untyped)
  PermissionGroup = ::T.let(nil, ::T.untyped)
  Phase1DHGroupNumbersList = ::T.let(nil, ::T.untyped)
  Phase1DHGroupNumbersListValue = ::T.let(nil, ::T.untyped)
  Phase1DHGroupNumbersRequestList = ::T.let(nil, ::T.untyped)
  Phase1DHGroupNumbersRequestListValue = ::T.let(nil, ::T.untyped)
  Phase1EncryptionAlgorithmsList = ::T.let(nil, ::T.untyped)
  Phase1EncryptionAlgorithmsListValue = ::T.let(nil, ::T.untyped)
  Phase1EncryptionAlgorithmsRequestList = ::T.let(nil, ::T.untyped)
  Phase1EncryptionAlgorithmsRequestListValue = ::T.let(nil, ::T.untyped)
  Phase1IntegrityAlgorithmsList = ::T.let(nil, ::T.untyped)
  Phase1IntegrityAlgorithmsListValue = ::T.let(nil, ::T.untyped)
  Phase1IntegrityAlgorithmsRequestList = ::T.let(nil, ::T.untyped)
  Phase1IntegrityAlgorithmsRequestListValue = ::T.let(nil, ::T.untyped)
  Phase2DHGroupNumbersList = ::T.let(nil, ::T.untyped)
  Phase2DHGroupNumbersListValue = ::T.let(nil, ::T.untyped)
  Phase2DHGroupNumbersRequestList = ::T.let(nil, ::T.untyped)
  Phase2DHGroupNumbersRequestListValue = ::T.let(nil, ::T.untyped)
  Phase2EncryptionAlgorithmsList = ::T.let(nil, ::T.untyped)
  Phase2EncryptionAlgorithmsListValue = ::T.let(nil, ::T.untyped)
  Phase2EncryptionAlgorithmsRequestList = ::T.let(nil, ::T.untyped)
  Phase2EncryptionAlgorithmsRequestListValue = ::T.let(nil, ::T.untyped)
  Phase2IntegrityAlgorithmsList = ::T.let(nil, ::T.untyped)
  Phase2IntegrityAlgorithmsListValue = ::T.let(nil, ::T.untyped)
  Phase2IntegrityAlgorithmsRequestList = ::T.let(nil, ::T.untyped)
  Phase2IntegrityAlgorithmsRequestListValue = ::T.let(nil, ::T.untyped)
  Placement = ::T.let(nil, ::T.untyped)
  PlacementGroup = ::T.let(nil, ::T.untyped)
  PlacementGroupId = ::T.let(nil, ::T.untyped)
  PlacementGroupIdStringList = ::T.let(nil, ::T.untyped)
  PlacementGroupInfo = ::T.let(nil, ::T.untyped)
  PlacementGroupList = ::T.let(nil, ::T.untyped)
  PlacementGroupName = ::T.let(nil, ::T.untyped)
  PlacementGroupState = ::T.let(nil, ::T.untyped)
  PlacementGroupStrategy = ::T.let(nil, ::T.untyped)
  PlacementGroupStrategyList = ::T.let(nil, ::T.untyped)
  PlacementGroupStringList = ::T.let(nil, ::T.untyped)
  PlacementResponse = ::T.let(nil, ::T.untyped)
  PlacementStrategy = ::T.let(nil, ::T.untyped)
  PlatformValues = ::T.let(nil, ::T.untyped)
  PoolCidrBlock = ::T.let(nil, ::T.untyped)
  PoolCidrBlocksSet = ::T.let(nil, ::T.untyped)
  PoolMaxResults = ::T.let(nil, ::T.untyped)
  PortRange = ::T.let(nil, ::T.untyped)
  PrefixList = ::T.let(nil, ::T.untyped)
  PrefixListAssociation = ::T.let(nil, ::T.untyped)
  PrefixListAssociationSet = ::T.let(nil, ::T.untyped)
  PrefixListEntry = ::T.let(nil, ::T.untyped)
  PrefixListEntrySet = ::T.let(nil, ::T.untyped)
  PrefixListId = ::T.let(nil, ::T.untyped)
  PrefixListIdList = ::T.let(nil, ::T.untyped)
  PrefixListIdSet = ::T.let(nil, ::T.untyped)
  PrefixListMaxResults = ::T.let(nil, ::T.untyped)
  PrefixListResourceId = ::T.let(nil, ::T.untyped)
  PrefixListResourceIdStringList = ::T.let(nil, ::T.untyped)
  PrefixListSet = ::T.let(nil, ::T.untyped)
  PrefixListState = ::T.let(nil, ::T.untyped)
  PriceSchedule = ::T.let(nil, ::T.untyped)
  PriceScheduleList = ::T.let(nil, ::T.untyped)
  PriceScheduleSpecification = ::T.let(nil, ::T.untyped)
  PriceScheduleSpecificationList = ::T.let(nil, ::T.untyped)
  PricingDetail = ::T.let(nil, ::T.untyped)
  PricingDetailsList = ::T.let(nil, ::T.untyped)
  PrincipalIdFormat = ::T.let(nil, ::T.untyped)
  PrincipalIdFormatList = ::T.let(nil, ::T.untyped)
  PrincipalType = ::T.let(nil, ::T.untyped)
  PrivateDnsNameConfiguration = ::T.let(nil, ::T.untyped)
  PrivateIpAddressConfigSet = ::T.let(nil, ::T.untyped)
  PrivateIpAddressSpecification = ::T.let(nil, ::T.untyped)
  PrivateIpAddressSpecificationList = ::T.let(nil, ::T.untyped)
  PrivateIpAddressStringList = ::T.let(nil, ::T.untyped)
  ProcessorInfo = ::T.let(nil, ::T.untyped)
  ProcessorSustainedClockSpeed = ::T.let(nil, ::T.untyped)
  ProductCode = ::T.let(nil, ::T.untyped)
  ProductCodeList = ::T.let(nil, ::T.untyped)
  ProductCodeStringList = ::T.let(nil, ::T.untyped)
  ProductCodeValues = ::T.let(nil, ::T.untyped)
  ProductDescriptionList = ::T.let(nil, ::T.untyped)
  PropagatingVgw = ::T.let(nil, ::T.untyped)
  PropagatingVgwList = ::T.let(nil, ::T.untyped)
  ProvisionByoipCidrRequest = ::T.let(nil, ::T.untyped)
  ProvisionByoipCidrResult = ::T.let(nil, ::T.untyped)
  ProvisionedBandwidth = ::T.let(nil, ::T.untyped)
  PublicIpStringList = ::T.let(nil, ::T.untyped)
  PublicIpv4Pool = ::T.let(nil, ::T.untyped)
  PublicIpv4PoolIdStringList = ::T.let(nil, ::T.untyped)
  PublicIpv4PoolRange = ::T.let(nil, ::T.untyped)
  PublicIpv4PoolRangeSet = ::T.let(nil, ::T.untyped)
  PublicIpv4PoolSet = ::T.let(nil, ::T.untyped)
  Purchase = ::T.let(nil, ::T.untyped)
  PurchaseHostReservationRequest = ::T.let(nil, ::T.untyped)
  PurchaseHostReservationResult = ::T.let(nil, ::T.untyped)
  PurchaseRequest = ::T.let(nil, ::T.untyped)
  PurchaseRequestSet = ::T.let(nil, ::T.untyped)
  PurchaseReservedInstancesOfferingRequest = ::T.let(nil, ::T.untyped)
  PurchaseReservedInstancesOfferingResult = ::T.let(nil, ::T.untyped)
  PurchaseScheduledInstancesRequest = ::T.let(nil, ::T.untyped)
  PurchaseScheduledInstancesResult = ::T.let(nil, ::T.untyped)
  PurchaseSet = ::T.let(nil, ::T.untyped)
  PurchasedScheduledInstanceSet = ::T.let(nil, ::T.untyped)
  RIProductDescription = ::T.let(nil, ::T.untyped)
  RamdiskId = ::T.let(nil, ::T.untyped)
  ReasonCodesList = ::T.let(nil, ::T.untyped)
  RebootInstancesRequest = ::T.let(nil, ::T.untyped)
  RecurringCharge = ::T.let(nil, ::T.untyped)
  RecurringChargeFrequency = ::T.let(nil, ::T.untyped)
  RecurringChargesList = ::T.let(nil, ::T.untyped)
  Region = ::T.let(nil, ::T.untyped)
  RegionList = ::T.let(nil, ::T.untyped)
  RegionNameStringList = ::T.let(nil, ::T.untyped)
  RegisterImageRequest = ::T.let(nil, ::T.untyped)
  RegisterImageResult = ::T.let(nil, ::T.untyped)
  RegisterInstanceEventNotificationAttributesRequest = ::T.let(nil, ::T.untyped)
  RegisterInstanceEventNotificationAttributesResult = ::T.let(nil, ::T.untyped)
  RegisterInstanceTagAttributeRequest = ::T.let(nil, ::T.untyped)
  RegisterTransitGatewayMulticastGroupMembersRequest = ::T.let(nil, ::T.untyped)
  RegisterTransitGatewayMulticastGroupMembersResult = ::T.let(nil, ::T.untyped)
  RegisterTransitGatewayMulticastGroupSourcesRequest = ::T.let(nil, ::T.untyped)
  RegisterTransitGatewayMulticastGroupSourcesResult = ::T.let(nil, ::T.untyped)
  RejectTransitGatewayPeeringAttachmentRequest = ::T.let(nil, ::T.untyped)
  RejectTransitGatewayPeeringAttachmentResult = ::T.let(nil, ::T.untyped)
  RejectTransitGatewayVpcAttachmentRequest = ::T.let(nil, ::T.untyped)
  RejectTransitGatewayVpcAttachmentResult = ::T.let(nil, ::T.untyped)
  RejectVpcEndpointConnectionsRequest = ::T.let(nil, ::T.untyped)
  RejectVpcEndpointConnectionsResult = ::T.let(nil, ::T.untyped)
  RejectVpcPeeringConnectionRequest = ::T.let(nil, ::T.untyped)
  RejectVpcPeeringConnectionResult = ::T.let(nil, ::T.untyped)
  ReleaseAddressRequest = ::T.let(nil, ::T.untyped)
  ReleaseHostsRequest = ::T.let(nil, ::T.untyped)
  ReleaseHostsResult = ::T.let(nil, ::T.untyped)
  RemovePrefixListEntries = ::T.let(nil, ::T.untyped)
  RemovePrefixListEntry = ::T.let(nil, ::T.untyped)
  ReplaceIamInstanceProfileAssociationRequest = ::T.let(nil, ::T.untyped)
  ReplaceIamInstanceProfileAssociationResult = ::T.let(nil, ::T.untyped)
  ReplaceNetworkAclAssociationRequest = ::T.let(nil, ::T.untyped)
  ReplaceNetworkAclAssociationResult = ::T.let(nil, ::T.untyped)
  ReplaceNetworkAclEntryRequest = ::T.let(nil, ::T.untyped)
  ReplaceRouteRequest = ::T.let(nil, ::T.untyped)
  ReplaceRouteTableAssociationRequest = ::T.let(nil, ::T.untyped)
  ReplaceRouteTableAssociationResult = ::T.let(nil, ::T.untyped)
  ReplaceTransitGatewayRouteRequest = ::T.let(nil, ::T.untyped)
  ReplaceTransitGatewayRouteResult = ::T.let(nil, ::T.untyped)
  ReportInstanceReasonCodes = ::T.let(nil, ::T.untyped)
  ReportInstanceStatusRequest = ::T.let(nil, ::T.untyped)
  ReportStatusType = ::T.let(nil, ::T.untyped)
  RequestHostIdList = ::T.let(nil, ::T.untyped)
  RequestHostIdSet = ::T.let(nil, ::T.untyped)
  RequestInstanceTypeList = ::T.let(nil, ::T.untyped)
  RequestLaunchTemplateData = ::T.let(nil, ::T.untyped)
  RequestSpotFleetRequest = ::T.let(nil, ::T.untyped)
  RequestSpotFleetResponse = ::T.let(nil, ::T.untyped)
  RequestSpotInstancesRequest = ::T.let(nil, ::T.untyped)
  RequestSpotInstancesResult = ::T.let(nil, ::T.untyped)
  RequestSpotLaunchSpecification = ::T.let(nil, ::T.untyped)
  RequestSpotLaunchSpecificationSecurityGroupIdList = ::T.let(nil, ::T.untyped)
  RequestSpotLaunchSpecificationSecurityGroupList = ::T.let(nil, ::T.untyped)
  Reservation = ::T.let(nil, ::T.untyped)
  ReservationId = ::T.let(nil, ::T.untyped)
  ReservationList = ::T.let(nil, ::T.untyped)
  ReservationState = ::T.let(nil, ::T.untyped)
  ReservationValue = ::T.let(nil, ::T.untyped)
  ReservedInstanceIdSet = ::T.let(nil, ::T.untyped)
  ReservedInstanceLimitPrice = ::T.let(nil, ::T.untyped)
  ReservedInstanceReservationValue = ::T.let(nil, ::T.untyped)
  ReservedInstanceReservationValueSet = ::T.let(nil, ::T.untyped)
  ReservedInstanceState = ::T.let(nil, ::T.untyped)
  ReservedInstances = ::T.let(nil, ::T.untyped)
  ReservedInstancesConfiguration = ::T.let(nil, ::T.untyped)
  ReservedInstancesConfigurationList = ::T.let(nil, ::T.untyped)
  ReservedInstancesId = ::T.let(nil, ::T.untyped)
  ReservedInstancesIdStringList = ::T.let(nil, ::T.untyped)
  ReservedInstancesList = ::T.let(nil, ::T.untyped)
  ReservedInstancesListing = ::T.let(nil, ::T.untyped)
  ReservedInstancesListingId = ::T.let(nil, ::T.untyped)
  ReservedInstancesListingList = ::T.let(nil, ::T.untyped)
  ReservedInstancesModification = ::T.let(nil, ::T.untyped)
  ReservedInstancesModificationId = ::T.let(nil, ::T.untyped)
  ReservedInstancesModificationIdStringList = ::T.let(nil, ::T.untyped)
  ReservedInstancesModificationList = ::T.let(nil, ::T.untyped)
  ReservedInstancesModificationResult = ::T.let(nil, ::T.untyped)
  ReservedInstancesModificationResultList = ::T.let(nil, ::T.untyped)
  ReservedInstancesOffering = ::T.let(nil, ::T.untyped)
  ReservedInstancesOfferingId = ::T.let(nil, ::T.untyped)
  ReservedInstancesOfferingIdStringList = ::T.let(nil, ::T.untyped)
  ReservedInstancesOfferingList = ::T.let(nil, ::T.untyped)
  ReservedIntancesIds = ::T.let(nil, ::T.untyped)
  ResetEbsDefaultKmsKeyIdRequest = ::T.let(nil, ::T.untyped)
  ResetEbsDefaultKmsKeyIdResult = ::T.let(nil, ::T.untyped)
  ResetFpgaImageAttributeName = ::T.let(nil, ::T.untyped)
  ResetFpgaImageAttributeRequest = ::T.let(nil, ::T.untyped)
  ResetFpgaImageAttributeResult = ::T.let(nil, ::T.untyped)
  ResetImageAttributeName = ::T.let(nil, ::T.untyped)
  ResetImageAttributeRequest = ::T.let(nil, ::T.untyped)
  ResetInstanceAttributeRequest = ::T.let(nil, ::T.untyped)
  ResetNetworkInterfaceAttributeRequest = ::T.let(nil, ::T.untyped)
  ResetSnapshotAttributeRequest = ::T.let(nil, ::T.untyped)
  ResourceArn = ::T.let(nil, ::T.untyped)
  ResourceIdList = ::T.let(nil, ::T.untyped)
  ResourceList = ::T.let(nil, ::T.untyped)
  ResourceType = ::T.let(nil, ::T.untyped)
  ResponseError = ::T.let(nil, ::T.untyped)
  ResponseHostIdList = ::T.let(nil, ::T.untyped)
  ResponseHostIdSet = ::T.let(nil, ::T.untyped)
  ResponseLaunchTemplateData = ::T.let(nil, ::T.untyped)
  RestorableByStringList = ::T.let(nil, ::T.untyped)
  RestoreAddressToClassicRequest = ::T.let(nil, ::T.untyped)
  RestoreAddressToClassicResult = ::T.let(nil, ::T.untyped)
  RestoreManagedPrefixListVersionRequest = ::T.let(nil, ::T.untyped)
  RestoreManagedPrefixListVersionResult = ::T.let(nil, ::T.untyped)
  RevokeClientVpnIngressRequest = ::T.let(nil, ::T.untyped)
  RevokeClientVpnIngressResult = ::T.let(nil, ::T.untyped)
  RevokeSecurityGroupEgressRequest = ::T.let(nil, ::T.untyped)
  RevokeSecurityGroupIngressRequest = ::T.let(nil, ::T.untyped)
  RootDeviceType = ::T.let(nil, ::T.untyped)
  RootDeviceTypeList = ::T.let(nil, ::T.untyped)
  Route = ::T.let(nil, ::T.untyped)
  RouteGatewayId = ::T.let(nil, ::T.untyped)
  RouteList = ::T.let(nil, ::T.untyped)
  RouteOrigin = ::T.let(nil, ::T.untyped)
  RouteState = ::T.let(nil, ::T.untyped)
  RouteTable = ::T.let(nil, ::T.untyped)
  RouteTableAssociation = ::T.let(nil, ::T.untyped)
  RouteTableAssociationId = ::T.let(nil, ::T.untyped)
  RouteTableAssociationList = ::T.let(nil, ::T.untyped)
  RouteTableAssociationState = ::T.let(nil, ::T.untyped)
  RouteTableAssociationStateCode = ::T.let(nil, ::T.untyped)
  RouteTableId = ::T.let(nil, ::T.untyped)
  RouteTableIdStringList = ::T.let(nil, ::T.untyped)
  RouteTableList = ::T.let(nil, ::T.untyped)
  RuleAction = ::T.let(nil, ::T.untyped)
  RunInstancesMonitoringEnabled = ::T.let(nil, ::T.untyped)
  RunInstancesRequest = ::T.let(nil, ::T.untyped)
  RunScheduledInstancesRequest = ::T.let(nil, ::T.untyped)
  RunScheduledInstancesResult = ::T.let(nil, ::T.untyped)
  S3Storage = ::T.let(nil, ::T.untyped)
  ScheduledInstance = ::T.let(nil, ::T.untyped)
  ScheduledInstanceAvailability = ::T.let(nil, ::T.untyped)
  ScheduledInstanceAvailabilitySet = ::T.let(nil, ::T.untyped)
  ScheduledInstanceId = ::T.let(nil, ::T.untyped)
  ScheduledInstanceIdRequestSet = ::T.let(nil, ::T.untyped)
  ScheduledInstanceRecurrence = ::T.let(nil, ::T.untyped)
  ScheduledInstanceRecurrenceRequest = ::T.let(nil, ::T.untyped)
  ScheduledInstanceSet = ::T.let(nil, ::T.untyped)
  ScheduledInstancesBlockDeviceMapping = ::T.let(nil, ::T.untyped)
  ScheduledInstancesBlockDeviceMappingSet = ::T.let(nil, ::T.untyped)
  ScheduledInstancesEbs = ::T.let(nil, ::T.untyped)
  ScheduledInstancesIamInstanceProfile = ::T.let(nil, ::T.untyped)
  ScheduledInstancesIpv6Address = ::T.let(nil, ::T.untyped)
  ScheduledInstancesIpv6AddressList = ::T.let(nil, ::T.untyped)
  ScheduledInstancesLaunchSpecification = ::T.let(nil, ::T.untyped)
  ScheduledInstancesMonitoring = ::T.let(nil, ::T.untyped)
  ScheduledInstancesNetworkInterface = ::T.let(nil, ::T.untyped)
  ScheduledInstancesNetworkInterfaceSet = ::T.let(nil, ::T.untyped)
  ScheduledInstancesPlacement = ::T.let(nil, ::T.untyped)
  ScheduledInstancesPrivateIpAddressConfig = ::T.let(nil, ::T.untyped)
  ScheduledInstancesSecurityGroupIdSet = ::T.let(nil, ::T.untyped)
  SearchLocalGatewayRoutesRequest = ::T.let(nil, ::T.untyped)
  SearchLocalGatewayRoutesResult = ::T.let(nil, ::T.untyped)
  SearchTransitGatewayMulticastGroupsRequest = ::T.let(nil, ::T.untyped)
  SearchTransitGatewayMulticastGroupsResult = ::T.let(nil, ::T.untyped)
  SearchTransitGatewayRoutesRequest = ::T.let(nil, ::T.untyped)
  SearchTransitGatewayRoutesResult = ::T.let(nil, ::T.untyped)
  SecurityGroup = ::T.let(nil, ::T.untyped)
  SecurityGroupId = ::T.let(nil, ::T.untyped)
  SecurityGroupIdStringList = ::T.let(nil, ::T.untyped)
  SecurityGroupIdentifier = ::T.let(nil, ::T.untyped)
  SecurityGroupList = ::T.let(nil, ::T.untyped)
  SecurityGroupName = ::T.let(nil, ::T.untyped)
  SecurityGroupReference = ::T.let(nil, ::T.untyped)
  SecurityGroupReferences = ::T.let(nil, ::T.untyped)
  SecurityGroupStringList = ::T.let(nil, ::T.untyped)
  SendDiagnosticInterruptRequest = ::T.let(nil, ::T.untyped)
  SensitiveUserData = ::T.let(nil, ::T.untyped)
  ServiceConfiguration = ::T.let(nil, ::T.untyped)
  ServiceConfigurationSet = ::T.let(nil, ::T.untyped)
  ServiceDetail = ::T.let(nil, ::T.untyped)
  ServiceDetailSet = ::T.let(nil, ::T.untyped)
  ServiceState = ::T.let(nil, ::T.untyped)
  ServiceType = ::T.let(nil, ::T.untyped)
  ServiceTypeDetail = ::T.let(nil, ::T.untyped)
  ServiceTypeDetailSet = ::T.let(nil, ::T.untyped)
  ShutdownBehavior = ::T.let(nil, ::T.untyped)
  SlotDateTimeRangeRequest = ::T.let(nil, ::T.untyped)
  SlotStartTimeRangeRequest = ::T.let(nil, ::T.untyped)
  Snapshot = ::T.let(nil, ::T.untyped)
  SnapshotAttributeName = ::T.let(nil, ::T.untyped)
  SnapshotDetail = ::T.let(nil, ::T.untyped)
  SnapshotDetailList = ::T.let(nil, ::T.untyped)
  SnapshotDiskContainer = ::T.let(nil, ::T.untyped)
  SnapshotId = ::T.let(nil, ::T.untyped)
  SnapshotIdStringList = ::T.let(nil, ::T.untyped)
  SnapshotInfo = ::T.let(nil, ::T.untyped)
  SnapshotList = ::T.let(nil, ::T.untyped)
  SnapshotSet = ::T.let(nil, ::T.untyped)
  SnapshotState = ::T.let(nil, ::T.untyped)
  SnapshotTaskDetail = ::T.let(nil, ::T.untyped)
  SpotAllocationStrategy = ::T.let(nil, ::T.untyped)
  SpotDatafeedSubscription = ::T.let(nil, ::T.untyped)
  SpotFleetLaunchSpecification = ::T.let(nil, ::T.untyped)
  SpotFleetMonitoring = ::T.let(nil, ::T.untyped)
  SpotFleetRequestConfig = ::T.let(nil, ::T.untyped)
  SpotFleetRequestConfigData = ::T.let(nil, ::T.untyped)
  SpotFleetRequestConfigSet = ::T.let(nil, ::T.untyped)
  SpotFleetRequestId = ::T.let(nil, ::T.untyped)
  SpotFleetRequestIdList = ::T.let(nil, ::T.untyped)
  SpotFleetTagSpecification = ::T.let(nil, ::T.untyped)
  SpotFleetTagSpecificationList = ::T.let(nil, ::T.untyped)
  SpotInstanceInterruptionBehavior = ::T.let(nil, ::T.untyped)
  SpotInstanceRequest = ::T.let(nil, ::T.untyped)
  SpotInstanceRequestId = ::T.let(nil, ::T.untyped)
  SpotInstanceRequestIdList = ::T.let(nil, ::T.untyped)
  SpotInstanceRequestList = ::T.let(nil, ::T.untyped)
  SpotInstanceState = ::T.let(nil, ::T.untyped)
  SpotInstanceStateFault = ::T.let(nil, ::T.untyped)
  SpotInstanceStatus = ::T.let(nil, ::T.untyped)
  SpotInstanceType = ::T.let(nil, ::T.untyped)
  SpotMarketOptions = ::T.let(nil, ::T.untyped)
  SpotOptions = ::T.let(nil, ::T.untyped)
  SpotOptionsRequest = ::T.let(nil, ::T.untyped)
  SpotPlacement = ::T.let(nil, ::T.untyped)
  SpotPrice = ::T.let(nil, ::T.untyped)
  SpotPriceHistoryList = ::T.let(nil, ::T.untyped)
  StaleIpPermission = ::T.let(nil, ::T.untyped)
  StaleIpPermissionSet = ::T.let(nil, ::T.untyped)
  StaleSecurityGroup = ::T.let(nil, ::T.untyped)
  StaleSecurityGroupSet = ::T.let(nil, ::T.untyped)
  StartInstancesRequest = ::T.let(nil, ::T.untyped)
  StartInstancesResult = ::T.let(nil, ::T.untyped)
  StartVpcEndpointServicePrivateDnsVerificationRequest = ::T.let(nil, ::T.untyped)
  StartVpcEndpointServicePrivateDnsVerificationResult = ::T.let(nil, ::T.untyped)
  State = ::T.let(nil, ::T.untyped)
  StateReason = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  StatusName = ::T.let(nil, ::T.untyped)
  StatusType = ::T.let(nil, ::T.untyped)
  StopInstancesRequest = ::T.let(nil, ::T.untyped)
  StopInstancesResult = ::T.let(nil, ::T.untyped)
  Storage = ::T.let(nil, ::T.untyped)
  StorageLocation = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Subnet = ::T.let(nil, ::T.untyped)
  SubnetAssociation = ::T.let(nil, ::T.untyped)
  SubnetAssociationList = ::T.let(nil, ::T.untyped)
  SubnetCidrAssociationId = ::T.let(nil, ::T.untyped)
  SubnetCidrBlockState = ::T.let(nil, ::T.untyped)
  SubnetCidrBlockStateCode = ::T.let(nil, ::T.untyped)
  SubnetId = ::T.let(nil, ::T.untyped)
  SubnetIdStringList = ::T.let(nil, ::T.untyped)
  SubnetIpv6CidrBlockAssociation = ::T.let(nil, ::T.untyped)
  SubnetIpv6CidrBlockAssociationSet = ::T.let(nil, ::T.untyped)
  SubnetList = ::T.let(nil, ::T.untyped)
  SubnetState = ::T.let(nil, ::T.untyped)
  SuccessfulInstanceCreditSpecificationItem = ::T.let(nil, ::T.untyped)
  SuccessfulInstanceCreditSpecificationSet = ::T.let(nil, ::T.untyped)
  SuccessfulQueuedPurchaseDeletion = ::T.let(nil, ::T.untyped)
  SuccessfulQueuedPurchaseDeletionSet = ::T.let(nil, ::T.untyped)
  SummaryStatus = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
  TagDescription = ::T.let(nil, ::T.untyped)
  TagDescriptionList = ::T.let(nil, ::T.untyped)
  TagList = ::T.let(nil, ::T.untyped)
  TagSpecification = ::T.let(nil, ::T.untyped)
  TagSpecificationList = ::T.let(nil, ::T.untyped)
  TaggableResourceId = ::T.let(nil, ::T.untyped)
  TargetCapacitySpecification = ::T.let(nil, ::T.untyped)
  TargetCapacitySpecificationRequest = ::T.let(nil, ::T.untyped)
  TargetConfiguration = ::T.let(nil, ::T.untyped)
  TargetConfigurationRequest = ::T.let(nil, ::T.untyped)
  TargetConfigurationRequestSet = ::T.let(nil, ::T.untyped)
  TargetGroup = ::T.let(nil, ::T.untyped)
  TargetGroups = ::T.let(nil, ::T.untyped)
  TargetGroupsConfig = ::T.let(nil, ::T.untyped)
  TargetNetwork = ::T.let(nil, ::T.untyped)
  TargetNetworkSet = ::T.let(nil, ::T.untyped)
  TargetReservationValue = ::T.let(nil, ::T.untyped)
  TargetReservationValueSet = ::T.let(nil, ::T.untyped)
  TelemetryStatus = ::T.let(nil, ::T.untyped)
  Tenancy = ::T.let(nil, ::T.untyped)
  TerminateClientVpnConnectionsRequest = ::T.let(nil, ::T.untyped)
  TerminateClientVpnConnectionsResult = ::T.let(nil, ::T.untyped)
  TerminateConnectionStatus = ::T.let(nil, ::T.untyped)
  TerminateConnectionStatusSet = ::T.let(nil, ::T.untyped)
  TerminateInstancesRequest = ::T.let(nil, ::T.untyped)
  TerminateInstancesResult = ::T.let(nil, ::T.untyped)
  ThreadsPerCore = ::T.let(nil, ::T.untyped)
  ThreadsPerCoreList = ::T.let(nil, ::T.untyped)
  TrafficDirection = ::T.let(nil, ::T.untyped)
  TrafficMirrorFilter = ::T.let(nil, ::T.untyped)
  TrafficMirrorFilterId = ::T.let(nil, ::T.untyped)
  TrafficMirrorFilterIdList = ::T.let(nil, ::T.untyped)
  TrafficMirrorFilterRule = ::T.let(nil, ::T.untyped)
  TrafficMirrorFilterRuleField = ::T.let(nil, ::T.untyped)
  TrafficMirrorFilterRuleFieldList = ::T.let(nil, ::T.untyped)
  TrafficMirrorFilterRuleId = ::T.let(nil, ::T.untyped)
  TrafficMirrorFilterRuleList = ::T.let(nil, ::T.untyped)
  TrafficMirrorFilterSet = ::T.let(nil, ::T.untyped)
  TrafficMirrorNetworkService = ::T.let(nil, ::T.untyped)
  TrafficMirrorNetworkServiceList = ::T.let(nil, ::T.untyped)
  TrafficMirrorPortRange = ::T.let(nil, ::T.untyped)
  TrafficMirrorPortRangeRequest = ::T.let(nil, ::T.untyped)
  TrafficMirrorRuleAction = ::T.let(nil, ::T.untyped)
  TrafficMirrorSession = ::T.let(nil, ::T.untyped)
  TrafficMirrorSessionField = ::T.let(nil, ::T.untyped)
  TrafficMirrorSessionFieldList = ::T.let(nil, ::T.untyped)
  TrafficMirrorSessionId = ::T.let(nil, ::T.untyped)
  TrafficMirrorSessionIdList = ::T.let(nil, ::T.untyped)
  TrafficMirrorSessionSet = ::T.let(nil, ::T.untyped)
  TrafficMirrorTarget = ::T.let(nil, ::T.untyped)
  TrafficMirrorTargetId = ::T.let(nil, ::T.untyped)
  TrafficMirrorTargetIdList = ::T.let(nil, ::T.untyped)
  TrafficMirrorTargetSet = ::T.let(nil, ::T.untyped)
  TrafficMirrorTargetType = ::T.let(nil, ::T.untyped)
  TrafficMirroringMaxResults = ::T.let(nil, ::T.untyped)
  TrafficType = ::T.let(nil, ::T.untyped)
  TransitAssociationGatewayId = ::T.let(nil, ::T.untyped)
  TransitGateway = ::T.let(nil, ::T.untyped)
  TransitGatewayAssociation = ::T.let(nil, ::T.untyped)
  TransitGatewayAssociationState = ::T.let(nil, ::T.untyped)
  TransitGatewayAttachment = ::T.let(nil, ::T.untyped)
  TransitGatewayAttachmentAssociation = ::T.let(nil, ::T.untyped)
  TransitGatewayAttachmentId = ::T.let(nil, ::T.untyped)
  TransitGatewayAttachmentIdStringList = ::T.let(nil, ::T.untyped)
  TransitGatewayAttachmentList = ::T.let(nil, ::T.untyped)
  TransitGatewayAttachmentPropagation = ::T.let(nil, ::T.untyped)
  TransitGatewayAttachmentPropagationList = ::T.let(nil, ::T.untyped)
  TransitGatewayAttachmentResourceType = ::T.let(nil, ::T.untyped)
  TransitGatewayAttachmentState = ::T.let(nil, ::T.untyped)
  TransitGatewayId = ::T.let(nil, ::T.untyped)
  TransitGatewayIdStringList = ::T.let(nil, ::T.untyped)
  TransitGatewayList = ::T.let(nil, ::T.untyped)
  TransitGatewayMaxResults = ::T.let(nil, ::T.untyped)
  TransitGatewayMulitcastDomainAssociationState = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastDeregisteredGroupMembers = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastDeregisteredGroupSources = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastDomain = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastDomainAssociation = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastDomainAssociationList = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastDomainAssociations = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastDomainId = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastDomainIdStringList = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastDomainList = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastDomainState = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastGroup = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastGroupList = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastRegisteredGroupMembers = ::T.let(nil, ::T.untyped)
  TransitGatewayMulticastRegisteredGroupSources = ::T.let(nil, ::T.untyped)
  TransitGatewayNetworkInterfaceIdList = ::T.let(nil, ::T.untyped)
  TransitGatewayOptions = ::T.let(nil, ::T.untyped)
  TransitGatewayPeeringAttachment = ::T.let(nil, ::T.untyped)
  TransitGatewayPeeringAttachmentList = ::T.let(nil, ::T.untyped)
  TransitGatewayPropagation = ::T.let(nil, ::T.untyped)
  TransitGatewayPropagationState = ::T.let(nil, ::T.untyped)
  TransitGatewayRequestOptions = ::T.let(nil, ::T.untyped)
  TransitGatewayRoute = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteAttachment = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteAttachmentList = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteList = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteState = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteTable = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteTableAssociation = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteTableAssociationList = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteTableId = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteTableIdStringList = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteTableList = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteTablePropagation = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteTablePropagationList = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteTableState = ::T.let(nil, ::T.untyped)
  TransitGatewayRouteType = ::T.let(nil, ::T.untyped)
  TransitGatewayState = ::T.let(nil, ::T.untyped)
  TransitGatewaySubnetIdList = ::T.let(nil, ::T.untyped)
  TransitGatewayVpcAttachment = ::T.let(nil, ::T.untyped)
  TransitGatewayVpcAttachmentList = ::T.let(nil, ::T.untyped)
  TransitGatewayVpcAttachmentOptions = ::T.let(nil, ::T.untyped)
  TransportProtocol = ::T.let(nil, ::T.untyped)
  TunnelOption = ::T.let(nil, ::T.untyped)
  TunnelOptionsList = ::T.let(nil, ::T.untyped)
  UnassignIpv6AddressesRequest = ::T.let(nil, ::T.untyped)
  UnassignIpv6AddressesResult = ::T.let(nil, ::T.untyped)
  UnassignPrivateIpAddressesRequest = ::T.let(nil, ::T.untyped)
  UnlimitedSupportedInstanceFamily = ::T.let(nil, ::T.untyped)
  UnmonitorInstancesRequest = ::T.let(nil, ::T.untyped)
  UnmonitorInstancesResult = ::T.let(nil, ::T.untyped)
  UnsuccessfulInstanceCreditSpecificationErrorCode = ::T.let(nil, ::T.untyped)
  UnsuccessfulInstanceCreditSpecificationItem = ::T.let(nil, ::T.untyped)
  UnsuccessfulInstanceCreditSpecificationItemError = ::T.let(nil, ::T.untyped)
  UnsuccessfulInstanceCreditSpecificationSet = ::T.let(nil, ::T.untyped)
  UnsuccessfulItem = ::T.let(nil, ::T.untyped)
  UnsuccessfulItemError = ::T.let(nil, ::T.untyped)
  UnsuccessfulItemList = ::T.let(nil, ::T.untyped)
  UnsuccessfulItemSet = ::T.let(nil, ::T.untyped)
  UpdateSecurityGroupRuleDescriptionsEgressRequest = ::T.let(nil, ::T.untyped)
  UpdateSecurityGroupRuleDescriptionsEgressResult = ::T.let(nil, ::T.untyped)
  UpdateSecurityGroupRuleDescriptionsIngressRequest = ::T.let(nil, ::T.untyped)
  UpdateSecurityGroupRuleDescriptionsIngressResult = ::T.let(nil, ::T.untyped)
  UsageClassType = ::T.let(nil, ::T.untyped)
  UsageClassTypeList = ::T.let(nil, ::T.untyped)
  UserBucket = ::T.let(nil, ::T.untyped)
  UserBucketDetails = ::T.let(nil, ::T.untyped)
  UserData = ::T.let(nil, ::T.untyped)
  UserGroupStringList = ::T.let(nil, ::T.untyped)
  UserIdGroupPair = ::T.let(nil, ::T.untyped)
  UserIdGroupPairList = ::T.let(nil, ::T.untyped)
  UserIdGroupPairSet = ::T.let(nil, ::T.untyped)
  UserIdStringList = ::T.let(nil, ::T.untyped)
  VCpuCount = ::T.let(nil, ::T.untyped)
  VCpuInfo = ::T.let(nil, ::T.untyped)
  ValidationError = ::T.let(nil, ::T.untyped)
  ValidationWarning = ::T.let(nil, ::T.untyped)
  ValueStringList = ::T.let(nil, ::T.untyped)
  VersionDescription = ::T.let(nil, ::T.untyped)
  VersionStringList = ::T.let(nil, ::T.untyped)
  VgwTelemetry = ::T.let(nil, ::T.untyped)
  VgwTelemetryList = ::T.let(nil, ::T.untyped)
  VirtualizationType = ::T.let(nil, ::T.untyped)
  VirtualizationTypeList = ::T.let(nil, ::T.untyped)
  Volume = ::T.let(nil, ::T.untyped)
  VolumeAttachment = ::T.let(nil, ::T.untyped)
  VolumeAttachmentList = ::T.let(nil, ::T.untyped)
  VolumeAttachmentState = ::T.let(nil, ::T.untyped)
  VolumeAttributeName = ::T.let(nil, ::T.untyped)
  VolumeDetail = ::T.let(nil, ::T.untyped)
  VolumeId = ::T.let(nil, ::T.untyped)
  VolumeIdStringList = ::T.let(nil, ::T.untyped)
  VolumeList = ::T.let(nil, ::T.untyped)
  VolumeModification = ::T.let(nil, ::T.untyped)
  VolumeModificationList = ::T.let(nil, ::T.untyped)
  VolumeModificationState = ::T.let(nil, ::T.untyped)
  VolumeState = ::T.let(nil, ::T.untyped)
  VolumeStatusAction = ::T.let(nil, ::T.untyped)
  VolumeStatusActionsList = ::T.let(nil, ::T.untyped)
  VolumeStatusAttachmentStatus = ::T.let(nil, ::T.untyped)
  VolumeStatusAttachmentStatusList = ::T.let(nil, ::T.untyped)
  VolumeStatusDetails = ::T.let(nil, ::T.untyped)
  VolumeStatusDetailsList = ::T.let(nil, ::T.untyped)
  VolumeStatusEvent = ::T.let(nil, ::T.untyped)
  VolumeStatusEventsList = ::T.let(nil, ::T.untyped)
  VolumeStatusInfo = ::T.let(nil, ::T.untyped)
  VolumeStatusInfoStatus = ::T.let(nil, ::T.untyped)
  VolumeStatusItem = ::T.let(nil, ::T.untyped)
  VolumeStatusList = ::T.let(nil, ::T.untyped)
  VolumeStatusName = ::T.let(nil, ::T.untyped)
  VolumeType = ::T.let(nil, ::T.untyped)
  Vpc = ::T.let(nil, ::T.untyped)
  VpcAttachment = ::T.let(nil, ::T.untyped)
  VpcAttachmentList = ::T.let(nil, ::T.untyped)
  VpcAttributeName = ::T.let(nil, ::T.untyped)
  VpcCidrAssociationId = ::T.let(nil, ::T.untyped)
  VpcCidrBlockAssociation = ::T.let(nil, ::T.untyped)
  VpcCidrBlockAssociationSet = ::T.let(nil, ::T.untyped)
  VpcCidrBlockState = ::T.let(nil, ::T.untyped)
  VpcCidrBlockStateCode = ::T.let(nil, ::T.untyped)
  VpcClassicLink = ::T.let(nil, ::T.untyped)
  VpcClassicLinkIdList = ::T.let(nil, ::T.untyped)
  VpcClassicLinkList = ::T.let(nil, ::T.untyped)
  VpcEndpoint = ::T.let(nil, ::T.untyped)
  VpcEndpointConnection = ::T.let(nil, ::T.untyped)
  VpcEndpointConnectionSet = ::T.let(nil, ::T.untyped)
  VpcEndpointId = ::T.let(nil, ::T.untyped)
  VpcEndpointIdList = ::T.let(nil, ::T.untyped)
  VpcEndpointRouteTableIdList = ::T.let(nil, ::T.untyped)
  VpcEndpointSecurityGroupIdList = ::T.let(nil, ::T.untyped)
  VpcEndpointServiceId = ::T.let(nil, ::T.untyped)
  VpcEndpointServiceIdList = ::T.let(nil, ::T.untyped)
  VpcEndpointSet = ::T.let(nil, ::T.untyped)
  VpcEndpointSubnetIdList = ::T.let(nil, ::T.untyped)
  VpcEndpointType = ::T.let(nil, ::T.untyped)
  VpcFlowLogId = ::T.let(nil, ::T.untyped)
  VpcId = ::T.let(nil, ::T.untyped)
  VpcIdStringList = ::T.let(nil, ::T.untyped)
  VpcIpv6CidrBlockAssociation = ::T.let(nil, ::T.untyped)
  VpcIpv6CidrBlockAssociationSet = ::T.let(nil, ::T.untyped)
  VpcList = ::T.let(nil, ::T.untyped)
  VpcPeeringConnection = ::T.let(nil, ::T.untyped)
  VpcPeeringConnectionId = ::T.let(nil, ::T.untyped)
  VpcPeeringConnectionIdList = ::T.let(nil, ::T.untyped)
  VpcPeeringConnectionList = ::T.let(nil, ::T.untyped)
  VpcPeeringConnectionOptionsDescription = ::T.let(nil, ::T.untyped)
  VpcPeeringConnectionStateReason = ::T.let(nil, ::T.untyped)
  VpcPeeringConnectionStateReasonCode = ::T.let(nil, ::T.untyped)
  VpcPeeringConnectionVpcInfo = ::T.let(nil, ::T.untyped)
  VpcState = ::T.let(nil, ::T.untyped)
  VpcTenancy = ::T.let(nil, ::T.untyped)
  VpnConnection = ::T.let(nil, ::T.untyped)
  VpnConnectionId = ::T.let(nil, ::T.untyped)
  VpnConnectionIdStringList = ::T.let(nil, ::T.untyped)
  VpnConnectionList = ::T.let(nil, ::T.untyped)
  VpnConnectionOptions = ::T.let(nil, ::T.untyped)
  VpnConnectionOptionsSpecification = ::T.let(nil, ::T.untyped)
  VpnEcmpSupportValue = ::T.let(nil, ::T.untyped)
  VpnGateway = ::T.let(nil, ::T.untyped)
  VpnGatewayId = ::T.let(nil, ::T.untyped)
  VpnGatewayIdStringList = ::T.let(nil, ::T.untyped)
  VpnGatewayList = ::T.let(nil, ::T.untyped)
  VpnProtocol = ::T.let(nil, ::T.untyped)
  VpnState = ::T.let(nil, ::T.untyped)
  VpnStaticRoute = ::T.let(nil, ::T.untyped)
  VpnStaticRouteList = ::T.let(nil, ::T.untyped)
  VpnStaticRouteSource = ::T.let(nil, ::T.untyped)
  VpnTunnelOptionsSpecification = ::T.let(nil, ::T.untyped)
  VpnTunnelOptionsSpecificationsList = ::T.let(nil, ::T.untyped)
  WithdrawByoipCidrRequest = ::T.let(nil, ::T.untyped)
  WithdrawByoipCidrResult = ::T.let(nil, ::T.untyped)
  ZoneIdStringList = ::T.let(nil, ::T.untyped)
  ZoneNameStringList = ::T.let(nil, ::T.untyped)
end

module Aws::EC2::ClientApi
end

class Aws::EC2::DhcpOptions
  def associate_with_vpc(options=T.unsafe(nil)); end

  def client(); end

  def create_tags(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def dhcp_configurations(); end

  def dhcp_options_id(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def owner_id(); end

  def reload(); end

  def tags(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::DhcpOptions::Collection
end

class Aws::EC2::DhcpOptions::Collection
end

class Aws::EC2::DhcpOptions
  extend ::Aws::Deprecations
end

module Aws::EC2::Errors
end

class Aws::EC2::Errors::ServiceError
end

class Aws::EC2::Errors::ServiceError
end

module Aws::EC2::Errors
  extend ::Aws::Errors::DynamicErrors
end

class Aws::EC2::Image
  def architecture(); end

  def block_device_mappings(); end

  def client(); end

  def create_tags(options=T.unsafe(nil)); end

  def creation_date(); end

  def data(); end

  def data_loaded?(); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def deregister(options=T.unsafe(nil)); end

  def describe_attribute(options=T.unsafe(nil)); end

  def description(); end

  def ena_support(); end

  def exists?(options=T.unsafe(nil)); end

  def hypervisor(); end

  def id(); end

  def identifiers(*args, &block); end

  def image_id(); end

  def image_location(); end

  def image_owner_alias(); end

  def image_type(); end

  def initialize(*args); end

  def kernel_id(); end

  def load(); end

  def modify_attribute(options=T.unsafe(nil)); end

  def name(); end

  def owner_id(); end

  def platform(); end

  def platform_details(); end

  def product_codes(); end

  def public(); end

  def ramdisk_id(); end

  def reload(); end

  def reset_attribute(options=T.unsafe(nil)); end

  def root_device_name(); end

  def root_device_type(); end

  def sriov_net_support(); end

  def state(); end

  def state_reason(); end

  def tags(); end

  def usage_operation(); end

  def virtualization_type(); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_exists(options=T.unsafe(nil), &block); end
end

class Aws::EC2::Image::Collection
end

class Aws::EC2::Image::Collection
end

class Aws::EC2::Image
  extend ::Aws::Deprecations
end

class Aws::EC2::Instance
  def ami_launch_index(); end

  def architecture(); end

  def attach_classic_link_vpc(options=T.unsafe(nil)); end

  def attach_volume(options=T.unsafe(nil)); end

  def block_device_mappings(); end

  def capacity_reservation_id(); end

  def capacity_reservation_specification(); end

  def classic_address(); end

  def client(); end

  def client_token(); end

  def console_output(options=T.unsafe(nil)); end

  def cpu_options(); end

  def create_image(options=T.unsafe(nil)); end

  def create_tags(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def decrypt_windows_password(key_pair_path); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def describe_attribute(options=T.unsafe(nil)); end

  def detach_classic_link_vpc(options=T.unsafe(nil)); end

  def detach_volume(options=T.unsafe(nil)); end

  def ebs_optimized(); end

  def elastic_gpu_associations(); end

  def elastic_inference_accelerator_associations(); end

  def ena_support(); end

  def exists?(options=T.unsafe(nil)); end

  def hibernation_options(); end

  def hypervisor(); end

  def iam_instance_profile(); end

  def id(); end

  def identifiers(*args, &block); end

  def image(); end

  def image_id(); end

  def initialize(*args); end

  def instance_id(); end

  def instance_lifecycle(); end

  def instance_type(); end

  def kernel_id(); end

  def key_name(); end

  def key_pair(); end

  def launch_time(); end

  def licenses(); end

  def load(); end

  def metadata_options(); end

  def modify_attribute(options=T.unsafe(nil)); end

  def monitor(options=T.unsafe(nil)); end

  def monitoring(); end

  def network_interfaces(); end

  def outpost_arn(); end

  def password_data(options=T.unsafe(nil)); end

  def placement(); end

  def placement_group(); end

  def platform(); end

  def private_dns_name(); end

  def private_ip_address(); end

  def product_codes(); end

  def public_dns_name(); end

  def public_ip_address(); end

  def ramdisk_id(); end

  def reboot(options=T.unsafe(nil)); end

  def reload(); end

  def report_status(options=T.unsafe(nil)); end

  def reset_attribute(options=T.unsafe(nil)); end

  def reset_kernel(options=T.unsafe(nil)); end

  def reset_ramdisk(options=T.unsafe(nil)); end

  def reset_source_dest_check(options=T.unsafe(nil)); end

  def root_device_name(); end

  def root_device_type(); end

  def security_groups(); end

  def source_dest_check(); end

  def spot_instance_request_id(); end

  def sriov_net_support(); end

  def start(options=T.unsafe(nil)); end

  def state(); end

  def state_reason(); end

  def state_transition_reason(); end

  def stop(options=T.unsafe(nil)); end

  def subnet(); end

  def subnet_id(); end

  def tags(); end

  def terminate(options=T.unsafe(nil)); end

  def unmonitor(options=T.unsafe(nil)); end

  def virtualization_type(); end

  def volumes(options=T.unsafe(nil)); end

  def vpc(); end

  def vpc_addresses(options=T.unsafe(nil)); end

  def vpc_id(); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_exists(options=T.unsafe(nil), &block); end

  def wait_until_running(options=T.unsafe(nil), &block); end

  def wait_until_stopped(options=T.unsafe(nil), &block); end

  def wait_until_terminated(options=T.unsafe(nil), &block); end
end

class Aws::EC2::Instance::Collection
  def batch_create_tags(options=T.unsafe(nil)); end

  def batch_delete_tags!(options=T.unsafe(nil)); end

  def batch_monitor(options=T.unsafe(nil)); end

  def batch_reboot(options=T.unsafe(nil)); end

  def batch_start(options=T.unsafe(nil)); end

  def batch_stop(options=T.unsafe(nil)); end

  def batch_terminate!(options=T.unsafe(nil)); end

  def batch_unmonitor(options=T.unsafe(nil)); end

  def create_tags(*args, &block); end

  def deprecated_create_tags(options=T.unsafe(nil)); end

  def deprecated_monitor(options=T.unsafe(nil)); end

  def deprecated_reboot(options=T.unsafe(nil)); end

  def deprecated_start(options=T.unsafe(nil)); end

  def deprecated_stop(options=T.unsafe(nil)); end

  def deprecated_terminate(options=T.unsafe(nil)); end

  def deprecated_unmonitor(options=T.unsafe(nil)); end

  def monitor(*args, &block); end

  def reboot(*args, &block); end

  def start(*args, &block); end

  def stop(*args, &block); end

  def terminate(*args, &block); end

  def unmonitor(*args, &block); end
end

class Aws::EC2::Instance::Collection
end

class Aws::EC2::Instance
  extend ::Aws::Deprecations
end

class Aws::EC2::InternetGateway
  def attach_to_vpc(options=T.unsafe(nil)); end

  def attachments(); end

  def client(); end

  def create_tags(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def detach_from_vpc(options=T.unsafe(nil)); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def internet_gateway_id(); end

  def load(); end

  def owner_id(); end

  def reload(); end

  def tags(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::InternetGateway::Collection
end

class Aws::EC2::InternetGateway::Collection
end

class Aws::EC2::InternetGateway
  extend ::Aws::Deprecations
end

class Aws::EC2::KeyPair
  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def key_fingerprint(); end

  def key_material(); end

  def key_name(); end

  def key_pair_id(); end

  def load(); end

  def name(); end

  def reload(); end

  def tags(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::KeyPair::Collection
end

class Aws::EC2::KeyPair::Collection
end

class Aws::EC2::KeyPair
  extend ::Aws::Deprecations
end

class Aws::EC2::KeyPairInfo
  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def key_fingerprint(); end

  def key_name(); end

  def key_pair_id(); end

  def load(); end

  def name(); end

  def reload(); end

  def tags(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::KeyPairInfo::Collection
end

class Aws::EC2::KeyPairInfo::Collection
end

class Aws::EC2::KeyPairInfo
  extend ::Aws::Deprecations
end

class Aws::EC2::NatGateway
  def address(); end

  def client(); end

  def create_tags(options=T.unsafe(nil)); end

  def create_time(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def delete_time(); end

  def deprecated_identifiers(); end

  def failure_code(); end

  def failure_message(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def nat_gateway_addresses(); end

  def nat_gateway_id(); end

  def provisioned_bandwidth(); end

  def reload(); end

  def state(); end

  def subnet(); end

  def subnet_id(); end

  def tags(); end

  def vpc_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::NatGateway::Collection
end

class Aws::EC2::NatGateway::Collection
end

class Aws::EC2::NatGateway
  extend ::Aws::Deprecations
end

class Aws::EC2::NetworkAcl
  def associations(); end

  def client(); end

  def create_entry(options=T.unsafe(nil)); end

  def create_tags(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_entry(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def entries(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def is_default(); end

  def load(); end

  def network_acl_id(); end

  def owner_id(); end

  def reload(); end

  def replace_association(options=T.unsafe(nil)); end

  def replace_entry(options=T.unsafe(nil)); end

  def tags(); end

  def vpc(); end

  def vpc_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::NetworkAcl::Collection
end

class Aws::EC2::NetworkAcl::Collection
end

class Aws::EC2::NetworkAcl
  extend ::Aws::Deprecations
end

class Aws::EC2::NetworkInterface
  def assign_private_ip_addresses(options=T.unsafe(nil)); end

  def association(); end

  def attach(options=T.unsafe(nil)); end

  def attachment(); end

  def availability_zone(); end

  def client(); end

  def create_tags(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def describe_attribute(options=T.unsafe(nil)); end

  def description(); end

  def detach(options=T.unsafe(nil)); end

  def groups(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def interface_type(); end

  def ipv_6_addresses(); end

  def load(); end

  def mac_address(); end

  def modify_attribute(options=T.unsafe(nil)); end

  def network_interface_id(); end

  def outpost_arn(); end

  def owner_id(); end

  def private_dns_name(); end

  def private_ip_address(); end

  def private_ip_addresses(); end

  def reload(); end

  def requester_id(); end

  def requester_managed(); end

  def reset_attribute(options=T.unsafe(nil)); end

  def source_dest_check(); end

  def status(); end

  def subnet(); end

  def subnet_id(); end

  def tag_set(); end

  def unassign_private_ip_addresses(options=T.unsafe(nil)); end

  def vpc(); end

  def vpc_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::NetworkInterface::Collection
end

class Aws::EC2::NetworkInterface::Collection
end

class Aws::EC2::NetworkInterface
  extend ::Aws::Deprecations
end

class Aws::EC2::NetworkInterfaceAssociation
  def address(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def ip_owner_id(); end

  def load(); end

  def public_dns_name(); end

  def public_ip(); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::NetworkInterfaceAssociation::Collection
end

class Aws::EC2::NetworkInterfaceAssociation::Collection
end

class Aws::EC2::NetworkInterfaceAssociation
  extend ::Aws::Deprecations
end

class Aws::EC2::PlacementGroup
  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def group_id(); end

  def group_name(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def instances(options=T.unsafe(nil)); end

  def load(); end

  def name(); end

  def partition_count(); end

  def reload(); end

  def state(); end

  def strategy(); end

  def tags(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::PlacementGroup::Collection
end

class Aws::EC2::PlacementGroup::Collection
end

class Aws::EC2::PlacementGroup
  extend ::Aws::Deprecations
end

module Aws::EC2::Plugins
end

class Aws::EC2::Plugins::CopyEncryptedSnapshot
end

class Aws::EC2::Plugins::CopyEncryptedSnapshot::Handler
end

class Aws::EC2::Plugins::CopyEncryptedSnapshot::Handler
end

class Aws::EC2::Plugins::CopyEncryptedSnapshot
end

class Aws::EC2::Plugins::RegionValidation
end

class Aws::EC2::Plugins::RegionValidation
end

module Aws::EC2::Plugins
end

class Aws::EC2::Resource
  def classic_addresses(options=T.unsafe(nil)); end

  def client(); end

  def create_dhcp_options(options=T.unsafe(nil)); end

  def create_instances(options=T.unsafe(nil)); end

  def create_internet_gateway(options=T.unsafe(nil)); end

  def create_key_pair(options=T.unsafe(nil)); end

  def create_nat_gateway(options=T.unsafe(nil)); end

  def create_network_acl(options=T.unsafe(nil)); end

  def create_network_interface(options=T.unsafe(nil)); end

  def create_placement_group(options=T.unsafe(nil)); end

  def create_route_table(options=T.unsafe(nil)); end

  def create_security_group(options=T.unsafe(nil)); end

  def create_snapshot(options=T.unsafe(nil)); end

  def create_subnet(options=T.unsafe(nil)); end

  def create_tags(options); end

  def create_volume(options=T.unsafe(nil)); end

  def create_vpc(options=T.unsafe(nil)); end

  def create_vpc_peering_connection(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def dhcp_options(id); end

  def dhcp_options_sets(options=T.unsafe(nil)); end

  def disassociate_route_table(options=T.unsafe(nil)); end

  def image(id); end

  def images(options=T.unsafe(nil)); end

  def import_key_pair(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def instance(id); end

  def instances(options=T.unsafe(nil)); end

  def internet_gateway(id); end

  def internet_gateways(options=T.unsafe(nil)); end

  def key_pair(name); end

  def key_pairs(options=T.unsafe(nil)); end

  def nat_gateway(id); end

  def nat_gateways(options=T.unsafe(nil)); end

  def network_acl(id); end

  def network_acls(options=T.unsafe(nil)); end

  def network_interface(id); end

  def network_interfaces(options=T.unsafe(nil)); end

  def placement_group(name); end

  def placement_groups(options=T.unsafe(nil)); end

  def register_image(options=T.unsafe(nil)); end

  def route_table(id); end

  def route_table_association(id); end

  def route_tables(options=T.unsafe(nil)); end

  def security_group(id); end

  def security_groups(options=T.unsafe(nil)); end

  def snapshot(id); end

  def snapshots(options=T.unsafe(nil)); end

  def subnet(id); end

  def subnets(options=T.unsafe(nil)); end

  def volume(id); end

  def volumes(options=T.unsafe(nil)); end

  def vpc(id); end

  def vpc_addresses(options=T.unsafe(nil)); end

  def vpc_peering_connection(id); end

  def vpc_peering_connections(options=T.unsafe(nil)); end

  def vpcs(options=T.unsafe(nil)); end
end

class Aws::EC2::Resource
end

class Aws::EC2::Route
  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def destination_cidr_block(); end

  def destination_ipv_6_cidr_block(); end

  def destination_prefix_list_id(); end

  def egress_only_internet_gateway_id(); end

  def gateway_id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def instance_id(); end

  def instance_owner_id(); end

  def load(); end

  def local_gateway_id(); end

  def nat_gateway_id(); end

  def network_interface_id(); end

  def origin(); end

  def reload(); end

  def replace(options=T.unsafe(nil)); end

  def route_table(); end

  def route_table_id(); end

  def state(); end

  def transit_gateway_id(); end

  def vpc_peering_connection_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::Route::Collection
end

class Aws::EC2::Route::Collection
end

class Aws::EC2::Route
  extend ::Aws::Deprecations
end

class Aws::EC2::RouteTable
  def associate_with_subnet(options=T.unsafe(nil)); end

  def associations(); end

  def client(); end

  def create_route(options=T.unsafe(nil)); end

  def create_tags(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def owner_id(); end

  def propagating_vgws(); end

  def reload(); end

  def route_table_id(); end

  def routes(); end

  def tags(); end

  def vpc(); end

  def vpc_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::RouteTable::Collection
end

class Aws::EC2::RouteTable::Collection
end

class Aws::EC2::RouteTable
  extend ::Aws::Deprecations
end

class Aws::EC2::RouteTableAssociation
  def association_state(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def gateway_id(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def main(); end

  def reload(); end

  def replace_subnet(options=T.unsafe(nil)); end

  def route_table(); end

  def route_table_association_id(); end

  def route_table_id(); end

  def subnet(); end

  def subnet_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::RouteTableAssociation::Collection
end

class Aws::EC2::RouteTableAssociation::Collection
end

class Aws::EC2::RouteTableAssociation
  extend ::Aws::Deprecations
end

class Aws::EC2::SecurityGroup
  def authorize_egress(options=T.unsafe(nil)); end

  def authorize_ingress(options=T.unsafe(nil)); end

  def client(); end

  def create_tags(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def description(); end

  def group_id(); end

  def group_name(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def ip_permissions(); end

  def ip_permissions_egress(); end

  def load(); end

  def owner_id(); end

  def reload(); end

  def revoke_egress(options=T.unsafe(nil)); end

  def revoke_ingress(options=T.unsafe(nil)); end

  def tags(); end

  def vpc_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::SecurityGroup::Collection
end

class Aws::EC2::SecurityGroup::Collection
end

class Aws::EC2::SecurityGroup
  extend ::Aws::Deprecations
end

class Aws::EC2::Snapshot
  def client(); end

  def copy(options=T.unsafe(nil)); end

  def create_tags(options=T.unsafe(nil)); end

  def data(); end

  def data_encryption_key_id(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def describe_attribute(options=T.unsafe(nil)); end

  def description(); end

  def encrypted(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def kms_key_id(); end

  def load(); end

  def modify_attribute(options=T.unsafe(nil)); end

  def owner_alias(); end

  def owner_id(); end

  def progress(); end

  def reload(); end

  def reset_attribute(options=T.unsafe(nil)); end

  def snapshot_id(); end

  def start_time(); end

  def state(); end

  def state_message(); end

  def tags(); end

  def volume(); end

  def volume_id(); end

  def volume_size(); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_completed(options=T.unsafe(nil), &block); end
end

class Aws::EC2::Snapshot::Collection
end

class Aws::EC2::Snapshot::Collection
end

class Aws::EC2::Snapshot
  extend ::Aws::Deprecations
end

class Aws::EC2::Subnet
  def assign_ipv_6_address_on_creation(); end

  def availability_zone(); end

  def availability_zone_id(); end

  def available_ip_address_count(); end

  def cidr_block(); end

  def client(); end

  def create_instances(options=T.unsafe(nil)); end

  def create_network_interface(options=T.unsafe(nil)); end

  def create_tags(options=T.unsafe(nil)); end

  def customer_owned_ipv_4_pool(); end

  def data(); end

  def data_loaded?(); end

  def default_for_az(); end

  def delete(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def instances(options=T.unsafe(nil)); end

  def ipv_6_cidr_block_association_set(); end

  def load(); end

  def map_customer_owned_ip_on_launch(); end

  def map_public_ip_on_launch(); end

  def nat_gateways(options=T.unsafe(nil)); end

  def network_interfaces(options=T.unsafe(nil)); end

  def outpost_arn(); end

  def owner_id(); end

  def reload(); end

  def state(); end

  def subnet_arn(); end

  def subnet_id(); end

  def tags(); end

  def vpc(); end

  def vpc_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::Subnet::Collection
end

class Aws::EC2::Subnet::Collection
end

class Aws::EC2::Subnet
  extend ::Aws::Deprecations
end

class Aws::EC2::Tag
  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def key(); end

  def load(); end

  def reload(); end

  def resource_id(); end

  def resource_type(); end

  def value(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::Tag::Collection
  def batch_delete!(options=T.unsafe(nil)); end

  def delete(*args, &block); end

  def deprecated_delete(options=T.unsafe(nil)); end
end

class Aws::EC2::Tag::Collection
end

class Aws::EC2::Tag
  extend ::Aws::Deprecations
end

module Aws::EC2::Types
end

class Aws::EC2::Types::AcceptReservedInstancesExchangeQuoteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AcceptReservedInstancesExchangeQuoteRequest
end

class Aws::EC2::Types::AcceptReservedInstancesExchangeQuoteResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AcceptReservedInstancesExchangeQuoteResult
end

class Aws::EC2::Types::AcceptTransitGatewayPeeringAttachmentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AcceptTransitGatewayPeeringAttachmentRequest
end

class Aws::EC2::Types::AcceptTransitGatewayPeeringAttachmentResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AcceptTransitGatewayPeeringAttachmentResult
end

class Aws::EC2::Types::AcceptTransitGatewayVpcAttachmentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AcceptTransitGatewayVpcAttachmentRequest
end

class Aws::EC2::Types::AcceptTransitGatewayVpcAttachmentResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AcceptTransitGatewayVpcAttachmentResult
end

class Aws::EC2::Types::AcceptVpcEndpointConnectionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AcceptVpcEndpointConnectionsRequest
end

class Aws::EC2::Types::AcceptVpcEndpointConnectionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AcceptVpcEndpointConnectionsResult
end

class Aws::EC2::Types::AcceptVpcPeeringConnectionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AcceptVpcPeeringConnectionRequest
end

class Aws::EC2::Types::AcceptVpcPeeringConnectionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AcceptVpcPeeringConnectionResult
end

class Aws::EC2::Types::AccountAttribute
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AccountAttribute
end

class Aws::EC2::Types::AccountAttributeValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AccountAttributeValue
end

class Aws::EC2::Types::ActiveInstance
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ActiveInstance
end

class Aws::EC2::Types::AddPrefixListEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AddPrefixListEntry
end

class Aws::EC2::Types::Address
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Address
end

class Aws::EC2::Types::AdvertiseByoipCidrRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AdvertiseByoipCidrRequest
end

class Aws::EC2::Types::AdvertiseByoipCidrResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AdvertiseByoipCidrResult
end

class Aws::EC2::Types::AllocateAddressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AllocateAddressRequest
end

class Aws::EC2::Types::AllocateAddressResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AllocateAddressResult
end

class Aws::EC2::Types::AllocateHostsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AllocateHostsRequest
end

class Aws::EC2::Types::AllocateHostsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AllocateHostsResult
end

class Aws::EC2::Types::AllowedPrincipal
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AllowedPrincipal
end

class Aws::EC2::Types::ApplySecurityGroupsToClientVpnTargetNetworkRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ApplySecurityGroupsToClientVpnTargetNetworkRequest
end

class Aws::EC2::Types::ApplySecurityGroupsToClientVpnTargetNetworkResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ApplySecurityGroupsToClientVpnTargetNetworkResult
end

class Aws::EC2::Types::AssignIpv6AddressesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssignIpv6AddressesRequest
end

class Aws::EC2::Types::AssignIpv6AddressesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssignIpv6AddressesResult
end

class Aws::EC2::Types::AssignPrivateIpAddressesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssignPrivateIpAddressesRequest
end

class Aws::EC2::Types::AssignPrivateIpAddressesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssignPrivateIpAddressesResult
end

class Aws::EC2::Types::AssignedPrivateIpAddress
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssignedPrivateIpAddress
end

class Aws::EC2::Types::AssociateAddressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateAddressRequest
end

class Aws::EC2::Types::AssociateAddressResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateAddressResult
end

class Aws::EC2::Types::AssociateClientVpnTargetNetworkRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateClientVpnTargetNetworkRequest
end

class Aws::EC2::Types::AssociateClientVpnTargetNetworkResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateClientVpnTargetNetworkResult
end

class Aws::EC2::Types::AssociateDhcpOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateDhcpOptionsRequest
end

class Aws::EC2::Types::AssociateIamInstanceProfileRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateIamInstanceProfileRequest
end

class Aws::EC2::Types::AssociateIamInstanceProfileResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateIamInstanceProfileResult
end

class Aws::EC2::Types::AssociateRouteTableRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateRouteTableRequest
end

class Aws::EC2::Types::AssociateRouteTableResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateRouteTableResult
end

class Aws::EC2::Types::AssociateSubnetCidrBlockRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateSubnetCidrBlockRequest
end

class Aws::EC2::Types::AssociateSubnetCidrBlockResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateSubnetCidrBlockResult
end

class Aws::EC2::Types::AssociateTransitGatewayMulticastDomainRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateTransitGatewayMulticastDomainRequest
end

class Aws::EC2::Types::AssociateTransitGatewayMulticastDomainResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateTransitGatewayMulticastDomainResult
end

class Aws::EC2::Types::AssociateTransitGatewayRouteTableRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateTransitGatewayRouteTableRequest
end

class Aws::EC2::Types::AssociateTransitGatewayRouteTableResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateTransitGatewayRouteTableResult
end

class Aws::EC2::Types::AssociateVpcCidrBlockRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateVpcCidrBlockRequest
end

class Aws::EC2::Types::AssociateVpcCidrBlockResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociateVpcCidrBlockResult
end

class Aws::EC2::Types::AssociatedTargetNetwork
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociatedTargetNetwork
end

class Aws::EC2::Types::AssociationStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AssociationStatus
end

class Aws::EC2::Types::AttachClassicLinkVpcRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AttachClassicLinkVpcRequest
end

class Aws::EC2::Types::AttachClassicLinkVpcResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AttachClassicLinkVpcResult
end

class Aws::EC2::Types::AttachInternetGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AttachInternetGatewayRequest
end

class Aws::EC2::Types::AttachNetworkInterfaceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AttachNetworkInterfaceRequest
end

class Aws::EC2::Types::AttachNetworkInterfaceResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AttachNetworkInterfaceResult
end

class Aws::EC2::Types::AttachVolumeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AttachVolumeRequest
end

class Aws::EC2::Types::AttachVpnGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AttachVpnGatewayRequest
end

class Aws::EC2::Types::AttachVpnGatewayResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AttachVpnGatewayResult
end

class Aws::EC2::Types::AttributeBooleanValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AttributeBooleanValue
end

class Aws::EC2::Types::AttributeValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AttributeValue
end

class Aws::EC2::Types::AuthorizationRule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AuthorizationRule
end

class Aws::EC2::Types::AuthorizeClientVpnIngressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AuthorizeClientVpnIngressRequest
end

class Aws::EC2::Types::AuthorizeClientVpnIngressResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AuthorizeClientVpnIngressResult
end

class Aws::EC2::Types::AuthorizeSecurityGroupEgressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AuthorizeSecurityGroupEgressRequest
end

class Aws::EC2::Types::AuthorizeSecurityGroupIngressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AuthorizeSecurityGroupIngressRequest
end

class Aws::EC2::Types::AvailabilityZone
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AvailabilityZone
end

class Aws::EC2::Types::AvailabilityZoneMessage
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AvailabilityZoneMessage
end

class Aws::EC2::Types::AvailableCapacity
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::AvailableCapacity
end

class Aws::EC2::Types::BlobAttributeValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::BlobAttributeValue
end

class Aws::EC2::Types::BlockDeviceMapping
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::BlockDeviceMapping
end

class Aws::EC2::Types::BundleInstanceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::BundleInstanceRequest
end

class Aws::EC2::Types::BundleInstanceResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::BundleInstanceResult
end

class Aws::EC2::Types::BundleTask
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::BundleTask
end

class Aws::EC2::Types::BundleTaskError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::BundleTaskError
end

class Aws::EC2::Types::ByoipCidr
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ByoipCidr
end

class Aws::EC2::Types::CancelBundleTaskRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelBundleTaskRequest
end

class Aws::EC2::Types::CancelBundleTaskResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelBundleTaskResult
end

class Aws::EC2::Types::CancelCapacityReservationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelCapacityReservationRequest
end

class Aws::EC2::Types::CancelCapacityReservationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelCapacityReservationResult
end

class Aws::EC2::Types::CancelConversionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelConversionRequest
end

class Aws::EC2::Types::CancelExportTaskRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelExportTaskRequest
end

class Aws::EC2::Types::CancelImportTaskRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelImportTaskRequest
end

class Aws::EC2::Types::CancelImportTaskResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelImportTaskResult
end

class Aws::EC2::Types::CancelReservedInstancesListingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelReservedInstancesListingRequest
end

class Aws::EC2::Types::CancelReservedInstancesListingResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelReservedInstancesListingResult
end

class Aws::EC2::Types::CancelSpotFleetRequestsError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelSpotFleetRequestsError
end

class Aws::EC2::Types::CancelSpotFleetRequestsErrorItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelSpotFleetRequestsErrorItem
end

class Aws::EC2::Types::CancelSpotFleetRequestsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelSpotFleetRequestsRequest
end

class Aws::EC2::Types::CancelSpotFleetRequestsResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelSpotFleetRequestsResponse
end

class Aws::EC2::Types::CancelSpotFleetRequestsSuccessItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelSpotFleetRequestsSuccessItem
end

class Aws::EC2::Types::CancelSpotInstanceRequestsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelSpotInstanceRequestsRequest
end

class Aws::EC2::Types::CancelSpotInstanceRequestsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelSpotInstanceRequestsResult
end

class Aws::EC2::Types::CancelledSpotInstanceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CancelledSpotInstanceRequest
end

class Aws::EC2::Types::CapacityReservation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CapacityReservation
end

class Aws::EC2::Types::CapacityReservationOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CapacityReservationOptions
end

class Aws::EC2::Types::CapacityReservationOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CapacityReservationOptionsRequest
end

class Aws::EC2::Types::CapacityReservationSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CapacityReservationSpecification
end

class Aws::EC2::Types::CapacityReservationSpecificationResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CapacityReservationSpecificationResponse
end

class Aws::EC2::Types::CapacityReservationTarget
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CapacityReservationTarget
end

class Aws::EC2::Types::CapacityReservationTargetResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CapacityReservationTargetResponse
end

class Aws::EC2::Types::CertificateAuthentication
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CertificateAuthentication
end

class Aws::EC2::Types::CertificateAuthenticationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CertificateAuthenticationRequest
end

class Aws::EC2::Types::CidrAuthorizationContext
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CidrAuthorizationContext
end

class Aws::EC2::Types::CidrBlock
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CidrBlock
end

class Aws::EC2::Types::ClassicLinkDnsSupport
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClassicLinkDnsSupport
end

class Aws::EC2::Types::ClassicLinkInstance
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClassicLinkInstance
end

class Aws::EC2::Types::ClassicLoadBalancer
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClassicLoadBalancer
end

class Aws::EC2::Types::ClassicLoadBalancersConfig
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClassicLoadBalancersConfig
end

class Aws::EC2::Types::ClientCertificateRevocationListStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientCertificateRevocationListStatus
end

class Aws::EC2::Types::ClientData
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientData
end

class Aws::EC2::Types::ClientVpnAuthentication
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientVpnAuthentication
end

class Aws::EC2::Types::ClientVpnAuthenticationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientVpnAuthenticationRequest
end

class Aws::EC2::Types::ClientVpnAuthorizationRuleStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientVpnAuthorizationRuleStatus
end

class Aws::EC2::Types::ClientVpnConnection
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientVpnConnection
end

class Aws::EC2::Types::ClientVpnConnectionStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientVpnConnectionStatus
end

class Aws::EC2::Types::ClientVpnEndpoint
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientVpnEndpoint
end

class Aws::EC2::Types::ClientVpnEndpointStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientVpnEndpointStatus
end

class Aws::EC2::Types::ClientVpnRoute
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientVpnRoute
end

class Aws::EC2::Types::ClientVpnRouteStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ClientVpnRouteStatus
end

class Aws::EC2::Types::CoipAddressUsage
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CoipAddressUsage
end

class Aws::EC2::Types::CoipPool
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CoipPool
end

class Aws::EC2::Types::ConfirmProductInstanceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ConfirmProductInstanceRequest
end

class Aws::EC2::Types::ConfirmProductInstanceResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ConfirmProductInstanceResult
end

class Aws::EC2::Types::ConnectionLogOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ConnectionLogOptions
end

class Aws::EC2::Types::ConnectionLogResponseOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ConnectionLogResponseOptions
end

class Aws::EC2::Types::ConnectionNotification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ConnectionNotification
end

class Aws::EC2::Types::ConversionTask
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ConversionTask
end

class Aws::EC2::Types::CopyFpgaImageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CopyFpgaImageRequest
end

class Aws::EC2::Types::CopyFpgaImageResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CopyFpgaImageResult
end

class Aws::EC2::Types::CopyImageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CopyImageRequest
end

class Aws::EC2::Types::CopyImageResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CopyImageResult
end

class Aws::EC2::Types::CopySnapshotRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CopySnapshotRequest
end

class Aws::EC2::Types::CopySnapshotResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CopySnapshotResult
end

class Aws::EC2::Types::CpuOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CpuOptions
end

class Aws::EC2::Types::CpuOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CpuOptionsRequest
end

class Aws::EC2::Types::CreateCapacityReservationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateCapacityReservationRequest
end

class Aws::EC2::Types::CreateCapacityReservationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateCapacityReservationResult
end

class Aws::EC2::Types::CreateClientVpnEndpointRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateClientVpnEndpointRequest
end

class Aws::EC2::Types::CreateClientVpnEndpointResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateClientVpnEndpointResult
end

class Aws::EC2::Types::CreateClientVpnRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateClientVpnRouteRequest
end

class Aws::EC2::Types::CreateClientVpnRouteResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateClientVpnRouteResult
end

class Aws::EC2::Types::CreateCustomerGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateCustomerGatewayRequest
end

class Aws::EC2::Types::CreateCustomerGatewayResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateCustomerGatewayResult
end

class Aws::EC2::Types::CreateDefaultSubnetRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateDefaultSubnetRequest
end

class Aws::EC2::Types::CreateDefaultSubnetResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateDefaultSubnetResult
end

class Aws::EC2::Types::CreateDefaultVpcRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateDefaultVpcRequest
end

class Aws::EC2::Types::CreateDefaultVpcResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateDefaultVpcResult
end

class Aws::EC2::Types::CreateDhcpOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateDhcpOptionsRequest
end

class Aws::EC2::Types::CreateDhcpOptionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateDhcpOptionsResult
end

class Aws::EC2::Types::CreateEgressOnlyInternetGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateEgressOnlyInternetGatewayRequest
end

class Aws::EC2::Types::CreateEgressOnlyInternetGatewayResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateEgressOnlyInternetGatewayResult
end

class Aws::EC2::Types::CreateFleetError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateFleetError
end

class Aws::EC2::Types::CreateFleetInstance
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateFleetInstance
end

class Aws::EC2::Types::CreateFleetRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateFleetRequest
end

class Aws::EC2::Types::CreateFleetResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateFleetResult
end

class Aws::EC2::Types::CreateFlowLogsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateFlowLogsRequest
end

class Aws::EC2::Types::CreateFlowLogsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateFlowLogsResult
end

class Aws::EC2::Types::CreateFpgaImageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateFpgaImageRequest
end

class Aws::EC2::Types::CreateFpgaImageResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateFpgaImageResult
end

class Aws::EC2::Types::CreateImageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateImageRequest
end

class Aws::EC2::Types::CreateImageResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateImageResult
end

class Aws::EC2::Types::CreateInstanceExportTaskRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateInstanceExportTaskRequest
end

class Aws::EC2::Types::CreateInstanceExportTaskResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateInstanceExportTaskResult
end

class Aws::EC2::Types::CreateInternetGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateInternetGatewayRequest
end

class Aws::EC2::Types::CreateInternetGatewayResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateInternetGatewayResult
end

class Aws::EC2::Types::CreateKeyPairRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateKeyPairRequest
end

class Aws::EC2::Types::CreateLaunchTemplateRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateLaunchTemplateRequest
end

class Aws::EC2::Types::CreateLaunchTemplateResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateLaunchTemplateResult
end

class Aws::EC2::Types::CreateLaunchTemplateVersionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateLaunchTemplateVersionRequest
end

class Aws::EC2::Types::CreateLaunchTemplateVersionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateLaunchTemplateVersionResult
end

class Aws::EC2::Types::CreateLocalGatewayRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateLocalGatewayRouteRequest
end

class Aws::EC2::Types::CreateLocalGatewayRouteResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateLocalGatewayRouteResult
end

class Aws::EC2::Types::CreateLocalGatewayRouteTableVpcAssociationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateLocalGatewayRouteTableVpcAssociationRequest
end

class Aws::EC2::Types::CreateLocalGatewayRouteTableVpcAssociationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateLocalGatewayRouteTableVpcAssociationResult
end

class Aws::EC2::Types::CreateManagedPrefixListRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateManagedPrefixListRequest
end

class Aws::EC2::Types::CreateManagedPrefixListResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateManagedPrefixListResult
end

class Aws::EC2::Types::CreateNatGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateNatGatewayRequest
end

class Aws::EC2::Types::CreateNatGatewayResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateNatGatewayResult
end

class Aws::EC2::Types::CreateNetworkAclEntryRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateNetworkAclEntryRequest
end

class Aws::EC2::Types::CreateNetworkAclRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateNetworkAclRequest
end

class Aws::EC2::Types::CreateNetworkAclResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateNetworkAclResult
end

class Aws::EC2::Types::CreateNetworkInterfacePermissionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateNetworkInterfacePermissionRequest
end

class Aws::EC2::Types::CreateNetworkInterfacePermissionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateNetworkInterfacePermissionResult
end

class Aws::EC2::Types::CreateNetworkInterfaceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateNetworkInterfaceRequest
end

class Aws::EC2::Types::CreateNetworkInterfaceResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateNetworkInterfaceResult
end

class Aws::EC2::Types::CreatePlacementGroupRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreatePlacementGroupRequest
end

class Aws::EC2::Types::CreatePlacementGroupResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreatePlacementGroupResult
end

class Aws::EC2::Types::CreateReservedInstancesListingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateReservedInstancesListingRequest
end

class Aws::EC2::Types::CreateReservedInstancesListingResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateReservedInstancesListingResult
end

class Aws::EC2::Types::CreateRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateRouteRequest
end

class Aws::EC2::Types::CreateRouteResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateRouteResult
end

class Aws::EC2::Types::CreateRouteTableRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateRouteTableRequest
end

class Aws::EC2::Types::CreateRouteTableResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateRouteTableResult
end

class Aws::EC2::Types::CreateSecurityGroupRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateSecurityGroupRequest
end

class Aws::EC2::Types::CreateSecurityGroupResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateSecurityGroupResult
end

class Aws::EC2::Types::CreateSnapshotRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateSnapshotRequest
end

class Aws::EC2::Types::CreateSnapshotsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateSnapshotsRequest
end

class Aws::EC2::Types::CreateSnapshotsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateSnapshotsResult
end

class Aws::EC2::Types::CreateSpotDatafeedSubscriptionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateSpotDatafeedSubscriptionRequest
end

class Aws::EC2::Types::CreateSpotDatafeedSubscriptionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateSpotDatafeedSubscriptionResult
end

class Aws::EC2::Types::CreateSubnetRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateSubnetRequest
end

class Aws::EC2::Types::CreateSubnetResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateSubnetResult
end

class Aws::EC2::Types::CreateTagsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTagsRequest
end

class Aws::EC2::Types::CreateTrafficMirrorFilterRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTrafficMirrorFilterRequest
end

class Aws::EC2::Types::CreateTrafficMirrorFilterResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTrafficMirrorFilterResult
end

class Aws::EC2::Types::CreateTrafficMirrorFilterRuleRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTrafficMirrorFilterRuleRequest
end

class Aws::EC2::Types::CreateTrafficMirrorFilterRuleResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTrafficMirrorFilterRuleResult
end

class Aws::EC2::Types::CreateTrafficMirrorSessionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTrafficMirrorSessionRequest
end

class Aws::EC2::Types::CreateTrafficMirrorSessionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTrafficMirrorSessionResult
end

class Aws::EC2::Types::CreateTrafficMirrorTargetRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTrafficMirrorTargetRequest
end

class Aws::EC2::Types::CreateTrafficMirrorTargetResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTrafficMirrorTargetResult
end

class Aws::EC2::Types::CreateTransitGatewayMulticastDomainRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayMulticastDomainRequest
end

class Aws::EC2::Types::CreateTransitGatewayMulticastDomainResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayMulticastDomainResult
end

class Aws::EC2::Types::CreateTransitGatewayPeeringAttachmentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayPeeringAttachmentRequest
end

class Aws::EC2::Types::CreateTransitGatewayPeeringAttachmentResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayPeeringAttachmentResult
end

class Aws::EC2::Types::CreateTransitGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayRequest
end

class Aws::EC2::Types::CreateTransitGatewayResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayResult
end

class Aws::EC2::Types::CreateTransitGatewayRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayRouteRequest
end

class Aws::EC2::Types::CreateTransitGatewayRouteResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayRouteResult
end

class Aws::EC2::Types::CreateTransitGatewayRouteTableRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayRouteTableRequest
end

class Aws::EC2::Types::CreateTransitGatewayRouteTableResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayRouteTableResult
end

class Aws::EC2::Types::CreateTransitGatewayVpcAttachmentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayVpcAttachmentRequest
end

class Aws::EC2::Types::CreateTransitGatewayVpcAttachmentRequestOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayVpcAttachmentRequestOptions
end

class Aws::EC2::Types::CreateTransitGatewayVpcAttachmentResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateTransitGatewayVpcAttachmentResult
end

class Aws::EC2::Types::CreateVolumePermission
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVolumePermission
end

class Aws::EC2::Types::CreateVolumePermissionModifications
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVolumePermissionModifications
end

class Aws::EC2::Types::CreateVolumeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVolumeRequest
end

class Aws::EC2::Types::CreateVpcEndpointConnectionNotificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpcEndpointConnectionNotificationRequest
end

class Aws::EC2::Types::CreateVpcEndpointConnectionNotificationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpcEndpointConnectionNotificationResult
end

class Aws::EC2::Types::CreateVpcEndpointRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpcEndpointRequest
end

class Aws::EC2::Types::CreateVpcEndpointResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpcEndpointResult
end

class Aws::EC2::Types::CreateVpcEndpointServiceConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpcEndpointServiceConfigurationRequest
end

class Aws::EC2::Types::CreateVpcEndpointServiceConfigurationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpcEndpointServiceConfigurationResult
end

class Aws::EC2::Types::CreateVpcPeeringConnectionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpcPeeringConnectionRequest
end

class Aws::EC2::Types::CreateVpcPeeringConnectionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpcPeeringConnectionResult
end

class Aws::EC2::Types::CreateVpcRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpcRequest
end

class Aws::EC2::Types::CreateVpcResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpcResult
end

class Aws::EC2::Types::CreateVpnConnectionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpnConnectionRequest
end

class Aws::EC2::Types::CreateVpnConnectionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpnConnectionResult
end

class Aws::EC2::Types::CreateVpnConnectionRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpnConnectionRouteRequest
end

class Aws::EC2::Types::CreateVpnGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpnGatewayRequest
end

class Aws::EC2::Types::CreateVpnGatewayResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreateVpnGatewayResult
end

class Aws::EC2::Types::CreditSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreditSpecification
end

class Aws::EC2::Types::CreditSpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CreditSpecificationRequest
end

class Aws::EC2::Types::CustomerGateway
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::CustomerGateway
end

class Aws::EC2::Types::DeleteClientVpnEndpointRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteClientVpnEndpointRequest
end

class Aws::EC2::Types::DeleteClientVpnEndpointResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteClientVpnEndpointResult
end

class Aws::EC2::Types::DeleteClientVpnRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteClientVpnRouteRequest
end

class Aws::EC2::Types::DeleteClientVpnRouteResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteClientVpnRouteResult
end

class Aws::EC2::Types::DeleteCustomerGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteCustomerGatewayRequest
end

class Aws::EC2::Types::DeleteDhcpOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteDhcpOptionsRequest
end

class Aws::EC2::Types::DeleteEgressOnlyInternetGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteEgressOnlyInternetGatewayRequest
end

class Aws::EC2::Types::DeleteEgressOnlyInternetGatewayResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteEgressOnlyInternetGatewayResult
end

class Aws::EC2::Types::DeleteFleetError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteFleetError
end

class Aws::EC2::Types::DeleteFleetErrorItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteFleetErrorItem
end

class Aws::EC2::Types::DeleteFleetSuccessItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteFleetSuccessItem
end

class Aws::EC2::Types::DeleteFleetsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteFleetsRequest
end

class Aws::EC2::Types::DeleteFleetsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteFleetsResult
end

class Aws::EC2::Types::DeleteFlowLogsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteFlowLogsRequest
end

class Aws::EC2::Types::DeleteFlowLogsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteFlowLogsResult
end

class Aws::EC2::Types::DeleteFpgaImageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteFpgaImageRequest
end

class Aws::EC2::Types::DeleteFpgaImageResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteFpgaImageResult
end

class Aws::EC2::Types::DeleteInternetGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteInternetGatewayRequest
end

class Aws::EC2::Types::DeleteKeyPairRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteKeyPairRequest
end

class Aws::EC2::Types::DeleteLaunchTemplateRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteLaunchTemplateRequest
end

class Aws::EC2::Types::DeleteLaunchTemplateResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteLaunchTemplateResult
end

class Aws::EC2::Types::DeleteLaunchTemplateVersionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteLaunchTemplateVersionsRequest
end

class Aws::EC2::Types::DeleteLaunchTemplateVersionsResponseErrorItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteLaunchTemplateVersionsResponseErrorItem
end

class Aws::EC2::Types::DeleteLaunchTemplateVersionsResponseSuccessItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteLaunchTemplateVersionsResponseSuccessItem
end

class Aws::EC2::Types::DeleteLaunchTemplateVersionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteLaunchTemplateVersionsResult
end

class Aws::EC2::Types::DeleteLocalGatewayRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteLocalGatewayRouteRequest
end

class Aws::EC2::Types::DeleteLocalGatewayRouteResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteLocalGatewayRouteResult
end

class Aws::EC2::Types::DeleteLocalGatewayRouteTableVpcAssociationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteLocalGatewayRouteTableVpcAssociationRequest
end

class Aws::EC2::Types::DeleteLocalGatewayRouteTableVpcAssociationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteLocalGatewayRouteTableVpcAssociationResult
end

class Aws::EC2::Types::DeleteManagedPrefixListRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteManagedPrefixListRequest
end

class Aws::EC2::Types::DeleteManagedPrefixListResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteManagedPrefixListResult
end

class Aws::EC2::Types::DeleteNatGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteNatGatewayRequest
end

class Aws::EC2::Types::DeleteNatGatewayResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteNatGatewayResult
end

class Aws::EC2::Types::DeleteNetworkAclEntryRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteNetworkAclEntryRequest
end

class Aws::EC2::Types::DeleteNetworkAclRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteNetworkAclRequest
end

class Aws::EC2::Types::DeleteNetworkInterfacePermissionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteNetworkInterfacePermissionRequest
end

class Aws::EC2::Types::DeleteNetworkInterfacePermissionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteNetworkInterfacePermissionResult
end

class Aws::EC2::Types::DeleteNetworkInterfaceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteNetworkInterfaceRequest
end

class Aws::EC2::Types::DeletePlacementGroupRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeletePlacementGroupRequest
end

class Aws::EC2::Types::DeleteQueuedReservedInstancesError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteQueuedReservedInstancesError
end

class Aws::EC2::Types::DeleteQueuedReservedInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteQueuedReservedInstancesRequest
end

class Aws::EC2::Types::DeleteQueuedReservedInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteQueuedReservedInstancesResult
end

class Aws::EC2::Types::DeleteRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteRouteRequest
end

class Aws::EC2::Types::DeleteRouteTableRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteRouteTableRequest
end

class Aws::EC2::Types::DeleteSecurityGroupRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteSecurityGroupRequest
end

class Aws::EC2::Types::DeleteSnapshotRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteSnapshotRequest
end

class Aws::EC2::Types::DeleteSpotDatafeedSubscriptionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteSpotDatafeedSubscriptionRequest
end

class Aws::EC2::Types::DeleteSubnetRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteSubnetRequest
end

class Aws::EC2::Types::DeleteTagsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTagsRequest
end

class Aws::EC2::Types::DeleteTrafficMirrorFilterRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTrafficMirrorFilterRequest
end

class Aws::EC2::Types::DeleteTrafficMirrorFilterResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTrafficMirrorFilterResult
end

class Aws::EC2::Types::DeleteTrafficMirrorFilterRuleRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTrafficMirrorFilterRuleRequest
end

class Aws::EC2::Types::DeleteTrafficMirrorFilterRuleResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTrafficMirrorFilterRuleResult
end

class Aws::EC2::Types::DeleteTrafficMirrorSessionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTrafficMirrorSessionRequest
end

class Aws::EC2::Types::DeleteTrafficMirrorSessionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTrafficMirrorSessionResult
end

class Aws::EC2::Types::DeleteTrafficMirrorTargetRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTrafficMirrorTargetRequest
end

class Aws::EC2::Types::DeleteTrafficMirrorTargetResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTrafficMirrorTargetResult
end

class Aws::EC2::Types::DeleteTransitGatewayMulticastDomainRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayMulticastDomainRequest
end

class Aws::EC2::Types::DeleteTransitGatewayMulticastDomainResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayMulticastDomainResult
end

class Aws::EC2::Types::DeleteTransitGatewayPeeringAttachmentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayPeeringAttachmentRequest
end

class Aws::EC2::Types::DeleteTransitGatewayPeeringAttachmentResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayPeeringAttachmentResult
end

class Aws::EC2::Types::DeleteTransitGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayRequest
end

class Aws::EC2::Types::DeleteTransitGatewayResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayResult
end

class Aws::EC2::Types::DeleteTransitGatewayRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayRouteRequest
end

class Aws::EC2::Types::DeleteTransitGatewayRouteResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayRouteResult
end

class Aws::EC2::Types::DeleteTransitGatewayRouteTableRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayRouteTableRequest
end

class Aws::EC2::Types::DeleteTransitGatewayRouteTableResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayRouteTableResult
end

class Aws::EC2::Types::DeleteTransitGatewayVpcAttachmentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayVpcAttachmentRequest
end

class Aws::EC2::Types::DeleteTransitGatewayVpcAttachmentResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteTransitGatewayVpcAttachmentResult
end

class Aws::EC2::Types::DeleteVolumeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVolumeRequest
end

class Aws::EC2::Types::DeleteVpcEndpointConnectionNotificationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpcEndpointConnectionNotificationsRequest
end

class Aws::EC2::Types::DeleteVpcEndpointConnectionNotificationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpcEndpointConnectionNotificationsResult
end

class Aws::EC2::Types::DeleteVpcEndpointServiceConfigurationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpcEndpointServiceConfigurationsRequest
end

class Aws::EC2::Types::DeleteVpcEndpointServiceConfigurationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpcEndpointServiceConfigurationsResult
end

class Aws::EC2::Types::DeleteVpcEndpointsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpcEndpointsRequest
end

class Aws::EC2::Types::DeleteVpcEndpointsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpcEndpointsResult
end

class Aws::EC2::Types::DeleteVpcPeeringConnectionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpcPeeringConnectionRequest
end

class Aws::EC2::Types::DeleteVpcPeeringConnectionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpcPeeringConnectionResult
end

class Aws::EC2::Types::DeleteVpcRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpcRequest
end

class Aws::EC2::Types::DeleteVpnConnectionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpnConnectionRequest
end

class Aws::EC2::Types::DeleteVpnConnectionRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpnConnectionRouteRequest
end

class Aws::EC2::Types::DeleteVpnGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeleteVpnGatewayRequest
end

class Aws::EC2::Types::DeprovisionByoipCidrRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeprovisionByoipCidrRequest
end

class Aws::EC2::Types::DeprovisionByoipCidrResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeprovisionByoipCidrResult
end

class Aws::EC2::Types::DeregisterImageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeregisterImageRequest
end

class Aws::EC2::Types::DeregisterInstanceEventNotificationAttributesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeregisterInstanceEventNotificationAttributesRequest
end

class Aws::EC2::Types::DeregisterInstanceEventNotificationAttributesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeregisterInstanceEventNotificationAttributesResult
end

class Aws::EC2::Types::DeregisterInstanceTagAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeregisterInstanceTagAttributeRequest
end

class Aws::EC2::Types::DeregisterTransitGatewayMulticastGroupMembersRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeregisterTransitGatewayMulticastGroupMembersRequest
end

class Aws::EC2::Types::DeregisterTransitGatewayMulticastGroupMembersResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeregisterTransitGatewayMulticastGroupMembersResult
end

class Aws::EC2::Types::DeregisterTransitGatewayMulticastGroupSourcesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeregisterTransitGatewayMulticastGroupSourcesRequest
end

class Aws::EC2::Types::DeregisterTransitGatewayMulticastGroupSourcesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DeregisterTransitGatewayMulticastGroupSourcesResult
end

class Aws::EC2::Types::DescribeAccountAttributesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeAccountAttributesRequest
end

class Aws::EC2::Types::DescribeAccountAttributesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeAccountAttributesResult
end

class Aws::EC2::Types::DescribeAddressesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeAddressesRequest
end

class Aws::EC2::Types::DescribeAddressesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeAddressesResult
end

class Aws::EC2::Types::DescribeAggregateIdFormatRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeAggregateIdFormatRequest
end

class Aws::EC2::Types::DescribeAggregateIdFormatResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeAggregateIdFormatResult
end

class Aws::EC2::Types::DescribeAvailabilityZonesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeAvailabilityZonesRequest
end

class Aws::EC2::Types::DescribeAvailabilityZonesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeAvailabilityZonesResult
end

class Aws::EC2::Types::DescribeBundleTasksRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeBundleTasksRequest
end

class Aws::EC2::Types::DescribeBundleTasksResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeBundleTasksResult
end

class Aws::EC2::Types::DescribeByoipCidrsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeByoipCidrsRequest
end

class Aws::EC2::Types::DescribeByoipCidrsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeByoipCidrsResult
end

class Aws::EC2::Types::DescribeCapacityReservationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeCapacityReservationsRequest
end

class Aws::EC2::Types::DescribeCapacityReservationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeCapacityReservationsResult
end

class Aws::EC2::Types::DescribeClassicLinkInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClassicLinkInstancesRequest
end

class Aws::EC2::Types::DescribeClassicLinkInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClassicLinkInstancesResult
end

class Aws::EC2::Types::DescribeClientVpnAuthorizationRulesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClientVpnAuthorizationRulesRequest
end

class Aws::EC2::Types::DescribeClientVpnAuthorizationRulesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClientVpnAuthorizationRulesResult
end

class Aws::EC2::Types::DescribeClientVpnConnectionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClientVpnConnectionsRequest
end

class Aws::EC2::Types::DescribeClientVpnConnectionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClientVpnConnectionsResult
end

class Aws::EC2::Types::DescribeClientVpnEndpointsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClientVpnEndpointsRequest
end

class Aws::EC2::Types::DescribeClientVpnEndpointsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClientVpnEndpointsResult
end

class Aws::EC2::Types::DescribeClientVpnRoutesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClientVpnRoutesRequest
end

class Aws::EC2::Types::DescribeClientVpnRoutesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClientVpnRoutesResult
end

class Aws::EC2::Types::DescribeClientVpnTargetNetworksRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClientVpnTargetNetworksRequest
end

class Aws::EC2::Types::DescribeClientVpnTargetNetworksResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeClientVpnTargetNetworksResult
end

class Aws::EC2::Types::DescribeCoipPoolsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeCoipPoolsRequest
end

class Aws::EC2::Types::DescribeCoipPoolsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeCoipPoolsResult
end

class Aws::EC2::Types::DescribeConversionTasksRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeConversionTasksRequest
end

class Aws::EC2::Types::DescribeConversionTasksResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeConversionTasksResult
end

class Aws::EC2::Types::DescribeCustomerGatewaysRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeCustomerGatewaysRequest
end

class Aws::EC2::Types::DescribeCustomerGatewaysResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeCustomerGatewaysResult
end

class Aws::EC2::Types::DescribeDhcpOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeDhcpOptionsRequest
end

class Aws::EC2::Types::DescribeDhcpOptionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeDhcpOptionsResult
end

class Aws::EC2::Types::DescribeEgressOnlyInternetGatewaysRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeEgressOnlyInternetGatewaysRequest
end

class Aws::EC2::Types::DescribeEgressOnlyInternetGatewaysResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeEgressOnlyInternetGatewaysResult
end

class Aws::EC2::Types::DescribeElasticGpusRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeElasticGpusRequest
end

class Aws::EC2::Types::DescribeElasticGpusResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeElasticGpusResult
end

class Aws::EC2::Types::DescribeExportImageTasksRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeExportImageTasksRequest
end

class Aws::EC2::Types::DescribeExportImageTasksResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeExportImageTasksResult
end

class Aws::EC2::Types::DescribeExportTasksRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeExportTasksRequest
end

class Aws::EC2::Types::DescribeExportTasksResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeExportTasksResult
end

class Aws::EC2::Types::DescribeFastSnapshotRestoreSuccessItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFastSnapshotRestoreSuccessItem
end

class Aws::EC2::Types::DescribeFastSnapshotRestoresRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFastSnapshotRestoresRequest
end

class Aws::EC2::Types::DescribeFastSnapshotRestoresResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFastSnapshotRestoresResult
end

class Aws::EC2::Types::DescribeFleetError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFleetError
end

class Aws::EC2::Types::DescribeFleetHistoryRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFleetHistoryRequest
end

class Aws::EC2::Types::DescribeFleetHistoryResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFleetHistoryResult
end

class Aws::EC2::Types::DescribeFleetInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFleetInstancesRequest
end

class Aws::EC2::Types::DescribeFleetInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFleetInstancesResult
end

class Aws::EC2::Types::DescribeFleetsInstances
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFleetsInstances
end

class Aws::EC2::Types::DescribeFleetsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFleetsRequest
end

class Aws::EC2::Types::DescribeFleetsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFleetsResult
end

class Aws::EC2::Types::DescribeFlowLogsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFlowLogsRequest
end

class Aws::EC2::Types::DescribeFlowLogsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFlowLogsResult
end

class Aws::EC2::Types::DescribeFpgaImageAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFpgaImageAttributeRequest
end

class Aws::EC2::Types::DescribeFpgaImageAttributeResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFpgaImageAttributeResult
end

class Aws::EC2::Types::DescribeFpgaImagesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFpgaImagesRequest
end

class Aws::EC2::Types::DescribeFpgaImagesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeFpgaImagesResult
end

class Aws::EC2::Types::DescribeHostReservationOfferingsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeHostReservationOfferingsRequest
end

class Aws::EC2::Types::DescribeHostReservationOfferingsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeHostReservationOfferingsResult
end

class Aws::EC2::Types::DescribeHostReservationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeHostReservationsRequest
end

class Aws::EC2::Types::DescribeHostReservationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeHostReservationsResult
end

class Aws::EC2::Types::DescribeHostsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeHostsRequest
end

class Aws::EC2::Types::DescribeHostsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeHostsResult
end

class Aws::EC2::Types::DescribeIamInstanceProfileAssociationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeIamInstanceProfileAssociationsRequest
end

class Aws::EC2::Types::DescribeIamInstanceProfileAssociationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeIamInstanceProfileAssociationsResult
end

class Aws::EC2::Types::DescribeIdFormatRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeIdFormatRequest
end

class Aws::EC2::Types::DescribeIdFormatResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeIdFormatResult
end

class Aws::EC2::Types::DescribeIdentityIdFormatRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeIdentityIdFormatRequest
end

class Aws::EC2::Types::DescribeIdentityIdFormatResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeIdentityIdFormatResult
end

class Aws::EC2::Types::DescribeImageAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeImageAttributeRequest
end

class Aws::EC2::Types::DescribeImagesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeImagesRequest
end

class Aws::EC2::Types::DescribeImagesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeImagesResult
end

class Aws::EC2::Types::DescribeImportImageTasksRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeImportImageTasksRequest
end

class Aws::EC2::Types::DescribeImportImageTasksResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeImportImageTasksResult
end

class Aws::EC2::Types::DescribeImportSnapshotTasksRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeImportSnapshotTasksRequest
end

class Aws::EC2::Types::DescribeImportSnapshotTasksResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeImportSnapshotTasksResult
end

class Aws::EC2::Types::DescribeInstanceAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceAttributeRequest
end

class Aws::EC2::Types::DescribeInstanceCreditSpecificationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceCreditSpecificationsRequest
end

class Aws::EC2::Types::DescribeInstanceCreditSpecificationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceCreditSpecificationsResult
end

class Aws::EC2::Types::DescribeInstanceEventNotificationAttributesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceEventNotificationAttributesRequest
end

class Aws::EC2::Types::DescribeInstanceEventNotificationAttributesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceEventNotificationAttributesResult
end

class Aws::EC2::Types::DescribeInstanceStatusRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceStatusRequest
end

class Aws::EC2::Types::DescribeInstanceStatusResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceStatusResult
end

class Aws::EC2::Types::DescribeInstanceTypeOfferingsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceTypeOfferingsRequest
end

class Aws::EC2::Types::DescribeInstanceTypeOfferingsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceTypeOfferingsResult
end

class Aws::EC2::Types::DescribeInstanceTypesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceTypesRequest
end

class Aws::EC2::Types::DescribeInstanceTypesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstanceTypesResult
end

class Aws::EC2::Types::DescribeInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstancesRequest
end

class Aws::EC2::Types::DescribeInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInstancesResult
end

class Aws::EC2::Types::DescribeInternetGatewaysRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInternetGatewaysRequest
end

class Aws::EC2::Types::DescribeInternetGatewaysResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeInternetGatewaysResult
end

class Aws::EC2::Types::DescribeIpv6PoolsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeIpv6PoolsRequest
end

class Aws::EC2::Types::DescribeIpv6PoolsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeIpv6PoolsResult
end

class Aws::EC2::Types::DescribeKeyPairsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeKeyPairsRequest
end

class Aws::EC2::Types::DescribeKeyPairsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeKeyPairsResult
end

class Aws::EC2::Types::DescribeLaunchTemplateVersionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLaunchTemplateVersionsRequest
end

class Aws::EC2::Types::DescribeLaunchTemplateVersionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLaunchTemplateVersionsResult
end

class Aws::EC2::Types::DescribeLaunchTemplatesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLaunchTemplatesRequest
end

class Aws::EC2::Types::DescribeLaunchTemplatesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLaunchTemplatesResult
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTableVpcAssociationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTableVpcAssociationsRequest
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTableVpcAssociationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTableVpcAssociationsResult
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTablesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTablesRequest
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTablesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewayRouteTablesResult
end

class Aws::EC2::Types::DescribeLocalGatewayVirtualInterfaceGroupsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewayVirtualInterfaceGroupsRequest
end

class Aws::EC2::Types::DescribeLocalGatewayVirtualInterfaceGroupsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewayVirtualInterfaceGroupsResult
end

class Aws::EC2::Types::DescribeLocalGatewayVirtualInterfacesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewayVirtualInterfacesRequest
end

class Aws::EC2::Types::DescribeLocalGatewayVirtualInterfacesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewayVirtualInterfacesResult
end

class Aws::EC2::Types::DescribeLocalGatewaysRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewaysRequest
end

class Aws::EC2::Types::DescribeLocalGatewaysResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeLocalGatewaysResult
end

class Aws::EC2::Types::DescribeManagedPrefixListsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeManagedPrefixListsRequest
end

class Aws::EC2::Types::DescribeManagedPrefixListsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeManagedPrefixListsResult
end

class Aws::EC2::Types::DescribeMovingAddressesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeMovingAddressesRequest
end

class Aws::EC2::Types::DescribeMovingAddressesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeMovingAddressesResult
end

class Aws::EC2::Types::DescribeNatGatewaysRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeNatGatewaysRequest
end

class Aws::EC2::Types::DescribeNatGatewaysResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeNatGatewaysResult
end

class Aws::EC2::Types::DescribeNetworkAclsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeNetworkAclsRequest
end

class Aws::EC2::Types::DescribeNetworkAclsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeNetworkAclsResult
end

class Aws::EC2::Types::DescribeNetworkInterfaceAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeNetworkInterfaceAttributeRequest
end

class Aws::EC2::Types::DescribeNetworkInterfaceAttributeResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeNetworkInterfaceAttributeResult
end

class Aws::EC2::Types::DescribeNetworkInterfacePermissionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeNetworkInterfacePermissionsRequest
end

class Aws::EC2::Types::DescribeNetworkInterfacePermissionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeNetworkInterfacePermissionsResult
end

class Aws::EC2::Types::DescribeNetworkInterfacesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeNetworkInterfacesRequest
end

class Aws::EC2::Types::DescribeNetworkInterfacesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeNetworkInterfacesResult
end

class Aws::EC2::Types::DescribePlacementGroupsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribePlacementGroupsRequest
end

class Aws::EC2::Types::DescribePlacementGroupsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribePlacementGroupsResult
end

class Aws::EC2::Types::DescribePrefixListsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribePrefixListsRequest
end

class Aws::EC2::Types::DescribePrefixListsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribePrefixListsResult
end

class Aws::EC2::Types::DescribePrincipalIdFormatRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribePrincipalIdFormatRequest
end

class Aws::EC2::Types::DescribePrincipalIdFormatResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribePrincipalIdFormatResult
end

class Aws::EC2::Types::DescribePublicIpv4PoolsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribePublicIpv4PoolsRequest
end

class Aws::EC2::Types::DescribePublicIpv4PoolsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribePublicIpv4PoolsResult
end

class Aws::EC2::Types::DescribeRegionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeRegionsRequest
end

class Aws::EC2::Types::DescribeRegionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeRegionsResult
end

class Aws::EC2::Types::DescribeReservedInstancesListingsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeReservedInstancesListingsRequest
end

class Aws::EC2::Types::DescribeReservedInstancesListingsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeReservedInstancesListingsResult
end

class Aws::EC2::Types::DescribeReservedInstancesModificationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeReservedInstancesModificationsRequest
end

class Aws::EC2::Types::DescribeReservedInstancesModificationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeReservedInstancesModificationsResult
end

class Aws::EC2::Types::DescribeReservedInstancesOfferingsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeReservedInstancesOfferingsRequest
end

class Aws::EC2::Types::DescribeReservedInstancesOfferingsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeReservedInstancesOfferingsResult
end

class Aws::EC2::Types::DescribeReservedInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeReservedInstancesRequest
end

class Aws::EC2::Types::DescribeReservedInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeReservedInstancesResult
end

class Aws::EC2::Types::DescribeRouteTablesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeRouteTablesRequest
end

class Aws::EC2::Types::DescribeRouteTablesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeRouteTablesResult
end

class Aws::EC2::Types::DescribeScheduledInstanceAvailabilityRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeScheduledInstanceAvailabilityRequest
end

class Aws::EC2::Types::DescribeScheduledInstanceAvailabilityResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeScheduledInstanceAvailabilityResult
end

class Aws::EC2::Types::DescribeScheduledInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeScheduledInstancesRequest
end

class Aws::EC2::Types::DescribeScheduledInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeScheduledInstancesResult
end

class Aws::EC2::Types::DescribeSecurityGroupReferencesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSecurityGroupReferencesRequest
end

class Aws::EC2::Types::DescribeSecurityGroupReferencesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSecurityGroupReferencesResult
end

class Aws::EC2::Types::DescribeSecurityGroupsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSecurityGroupsRequest
end

class Aws::EC2::Types::DescribeSecurityGroupsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSecurityGroupsResult
end

class Aws::EC2::Types::DescribeSnapshotAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSnapshotAttributeRequest
end

class Aws::EC2::Types::DescribeSnapshotAttributeResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSnapshotAttributeResult
end

class Aws::EC2::Types::DescribeSnapshotsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSnapshotsRequest
end

class Aws::EC2::Types::DescribeSnapshotsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSnapshotsResult
end

class Aws::EC2::Types::DescribeSpotDatafeedSubscriptionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotDatafeedSubscriptionRequest
end

class Aws::EC2::Types::DescribeSpotDatafeedSubscriptionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotDatafeedSubscriptionResult
end

class Aws::EC2::Types::DescribeSpotFleetInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotFleetInstancesRequest
end

class Aws::EC2::Types::DescribeSpotFleetInstancesResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotFleetInstancesResponse
end

class Aws::EC2::Types::DescribeSpotFleetRequestHistoryRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotFleetRequestHistoryRequest
end

class Aws::EC2::Types::DescribeSpotFleetRequestHistoryResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotFleetRequestHistoryResponse
end

class Aws::EC2::Types::DescribeSpotFleetRequestsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotFleetRequestsRequest
end

class Aws::EC2::Types::DescribeSpotFleetRequestsResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotFleetRequestsResponse
end

class Aws::EC2::Types::DescribeSpotInstanceRequestsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotInstanceRequestsRequest
end

class Aws::EC2::Types::DescribeSpotInstanceRequestsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotInstanceRequestsResult
end

class Aws::EC2::Types::DescribeSpotPriceHistoryRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotPriceHistoryRequest
end

class Aws::EC2::Types::DescribeSpotPriceHistoryResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSpotPriceHistoryResult
end

class Aws::EC2::Types::DescribeStaleSecurityGroupsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeStaleSecurityGroupsRequest
end

class Aws::EC2::Types::DescribeStaleSecurityGroupsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeStaleSecurityGroupsResult
end

class Aws::EC2::Types::DescribeSubnetsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSubnetsRequest
end

class Aws::EC2::Types::DescribeSubnetsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeSubnetsResult
end

class Aws::EC2::Types::DescribeTagsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTagsRequest
end

class Aws::EC2::Types::DescribeTagsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTagsResult
end

class Aws::EC2::Types::DescribeTrafficMirrorFiltersRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTrafficMirrorFiltersRequest
end

class Aws::EC2::Types::DescribeTrafficMirrorFiltersResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTrafficMirrorFiltersResult
end

class Aws::EC2::Types::DescribeTrafficMirrorSessionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTrafficMirrorSessionsRequest
end

class Aws::EC2::Types::DescribeTrafficMirrorSessionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTrafficMirrorSessionsResult
end

class Aws::EC2::Types::DescribeTrafficMirrorTargetsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTrafficMirrorTargetsRequest
end

class Aws::EC2::Types::DescribeTrafficMirrorTargetsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTrafficMirrorTargetsResult
end

class Aws::EC2::Types::DescribeTransitGatewayAttachmentsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewayAttachmentsRequest
end

class Aws::EC2::Types::DescribeTransitGatewayAttachmentsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewayAttachmentsResult
end

class Aws::EC2::Types::DescribeTransitGatewayMulticastDomainsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewayMulticastDomainsRequest
end

class Aws::EC2::Types::DescribeTransitGatewayMulticastDomainsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewayMulticastDomainsResult
end

class Aws::EC2::Types::DescribeTransitGatewayPeeringAttachmentsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewayPeeringAttachmentsRequest
end

class Aws::EC2::Types::DescribeTransitGatewayPeeringAttachmentsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewayPeeringAttachmentsResult
end

class Aws::EC2::Types::DescribeTransitGatewayRouteTablesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewayRouteTablesRequest
end

class Aws::EC2::Types::DescribeTransitGatewayRouteTablesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewayRouteTablesResult
end

class Aws::EC2::Types::DescribeTransitGatewayVpcAttachmentsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewayVpcAttachmentsRequest
end

class Aws::EC2::Types::DescribeTransitGatewayVpcAttachmentsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewayVpcAttachmentsResult
end

class Aws::EC2::Types::DescribeTransitGatewaysRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewaysRequest
end

class Aws::EC2::Types::DescribeTransitGatewaysResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeTransitGatewaysResult
end

class Aws::EC2::Types::DescribeVolumeAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVolumeAttributeRequest
end

class Aws::EC2::Types::DescribeVolumeAttributeResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVolumeAttributeResult
end

class Aws::EC2::Types::DescribeVolumeStatusRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVolumeStatusRequest
end

class Aws::EC2::Types::DescribeVolumeStatusResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVolumeStatusResult
end

class Aws::EC2::Types::DescribeVolumesModificationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVolumesModificationsRequest
end

class Aws::EC2::Types::DescribeVolumesModificationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVolumesModificationsResult
end

class Aws::EC2::Types::DescribeVolumesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVolumesRequest
end

class Aws::EC2::Types::DescribeVolumesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVolumesResult
end

class Aws::EC2::Types::DescribeVpcAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcAttributeRequest
end

class Aws::EC2::Types::DescribeVpcAttributeResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcAttributeResult
end

class Aws::EC2::Types::DescribeVpcClassicLinkDnsSupportRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcClassicLinkDnsSupportRequest
end

class Aws::EC2::Types::DescribeVpcClassicLinkDnsSupportResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcClassicLinkDnsSupportResult
end

class Aws::EC2::Types::DescribeVpcClassicLinkRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcClassicLinkRequest
end

class Aws::EC2::Types::DescribeVpcClassicLinkResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcClassicLinkResult
end

class Aws::EC2::Types::DescribeVpcEndpointConnectionNotificationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointConnectionNotificationsRequest
end

class Aws::EC2::Types::DescribeVpcEndpointConnectionNotificationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointConnectionNotificationsResult
end

class Aws::EC2::Types::DescribeVpcEndpointConnectionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointConnectionsRequest
end

class Aws::EC2::Types::DescribeVpcEndpointConnectionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointConnectionsResult
end

class Aws::EC2::Types::DescribeVpcEndpointServiceConfigurationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointServiceConfigurationsRequest
end

class Aws::EC2::Types::DescribeVpcEndpointServiceConfigurationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointServiceConfigurationsResult
end

class Aws::EC2::Types::DescribeVpcEndpointServicePermissionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointServicePermissionsRequest
end

class Aws::EC2::Types::DescribeVpcEndpointServicePermissionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointServicePermissionsResult
end

class Aws::EC2::Types::DescribeVpcEndpointServicesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointServicesRequest
end

class Aws::EC2::Types::DescribeVpcEndpointServicesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointServicesResult
end

class Aws::EC2::Types::DescribeVpcEndpointsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointsRequest
end

class Aws::EC2::Types::DescribeVpcEndpointsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcEndpointsResult
end

class Aws::EC2::Types::DescribeVpcPeeringConnectionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcPeeringConnectionsRequest
end

class Aws::EC2::Types::DescribeVpcPeeringConnectionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcPeeringConnectionsResult
end

class Aws::EC2::Types::DescribeVpcsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcsRequest
end

class Aws::EC2::Types::DescribeVpcsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpcsResult
end

class Aws::EC2::Types::DescribeVpnConnectionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpnConnectionsRequest
end

class Aws::EC2::Types::DescribeVpnConnectionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpnConnectionsResult
end

class Aws::EC2::Types::DescribeVpnGatewaysRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpnGatewaysRequest
end

class Aws::EC2::Types::DescribeVpnGatewaysResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DescribeVpnGatewaysResult
end

class Aws::EC2::Types::DetachClassicLinkVpcRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DetachClassicLinkVpcRequest
end

class Aws::EC2::Types::DetachClassicLinkVpcResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DetachClassicLinkVpcResult
end

class Aws::EC2::Types::DetachInternetGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DetachInternetGatewayRequest
end

class Aws::EC2::Types::DetachNetworkInterfaceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DetachNetworkInterfaceRequest
end

class Aws::EC2::Types::DetachVolumeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DetachVolumeRequest
end

class Aws::EC2::Types::DetachVpnGatewayRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DetachVpnGatewayRequest
end

class Aws::EC2::Types::DhcpConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DhcpConfiguration
end

class Aws::EC2::Types::DhcpOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DhcpOptions
end

class Aws::EC2::Types::DirectoryServiceAuthentication
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DirectoryServiceAuthentication
end

class Aws::EC2::Types::DirectoryServiceAuthenticationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DirectoryServiceAuthenticationRequest
end

class Aws::EC2::Types::DisableEbsEncryptionByDefaultRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableEbsEncryptionByDefaultRequest
end

class Aws::EC2::Types::DisableEbsEncryptionByDefaultResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableEbsEncryptionByDefaultResult
end

class Aws::EC2::Types::DisableFastSnapshotRestoreErrorItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableFastSnapshotRestoreErrorItem
end

class Aws::EC2::Types::DisableFastSnapshotRestoreStateError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableFastSnapshotRestoreStateError
end

class Aws::EC2::Types::DisableFastSnapshotRestoreStateErrorItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableFastSnapshotRestoreStateErrorItem
end

class Aws::EC2::Types::DisableFastSnapshotRestoreSuccessItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableFastSnapshotRestoreSuccessItem
end

class Aws::EC2::Types::DisableFastSnapshotRestoresRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableFastSnapshotRestoresRequest
end

class Aws::EC2::Types::DisableFastSnapshotRestoresResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableFastSnapshotRestoresResult
end

class Aws::EC2::Types::DisableTransitGatewayRouteTablePropagationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableTransitGatewayRouteTablePropagationRequest
end

class Aws::EC2::Types::DisableTransitGatewayRouteTablePropagationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableTransitGatewayRouteTablePropagationResult
end

class Aws::EC2::Types::DisableVgwRoutePropagationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableVgwRoutePropagationRequest
end

class Aws::EC2::Types::DisableVpcClassicLinkDnsSupportRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableVpcClassicLinkDnsSupportRequest
end

class Aws::EC2::Types::DisableVpcClassicLinkDnsSupportResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableVpcClassicLinkDnsSupportResult
end

class Aws::EC2::Types::DisableVpcClassicLinkRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableVpcClassicLinkRequest
end

class Aws::EC2::Types::DisableVpcClassicLinkResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisableVpcClassicLinkResult
end

class Aws::EC2::Types::DisassociateAddressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateAddressRequest
end

class Aws::EC2::Types::DisassociateClientVpnTargetNetworkRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateClientVpnTargetNetworkRequest
end

class Aws::EC2::Types::DisassociateClientVpnTargetNetworkResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateClientVpnTargetNetworkResult
end

class Aws::EC2::Types::DisassociateIamInstanceProfileRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateIamInstanceProfileRequest
end

class Aws::EC2::Types::DisassociateIamInstanceProfileResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateIamInstanceProfileResult
end

class Aws::EC2::Types::DisassociateRouteTableRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateRouteTableRequest
end

class Aws::EC2::Types::DisassociateSubnetCidrBlockRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateSubnetCidrBlockRequest
end

class Aws::EC2::Types::DisassociateSubnetCidrBlockResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateSubnetCidrBlockResult
end

class Aws::EC2::Types::DisassociateTransitGatewayMulticastDomainRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateTransitGatewayMulticastDomainRequest
end

class Aws::EC2::Types::DisassociateTransitGatewayMulticastDomainResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateTransitGatewayMulticastDomainResult
end

class Aws::EC2::Types::DisassociateTransitGatewayRouteTableRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateTransitGatewayRouteTableRequest
end

class Aws::EC2::Types::DisassociateTransitGatewayRouteTableResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateTransitGatewayRouteTableResult
end

class Aws::EC2::Types::DisassociateVpcCidrBlockRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateVpcCidrBlockRequest
end

class Aws::EC2::Types::DisassociateVpcCidrBlockResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DisassociateVpcCidrBlockResult
end

class Aws::EC2::Types::DiskImage
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DiskImage
end

class Aws::EC2::Types::DiskImageDescription
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DiskImageDescription
end

class Aws::EC2::Types::DiskImageDetail
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DiskImageDetail
end

class Aws::EC2::Types::DiskImageVolumeDescription
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DiskImageVolumeDescription
end

class Aws::EC2::Types::DiskInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DiskInfo
end

class Aws::EC2::Types::DnsEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DnsEntry
end

class Aws::EC2::Types::DnsServersOptionsModifyStructure
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::DnsServersOptionsModifyStructure
end

class Aws::EC2::Types::EbsBlockDevice
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EbsBlockDevice
end

class Aws::EC2::Types::EbsInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EbsInfo
end

class Aws::EC2::Types::EbsInstanceBlockDevice
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EbsInstanceBlockDevice
end

class Aws::EC2::Types::EbsInstanceBlockDeviceSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EbsInstanceBlockDeviceSpecification
end

class Aws::EC2::Types::EbsOptimizedInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EbsOptimizedInfo
end

class Aws::EC2::Types::EgressOnlyInternetGateway
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EgressOnlyInternetGateway
end

class Aws::EC2::Types::ElasticGpuAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ElasticGpuAssociation
end

class Aws::EC2::Types::ElasticGpuHealth
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ElasticGpuHealth
end

class Aws::EC2::Types::ElasticGpuSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ElasticGpuSpecification
end

class Aws::EC2::Types::ElasticGpuSpecificationResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ElasticGpuSpecificationResponse
end

class Aws::EC2::Types::ElasticGpus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ElasticGpus
end

class Aws::EC2::Types::ElasticInferenceAccelerator
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ElasticInferenceAccelerator
end

class Aws::EC2::Types::ElasticInferenceAcceleratorAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ElasticInferenceAcceleratorAssociation
end

class Aws::EC2::Types::EnableEbsEncryptionByDefaultRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableEbsEncryptionByDefaultRequest
end

class Aws::EC2::Types::EnableEbsEncryptionByDefaultResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableEbsEncryptionByDefaultResult
end

class Aws::EC2::Types::EnableFastSnapshotRestoreErrorItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableFastSnapshotRestoreErrorItem
end

class Aws::EC2::Types::EnableFastSnapshotRestoreStateError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableFastSnapshotRestoreStateError
end

class Aws::EC2::Types::EnableFastSnapshotRestoreStateErrorItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableFastSnapshotRestoreStateErrorItem
end

class Aws::EC2::Types::EnableFastSnapshotRestoreSuccessItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableFastSnapshotRestoreSuccessItem
end

class Aws::EC2::Types::EnableFastSnapshotRestoresRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableFastSnapshotRestoresRequest
end

class Aws::EC2::Types::EnableFastSnapshotRestoresResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableFastSnapshotRestoresResult
end

class Aws::EC2::Types::EnableTransitGatewayRouteTablePropagationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableTransitGatewayRouteTablePropagationRequest
end

class Aws::EC2::Types::EnableTransitGatewayRouteTablePropagationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableTransitGatewayRouteTablePropagationResult
end

class Aws::EC2::Types::EnableVgwRoutePropagationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableVgwRoutePropagationRequest
end

class Aws::EC2::Types::EnableVolumeIORequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableVolumeIORequest
end

class Aws::EC2::Types::EnableVpcClassicLinkDnsSupportRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableVpcClassicLinkDnsSupportRequest
end

class Aws::EC2::Types::EnableVpcClassicLinkDnsSupportResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableVpcClassicLinkDnsSupportResult
end

class Aws::EC2::Types::EnableVpcClassicLinkRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableVpcClassicLinkRequest
end

class Aws::EC2::Types::EnableVpcClassicLinkResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EnableVpcClassicLinkResult
end

class Aws::EC2::Types::EventInformation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::EventInformation
end

class Aws::EC2::Types::ExportClientVpnClientCertificateRevocationListRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportClientVpnClientCertificateRevocationListRequest
end

class Aws::EC2::Types::ExportClientVpnClientCertificateRevocationListResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportClientVpnClientCertificateRevocationListResult
end

class Aws::EC2::Types::ExportClientVpnClientConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportClientVpnClientConfigurationRequest
end

class Aws::EC2::Types::ExportClientVpnClientConfigurationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportClientVpnClientConfigurationResult
end

class Aws::EC2::Types::ExportImageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportImageRequest
end

class Aws::EC2::Types::ExportImageResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportImageResult
end

class Aws::EC2::Types::ExportImageTask
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportImageTask
end

class Aws::EC2::Types::ExportTask
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportTask
end

class Aws::EC2::Types::ExportTaskS3Location
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportTaskS3Location
end

class Aws::EC2::Types::ExportTaskS3LocationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportTaskS3LocationRequest
end

class Aws::EC2::Types::ExportToS3Task
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportToS3Task
end

class Aws::EC2::Types::ExportToS3TaskSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportToS3TaskSpecification
end

class Aws::EC2::Types::ExportTransitGatewayRoutesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportTransitGatewayRoutesRequest
end

class Aws::EC2::Types::ExportTransitGatewayRoutesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ExportTransitGatewayRoutesResult
end

class Aws::EC2::Types::FailedQueuedPurchaseDeletion
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FailedQueuedPurchaseDeletion
end

class Aws::EC2::Types::FederatedAuthentication
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FederatedAuthentication
end

class Aws::EC2::Types::FederatedAuthenticationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FederatedAuthenticationRequest
end

class Aws::EC2::Types::Filter
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Filter
end

class Aws::EC2::Types::FleetData
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FleetData
end

class Aws::EC2::Types::FleetLaunchTemplateConfig
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FleetLaunchTemplateConfig
end

class Aws::EC2::Types::FleetLaunchTemplateConfigRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FleetLaunchTemplateConfigRequest
end

class Aws::EC2::Types::FleetLaunchTemplateOverrides
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FleetLaunchTemplateOverrides
end

class Aws::EC2::Types::FleetLaunchTemplateOverridesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FleetLaunchTemplateOverridesRequest
end

class Aws::EC2::Types::FleetLaunchTemplateSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FleetLaunchTemplateSpecification
end

class Aws::EC2::Types::FleetLaunchTemplateSpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FleetLaunchTemplateSpecificationRequest
end

class Aws::EC2::Types::FlowLog
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FlowLog
end

class Aws::EC2::Types::FpgaDeviceInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FpgaDeviceInfo
end

class Aws::EC2::Types::FpgaDeviceMemoryInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FpgaDeviceMemoryInfo
end

class Aws::EC2::Types::FpgaImage
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FpgaImage
end

class Aws::EC2::Types::FpgaImageAttribute
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FpgaImageAttribute
end

class Aws::EC2::Types::FpgaImageState
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FpgaImageState
end

class Aws::EC2::Types::FpgaInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::FpgaInfo
end

class Aws::EC2::Types::GetAssociatedIpv6PoolCidrsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetAssociatedIpv6PoolCidrsRequest
end

class Aws::EC2::Types::GetAssociatedIpv6PoolCidrsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetAssociatedIpv6PoolCidrsResult
end

class Aws::EC2::Types::GetCapacityReservationUsageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetCapacityReservationUsageRequest
end

class Aws::EC2::Types::GetCapacityReservationUsageResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetCapacityReservationUsageResult
end

class Aws::EC2::Types::GetCoipPoolUsageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetCoipPoolUsageRequest
end

class Aws::EC2::Types::GetCoipPoolUsageResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetCoipPoolUsageResult
end

class Aws::EC2::Types::GetConsoleOutputRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetConsoleOutputRequest
end

class Aws::EC2::Types::GetConsoleOutputResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetConsoleOutputResult
end

class Aws::EC2::Types::GetConsoleScreenshotRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetConsoleScreenshotRequest
end

class Aws::EC2::Types::GetConsoleScreenshotResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetConsoleScreenshotResult
end

class Aws::EC2::Types::GetDefaultCreditSpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetDefaultCreditSpecificationRequest
end

class Aws::EC2::Types::GetDefaultCreditSpecificationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetDefaultCreditSpecificationResult
end

class Aws::EC2::Types::GetEbsDefaultKmsKeyIdRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetEbsDefaultKmsKeyIdRequest
end

class Aws::EC2::Types::GetEbsDefaultKmsKeyIdResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetEbsDefaultKmsKeyIdResult
end

class Aws::EC2::Types::GetEbsEncryptionByDefaultRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetEbsEncryptionByDefaultRequest
end

class Aws::EC2::Types::GetEbsEncryptionByDefaultResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetEbsEncryptionByDefaultResult
end

class Aws::EC2::Types::GetHostReservationPurchasePreviewRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetHostReservationPurchasePreviewRequest
end

class Aws::EC2::Types::GetHostReservationPurchasePreviewResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetHostReservationPurchasePreviewResult
end

class Aws::EC2::Types::GetLaunchTemplateDataRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetLaunchTemplateDataRequest
end

class Aws::EC2::Types::GetLaunchTemplateDataResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetLaunchTemplateDataResult
end

class Aws::EC2::Types::GetManagedPrefixListAssociationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetManagedPrefixListAssociationsRequest
end

class Aws::EC2::Types::GetManagedPrefixListAssociationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetManagedPrefixListAssociationsResult
end

class Aws::EC2::Types::GetManagedPrefixListEntriesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetManagedPrefixListEntriesRequest
end

class Aws::EC2::Types::GetManagedPrefixListEntriesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetManagedPrefixListEntriesResult
end

class Aws::EC2::Types::GetPasswordDataRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetPasswordDataRequest
end

class Aws::EC2::Types::GetPasswordDataResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetPasswordDataResult
end

class Aws::EC2::Types::GetReservedInstancesExchangeQuoteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetReservedInstancesExchangeQuoteRequest
end

class Aws::EC2::Types::GetReservedInstancesExchangeQuoteResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetReservedInstancesExchangeQuoteResult
end

class Aws::EC2::Types::GetTransitGatewayAttachmentPropagationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetTransitGatewayAttachmentPropagationsRequest
end

class Aws::EC2::Types::GetTransitGatewayAttachmentPropagationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetTransitGatewayAttachmentPropagationsResult
end

class Aws::EC2::Types::GetTransitGatewayMulticastDomainAssociationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetTransitGatewayMulticastDomainAssociationsRequest
end

class Aws::EC2::Types::GetTransitGatewayMulticastDomainAssociationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetTransitGatewayMulticastDomainAssociationsResult
end

class Aws::EC2::Types::GetTransitGatewayRouteTableAssociationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetTransitGatewayRouteTableAssociationsRequest
end

class Aws::EC2::Types::GetTransitGatewayRouteTableAssociationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetTransitGatewayRouteTableAssociationsResult
end

class Aws::EC2::Types::GetTransitGatewayRouteTablePropagationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetTransitGatewayRouteTablePropagationsRequest
end

class Aws::EC2::Types::GetTransitGatewayRouteTablePropagationsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GetTransitGatewayRouteTablePropagationsResult
end

class Aws::EC2::Types::GpuDeviceInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GpuDeviceInfo
end

class Aws::EC2::Types::GpuDeviceMemoryInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GpuDeviceMemoryInfo
end

class Aws::EC2::Types::GpuInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GpuInfo
end

class Aws::EC2::Types::GroupIdentifier
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::GroupIdentifier
end

class Aws::EC2::Types::HibernationOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::HibernationOptions
end

class Aws::EC2::Types::HibernationOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::HibernationOptionsRequest
end

class Aws::EC2::Types::HistoryRecord
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::HistoryRecord
end

class Aws::EC2::Types::HistoryRecordEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::HistoryRecordEntry
end

class Aws::EC2::Types::Host
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Host
end

class Aws::EC2::Types::HostInstance
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::HostInstance
end

class Aws::EC2::Types::HostOffering
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::HostOffering
end

class Aws::EC2::Types::HostProperties
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::HostProperties
end

class Aws::EC2::Types::HostReservation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::HostReservation
end

class Aws::EC2::Types::IKEVersionsListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::IKEVersionsListValue
end

class Aws::EC2::Types::IKEVersionsRequestListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::IKEVersionsRequestListValue
end

class Aws::EC2::Types::IamInstanceProfile
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::IamInstanceProfile
end

class Aws::EC2::Types::IamInstanceProfileAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::IamInstanceProfileAssociation
end

class Aws::EC2::Types::IamInstanceProfileSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::IamInstanceProfileSpecification
end

class Aws::EC2::Types::IcmpTypeCode
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::IcmpTypeCode
end

class Aws::EC2::Types::IdFormat
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::IdFormat
end

class Aws::EC2::Types::Image
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Image
end

class Aws::EC2::Types::ImageAttribute
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImageAttribute
end

class Aws::EC2::Types::ImageDiskContainer
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImageDiskContainer
end

class Aws::EC2::Types::ImportClientVpnClientCertificateRevocationListRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportClientVpnClientCertificateRevocationListRequest
end

class Aws::EC2::Types::ImportClientVpnClientCertificateRevocationListResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportClientVpnClientCertificateRevocationListResult
end

class Aws::EC2::Types::ImportImageLicenseConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportImageLicenseConfigurationRequest
end

class Aws::EC2::Types::ImportImageLicenseConfigurationResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportImageLicenseConfigurationResponse
end

class Aws::EC2::Types::ImportImageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportImageRequest
end

class Aws::EC2::Types::ImportImageResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportImageResult
end

class Aws::EC2::Types::ImportImageTask
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportImageTask
end

class Aws::EC2::Types::ImportInstanceLaunchSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportInstanceLaunchSpecification
end

class Aws::EC2::Types::ImportInstanceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportInstanceRequest
end

class Aws::EC2::Types::ImportInstanceResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportInstanceResult
end

class Aws::EC2::Types::ImportInstanceTaskDetails
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportInstanceTaskDetails
end

class Aws::EC2::Types::ImportInstanceVolumeDetailItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportInstanceVolumeDetailItem
end

class Aws::EC2::Types::ImportKeyPairRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportKeyPairRequest
end

class Aws::EC2::Types::ImportKeyPairResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportKeyPairResult
end

class Aws::EC2::Types::ImportSnapshotRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportSnapshotRequest
end

class Aws::EC2::Types::ImportSnapshotResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportSnapshotResult
end

class Aws::EC2::Types::ImportSnapshotTask
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportSnapshotTask
end

class Aws::EC2::Types::ImportVolumeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportVolumeRequest
end

class Aws::EC2::Types::ImportVolumeResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportVolumeResult
end

class Aws::EC2::Types::ImportVolumeTaskDetails
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ImportVolumeTaskDetails
end

class Aws::EC2::Types::InferenceAcceleratorInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InferenceAcceleratorInfo
end

class Aws::EC2::Types::InferenceDeviceInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InferenceDeviceInfo
end

class Aws::EC2::Types::Instance
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Instance
end

class Aws::EC2::Types::InstanceAttribute
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceAttribute
end

class Aws::EC2::Types::InstanceBlockDeviceMapping
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceBlockDeviceMapping
end

class Aws::EC2::Types::InstanceBlockDeviceMappingSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceBlockDeviceMappingSpecification
end

class Aws::EC2::Types::InstanceCapacity
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceCapacity
end

class Aws::EC2::Types::InstanceCount
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceCount
end

class Aws::EC2::Types::InstanceCreditSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceCreditSpecification
end

class Aws::EC2::Types::InstanceCreditSpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceCreditSpecificationRequest
end

class Aws::EC2::Types::InstanceExportDetails
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceExportDetails
end

class Aws::EC2::Types::InstanceFamilyCreditSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceFamilyCreditSpecification
end

class Aws::EC2::Types::InstanceIpv6Address
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceIpv6Address
end

class Aws::EC2::Types::InstanceIpv6AddressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceIpv6AddressRequest
end

class Aws::EC2::Types::InstanceMarketOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceMarketOptionsRequest
end

class Aws::EC2::Types::InstanceMetadataOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceMetadataOptionsRequest
end

class Aws::EC2::Types::InstanceMetadataOptionsResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceMetadataOptionsResponse
end

class Aws::EC2::Types::InstanceMonitoring
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceMonitoring
end

class Aws::EC2::Types::InstanceNetworkInterface
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceNetworkInterface
end

class Aws::EC2::Types::InstanceNetworkInterfaceAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceNetworkInterfaceAssociation
end

class Aws::EC2::Types::InstanceNetworkInterfaceAttachment
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceNetworkInterfaceAttachment
end

class Aws::EC2::Types::InstanceNetworkInterfaceSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceNetworkInterfaceSpecification
end

class Aws::EC2::Types::InstancePrivateIpAddress
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstancePrivateIpAddress
end

class Aws::EC2::Types::InstanceSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceSpecification
end

class Aws::EC2::Types::InstanceState
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceState
end

class Aws::EC2::Types::InstanceStateChange
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceStateChange
end

class Aws::EC2::Types::InstanceStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceStatus
end

class Aws::EC2::Types::InstanceStatusDetails
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceStatusDetails
end

class Aws::EC2::Types::InstanceStatusEvent
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceStatusEvent
end

class Aws::EC2::Types::InstanceStatusSummary
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceStatusSummary
end

class Aws::EC2::Types::InstanceStorageInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceStorageInfo
end

class Aws::EC2::Types::InstanceTagNotificationAttribute
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceTagNotificationAttribute
end

class Aws::EC2::Types::InstanceTypeInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceTypeInfo
end

class Aws::EC2::Types::InstanceTypeOffering
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceTypeOffering
end

class Aws::EC2::Types::InstanceUsage
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InstanceUsage
end

class Aws::EC2::Types::InternetGateway
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InternetGateway
end

class Aws::EC2::Types::InternetGatewayAttachment
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::InternetGatewayAttachment
end

class Aws::EC2::Types::IpPermission
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::IpPermission
end

class Aws::EC2::Types::IpRange
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::IpRange
end

class Aws::EC2::Types::Ipv6CidrAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Ipv6CidrAssociation
end

class Aws::EC2::Types::Ipv6CidrBlock
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Ipv6CidrBlock
end

class Aws::EC2::Types::Ipv6Pool
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Ipv6Pool
end

class Aws::EC2::Types::Ipv6Range
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Ipv6Range
end

class Aws::EC2::Types::KeyPair
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::KeyPair
end

class Aws::EC2::Types::KeyPairInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::KeyPairInfo
end

class Aws::EC2::Types::LastError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LastError
end

class Aws::EC2::Types::LaunchPermission
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchPermission
end

class Aws::EC2::Types::LaunchPermissionModifications
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchPermissionModifications
end

class Aws::EC2::Types::LaunchSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchSpecification
end

class Aws::EC2::Types::LaunchTemplate
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplate
end

class Aws::EC2::Types::LaunchTemplateAndOverridesResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateAndOverridesResponse
end

class Aws::EC2::Types::LaunchTemplateBlockDeviceMapping
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateBlockDeviceMapping
end

class Aws::EC2::Types::LaunchTemplateBlockDeviceMappingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateBlockDeviceMappingRequest
end

class Aws::EC2::Types::LaunchTemplateCapacityReservationSpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateCapacityReservationSpecificationRequest
end

class Aws::EC2::Types::LaunchTemplateCapacityReservationSpecificationResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateCapacityReservationSpecificationResponse
end

class Aws::EC2::Types::LaunchTemplateConfig
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateConfig
end

class Aws::EC2::Types::LaunchTemplateCpuOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateCpuOptions
end

class Aws::EC2::Types::LaunchTemplateCpuOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateCpuOptionsRequest
end

class Aws::EC2::Types::LaunchTemplateEbsBlockDevice
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateEbsBlockDevice
end

class Aws::EC2::Types::LaunchTemplateEbsBlockDeviceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateEbsBlockDeviceRequest
end

class Aws::EC2::Types::LaunchTemplateElasticInferenceAccelerator
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateElasticInferenceAccelerator
end

class Aws::EC2::Types::LaunchTemplateElasticInferenceAcceleratorResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateElasticInferenceAcceleratorResponse
end

class Aws::EC2::Types::LaunchTemplateHibernationOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateHibernationOptions
end

class Aws::EC2::Types::LaunchTemplateHibernationOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateHibernationOptionsRequest
end

class Aws::EC2::Types::LaunchTemplateIamInstanceProfileSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateIamInstanceProfileSpecification
end

class Aws::EC2::Types::LaunchTemplateIamInstanceProfileSpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateIamInstanceProfileSpecificationRequest
end

class Aws::EC2::Types::LaunchTemplateInstanceMarketOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateInstanceMarketOptions
end

class Aws::EC2::Types::LaunchTemplateInstanceMarketOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateInstanceMarketOptionsRequest
end

class Aws::EC2::Types::LaunchTemplateInstanceMetadataOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateInstanceMetadataOptions
end

class Aws::EC2::Types::LaunchTemplateInstanceMetadataOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateInstanceMetadataOptionsRequest
end

class Aws::EC2::Types::LaunchTemplateInstanceNetworkInterfaceSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateInstanceNetworkInterfaceSpecification
end

class Aws::EC2::Types::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest
end

class Aws::EC2::Types::LaunchTemplateLicenseConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateLicenseConfiguration
end

class Aws::EC2::Types::LaunchTemplateLicenseConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateLicenseConfigurationRequest
end

class Aws::EC2::Types::LaunchTemplateOverrides
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateOverrides
end

class Aws::EC2::Types::LaunchTemplatePlacement
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplatePlacement
end

class Aws::EC2::Types::LaunchTemplatePlacementRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplatePlacementRequest
end

class Aws::EC2::Types::LaunchTemplateSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateSpecification
end

class Aws::EC2::Types::LaunchTemplateSpotMarketOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateSpotMarketOptions
end

class Aws::EC2::Types::LaunchTemplateSpotMarketOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateSpotMarketOptionsRequest
end

class Aws::EC2::Types::LaunchTemplateTagSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateTagSpecification
end

class Aws::EC2::Types::LaunchTemplateTagSpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateTagSpecificationRequest
end

class Aws::EC2::Types::LaunchTemplateVersion
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplateVersion
end

class Aws::EC2::Types::LaunchTemplatesMonitoring
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplatesMonitoring
end

class Aws::EC2::Types::LaunchTemplatesMonitoringRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LaunchTemplatesMonitoringRequest
end

class Aws::EC2::Types::LicenseConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LicenseConfiguration
end

class Aws::EC2::Types::LicenseConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LicenseConfigurationRequest
end

class Aws::EC2::Types::LoadBalancersConfig
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LoadBalancersConfig
end

class Aws::EC2::Types::LoadPermission
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LoadPermission
end

class Aws::EC2::Types::LoadPermissionModifications
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LoadPermissionModifications
end

class Aws::EC2::Types::LoadPermissionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LoadPermissionRequest
end

class Aws::EC2::Types::LocalGateway
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LocalGateway
end

class Aws::EC2::Types::LocalGatewayRoute
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LocalGatewayRoute
end

class Aws::EC2::Types::LocalGatewayRouteTable
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LocalGatewayRouteTable
end

class Aws::EC2::Types::LocalGatewayRouteTableVirtualInterfaceGroupAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LocalGatewayRouteTableVirtualInterfaceGroupAssociation
end

class Aws::EC2::Types::LocalGatewayRouteTableVpcAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LocalGatewayRouteTableVpcAssociation
end

class Aws::EC2::Types::LocalGatewayVirtualInterface
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LocalGatewayVirtualInterface
end

class Aws::EC2::Types::LocalGatewayVirtualInterfaceGroup
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::LocalGatewayVirtualInterfaceGroup
end

class Aws::EC2::Types::ManagedPrefixList
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ManagedPrefixList
end

class Aws::EC2::Types::MemoryInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::MemoryInfo
end

class Aws::EC2::Types::ModifyAvailabilityZoneGroupRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyAvailabilityZoneGroupRequest
end

class Aws::EC2::Types::ModifyAvailabilityZoneGroupResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyAvailabilityZoneGroupResult
end

class Aws::EC2::Types::ModifyCapacityReservationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyCapacityReservationRequest
end

class Aws::EC2::Types::ModifyCapacityReservationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyCapacityReservationResult
end

class Aws::EC2::Types::ModifyClientVpnEndpointRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyClientVpnEndpointRequest
end

class Aws::EC2::Types::ModifyClientVpnEndpointResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyClientVpnEndpointResult
end

class Aws::EC2::Types::ModifyDefaultCreditSpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyDefaultCreditSpecificationRequest
end

class Aws::EC2::Types::ModifyDefaultCreditSpecificationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyDefaultCreditSpecificationResult
end

class Aws::EC2::Types::ModifyEbsDefaultKmsKeyIdRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyEbsDefaultKmsKeyIdRequest
end

class Aws::EC2::Types::ModifyEbsDefaultKmsKeyIdResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyEbsDefaultKmsKeyIdResult
end

class Aws::EC2::Types::ModifyFleetRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyFleetRequest
end

class Aws::EC2::Types::ModifyFleetResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyFleetResult
end

class Aws::EC2::Types::ModifyFpgaImageAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyFpgaImageAttributeRequest
end

class Aws::EC2::Types::ModifyFpgaImageAttributeResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyFpgaImageAttributeResult
end

class Aws::EC2::Types::ModifyHostsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyHostsRequest
end

class Aws::EC2::Types::ModifyHostsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyHostsResult
end

class Aws::EC2::Types::ModifyIdFormatRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyIdFormatRequest
end

class Aws::EC2::Types::ModifyIdentityIdFormatRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyIdentityIdFormatRequest
end

class Aws::EC2::Types::ModifyImageAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyImageAttributeRequest
end

class Aws::EC2::Types::ModifyInstanceAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstanceAttributeRequest
end

class Aws::EC2::Types::ModifyInstanceCapacityReservationAttributesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstanceCapacityReservationAttributesRequest
end

class Aws::EC2::Types::ModifyInstanceCapacityReservationAttributesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstanceCapacityReservationAttributesResult
end

class Aws::EC2::Types::ModifyInstanceCreditSpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstanceCreditSpecificationRequest
end

class Aws::EC2::Types::ModifyInstanceCreditSpecificationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstanceCreditSpecificationResult
end

class Aws::EC2::Types::ModifyInstanceEventStartTimeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstanceEventStartTimeRequest
end

class Aws::EC2::Types::ModifyInstanceEventStartTimeResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstanceEventStartTimeResult
end

class Aws::EC2::Types::ModifyInstanceMetadataOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstanceMetadataOptionsRequest
end

class Aws::EC2::Types::ModifyInstanceMetadataOptionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstanceMetadataOptionsResult
end

class Aws::EC2::Types::ModifyInstancePlacementRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstancePlacementRequest
end

class Aws::EC2::Types::ModifyInstancePlacementResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyInstancePlacementResult
end

class Aws::EC2::Types::ModifyLaunchTemplateRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyLaunchTemplateRequest
end

class Aws::EC2::Types::ModifyLaunchTemplateResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyLaunchTemplateResult
end

class Aws::EC2::Types::ModifyManagedPrefixListRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyManagedPrefixListRequest
end

class Aws::EC2::Types::ModifyManagedPrefixListResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyManagedPrefixListResult
end

class Aws::EC2::Types::ModifyNetworkInterfaceAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyNetworkInterfaceAttributeRequest
end

class Aws::EC2::Types::ModifyReservedInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyReservedInstancesRequest
end

class Aws::EC2::Types::ModifyReservedInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyReservedInstancesResult
end

class Aws::EC2::Types::ModifySnapshotAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifySnapshotAttributeRequest
end

class Aws::EC2::Types::ModifySpotFleetRequestRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifySpotFleetRequestRequest
end

class Aws::EC2::Types::ModifySpotFleetRequestResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifySpotFleetRequestResponse
end

class Aws::EC2::Types::ModifySubnetAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifySubnetAttributeRequest
end

class Aws::EC2::Types::ModifyTrafficMirrorFilterNetworkServicesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyTrafficMirrorFilterNetworkServicesRequest
end

class Aws::EC2::Types::ModifyTrafficMirrorFilterNetworkServicesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyTrafficMirrorFilterNetworkServicesResult
end

class Aws::EC2::Types::ModifyTrafficMirrorFilterRuleRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyTrafficMirrorFilterRuleRequest
end

class Aws::EC2::Types::ModifyTrafficMirrorFilterRuleResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyTrafficMirrorFilterRuleResult
end

class Aws::EC2::Types::ModifyTrafficMirrorSessionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyTrafficMirrorSessionRequest
end

class Aws::EC2::Types::ModifyTrafficMirrorSessionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyTrafficMirrorSessionResult
end

class Aws::EC2::Types::ModifyTransitGatewayVpcAttachmentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyTransitGatewayVpcAttachmentRequest
end

class Aws::EC2::Types::ModifyTransitGatewayVpcAttachmentRequestOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyTransitGatewayVpcAttachmentRequestOptions
end

class Aws::EC2::Types::ModifyTransitGatewayVpcAttachmentResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyTransitGatewayVpcAttachmentResult
end

class Aws::EC2::Types::ModifyVolumeAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVolumeAttributeRequest
end

class Aws::EC2::Types::ModifyVolumeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVolumeRequest
end

class Aws::EC2::Types::ModifyVolumeResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVolumeResult
end

class Aws::EC2::Types::ModifyVpcAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcAttributeRequest
end

class Aws::EC2::Types::ModifyVpcEndpointConnectionNotificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcEndpointConnectionNotificationRequest
end

class Aws::EC2::Types::ModifyVpcEndpointConnectionNotificationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcEndpointConnectionNotificationResult
end

class Aws::EC2::Types::ModifyVpcEndpointRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcEndpointRequest
end

class Aws::EC2::Types::ModifyVpcEndpointResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcEndpointResult
end

class Aws::EC2::Types::ModifyVpcEndpointServiceConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcEndpointServiceConfigurationRequest
end

class Aws::EC2::Types::ModifyVpcEndpointServiceConfigurationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcEndpointServiceConfigurationResult
end

class Aws::EC2::Types::ModifyVpcEndpointServicePermissionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcEndpointServicePermissionsRequest
end

class Aws::EC2::Types::ModifyVpcEndpointServicePermissionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcEndpointServicePermissionsResult
end

class Aws::EC2::Types::ModifyVpcPeeringConnectionOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcPeeringConnectionOptionsRequest
end

class Aws::EC2::Types::ModifyVpcPeeringConnectionOptionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcPeeringConnectionOptionsResult
end

class Aws::EC2::Types::ModifyVpcTenancyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcTenancyRequest
end

class Aws::EC2::Types::ModifyVpcTenancyResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpcTenancyResult
end

class Aws::EC2::Types::ModifyVpnConnectionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpnConnectionRequest
end

class Aws::EC2::Types::ModifyVpnConnectionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpnConnectionResult
end

class Aws::EC2::Types::ModifyVpnTunnelCertificateRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpnTunnelCertificateRequest
end

class Aws::EC2::Types::ModifyVpnTunnelCertificateResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpnTunnelCertificateResult
end

class Aws::EC2::Types::ModifyVpnTunnelOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpnTunnelOptionsRequest
end

class Aws::EC2::Types::ModifyVpnTunnelOptionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpnTunnelOptionsResult
end

class Aws::EC2::Types::ModifyVpnTunnelOptionsSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ModifyVpnTunnelOptionsSpecification
end

class Aws::EC2::Types::MonitorInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::MonitorInstancesRequest
end

class Aws::EC2::Types::MonitorInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::MonitorInstancesResult
end

class Aws::EC2::Types::Monitoring
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Monitoring
end

class Aws::EC2::Types::MoveAddressToVpcRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::MoveAddressToVpcRequest
end

class Aws::EC2::Types::MoveAddressToVpcResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::MoveAddressToVpcResult
end

class Aws::EC2::Types::MovingAddressStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::MovingAddressStatus
end

class Aws::EC2::Types::NatGateway
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NatGateway
end

class Aws::EC2::Types::NatGatewayAddress
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NatGatewayAddress
end

class Aws::EC2::Types::NetworkAcl
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkAcl
end

class Aws::EC2::Types::NetworkAclAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkAclAssociation
end

class Aws::EC2::Types::NetworkAclEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkAclEntry
end

class Aws::EC2::Types::NetworkInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkInfo
end

class Aws::EC2::Types::NetworkInterface
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkInterface
end

class Aws::EC2::Types::NetworkInterfaceAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkInterfaceAssociation
end

class Aws::EC2::Types::NetworkInterfaceAttachment
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkInterfaceAttachment
end

class Aws::EC2::Types::NetworkInterfaceAttachmentChanges
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkInterfaceAttachmentChanges
end

class Aws::EC2::Types::NetworkInterfaceIpv6Address
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkInterfaceIpv6Address
end

class Aws::EC2::Types::NetworkInterfacePermission
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkInterfacePermission
end

class Aws::EC2::Types::NetworkInterfacePermissionState
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkInterfacePermissionState
end

class Aws::EC2::Types::NetworkInterfacePrivateIpAddress
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NetworkInterfacePrivateIpAddress
end

class Aws::EC2::Types::NewDhcpConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::NewDhcpConfiguration
end

class Aws::EC2::Types::OnDemandOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::OnDemandOptions
end

class Aws::EC2::Types::OnDemandOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::OnDemandOptionsRequest
end

class Aws::EC2::Types::PciId
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PciId
end

class Aws::EC2::Types::PeeringAttachmentStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PeeringAttachmentStatus
end

class Aws::EC2::Types::PeeringConnectionOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PeeringConnectionOptions
end

class Aws::EC2::Types::PeeringConnectionOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PeeringConnectionOptionsRequest
end

class Aws::EC2::Types::PeeringTgwInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PeeringTgwInfo
end

class Aws::EC2::Types::Phase1DHGroupNumbersListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase1DHGroupNumbersListValue
end

class Aws::EC2::Types::Phase1DHGroupNumbersRequestListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase1DHGroupNumbersRequestListValue
end

class Aws::EC2::Types::Phase1EncryptionAlgorithmsListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase1EncryptionAlgorithmsListValue
end

class Aws::EC2::Types::Phase1EncryptionAlgorithmsRequestListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase1EncryptionAlgorithmsRequestListValue
end

class Aws::EC2::Types::Phase1IntegrityAlgorithmsListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase1IntegrityAlgorithmsListValue
end

class Aws::EC2::Types::Phase1IntegrityAlgorithmsRequestListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase1IntegrityAlgorithmsRequestListValue
end

class Aws::EC2::Types::Phase2DHGroupNumbersListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase2DHGroupNumbersListValue
end

class Aws::EC2::Types::Phase2DHGroupNumbersRequestListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase2DHGroupNumbersRequestListValue
end

class Aws::EC2::Types::Phase2EncryptionAlgorithmsListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase2EncryptionAlgorithmsListValue
end

class Aws::EC2::Types::Phase2EncryptionAlgorithmsRequestListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase2EncryptionAlgorithmsRequestListValue
end

class Aws::EC2::Types::Phase2IntegrityAlgorithmsListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase2IntegrityAlgorithmsListValue
end

class Aws::EC2::Types::Phase2IntegrityAlgorithmsRequestListValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Phase2IntegrityAlgorithmsRequestListValue
end

class Aws::EC2::Types::Placement
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Placement
end

class Aws::EC2::Types::PlacementGroup
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PlacementGroup
end

class Aws::EC2::Types::PlacementGroupInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PlacementGroupInfo
end

class Aws::EC2::Types::PlacementResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PlacementResponse
end

class Aws::EC2::Types::PoolCidrBlock
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PoolCidrBlock
end

class Aws::EC2::Types::PortRange
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PortRange
end

class Aws::EC2::Types::PrefixList
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PrefixList
end

class Aws::EC2::Types::PrefixListAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PrefixListAssociation
end

class Aws::EC2::Types::PrefixListEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PrefixListEntry
end

class Aws::EC2::Types::PrefixListId
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PrefixListId
end

class Aws::EC2::Types::PriceSchedule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PriceSchedule
end

class Aws::EC2::Types::PriceScheduleSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PriceScheduleSpecification
end

class Aws::EC2::Types::PricingDetail
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PricingDetail
end

class Aws::EC2::Types::PrincipalIdFormat
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PrincipalIdFormat
end

class Aws::EC2::Types::PrivateDnsNameConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PrivateDnsNameConfiguration
end

class Aws::EC2::Types::PrivateIpAddressSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PrivateIpAddressSpecification
end

class Aws::EC2::Types::ProcessorInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ProcessorInfo
end

class Aws::EC2::Types::ProductCode
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ProductCode
end

class Aws::EC2::Types::PropagatingVgw
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PropagatingVgw
end

class Aws::EC2::Types::ProvisionByoipCidrRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ProvisionByoipCidrRequest
end

class Aws::EC2::Types::ProvisionByoipCidrResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ProvisionByoipCidrResult
end

class Aws::EC2::Types::ProvisionedBandwidth
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ProvisionedBandwidth
end

class Aws::EC2::Types::PublicIpv4Pool
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PublicIpv4Pool
end

class Aws::EC2::Types::PublicIpv4PoolRange
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PublicIpv4PoolRange
end

class Aws::EC2::Types::Purchase
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Purchase
end

class Aws::EC2::Types::PurchaseHostReservationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PurchaseHostReservationRequest
end

class Aws::EC2::Types::PurchaseHostReservationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PurchaseHostReservationResult
end

class Aws::EC2::Types::PurchaseRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PurchaseRequest
end

class Aws::EC2::Types::PurchaseReservedInstancesOfferingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PurchaseReservedInstancesOfferingRequest
end

class Aws::EC2::Types::PurchaseReservedInstancesOfferingResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PurchaseReservedInstancesOfferingResult
end

class Aws::EC2::Types::PurchaseScheduledInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PurchaseScheduledInstancesRequest
end

class Aws::EC2::Types::PurchaseScheduledInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::PurchaseScheduledInstancesResult
end

class Aws::EC2::Types::RebootInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RebootInstancesRequest
end

class Aws::EC2::Types::RecurringCharge
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RecurringCharge
end

class Aws::EC2::Types::Region
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Region
end

class Aws::EC2::Types::RegisterImageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RegisterImageRequest
end

class Aws::EC2::Types::RegisterImageResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RegisterImageResult
end

class Aws::EC2::Types::RegisterInstanceEventNotificationAttributesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RegisterInstanceEventNotificationAttributesRequest
end

class Aws::EC2::Types::RegisterInstanceEventNotificationAttributesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RegisterInstanceEventNotificationAttributesResult
end

class Aws::EC2::Types::RegisterInstanceTagAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RegisterInstanceTagAttributeRequest
end

class Aws::EC2::Types::RegisterTransitGatewayMulticastGroupMembersRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RegisterTransitGatewayMulticastGroupMembersRequest
end

class Aws::EC2::Types::RegisterTransitGatewayMulticastGroupMembersResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RegisterTransitGatewayMulticastGroupMembersResult
end

class Aws::EC2::Types::RegisterTransitGatewayMulticastGroupSourcesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RegisterTransitGatewayMulticastGroupSourcesRequest
end

class Aws::EC2::Types::RegisterTransitGatewayMulticastGroupSourcesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RegisterTransitGatewayMulticastGroupSourcesResult
end

class Aws::EC2::Types::RejectTransitGatewayPeeringAttachmentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RejectTransitGatewayPeeringAttachmentRequest
end

class Aws::EC2::Types::RejectTransitGatewayPeeringAttachmentResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RejectTransitGatewayPeeringAttachmentResult
end

class Aws::EC2::Types::RejectTransitGatewayVpcAttachmentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RejectTransitGatewayVpcAttachmentRequest
end

class Aws::EC2::Types::RejectTransitGatewayVpcAttachmentResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RejectTransitGatewayVpcAttachmentResult
end

class Aws::EC2::Types::RejectVpcEndpointConnectionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RejectVpcEndpointConnectionsRequest
end

class Aws::EC2::Types::RejectVpcEndpointConnectionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RejectVpcEndpointConnectionsResult
end

class Aws::EC2::Types::RejectVpcPeeringConnectionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RejectVpcPeeringConnectionRequest
end

class Aws::EC2::Types::RejectVpcPeeringConnectionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RejectVpcPeeringConnectionResult
end

class Aws::EC2::Types::ReleaseAddressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReleaseAddressRequest
end

class Aws::EC2::Types::ReleaseHostsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReleaseHostsRequest
end

class Aws::EC2::Types::ReleaseHostsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReleaseHostsResult
end

class Aws::EC2::Types::RemovePrefixListEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RemovePrefixListEntry
end

class Aws::EC2::Types::ReplaceIamInstanceProfileAssociationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReplaceIamInstanceProfileAssociationRequest
end

class Aws::EC2::Types::ReplaceIamInstanceProfileAssociationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReplaceIamInstanceProfileAssociationResult
end

class Aws::EC2::Types::ReplaceNetworkAclAssociationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReplaceNetworkAclAssociationRequest
end

class Aws::EC2::Types::ReplaceNetworkAclAssociationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReplaceNetworkAclAssociationResult
end

class Aws::EC2::Types::ReplaceNetworkAclEntryRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReplaceNetworkAclEntryRequest
end

class Aws::EC2::Types::ReplaceRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReplaceRouteRequest
end

class Aws::EC2::Types::ReplaceRouteTableAssociationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReplaceRouteTableAssociationRequest
end

class Aws::EC2::Types::ReplaceRouteTableAssociationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReplaceRouteTableAssociationResult
end

class Aws::EC2::Types::ReplaceTransitGatewayRouteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReplaceTransitGatewayRouteRequest
end

class Aws::EC2::Types::ReplaceTransitGatewayRouteResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReplaceTransitGatewayRouteResult
end

class Aws::EC2::Types::ReportInstanceStatusRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReportInstanceStatusRequest
end

class Aws::EC2::Types::RequestLaunchTemplateData
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RequestLaunchTemplateData
end

class Aws::EC2::Types::RequestSpotFleetRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RequestSpotFleetRequest
end

class Aws::EC2::Types::RequestSpotFleetResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RequestSpotFleetResponse
end

class Aws::EC2::Types::RequestSpotInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RequestSpotInstancesRequest
end

class Aws::EC2::Types::RequestSpotInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RequestSpotInstancesResult
end

class Aws::EC2::Types::RequestSpotLaunchSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RequestSpotLaunchSpecification
end

class Aws::EC2::Types::Reservation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Reservation
end

class Aws::EC2::Types::ReservationValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReservationValue
end

class Aws::EC2::Types::ReservedInstanceLimitPrice
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReservedInstanceLimitPrice
end

class Aws::EC2::Types::ReservedInstanceReservationValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReservedInstanceReservationValue
end

class Aws::EC2::Types::ReservedInstances
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReservedInstances
end

class Aws::EC2::Types::ReservedInstancesConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReservedInstancesConfiguration
end

class Aws::EC2::Types::ReservedInstancesId
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReservedInstancesId
end

class Aws::EC2::Types::ReservedInstancesListing
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReservedInstancesListing
end

class Aws::EC2::Types::ReservedInstancesModification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReservedInstancesModification
end

class Aws::EC2::Types::ReservedInstancesModificationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReservedInstancesModificationResult
end

class Aws::EC2::Types::ReservedInstancesOffering
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ReservedInstancesOffering
end

class Aws::EC2::Types::ResetEbsDefaultKmsKeyIdRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ResetEbsDefaultKmsKeyIdRequest
end

class Aws::EC2::Types::ResetEbsDefaultKmsKeyIdResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ResetEbsDefaultKmsKeyIdResult
end

class Aws::EC2::Types::ResetFpgaImageAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ResetFpgaImageAttributeRequest
end

class Aws::EC2::Types::ResetFpgaImageAttributeResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ResetFpgaImageAttributeResult
end

class Aws::EC2::Types::ResetImageAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ResetImageAttributeRequest
end

class Aws::EC2::Types::ResetInstanceAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ResetInstanceAttributeRequest
end

class Aws::EC2::Types::ResetNetworkInterfaceAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ResetNetworkInterfaceAttributeRequest
end

class Aws::EC2::Types::ResetSnapshotAttributeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ResetSnapshotAttributeRequest
end

class Aws::EC2::Types::ResponseError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ResponseError
end

class Aws::EC2::Types::ResponseLaunchTemplateData
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ResponseLaunchTemplateData
end

class Aws::EC2::Types::RestoreAddressToClassicRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RestoreAddressToClassicRequest
end

class Aws::EC2::Types::RestoreAddressToClassicResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RestoreAddressToClassicResult
end

class Aws::EC2::Types::RestoreManagedPrefixListVersionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RestoreManagedPrefixListVersionRequest
end

class Aws::EC2::Types::RestoreManagedPrefixListVersionResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RestoreManagedPrefixListVersionResult
end

class Aws::EC2::Types::RevokeClientVpnIngressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RevokeClientVpnIngressRequest
end

class Aws::EC2::Types::RevokeClientVpnIngressResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RevokeClientVpnIngressResult
end

class Aws::EC2::Types::RevokeSecurityGroupEgressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RevokeSecurityGroupEgressRequest
end

class Aws::EC2::Types::RevokeSecurityGroupIngressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RevokeSecurityGroupIngressRequest
end

class Aws::EC2::Types::Route
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Route
end

class Aws::EC2::Types::RouteTable
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RouteTable
end

class Aws::EC2::Types::RouteTableAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RouteTableAssociation
end

class Aws::EC2::Types::RouteTableAssociationState
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RouteTableAssociationState
end

class Aws::EC2::Types::RunInstancesMonitoringEnabled
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RunInstancesMonitoringEnabled
end

class Aws::EC2::Types::RunInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RunInstancesRequest
end

class Aws::EC2::Types::RunScheduledInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RunScheduledInstancesRequest
end

class Aws::EC2::Types::RunScheduledInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::RunScheduledInstancesResult
end

class Aws::EC2::Types::S3Storage
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::S3Storage
end

class Aws::EC2::Types::ScheduledInstance
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstance
end

class Aws::EC2::Types::ScheduledInstanceAvailability
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstanceAvailability
end

class Aws::EC2::Types::ScheduledInstanceRecurrence
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstanceRecurrence
end

class Aws::EC2::Types::ScheduledInstanceRecurrenceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstanceRecurrenceRequest
end

class Aws::EC2::Types::ScheduledInstancesBlockDeviceMapping
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstancesBlockDeviceMapping
end

class Aws::EC2::Types::ScheduledInstancesEbs
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstancesEbs
end

class Aws::EC2::Types::ScheduledInstancesIamInstanceProfile
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstancesIamInstanceProfile
end

class Aws::EC2::Types::ScheduledInstancesIpv6Address
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstancesIpv6Address
end

class Aws::EC2::Types::ScheduledInstancesLaunchSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstancesLaunchSpecification
end

class Aws::EC2::Types::ScheduledInstancesMonitoring
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstancesMonitoring
end

class Aws::EC2::Types::ScheduledInstancesNetworkInterface
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstancesNetworkInterface
end

class Aws::EC2::Types::ScheduledInstancesPlacement
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstancesPlacement
end

class Aws::EC2::Types::ScheduledInstancesPrivateIpAddressConfig
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ScheduledInstancesPrivateIpAddressConfig
end

class Aws::EC2::Types::SearchLocalGatewayRoutesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SearchLocalGatewayRoutesRequest
end

class Aws::EC2::Types::SearchLocalGatewayRoutesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SearchLocalGatewayRoutesResult
end

class Aws::EC2::Types::SearchTransitGatewayMulticastGroupsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SearchTransitGatewayMulticastGroupsRequest
end

class Aws::EC2::Types::SearchTransitGatewayMulticastGroupsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SearchTransitGatewayMulticastGroupsResult
end

class Aws::EC2::Types::SearchTransitGatewayRoutesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SearchTransitGatewayRoutesRequest
end

class Aws::EC2::Types::SearchTransitGatewayRoutesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SearchTransitGatewayRoutesResult
end

class Aws::EC2::Types::SecurityGroup
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SecurityGroup
end

class Aws::EC2::Types::SecurityGroupIdentifier
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SecurityGroupIdentifier
end

class Aws::EC2::Types::SecurityGroupReference
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SecurityGroupReference
end

class Aws::EC2::Types::SendDiagnosticInterruptRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SendDiagnosticInterruptRequest
end

class Aws::EC2::Types::ServiceConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ServiceConfiguration
end

class Aws::EC2::Types::ServiceDetail
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ServiceDetail
end

class Aws::EC2::Types::ServiceTypeDetail
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ServiceTypeDetail
end

class Aws::EC2::Types::SlotDateTimeRangeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SlotDateTimeRangeRequest
end

class Aws::EC2::Types::SlotStartTimeRangeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SlotStartTimeRangeRequest
end

class Aws::EC2::Types::Snapshot
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Snapshot
end

class Aws::EC2::Types::SnapshotDetail
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SnapshotDetail
end

class Aws::EC2::Types::SnapshotDiskContainer
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SnapshotDiskContainer
end

class Aws::EC2::Types::SnapshotInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SnapshotInfo
end

class Aws::EC2::Types::SnapshotTaskDetail
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SnapshotTaskDetail
end

class Aws::EC2::Types::SpotDatafeedSubscription
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotDatafeedSubscription
end

class Aws::EC2::Types::SpotFleetLaunchSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotFleetLaunchSpecification
end

class Aws::EC2::Types::SpotFleetMonitoring
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotFleetMonitoring
end

class Aws::EC2::Types::SpotFleetRequestConfig
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotFleetRequestConfig
end

class Aws::EC2::Types::SpotFleetRequestConfigData
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotFleetRequestConfigData
end

class Aws::EC2::Types::SpotFleetTagSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotFleetTagSpecification
end

class Aws::EC2::Types::SpotInstanceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotInstanceRequest
end

class Aws::EC2::Types::SpotInstanceStateFault
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotInstanceStateFault
end

class Aws::EC2::Types::SpotInstanceStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotInstanceStatus
end

class Aws::EC2::Types::SpotMarketOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotMarketOptions
end

class Aws::EC2::Types::SpotOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotOptions
end

class Aws::EC2::Types::SpotOptionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotOptionsRequest
end

class Aws::EC2::Types::SpotPlacement
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotPlacement
end

class Aws::EC2::Types::SpotPrice
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SpotPrice
end

class Aws::EC2::Types::StaleIpPermission
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::StaleIpPermission
end

class Aws::EC2::Types::StaleSecurityGroup
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::StaleSecurityGroup
end

class Aws::EC2::Types::StartInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::StartInstancesRequest
end

class Aws::EC2::Types::StartInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::StartInstancesResult
end

class Aws::EC2::Types::StartVpcEndpointServicePrivateDnsVerificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::StartVpcEndpointServicePrivateDnsVerificationRequest
end

class Aws::EC2::Types::StartVpcEndpointServicePrivateDnsVerificationResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::StartVpcEndpointServicePrivateDnsVerificationResult
end

class Aws::EC2::Types::StateReason
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::StateReason
end

class Aws::EC2::Types::StopInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::StopInstancesRequest
end

class Aws::EC2::Types::StopInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::StopInstancesResult
end

class Aws::EC2::Types::Storage
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Storage
end

class Aws::EC2::Types::StorageLocation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::StorageLocation
end

class Aws::EC2::Types::Subnet
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Subnet
end

class Aws::EC2::Types::SubnetAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SubnetAssociation
end

class Aws::EC2::Types::SubnetCidrBlockState
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SubnetCidrBlockState
end

class Aws::EC2::Types::SubnetIpv6CidrBlockAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SubnetIpv6CidrBlockAssociation
end

class Aws::EC2::Types::SuccessfulInstanceCreditSpecificationItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SuccessfulInstanceCreditSpecificationItem
end

class Aws::EC2::Types::SuccessfulQueuedPurchaseDeletion
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::SuccessfulQueuedPurchaseDeletion
end

class Aws::EC2::Types::Tag
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Tag
end

class Aws::EC2::Types::TagDescription
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TagDescription
end

class Aws::EC2::Types::TagSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TagSpecification
end

class Aws::EC2::Types::TargetCapacitySpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TargetCapacitySpecification
end

class Aws::EC2::Types::TargetCapacitySpecificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TargetCapacitySpecificationRequest
end

class Aws::EC2::Types::TargetConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TargetConfiguration
end

class Aws::EC2::Types::TargetConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TargetConfigurationRequest
end

class Aws::EC2::Types::TargetGroup
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TargetGroup
end

class Aws::EC2::Types::TargetGroupsConfig
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TargetGroupsConfig
end

class Aws::EC2::Types::TargetNetwork
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TargetNetwork
end

class Aws::EC2::Types::TargetReservationValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TargetReservationValue
end

class Aws::EC2::Types::TerminateClientVpnConnectionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TerminateClientVpnConnectionsRequest
end

class Aws::EC2::Types::TerminateClientVpnConnectionsResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TerminateClientVpnConnectionsResult
end

class Aws::EC2::Types::TerminateConnectionStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TerminateConnectionStatus
end

class Aws::EC2::Types::TerminateInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TerminateInstancesRequest
end

class Aws::EC2::Types::TerminateInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TerminateInstancesResult
end

class Aws::EC2::Types::TrafficMirrorFilter
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TrafficMirrorFilter
end

class Aws::EC2::Types::TrafficMirrorFilterRule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TrafficMirrorFilterRule
end

class Aws::EC2::Types::TrafficMirrorPortRange
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TrafficMirrorPortRange
end

class Aws::EC2::Types::TrafficMirrorPortRangeRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TrafficMirrorPortRangeRequest
end

class Aws::EC2::Types::TrafficMirrorSession
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TrafficMirrorSession
end

class Aws::EC2::Types::TrafficMirrorTarget
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TrafficMirrorTarget
end

class Aws::EC2::Types::TransitGateway
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGateway
end

class Aws::EC2::Types::TransitGatewayAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayAssociation
end

class Aws::EC2::Types::TransitGatewayAttachment
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayAttachment
end

class Aws::EC2::Types::TransitGatewayAttachmentAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayAttachmentAssociation
end

class Aws::EC2::Types::TransitGatewayAttachmentPropagation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayAttachmentPropagation
end

class Aws::EC2::Types::TransitGatewayMulticastDeregisteredGroupMembers
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayMulticastDeregisteredGroupMembers
end

class Aws::EC2::Types::TransitGatewayMulticastDeregisteredGroupSources
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayMulticastDeregisteredGroupSources
end

class Aws::EC2::Types::TransitGatewayMulticastDomain
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayMulticastDomain
end

class Aws::EC2::Types::TransitGatewayMulticastDomainAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayMulticastDomainAssociation
end

class Aws::EC2::Types::TransitGatewayMulticastDomainAssociations
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayMulticastDomainAssociations
end

class Aws::EC2::Types::TransitGatewayMulticastGroup
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayMulticastGroup
end

class Aws::EC2::Types::TransitGatewayMulticastRegisteredGroupMembers
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayMulticastRegisteredGroupMembers
end

class Aws::EC2::Types::TransitGatewayMulticastRegisteredGroupSources
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayMulticastRegisteredGroupSources
end

class Aws::EC2::Types::TransitGatewayOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayOptions
end

class Aws::EC2::Types::TransitGatewayPeeringAttachment
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayPeeringAttachment
end

class Aws::EC2::Types::TransitGatewayPropagation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayPropagation
end

class Aws::EC2::Types::TransitGatewayRequestOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayRequestOptions
end

class Aws::EC2::Types::TransitGatewayRoute
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayRoute
end

class Aws::EC2::Types::TransitGatewayRouteAttachment
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayRouteAttachment
end

class Aws::EC2::Types::TransitGatewayRouteTable
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayRouteTable
end

class Aws::EC2::Types::TransitGatewayRouteTableAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayRouteTableAssociation
end

class Aws::EC2::Types::TransitGatewayRouteTablePropagation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayRouteTablePropagation
end

class Aws::EC2::Types::TransitGatewayVpcAttachment
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayVpcAttachment
end

class Aws::EC2::Types::TransitGatewayVpcAttachmentOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TransitGatewayVpcAttachmentOptions
end

class Aws::EC2::Types::TunnelOption
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::TunnelOption
end

class Aws::EC2::Types::UnassignIpv6AddressesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UnassignIpv6AddressesRequest
end

class Aws::EC2::Types::UnassignIpv6AddressesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UnassignIpv6AddressesResult
end

class Aws::EC2::Types::UnassignPrivateIpAddressesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UnassignPrivateIpAddressesRequest
end

class Aws::EC2::Types::UnmonitorInstancesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UnmonitorInstancesRequest
end

class Aws::EC2::Types::UnmonitorInstancesResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UnmonitorInstancesResult
end

class Aws::EC2::Types::UnsuccessfulInstanceCreditSpecificationItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UnsuccessfulInstanceCreditSpecificationItem
end

class Aws::EC2::Types::UnsuccessfulInstanceCreditSpecificationItemError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UnsuccessfulInstanceCreditSpecificationItemError
end

class Aws::EC2::Types::UnsuccessfulItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UnsuccessfulItem
end

class Aws::EC2::Types::UnsuccessfulItemError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UnsuccessfulItemError
end

class Aws::EC2::Types::UpdateSecurityGroupRuleDescriptionsEgressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UpdateSecurityGroupRuleDescriptionsEgressRequest
end

class Aws::EC2::Types::UpdateSecurityGroupRuleDescriptionsEgressResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UpdateSecurityGroupRuleDescriptionsEgressResult
end

class Aws::EC2::Types::UpdateSecurityGroupRuleDescriptionsIngressRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UpdateSecurityGroupRuleDescriptionsIngressRequest
end

class Aws::EC2::Types::UpdateSecurityGroupRuleDescriptionsIngressResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UpdateSecurityGroupRuleDescriptionsIngressResult
end

class Aws::EC2::Types::UserBucket
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UserBucket
end

class Aws::EC2::Types::UserBucketDetails
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UserBucketDetails
end

class Aws::EC2::Types::UserData
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UserData
end

class Aws::EC2::Types::UserIdGroupPair
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::UserIdGroupPair
end

class Aws::EC2::Types::VCpuInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VCpuInfo
end

class Aws::EC2::Types::ValidationError
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ValidationError
end

class Aws::EC2::Types::ValidationWarning
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::ValidationWarning
end

class Aws::EC2::Types::VgwTelemetry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VgwTelemetry
end

class Aws::EC2::Types::Volume
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Volume
end

class Aws::EC2::Types::VolumeAttachment
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VolumeAttachment
end

class Aws::EC2::Types::VolumeDetail
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VolumeDetail
end

class Aws::EC2::Types::VolumeModification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VolumeModification
end

class Aws::EC2::Types::VolumeStatusAction
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VolumeStatusAction
end

class Aws::EC2::Types::VolumeStatusAttachmentStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VolumeStatusAttachmentStatus
end

class Aws::EC2::Types::VolumeStatusDetails
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VolumeStatusDetails
end

class Aws::EC2::Types::VolumeStatusEvent
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VolumeStatusEvent
end

class Aws::EC2::Types::VolumeStatusInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VolumeStatusInfo
end

class Aws::EC2::Types::VolumeStatusItem
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VolumeStatusItem
end

class Aws::EC2::Types::Vpc
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::Vpc
end

class Aws::EC2::Types::VpcAttachment
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcAttachment
end

class Aws::EC2::Types::VpcCidrBlockAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcCidrBlockAssociation
end

class Aws::EC2::Types::VpcCidrBlockState
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcCidrBlockState
end

class Aws::EC2::Types::VpcClassicLink
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcClassicLink
end

class Aws::EC2::Types::VpcEndpoint
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcEndpoint
end

class Aws::EC2::Types::VpcEndpointConnection
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcEndpointConnection
end

class Aws::EC2::Types::VpcIpv6CidrBlockAssociation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcIpv6CidrBlockAssociation
end

class Aws::EC2::Types::VpcPeeringConnection
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcPeeringConnection
end

class Aws::EC2::Types::VpcPeeringConnectionOptionsDescription
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcPeeringConnectionOptionsDescription
end

class Aws::EC2::Types::VpcPeeringConnectionStateReason
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcPeeringConnectionStateReason
end

class Aws::EC2::Types::VpcPeeringConnectionVpcInfo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpcPeeringConnectionVpcInfo
end

class Aws::EC2::Types::VpnConnection
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpnConnection
end

class Aws::EC2::Types::VpnConnectionOptions
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpnConnectionOptions
end

class Aws::EC2::Types::VpnConnectionOptionsSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpnConnectionOptionsSpecification
end

class Aws::EC2::Types::VpnGateway
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpnGateway
end

class Aws::EC2::Types::VpnStaticRoute
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpnStaticRoute
end

class Aws::EC2::Types::VpnTunnelOptionsSpecification
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::VpnTunnelOptionsSpecification
end

class Aws::EC2::Types::WithdrawByoipCidrRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::WithdrawByoipCidrRequest
end

class Aws::EC2::Types::WithdrawByoipCidrResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::EC2::Types::WithdrawByoipCidrResult
end

module Aws::EC2::Types
end

class Aws::EC2::Volume
  def attach_to_instance(options=T.unsafe(nil)); end

  def attachments(); end

  def availability_zone(); end

  def client(); end

  def create_snapshot(options=T.unsafe(nil)); end

  def create_tags(options=T.unsafe(nil)); end

  def create_time(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def describe_attribute(options=T.unsafe(nil)); end

  def describe_status(options=T.unsafe(nil)); end

  def detach_from_instance(options=T.unsafe(nil)); end

  def enable_io(options=T.unsafe(nil)); end

  def encrypted(); end

  def fast_restored(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def iops(); end

  def kms_key_id(); end

  def load(); end

  def modify_attribute(options=T.unsafe(nil)); end

  def multi_attach_enabled(); end

  def outpost_arn(); end

  def reload(); end

  def size(); end

  def snapshot_id(); end

  def snapshots(options=T.unsafe(nil)); end

  def state(); end

  def tags(); end

  def volume_id(); end

  def volume_type(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::Volume::Collection
end

class Aws::EC2::Volume::Collection
end

class Aws::EC2::Volume
  extend ::Aws::Deprecations
end

class Aws::EC2::Vpc
  def accepted_vpc_peering_connections(options=T.unsafe(nil)); end

  def associate_dhcp_options(options=T.unsafe(nil)); end

  def attach_classic_link_instance(options=T.unsafe(nil)); end

  def attach_internet_gateway(options=T.unsafe(nil)); end

  def cidr_block(); end

  def cidr_block_association_set(); end

  def client(); end

  def create_network_acl(options=T.unsafe(nil)); end

  def create_route_table(options=T.unsafe(nil)); end

  def create_security_group(options=T.unsafe(nil)); end

  def create_subnet(options=T.unsafe(nil)); end

  def create_tags(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_tags(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def describe_attribute(options=T.unsafe(nil)); end

  def detach_classic_link_instance(options=T.unsafe(nil)); end

  def detach_internet_gateway(options=T.unsafe(nil)); end

  def dhcp_options(); end

  def dhcp_options_id(); end

  def disable_classic_link(options=T.unsafe(nil)); end

  def enable_classic_link(options=T.unsafe(nil)); end

  def exists?(options=T.unsafe(nil)); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def instance_tenancy(); end

  def instances(options=T.unsafe(nil)); end

  def internet_gateways(options=T.unsafe(nil)); end

  def ipv_6_cidr_block_association_set(); end

  def is_default(); end

  def load(); end

  def modify_attribute(options=T.unsafe(nil)); end

  def network_acls(options=T.unsafe(nil)); end

  def network_interfaces(options=T.unsafe(nil)); end

  def owner_id(); end

  def reload(); end

  def request_vpc_peering_connection(options=T.unsafe(nil)); end

  def requested_vpc_peering_connections(options=T.unsafe(nil)); end

  def route_tables(options=T.unsafe(nil)); end

  def security_groups(options=T.unsafe(nil)); end

  def state(); end

  def subnets(options=T.unsafe(nil)); end

  def tags(); end

  def vpc_id(); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_available(options=T.unsafe(nil), &block); end

  def wait_until_exists(options=T.unsafe(nil), &block); end
end

class Aws::EC2::Vpc::Collection
end

class Aws::EC2::Vpc::Collection
end

class Aws::EC2::Vpc
  extend ::Aws::Deprecations
end

class Aws::EC2::VpcAddress
  def allocation_id(); end

  def associate(options=T.unsafe(nil)); end

  def association(); end

  def association_id(); end

  def client(); end

  def customer_owned_ip(); end

  def customer_owned_ipv_4_pool(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def domain(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def instance_id(); end

  def load(); end

  def network_border_group(); end

  def network_interface_id(); end

  def network_interface_owner_id(); end

  def private_ip_address(); end

  def public_ip(); end

  def public_ipv_4_pool(); end

  def release(options=T.unsafe(nil)); end

  def reload(); end

  def tags(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::EC2::VpcAddress::Collection
end

class Aws::EC2::VpcAddress::Collection
end

class Aws::EC2::VpcAddress
  extend ::Aws::Deprecations
end

class Aws::EC2::VpcPeeringConnection
  def accept(options=T.unsafe(nil)); end

  def accepter_vpc(); end

  def accepter_vpc_info(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def exists?(options=T.unsafe(nil)); end

  def expiration_time(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def reject(options=T.unsafe(nil)); end

  def reload(); end

  def requester_vpc(); end

  def requester_vpc_info(); end

  def status(); end

  def tags(); end

  def vpc_peering_connection_id(); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_exists(options=T.unsafe(nil), &block); end
end

class Aws::EC2::VpcPeeringConnection::Collection
end

class Aws::EC2::VpcPeeringConnection::Collection
end

class Aws::EC2::VpcPeeringConnection
  extend ::Aws::Deprecations
end

module Aws::EC2::Waiters
end

class Aws::EC2::Waiters::BundleTaskComplete
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::BundleTaskComplete
end

class Aws::EC2::Waiters::ConversionTaskCancelled
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::ConversionTaskCancelled
end

class Aws::EC2::Waiters::ConversionTaskCompleted
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::ConversionTaskCompleted
end

class Aws::EC2::Waiters::ConversionTaskDeleted
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::ConversionTaskDeleted
end

class Aws::EC2::Waiters::CustomerGatewayAvailable
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::CustomerGatewayAvailable
end

class Aws::EC2::Waiters::ExportTaskCancelled
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::ExportTaskCancelled
end

class Aws::EC2::Waiters::ExportTaskCompleted
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::ExportTaskCompleted
end

class Aws::EC2::Waiters::ImageAvailable
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::ImageAvailable
end

class Aws::EC2::Waiters::ImageExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::ImageExists
end

class Aws::EC2::Waiters::InstanceExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::InstanceExists
end

class Aws::EC2::Waiters::InstanceRunning
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::InstanceRunning
end

class Aws::EC2::Waiters::InstanceStatusOk
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::InstanceStatusOk
end

class Aws::EC2::Waiters::InstanceStopped
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::InstanceStopped
end

class Aws::EC2::Waiters::InstanceTerminated
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::InstanceTerminated
end

class Aws::EC2::Waiters::KeyPairExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::KeyPairExists
end

class Aws::EC2::Waiters::NatGatewayAvailable
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::NatGatewayAvailable
end

class Aws::EC2::Waiters::NetworkInterfaceAvailable
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::NetworkInterfaceAvailable
end

class Aws::EC2::Waiters::PasswordDataAvailable
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::PasswordDataAvailable
end

class Aws::EC2::Waiters::SecurityGroupExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::SecurityGroupExists
end

class Aws::EC2::Waiters::SnapshotCompleted
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::SnapshotCompleted
end

class Aws::EC2::Waiters::SpotInstanceRequestFulfilled
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::SpotInstanceRequestFulfilled
end

class Aws::EC2::Waiters::SubnetAvailable
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::SubnetAvailable
end

class Aws::EC2::Waiters::SystemStatusOk
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::SystemStatusOk
end

class Aws::EC2::Waiters::VolumeAvailable
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::VolumeAvailable
end

class Aws::EC2::Waiters::VolumeDeleted
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::VolumeDeleted
end

class Aws::EC2::Waiters::VolumeInUse
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::VolumeInUse
end

class Aws::EC2::Waiters::VpcAvailable
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::VpcAvailable
end

class Aws::EC2::Waiters::VpcExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::VpcExists
end

class Aws::EC2::Waiters::VpcPeeringConnectionDeleted
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::VpcPeeringConnectionDeleted
end

class Aws::EC2::Waiters::VpcPeeringConnectionExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::VpcPeeringConnectionExists
end

class Aws::EC2::Waiters::VpnConnectionAvailable
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::VpnConnectionAvailable
end

class Aws::EC2::Waiters::VpnConnectionDeleted
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::EC2::Waiters::VpnConnectionDeleted
end

module Aws::EC2::Waiters
end

module Aws::EC2
end

class Aws::ECSCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials
  def retries(); end
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::ECSCredentials::Non200Response
end

class Aws::ECSCredentials::Non200Response
end

class Aws::ECSCredentials
end

class Aws::EagerLoader
  def load(klass_or_module); end

  def loaded(); end
end

class Aws::EagerLoader
end

class Aws::EmptyStructure
  include ::Aws::Structure
end

class Aws::EmptyStructure
end

class Aws::EndpointCache
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def delete_polling_thread(key); end

  def extract_key(ctx); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def max_entries(); end

  def max_threads(); end

  def pool(); end

  def stop_polling!(); end

  def threads_key?(key); end

  def update(key, ctx); end

  def update_polling_pool(key, thread); end
  MAX_ENTRIES = ::T.let(nil, ::T.untyped)
  MAX_THREADS = ::T.let(nil, ::T.untyped)
end

class Aws::EndpointCache::Endpoint
  def address(); end

  def expired?(); end

  def initialize(options); end
  CACHE_PERIOD = ::T.let(nil, ::T.untyped)
end

class Aws::EndpointCache::Endpoint
end

class Aws::EndpointCache
end

module Aws::Errors
end

class Aws::Errors::ChecksumError
end

class Aws::Errors::ChecksumError
end

class Aws::Errors::CredentialSourceConflictError
end

class Aws::Errors::CredentialSourceConflictError
end

module Aws::Errors::DynamicErrors
  def const_missing(constant); end

  def error_class(error_code); end
end

module Aws::Errors::DynamicErrors
  def self.extended(submodule); end
end

class Aws::Errors::EndpointDiscoveryError
  def initialize(*args); end
end

class Aws::Errors::EndpointDiscoveryError
end

class Aws::Errors::EventError
  def error_code(); end

  def error_message(); end

  def event_type(); end

  def initialize(event_type, code, message); end
end

class Aws::Errors::EventError
end

class Aws::Errors::EventStreamBuilderError
end

class Aws::Errors::EventStreamBuilderError
end

class Aws::Errors::EventStreamParserError
end

class Aws::Errors::EventStreamParserError
end

class Aws::Errors::InvalidARNError
end

class Aws::Errors::InvalidARNError
end

class Aws::Errors::InvalidARNPartitionError
  def initialize(*args); end
end

class Aws::Errors::InvalidARNPartitionError
end

class Aws::Errors::InvalidARNRegionError
  def initialize(*args); end
end

class Aws::Errors::InvalidARNRegionError
end

class Aws::Errors::InvalidCredentialSourceError
end

class Aws::Errors::InvalidCredentialSourceError
end

class Aws::Errors::InvalidProcessCredentialsPayload
end

class Aws::Errors::InvalidProcessCredentialsPayload
end

class Aws::Errors::InvalidRegionError
  def initialize(*args); end
end

class Aws::Errors::InvalidRegionError
end

class Aws::Errors::MetadataParserError
  def initialize(*args); end
end

class Aws::Errors::MetadataParserError
end

class Aws::Errors::MissingContentLength
  def initialize(*args); end
end

class Aws::Errors::MissingContentLength
end

class Aws::Errors::MissingCredentialsError
  def initialize(*args); end
end

class Aws::Errors::MissingCredentialsError
end

class Aws::Errors::MissingEndpointHostLabelValue
  def initialize(name); end
end

class Aws::Errors::MissingEndpointHostLabelValue
end

class Aws::Errors::MissingRegionError
  def initialize(*args); end
end

class Aws::Errors::MissingRegionError
end

class Aws::Errors::MissingWebIdentityTokenFile
  def initialize(*args); end
end

class Aws::Errors::MissingWebIdentityTokenFile
end

class Aws::Errors::NoSourceCredentialsError
end

class Aws::Errors::NoSourceCredentialsError
end

class Aws::Errors::NoSourceProfileError
end

class Aws::Errors::NoSourceProfileError
end

class Aws::Errors::NoSuchEndpointError
  def context(); end

  def endpoint(); end

  def initialize(options=T.unsafe(nil)); end

  def original_error(); end
end

class Aws::Errors::NoSuchEndpointError
end

class Aws::Errors::NoSuchProfileError
end

class Aws::Errors::NoSuchProfileError
end

class Aws::Errors::NonSupportedRubyVersionError
end

class Aws::Errors::NonSupportedRubyVersionError
end

class Aws::Errors::RetryCapacityNotAvailableError
  def initialize(*args); end
end

class Aws::Errors::RetryCapacityNotAvailableError
end

class Aws::Errors::ServiceError
  def code(); end

  def context(); end

  def data(); end

  def initialize(context, message, data=T.unsafe(nil)); end

  def retryable?(); end

  def throttling?(); end
end

class Aws::Errors::ServiceError
  def self.code(); end

  def self.code=(code); end
end

class Aws::Errors::SignalEventError
end

class Aws::Errors::SignalEventError
end

module Aws::Errors
end

class Aws::EventEmitter
  def emit(type, params); end

  def encoder(); end

  def encoder=(encoder); end

  def on(type, callback); end

  def signal(type, event); end

  def signal_queue(); end

  def signal_queue=(signal_queue); end

  def stream(); end

  def stream=(stream); end

  def validate_event(); end

  def validate_event=(validate_event); end
end

class Aws::EventEmitter
end

module Aws::EventStream
end

class Aws::EventStream::Decoder
  include ::Enumerable
  def decode(io, &block); end

  def decode_chunk(chunk=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::EventStream::Decoder
end

class Aws::EventStream::Encoder
  def encode(message, io=T.unsafe(nil)); end

  def encode_headers(message); end

  def encode_message(message); end
  MAX_HEADERS_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_PAYLOAD_LENGTH = ::T.let(nil, ::T.untyped)
  OVERHEAD_LENGTH = ::T.let(nil, ::T.untyped)
end

class Aws::EventStream::Encoder
end

module Aws::EventStream::Errors
end

class Aws::EventStream::Errors::EventHeadersLengthExceedError
  def initialize(*args); end
end

class Aws::EventStream::Errors::EventHeadersLengthExceedError
end

class Aws::EventStream::Errors::EventPayloadLengthExceedError
  def initialize(*args); end
end

class Aws::EventStream::Errors::EventPayloadLengthExceedError
end

class Aws::EventStream::Errors::IncompleteMessageError
  def initialize(*args); end
end

class Aws::EventStream::Errors::IncompleteMessageError
end

class Aws::EventStream::Errors::MessageChecksumError
  def initialize(*args); end
end

class Aws::EventStream::Errors::MessageChecksumError
end

class Aws::EventStream::Errors::PreludeChecksumError
  def initialize(*args); end
end

class Aws::EventStream::Errors::PreludeChecksumError
end

class Aws::EventStream::Errors::ReadBytesExceedLengthError
  def initialize(target_byte, total_len); end
end

class Aws::EventStream::Errors::ReadBytesExceedLengthError
end

module Aws::EventStream::Errors
end

class Aws::EventStream::HeaderValue
  def initialize(options); end

  def type(); end

  def value(); end
end

class Aws::EventStream::HeaderValue
end

class Aws::EventStream::Message
  def headers(); end

  def initialize(options); end

  def payload(); end
end

class Aws::EventStream::Message
end

module Aws::EventStream::Types
end

module Aws::EventStream::Types
  def self.pattern(); end

  def self.types(); end
end

module Aws::EventStream
end

class Aws::IniParser
end

class Aws::IniParser
  def self.ini_parse(raw); end
end

class Aws::InstanceProfileCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials
  def retries(); end
  METADATA_PATH_BASE = ::T.let(nil, ::T.untyped)
  METADATA_TOKEN_PATH = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::InstanceProfileCredentials::Non200Response
end

class Aws::InstanceProfileCredentials::Non200Response
end

class Aws::InstanceProfileCredentials::Token
  def expired?(); end

  def initialize(value, ttl); end

  def value(); end
end

class Aws::InstanceProfileCredentials::Token
end

class Aws::InstanceProfileCredentials::TokenExpiredError
end

class Aws::InstanceProfileCredentials::TokenExpiredError
end

class Aws::InstanceProfileCredentials::TokenRetrivalError
end

class Aws::InstanceProfileCredentials::TokenRetrivalError
end

class Aws::InstanceProfileCredentials
end

module Aws::Json
  ENGINE_DUMP_OPTIONS = ::T.let(nil, ::T.untyped)
  ENGINE_ERRORS = ::T.let(nil, ::T.untyped)
  ENGINE_LOAD_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Aws::Json::Builder
  include ::Seahorse::Model::Shapes
  def initialize(rules); end

  def serialize(params); end

  def to_json(params); end
end

class Aws::Json::Builder
end

Aws::Json::ENGINE = JSON

class Aws::Json::ErrorHandler
end

class Aws::Json::ErrorHandler
end

class Aws::Json::Handler
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Aws::Json::Handler
end

class Aws::Json::ParseError
  def error(); end

  def initialize(error); end
end

class Aws::Json::ParseError
end

class Aws::Json::Parser
  include ::Seahorse::Model::Shapes
  def initialize(rules); end

  def parse(json, target=T.unsafe(nil)); end
end

class Aws::Json::Parser
end

module Aws::Json
  def self.dump(value); end

  def self.load(json); end

  def self.load_file(path); end
end

module Aws::KMS
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Client
  include ::Aws::ClientStubs
  def cancel_key_deletion(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def connect_custom_key_store(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_alias(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_custom_key_store(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_grant(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def decrypt(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_alias(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_custom_key_store(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_imported_key_material(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_custom_key_stores(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disable_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disable_key_rotation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def disconnect_custom_key_store(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def enable_key_rotation(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def encrypt(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def generate_data_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def generate_data_key_pair(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def generate_data_key_pair_without_plaintext(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def generate_data_key_without_plaintext(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def generate_random(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_key_policy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_key_rotation_status(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_parameters_for_import(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_public_key(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def import_key_material(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(*args); end

  def list_aliases(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_grants(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_key_policies(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_keys(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_resource_tags(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_retirable_grants(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_key_policy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def re_encrypt(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def retire_grant(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def revoke_grant(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def schedule_key_deletion(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def sign(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def tag_resource(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def untag_resource(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_alias(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_custom_key_store(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_key_description(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def verify(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def waiter_names(); end
end

class Aws::KMS::Client
  def self.errors_module(); end

  def self.identifier(); end
end

module Aws::KMS::ClientApi
  include ::Seahorse::Model
  API = ::T.let(nil, ::T.untyped)
  AWSAccountIdType = ::T.let(nil, ::T.untyped)
  AlgorithmSpec = ::T.let(nil, ::T.untyped)
  AliasList = ::T.let(nil, ::T.untyped)
  AliasListEntry = ::T.let(nil, ::T.untyped)
  AliasNameType = ::T.let(nil, ::T.untyped)
  AlreadyExistsException = ::T.let(nil, ::T.untyped)
  ArnType = ::T.let(nil, ::T.untyped)
  BooleanType = ::T.let(nil, ::T.untyped)
  CancelKeyDeletionRequest = ::T.let(nil, ::T.untyped)
  CancelKeyDeletionResponse = ::T.let(nil, ::T.untyped)
  CiphertextType = ::T.let(nil, ::T.untyped)
  CloudHsmClusterIdType = ::T.let(nil, ::T.untyped)
  CloudHsmClusterInUseException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterInvalidConfigurationException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterNotActiveException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterNotFoundException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterNotRelatedException = ::T.let(nil, ::T.untyped)
  ConnectCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  ConnectCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  ConnectionErrorCodeType = ::T.let(nil, ::T.untyped)
  ConnectionStateType = ::T.let(nil, ::T.untyped)
  CreateAliasRequest = ::T.let(nil, ::T.untyped)
  CreateCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  CreateCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  CreateGrantRequest = ::T.let(nil, ::T.untyped)
  CreateGrantResponse = ::T.let(nil, ::T.untyped)
  CreateKeyRequest = ::T.let(nil, ::T.untyped)
  CreateKeyResponse = ::T.let(nil, ::T.untyped)
  CustomKeyStoreHasCMKsException = ::T.let(nil, ::T.untyped)
  CustomKeyStoreIdType = ::T.let(nil, ::T.untyped)
  CustomKeyStoreInvalidStateException = ::T.let(nil, ::T.untyped)
  CustomKeyStoreNameInUseException = ::T.let(nil, ::T.untyped)
  CustomKeyStoreNameType = ::T.let(nil, ::T.untyped)
  CustomKeyStoreNotFoundException = ::T.let(nil, ::T.untyped)
  CustomKeyStoresList = ::T.let(nil, ::T.untyped)
  CustomKeyStoresListEntry = ::T.let(nil, ::T.untyped)
  CustomerMasterKeySpec = ::T.let(nil, ::T.untyped)
  DataKeyPairSpec = ::T.let(nil, ::T.untyped)
  DataKeySpec = ::T.let(nil, ::T.untyped)
  DateType = ::T.let(nil, ::T.untyped)
  DecryptRequest = ::T.let(nil, ::T.untyped)
  DecryptResponse = ::T.let(nil, ::T.untyped)
  DeleteAliasRequest = ::T.let(nil, ::T.untyped)
  DeleteCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  DeleteCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  DeleteImportedKeyMaterialRequest = ::T.let(nil, ::T.untyped)
  DependencyTimeoutException = ::T.let(nil, ::T.untyped)
  DescribeCustomKeyStoresRequest = ::T.let(nil, ::T.untyped)
  DescribeCustomKeyStoresResponse = ::T.let(nil, ::T.untyped)
  DescribeKeyRequest = ::T.let(nil, ::T.untyped)
  DescribeKeyResponse = ::T.let(nil, ::T.untyped)
  DescriptionType = ::T.let(nil, ::T.untyped)
  DisableKeyRequest = ::T.let(nil, ::T.untyped)
  DisableKeyRotationRequest = ::T.let(nil, ::T.untyped)
  DisabledException = ::T.let(nil, ::T.untyped)
  DisconnectCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  DisconnectCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  EnableKeyRequest = ::T.let(nil, ::T.untyped)
  EnableKeyRotationRequest = ::T.let(nil, ::T.untyped)
  EncryptRequest = ::T.let(nil, ::T.untyped)
  EncryptResponse = ::T.let(nil, ::T.untyped)
  EncryptionAlgorithmSpec = ::T.let(nil, ::T.untyped)
  EncryptionAlgorithmSpecList = ::T.let(nil, ::T.untyped)
  EncryptionContextKey = ::T.let(nil, ::T.untyped)
  EncryptionContextType = ::T.let(nil, ::T.untyped)
  EncryptionContextValue = ::T.let(nil, ::T.untyped)
  ErrorMessageType = ::T.let(nil, ::T.untyped)
  ExpirationModelType = ::T.let(nil, ::T.untyped)
  ExpiredImportTokenException = ::T.let(nil, ::T.untyped)
  GenerateDataKeyPairRequest = ::T.let(nil, ::T.untyped)
  GenerateDataKeyPairResponse = ::T.let(nil, ::T.untyped)
  GenerateDataKeyPairWithoutPlaintextRequest = ::T.let(nil, ::T.untyped)
  GenerateDataKeyPairWithoutPlaintextResponse = ::T.let(nil, ::T.untyped)
  GenerateDataKeyRequest = ::T.let(nil, ::T.untyped)
  GenerateDataKeyResponse = ::T.let(nil, ::T.untyped)
  GenerateDataKeyWithoutPlaintextRequest = ::T.let(nil, ::T.untyped)
  GenerateDataKeyWithoutPlaintextResponse = ::T.let(nil, ::T.untyped)
  GenerateRandomRequest = ::T.let(nil, ::T.untyped)
  GenerateRandomResponse = ::T.let(nil, ::T.untyped)
  GetKeyPolicyRequest = ::T.let(nil, ::T.untyped)
  GetKeyPolicyResponse = ::T.let(nil, ::T.untyped)
  GetKeyRotationStatusRequest = ::T.let(nil, ::T.untyped)
  GetKeyRotationStatusResponse = ::T.let(nil, ::T.untyped)
  GetParametersForImportRequest = ::T.let(nil, ::T.untyped)
  GetParametersForImportResponse = ::T.let(nil, ::T.untyped)
  GetPublicKeyRequest = ::T.let(nil, ::T.untyped)
  GetPublicKeyResponse = ::T.let(nil, ::T.untyped)
  GrantConstraints = ::T.let(nil, ::T.untyped)
  GrantIdType = ::T.let(nil, ::T.untyped)
  GrantList = ::T.let(nil, ::T.untyped)
  GrantListEntry = ::T.let(nil, ::T.untyped)
  GrantNameType = ::T.let(nil, ::T.untyped)
  GrantOperation = ::T.let(nil, ::T.untyped)
  GrantOperationList = ::T.let(nil, ::T.untyped)
  GrantTokenList = ::T.let(nil, ::T.untyped)
  GrantTokenType = ::T.let(nil, ::T.untyped)
  ImportKeyMaterialRequest = ::T.let(nil, ::T.untyped)
  ImportKeyMaterialResponse = ::T.let(nil, ::T.untyped)
  IncorrectKeyException = ::T.let(nil, ::T.untyped)
  IncorrectKeyMaterialException = ::T.let(nil, ::T.untyped)
  IncorrectTrustAnchorException = ::T.let(nil, ::T.untyped)
  InvalidAliasNameException = ::T.let(nil, ::T.untyped)
  InvalidArnException = ::T.let(nil, ::T.untyped)
  InvalidCiphertextException = ::T.let(nil, ::T.untyped)
  InvalidGrantIdException = ::T.let(nil, ::T.untyped)
  InvalidGrantTokenException = ::T.let(nil, ::T.untyped)
  InvalidImportTokenException = ::T.let(nil, ::T.untyped)
  InvalidKeyUsageException = ::T.let(nil, ::T.untyped)
  InvalidMarkerException = ::T.let(nil, ::T.untyped)
  KMSInternalException = ::T.let(nil, ::T.untyped)
  KMSInvalidSignatureException = ::T.let(nil, ::T.untyped)
  KMSInvalidStateException = ::T.let(nil, ::T.untyped)
  KeyIdType = ::T.let(nil, ::T.untyped)
  KeyList = ::T.let(nil, ::T.untyped)
  KeyListEntry = ::T.let(nil, ::T.untyped)
  KeyManagerType = ::T.let(nil, ::T.untyped)
  KeyMetadata = ::T.let(nil, ::T.untyped)
  KeyState = ::T.let(nil, ::T.untyped)
  KeyStorePasswordType = ::T.let(nil, ::T.untyped)
  KeyUnavailableException = ::T.let(nil, ::T.untyped)
  KeyUsageType = ::T.let(nil, ::T.untyped)
  LimitExceededException = ::T.let(nil, ::T.untyped)
  LimitType = ::T.let(nil, ::T.untyped)
  ListAliasesRequest = ::T.let(nil, ::T.untyped)
  ListAliasesResponse = ::T.let(nil, ::T.untyped)
  ListGrantsRequest = ::T.let(nil, ::T.untyped)
  ListGrantsResponse = ::T.let(nil, ::T.untyped)
  ListKeyPoliciesRequest = ::T.let(nil, ::T.untyped)
  ListKeyPoliciesResponse = ::T.let(nil, ::T.untyped)
  ListKeysRequest = ::T.let(nil, ::T.untyped)
  ListKeysResponse = ::T.let(nil, ::T.untyped)
  ListResourceTagsRequest = ::T.let(nil, ::T.untyped)
  ListResourceTagsResponse = ::T.let(nil, ::T.untyped)
  ListRetirableGrantsRequest = ::T.let(nil, ::T.untyped)
  MalformedPolicyDocumentException = ::T.let(nil, ::T.untyped)
  MarkerType = ::T.let(nil, ::T.untyped)
  MessageType = ::T.let(nil, ::T.untyped)
  NotFoundException = ::T.let(nil, ::T.untyped)
  NumberOfBytesType = ::T.let(nil, ::T.untyped)
  OriginType = ::T.let(nil, ::T.untyped)
  PendingWindowInDaysType = ::T.let(nil, ::T.untyped)
  PlaintextType = ::T.let(nil, ::T.untyped)
  PolicyNameList = ::T.let(nil, ::T.untyped)
  PolicyNameType = ::T.let(nil, ::T.untyped)
  PolicyType = ::T.let(nil, ::T.untyped)
  PrincipalIdType = ::T.let(nil, ::T.untyped)
  PublicKeyType = ::T.let(nil, ::T.untyped)
  PutKeyPolicyRequest = ::T.let(nil, ::T.untyped)
  ReEncryptRequest = ::T.let(nil, ::T.untyped)
  ReEncryptResponse = ::T.let(nil, ::T.untyped)
  RetireGrantRequest = ::T.let(nil, ::T.untyped)
  RevokeGrantRequest = ::T.let(nil, ::T.untyped)
  ScheduleKeyDeletionRequest = ::T.let(nil, ::T.untyped)
  ScheduleKeyDeletionResponse = ::T.let(nil, ::T.untyped)
  SignRequest = ::T.let(nil, ::T.untyped)
  SignResponse = ::T.let(nil, ::T.untyped)
  SigningAlgorithmSpec = ::T.let(nil, ::T.untyped)
  SigningAlgorithmSpecList = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
  TagException = ::T.let(nil, ::T.untyped)
  TagKeyList = ::T.let(nil, ::T.untyped)
  TagKeyType = ::T.let(nil, ::T.untyped)
  TagList = ::T.let(nil, ::T.untyped)
  TagResourceRequest = ::T.let(nil, ::T.untyped)
  TagValueType = ::T.let(nil, ::T.untyped)
  TrustAnchorCertificateType = ::T.let(nil, ::T.untyped)
  UnsupportedOperationException = ::T.let(nil, ::T.untyped)
  UntagResourceRequest = ::T.let(nil, ::T.untyped)
  UpdateAliasRequest = ::T.let(nil, ::T.untyped)
  UpdateCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  UpdateCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  UpdateKeyDescriptionRequest = ::T.let(nil, ::T.untyped)
  VerifyRequest = ::T.let(nil, ::T.untyped)
  VerifyResponse = ::T.let(nil, ::T.untyped)
  WrappingKeySpec = ::T.let(nil, ::T.untyped)
end

module Aws::KMS::ClientApi
end

module Aws::KMS::Errors
end

class Aws::KMS::Errors::AlreadyExistsException
end

class Aws::KMS::Errors::AlreadyExistsException
end

class Aws::KMS::Errors::CloudHsmClusterInUseException
end

class Aws::KMS::Errors::CloudHsmClusterInUseException
end

class Aws::KMS::Errors::CloudHsmClusterInvalidConfigurationException
end

class Aws::KMS::Errors::CloudHsmClusterInvalidConfigurationException
end

class Aws::KMS::Errors::CloudHsmClusterNotActiveException
end

class Aws::KMS::Errors::CloudHsmClusterNotActiveException
end

class Aws::KMS::Errors::CloudHsmClusterNotFoundException
end

class Aws::KMS::Errors::CloudHsmClusterNotFoundException
end

class Aws::KMS::Errors::CloudHsmClusterNotRelatedException
end

class Aws::KMS::Errors::CloudHsmClusterNotRelatedException
end

class Aws::KMS::Errors::CustomKeyStoreHasCMKsException
end

class Aws::KMS::Errors::CustomKeyStoreHasCMKsException
end

class Aws::KMS::Errors::CustomKeyStoreInvalidStateException
end

class Aws::KMS::Errors::CustomKeyStoreInvalidStateException
end

class Aws::KMS::Errors::CustomKeyStoreNameInUseException
end

class Aws::KMS::Errors::CustomKeyStoreNameInUseException
end

class Aws::KMS::Errors::CustomKeyStoreNotFoundException
end

class Aws::KMS::Errors::CustomKeyStoreNotFoundException
end

class Aws::KMS::Errors::DependencyTimeoutException
end

class Aws::KMS::Errors::DependencyTimeoutException
end

class Aws::KMS::Errors::DisabledException
end

class Aws::KMS::Errors::DisabledException
end

class Aws::KMS::Errors::ExpiredImportTokenException
end

class Aws::KMS::Errors::ExpiredImportTokenException
end

class Aws::KMS::Errors::IncorrectKeyException
end

class Aws::KMS::Errors::IncorrectKeyException
end

class Aws::KMS::Errors::IncorrectKeyMaterialException
end

class Aws::KMS::Errors::IncorrectKeyMaterialException
end

class Aws::KMS::Errors::IncorrectTrustAnchorException
end

class Aws::KMS::Errors::IncorrectTrustAnchorException
end

class Aws::KMS::Errors::InvalidAliasNameException
end

class Aws::KMS::Errors::InvalidAliasNameException
end

class Aws::KMS::Errors::InvalidArnException
end

class Aws::KMS::Errors::InvalidArnException
end

class Aws::KMS::Errors::InvalidCiphertextException
end

class Aws::KMS::Errors::InvalidCiphertextException
end

class Aws::KMS::Errors::InvalidGrantIdException
end

class Aws::KMS::Errors::InvalidGrantIdException
end

class Aws::KMS::Errors::InvalidGrantTokenException
end

class Aws::KMS::Errors::InvalidGrantTokenException
end

class Aws::KMS::Errors::InvalidImportTokenException
end

class Aws::KMS::Errors::InvalidImportTokenException
end

class Aws::KMS::Errors::InvalidKeyUsageException
end

class Aws::KMS::Errors::InvalidKeyUsageException
end

class Aws::KMS::Errors::InvalidMarkerException
end

class Aws::KMS::Errors::InvalidMarkerException
end

class Aws::KMS::Errors::KMSInternalException
end

class Aws::KMS::Errors::KMSInternalException
end

class Aws::KMS::Errors::KMSInvalidSignatureException
end

class Aws::KMS::Errors::KMSInvalidSignatureException
end

class Aws::KMS::Errors::KMSInvalidStateException
end

class Aws::KMS::Errors::KMSInvalidStateException
end

class Aws::KMS::Errors::KeyUnavailableException
end

class Aws::KMS::Errors::KeyUnavailableException
end

class Aws::KMS::Errors::LimitExceededException
end

class Aws::KMS::Errors::LimitExceededException
end

class Aws::KMS::Errors::MalformedPolicyDocumentException
end

class Aws::KMS::Errors::MalformedPolicyDocumentException
end

class Aws::KMS::Errors::NotFoundException
end

class Aws::KMS::Errors::NotFoundException
end

class Aws::KMS::Errors::ServiceError
end

class Aws::KMS::Errors::ServiceError
end

class Aws::KMS::Errors::TagException
end

class Aws::KMS::Errors::TagException
end

class Aws::KMS::Errors::UnsupportedOperationException
end

class Aws::KMS::Errors::UnsupportedOperationException
end

module Aws::KMS::Errors
  extend ::Aws::Errors::DynamicErrors
end

class Aws::KMS::Resource
  def client(); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::KMS::Resource
end

module Aws::KMS::Types
end

class Aws::KMS::Types::AliasListEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::AliasListEntry
end

class Aws::KMS::Types::AlreadyExistsException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::AlreadyExistsException
end

class Aws::KMS::Types::CancelKeyDeletionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CancelKeyDeletionRequest
end

class Aws::KMS::Types::CancelKeyDeletionResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CancelKeyDeletionResponse
end

class Aws::KMS::Types::CloudHsmClusterInUseException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CloudHsmClusterInUseException
end

class Aws::KMS::Types::CloudHsmClusterInvalidConfigurationException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CloudHsmClusterInvalidConfigurationException
end

class Aws::KMS::Types::CloudHsmClusterNotActiveException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CloudHsmClusterNotActiveException
end

class Aws::KMS::Types::CloudHsmClusterNotFoundException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CloudHsmClusterNotFoundException
end

class Aws::KMS::Types::CloudHsmClusterNotRelatedException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CloudHsmClusterNotRelatedException
end

class Aws::KMS::Types::ConnectCustomKeyStoreRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ConnectCustomKeyStoreRequest
end

class Aws::KMS::Types::ConnectCustomKeyStoreResponse
end

class Aws::KMS::Types::ConnectCustomKeyStoreResponse
end

class Aws::KMS::Types::CreateAliasRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CreateAliasRequest
end

class Aws::KMS::Types::CreateCustomKeyStoreRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CreateCustomKeyStoreRequest
end

class Aws::KMS::Types::CreateCustomKeyStoreResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CreateCustomKeyStoreResponse
end

class Aws::KMS::Types::CreateGrantRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CreateGrantRequest
end

class Aws::KMS::Types::CreateGrantResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CreateGrantResponse
end

class Aws::KMS::Types::CreateKeyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CreateKeyRequest
end

class Aws::KMS::Types::CreateKeyResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CreateKeyResponse
end

class Aws::KMS::Types::CustomKeyStoreHasCMKsException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CustomKeyStoreHasCMKsException
end

class Aws::KMS::Types::CustomKeyStoreInvalidStateException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CustomKeyStoreInvalidStateException
end

class Aws::KMS::Types::CustomKeyStoreNameInUseException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CustomKeyStoreNameInUseException
end

class Aws::KMS::Types::CustomKeyStoreNotFoundException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CustomKeyStoreNotFoundException
end

class Aws::KMS::Types::CustomKeyStoresListEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::CustomKeyStoresListEntry
end

class Aws::KMS::Types::DecryptRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DecryptRequest
end

class Aws::KMS::Types::DecryptResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DecryptResponse
end

class Aws::KMS::Types::DeleteAliasRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DeleteAliasRequest
end

class Aws::KMS::Types::DeleteCustomKeyStoreRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DeleteCustomKeyStoreRequest
end

class Aws::KMS::Types::DeleteCustomKeyStoreResponse
end

class Aws::KMS::Types::DeleteCustomKeyStoreResponse
end

class Aws::KMS::Types::DeleteImportedKeyMaterialRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DeleteImportedKeyMaterialRequest
end

class Aws::KMS::Types::DependencyTimeoutException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DependencyTimeoutException
end

class Aws::KMS::Types::DescribeCustomKeyStoresRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DescribeCustomKeyStoresRequest
end

class Aws::KMS::Types::DescribeCustomKeyStoresResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DescribeCustomKeyStoresResponse
end

class Aws::KMS::Types::DescribeKeyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DescribeKeyRequest
end

class Aws::KMS::Types::DescribeKeyResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DescribeKeyResponse
end

class Aws::KMS::Types::DisableKeyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DisableKeyRequest
end

class Aws::KMS::Types::DisableKeyRotationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DisableKeyRotationRequest
end

class Aws::KMS::Types::DisabledException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DisabledException
end

class Aws::KMS::Types::DisconnectCustomKeyStoreRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::DisconnectCustomKeyStoreRequest
end

class Aws::KMS::Types::DisconnectCustomKeyStoreResponse
end

class Aws::KMS::Types::DisconnectCustomKeyStoreResponse
end

class Aws::KMS::Types::EnableKeyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::EnableKeyRequest
end

class Aws::KMS::Types::EnableKeyRotationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::EnableKeyRotationRequest
end

class Aws::KMS::Types::EncryptRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::EncryptRequest
end

class Aws::KMS::Types::EncryptResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::EncryptResponse
end

class Aws::KMS::Types::ExpiredImportTokenException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ExpiredImportTokenException
end

class Aws::KMS::Types::GenerateDataKeyPairRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GenerateDataKeyPairRequest
end

class Aws::KMS::Types::GenerateDataKeyPairResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GenerateDataKeyPairResponse
end

class Aws::KMS::Types::GenerateDataKeyPairWithoutPlaintextRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GenerateDataKeyPairWithoutPlaintextRequest
end

class Aws::KMS::Types::GenerateDataKeyPairWithoutPlaintextResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GenerateDataKeyPairWithoutPlaintextResponse
end

class Aws::KMS::Types::GenerateDataKeyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GenerateDataKeyRequest
end

class Aws::KMS::Types::GenerateDataKeyResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GenerateDataKeyResponse
end

class Aws::KMS::Types::GenerateDataKeyWithoutPlaintextRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GenerateDataKeyWithoutPlaintextRequest
end

class Aws::KMS::Types::GenerateDataKeyWithoutPlaintextResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GenerateDataKeyWithoutPlaintextResponse
end

class Aws::KMS::Types::GenerateRandomRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GenerateRandomRequest
end

class Aws::KMS::Types::GenerateRandomResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GenerateRandomResponse
end

class Aws::KMS::Types::GetKeyPolicyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GetKeyPolicyRequest
end

class Aws::KMS::Types::GetKeyPolicyResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GetKeyPolicyResponse
end

class Aws::KMS::Types::GetKeyRotationStatusRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GetKeyRotationStatusRequest
end

class Aws::KMS::Types::GetKeyRotationStatusResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GetKeyRotationStatusResponse
end

class Aws::KMS::Types::GetParametersForImportRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GetParametersForImportRequest
end

class Aws::KMS::Types::GetParametersForImportResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GetParametersForImportResponse
end

class Aws::KMS::Types::GetPublicKeyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GetPublicKeyRequest
end

class Aws::KMS::Types::GetPublicKeyResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GetPublicKeyResponse
end

class Aws::KMS::Types::GrantConstraints
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GrantConstraints
end

class Aws::KMS::Types::GrantListEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::GrantListEntry
end

class Aws::KMS::Types::ImportKeyMaterialRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ImportKeyMaterialRequest
end

class Aws::KMS::Types::ImportKeyMaterialResponse
end

class Aws::KMS::Types::ImportKeyMaterialResponse
end

class Aws::KMS::Types::IncorrectKeyException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::IncorrectKeyException
end

class Aws::KMS::Types::IncorrectKeyMaterialException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::IncorrectKeyMaterialException
end

class Aws::KMS::Types::IncorrectTrustAnchorException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::IncorrectTrustAnchorException
end

class Aws::KMS::Types::InvalidAliasNameException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::InvalidAliasNameException
end

class Aws::KMS::Types::InvalidArnException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::InvalidArnException
end

class Aws::KMS::Types::InvalidCiphertextException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::InvalidCiphertextException
end

class Aws::KMS::Types::InvalidGrantIdException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::InvalidGrantIdException
end

class Aws::KMS::Types::InvalidGrantTokenException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::InvalidGrantTokenException
end

class Aws::KMS::Types::InvalidImportTokenException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::InvalidImportTokenException
end

class Aws::KMS::Types::InvalidKeyUsageException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::InvalidKeyUsageException
end

class Aws::KMS::Types::InvalidMarkerException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::InvalidMarkerException
end

class Aws::KMS::Types::KMSInternalException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::KMSInternalException
end

class Aws::KMS::Types::KMSInvalidSignatureException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::KMSInvalidSignatureException
end

class Aws::KMS::Types::KMSInvalidStateException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::KMSInvalidStateException
end

class Aws::KMS::Types::KeyListEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::KeyListEntry
end

class Aws::KMS::Types::KeyMetadata
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::KeyMetadata
end

class Aws::KMS::Types::KeyUnavailableException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::KeyUnavailableException
end

class Aws::KMS::Types::LimitExceededException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::LimitExceededException
end

class Aws::KMS::Types::ListAliasesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListAliasesRequest
end

class Aws::KMS::Types::ListAliasesResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListAliasesResponse
end

class Aws::KMS::Types::ListGrantsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListGrantsRequest
end

class Aws::KMS::Types::ListGrantsResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListGrantsResponse
end

class Aws::KMS::Types::ListKeyPoliciesRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListKeyPoliciesRequest
end

class Aws::KMS::Types::ListKeyPoliciesResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListKeyPoliciesResponse
end

class Aws::KMS::Types::ListKeysRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListKeysRequest
end

class Aws::KMS::Types::ListKeysResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListKeysResponse
end

class Aws::KMS::Types::ListResourceTagsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListResourceTagsRequest
end

class Aws::KMS::Types::ListResourceTagsResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListResourceTagsResponse
end

class Aws::KMS::Types::ListRetirableGrantsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ListRetirableGrantsRequest
end

class Aws::KMS::Types::MalformedPolicyDocumentException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::MalformedPolicyDocumentException
end

class Aws::KMS::Types::NotFoundException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::NotFoundException
end

class Aws::KMS::Types::PutKeyPolicyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::PutKeyPolicyRequest
end

class Aws::KMS::Types::ReEncryptRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ReEncryptRequest
end

class Aws::KMS::Types::ReEncryptResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ReEncryptResponse
end

class Aws::KMS::Types::RetireGrantRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::RetireGrantRequest
end

class Aws::KMS::Types::RevokeGrantRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::RevokeGrantRequest
end

class Aws::KMS::Types::ScheduleKeyDeletionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ScheduleKeyDeletionRequest
end

class Aws::KMS::Types::ScheduleKeyDeletionResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::ScheduleKeyDeletionResponse
end

class Aws::KMS::Types::SignRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::SignRequest
end

class Aws::KMS::Types::SignResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::SignResponse
end

class Aws::KMS::Types::Tag
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::Tag
end

class Aws::KMS::Types::TagException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::TagException
end

class Aws::KMS::Types::TagResourceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::TagResourceRequest
end

class Aws::KMS::Types::UnsupportedOperationException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::UnsupportedOperationException
end

class Aws::KMS::Types::UntagResourceRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::UntagResourceRequest
end

class Aws::KMS::Types::UpdateAliasRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::UpdateAliasRequest
end

class Aws::KMS::Types::UpdateCustomKeyStoreRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::UpdateCustomKeyStoreRequest
end

class Aws::KMS::Types::UpdateCustomKeyStoreResponse
end

class Aws::KMS::Types::UpdateCustomKeyStoreResponse
end

class Aws::KMS::Types::UpdateKeyDescriptionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::UpdateKeyDescriptionRequest
end

class Aws::KMS::Types::VerifyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::VerifyRequest
end

class Aws::KMS::Types::VerifyResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::KMS::Types::VerifyResponse
end

module Aws::KMS::Types
end

module Aws::KMS
end

module Aws::Log
end

class Aws::Log::Formatter
  def format(response); end

  def initialize(pattern, options=T.unsafe(nil)); end

  def method_missing(method_name, *args); end

  def pattern(); end
end

class Aws::Log::Formatter
  def self.colored(options=T.unsafe(nil)); end

  def self.default(options=T.unsafe(nil)); end

  def self.short(options=T.unsafe(nil)); end
end

class Aws::Log::ParamFilter
  def filter(values, type); end

  def initialize(options=T.unsafe(nil)); end
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::Log::ParamFilter
end

class Aws::Log::ParamFormatter
  def initialize(options=T.unsafe(nil)); end

  def summarize(value); end
  MAX_STRING_SIZE = ::T.let(nil, ::T.untyped)
end

class Aws::Log::ParamFormatter
end

module Aws::Log
end

module Aws::PageableResponse
  def each(&block); end

  def each_page(&block); end

  def last_page?(); end

  def next_page(params=T.unsafe(nil)); end

  def next_page?(); end

  def pager(); end

  def pager=(pager); end
end

class Aws::PageableResponse::LastPageError
  def initialize(response); end

  def response(); end
end

class Aws::PageableResponse::LastPageError
end

module Aws::PageableResponse::UnsafeEnumerableMethods
  def count(); end

  def respond_to?(method_name, *args); end

  def to_h(); end
end

module Aws::PageableResponse::UnsafeEnumerableMethods
end

module Aws::PageableResponse
  def self.extended(base); end
end

class Aws::Pager
  def initialize(options); end

  def limit_key(); end

  def next_tokens(response); end

  def prev_tokens(response); end

  def truncated?(response); end
end

class Aws::Pager::NullPager
  def limit_key(); end

  def next_tokens(); end

  def prev_tokens(); end

  def truncated?(response); end
end

class Aws::Pager::NullPager
end

class Aws::Pager
end

class Aws::ParamConverter
  include ::Seahorse::Model::Shapes
  def close_opened_files(); end

  def convert(params); end

  def initialize(rules); end

  def opened_files(); end
end

class Aws::ParamConverter
  def self.add(shape_class, value_class, converter=T.unsafe(nil), &block); end

  def self.c(shape, value, instance=T.unsafe(nil)); end

  def self.convert(shape, params); end

  def self.ensure_open(file, converter); end
end

class Aws::ParamValidator
  include ::Seahorse::Model::Shapes
  def initialize(rules, options=T.unsafe(nil)); end

  def validate!(params); end
  EXPECTED_GOT = ::T.let(nil, ::T.untyped)
end

class Aws::ParamValidator
  def self.validate!(rules, params); end
end

module Aws::Partitions
end

class Aws::Partitions::EndpointProvider
  def dns_suffix_for(region); end

  def initialize(rules); end

  def resolve(region, service, sts_regional_endpoints); end

  def signing_region(region, service); end
  STS_LEGACY_REGIONS = ::T.let(nil, ::T.untyped)
end

class Aws::Partitions::EndpointProvider
  def self.dns_suffix_for(region); end

  def self.resolve(region, service, sts_regional_endpoints=T.unsafe(nil)); end

  def self.signing_region(region, service); end
end

class Aws::Partitions::Partition
  def initialize(options=T.unsafe(nil)); end

  def name(); end

  def region(region_name); end

  def region?(region_name); end

  def regions(); end

  def service(service_name); end

  def service?(service_name); end

  def services(); end
end

class Aws::Partitions::Partition
  def self.build(partition); end
end

class Aws::Partitions::PartitionList
  include ::Enumerable
  def add_partition(partition); end

  def clear(); end

  def each(&block); end

  def partition(partition_name); end

  def partitions(); end
end

class Aws::Partitions::PartitionList
  def self.build(partitions); end
end

class Aws::Partitions::Region
  def description(); end

  def initialize(options=T.unsafe(nil)); end

  def name(); end

  def partition_name(); end

  def services(); end
end

class Aws::Partitions::Region
  def self.build(region_name, region, partition); end
end

class Aws::Partitions::Service
  def initialize(options=T.unsafe(nil)); end

  def name(); end

  def partition_name(); end

  def partition_region(); end

  def regionalized?(); end

  def regions(); end
end

class Aws::Partitions::Service
  def self.build(service_name, service, partition); end
end

module Aws::Partitions
  extend ::Enumerable
  def self.add(new_partitions); end

  def self.clear(); end

  def self.default_partition_list(); end

  def self.defaults(); end

  def self.each(&block); end

  def self.partition(name); end

  def self.partitions(); end

  def self.service_ids(); end
end

module Aws::Plugins
end

class Aws::Plugins::ClientMetricsPlugin
end

class Aws::Plugins::ClientMetricsPlugin::Handler
end

class Aws::Plugins::ClientMetricsPlugin::Handler
end

class Aws::Plugins::ClientMetricsPlugin
  def self.resolve_client_id(cfg); end

  def self.resolve_client_side_monitoring(cfg); end

  def self.resolve_client_side_monitoring_host(cfg); end

  def self.resolve_client_side_monitoring_port(cfg); end

  def self.resolve_publisher(cfg); end
end

class Aws::Plugins::ClientMetricsSendPlugin
end

class Aws::Plugins::ClientMetricsSendPlugin::AttemptHandler
end

class Aws::Plugins::ClientMetricsSendPlugin::AttemptHandler
end

class Aws::Plugins::ClientMetricsSendPlugin::LatencyHandler
end

class Aws::Plugins::ClientMetricsSendPlugin::LatencyHandler
end

class Aws::Plugins::ClientMetricsSendPlugin
end

class Aws::Plugins::CredentialsConfiguration
end

class Aws::Plugins::CredentialsConfiguration
end

class Aws::Plugins::EndpointDiscovery
end

class Aws::Plugins::EndpointDiscovery::Handler
end

class Aws::Plugins::EndpointDiscovery::Handler
end

class Aws::Plugins::EndpointDiscovery
  def self.resolve_endpoint_discovery(cfg); end
end

class Aws::Plugins::EndpointPattern
end

class Aws::Plugins::EndpointPattern::Handler
end

class Aws::Plugins::EndpointPattern::Handler
end

class Aws::Plugins::EndpointPattern
end

class Aws::Plugins::EventStreamConfiguration
end

class Aws::Plugins::EventStreamConfiguration
end

class Aws::Plugins::GlobalConfiguration
end

class Aws::Plugins::GlobalConfiguration
  def self.add_identifier(identifier); end

  def self.identifiers(); end
end

class Aws::Plugins::HelpfulSocketErrors
end

class Aws::Plugins::HelpfulSocketErrors::Handler
end

class Aws::Plugins::HelpfulSocketErrors::Handler
end

class Aws::Plugins::HelpfulSocketErrors
end

class Aws::Plugins::HttpChecksum
  def add_handlers(handlers, _config); end
end

class Aws::Plugins::HttpChecksum::Handler
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::HttpChecksum::Handler
end

class Aws::Plugins::HttpChecksum
end

class Aws::Plugins::IdempotencyToken
end

class Aws::Plugins::IdempotencyToken::Handler
end

class Aws::Plugins::IdempotencyToken::Handler
end

class Aws::Plugins::IdempotencyToken
end

class Aws::Plugins::JsonvalueConverter
end

class Aws::Plugins::JsonvalueConverter::Handler
end

class Aws::Plugins::JsonvalueConverter::Handler
end

class Aws::Plugins::JsonvalueConverter
end

class Aws::Plugins::Logging
end

class Aws::Plugins::Logging::Handler
end

class Aws::Plugins::Logging::Handler
end

class Aws::Plugins::Logging
end

class Aws::Plugins::ParamConverter
end

class Aws::Plugins::ParamConverter::Handler
end

class Aws::Plugins::ParamConverter::Handler
end

class Aws::Plugins::ParamConverter
end

class Aws::Plugins::ParamValidator
end

class Aws::Plugins::ParamValidator::Handler
end

class Aws::Plugins::ParamValidator::Handler
end

class Aws::Plugins::ParamValidator
end

module Aws::Plugins::Protocols
end

class Aws::Plugins::Protocols::EC2
end

class Aws::Plugins::Protocols::EC2::Handler
end

class Aws::Plugins::Protocols::EC2::Handler
end

class Aws::Plugins::Protocols::EC2
end

class Aws::Plugins::Protocols::JsonRpc
end

class Aws::Plugins::Protocols::JsonRpc
end

class Aws::Plugins::Protocols::Query
end

class Aws::Plugins::Protocols::Query
end

class Aws::Plugins::Protocols::RestXml
end

class Aws::Plugins::Protocols::RestXml
end

module Aws::Plugins::Protocols
end

class Aws::Plugins::RegionalEndpoint
end

class Aws::Plugins::RegionalEndpoint
end

class Aws::Plugins::ResponsePaging
end

class Aws::Plugins::ResponsePaging::Handler
end

class Aws::Plugins::ResponsePaging::Handler
end

class Aws::Plugins::ResponsePaging
end

module Aws::Plugins::Retries
end

class Aws::Plugins::Retries::ClientRateLimiter
  def token_bucket_acquire(amount, wait_to_fill=T.unsafe(nil)); end

  def update_sending_rate(is_throttling_error); end
  BETA = ::T.let(nil, ::T.untyped)
  MIN_CAPACITY = ::T.let(nil, ::T.untyped)
  MIN_FILL_RATE = ::T.let(nil, ::T.untyped)
  SCALE_CONSTANT = ::T.let(nil, ::T.untyped)
  SMOOTH = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::ClientRateLimiter
end

class Aws::Plugins::Retries::ClockSkew
  def clock_correction(endpoint); end

  def clock_skewed?(context); end

  def estimated_skew(endpoint); end

  def update_clock_correction(context); end

  def update_estimated_skew(context); end
  CLOCK_SKEW_THRESHOLD = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::ClockSkew
end

class Aws::Plugins::Retries::ErrorInspector
  def checksum?(); end

  def clock_skew?(context); end

  def endpoint_discovery?(context); end

  def expired_credentials?(); end

  def initialize(error, http_status_code); end

  def modeled_retryable?(); end

  def modeled_throttling?(); end

  def networking?(); end

  def retryable?(context); end

  def server?(); end

  def throttling_error?(); end
  CHECKSUM_ERRORS = ::T.let(nil, ::T.untyped)
  CLOCK_SKEW_ERRORS = ::T.let(nil, ::T.untyped)
  EXPIRED_CREDS = ::T.let(nil, ::T.untyped)
  NETWORKING_ERRORS = ::T.let(nil, ::T.untyped)
  THROTTLING_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::ErrorInspector
end

class Aws::Plugins::Retries::RetryQuota
  def checkout_capacity(error_inspector); end

  def initialize(opts=T.unsafe(nil)); end

  def release(capacity_amount); end
  INITIAL_RETRY_TOKENS = ::T.let(nil, ::T.untyped)
  NO_RETRY_INCREMENT = ::T.let(nil, ::T.untyped)
  RETRY_COST = ::T.let(nil, ::T.untyped)
  TIMEOUT_RETRY_COST = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::RetryQuota
end

module Aws::Plugins::Retries
end

class Aws::Plugins::RetryErrors
  DEFAULT_BACKOFF = ::T.let(nil, ::T.untyped)
  EQUAL_JITTER = ::T.let(nil, ::T.untyped)
  FULL_JITTER = ::T.let(nil, ::T.untyped)
  JITTERS = ::T.let(nil, ::T.untyped)
  NO_JITTER = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::RetryErrors::Handler
  MAX_BACKOFF = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::RetryErrors::Handler
end

class Aws::Plugins::RetryErrors::LegacyHandler
end

class Aws::Plugins::RetryErrors::LegacyHandler
end

class Aws::Plugins::RetryErrors
  def self.resolve_adaptive_retry_wait_to_fill(cfg); end

  def self.resolve_correct_clock_skew(cfg); end

  def self.resolve_max_attempts(cfg); end

  def self.resolve_retry_mode(cfg); end
end

class Aws::Plugins::SignatureV4
  def add_handlers(handlers, cfg); end
end

class Aws::Plugins::SignatureV4::Handler
end

class Aws::Plugins::SignatureV4::Handler
end

class Aws::Plugins::SignatureV4::MissingCredentialsSigner
  def sign_request(*args); end
end

class Aws::Plugins::SignatureV4::MissingCredentialsSigner
end

class Aws::Plugins::SignatureV4
  def self.apply_authtype(context); end

  def self.apply_signature(options=T.unsafe(nil)); end

  def self.build_signer(cfg); end
end

class Aws::Plugins::StubResponses
end

class Aws::Plugins::StubResponses::Handler
  def apply_stub(stub, response, async_mode=T.unsafe(nil)); end

  def signal_error(error, http_resp); end

  def signal_http(stub, http_resp, async_mode=T.unsafe(nil)); end
end

class Aws::Plugins::StubResponses::Handler
end

class Aws::Plugins::StubResponses
end

class Aws::Plugins::TransferEncoding
end

class Aws::Plugins::TransferEncoding::Handler
end

class Aws::Plugins::TransferEncoding::Handler
end

class Aws::Plugins::TransferEncoding
end

class Aws::Plugins::UserAgent
end

class Aws::Plugins::UserAgent::Handler
  def set_user_agent(context); end
end

class Aws::Plugins::UserAgent::Handler
end

class Aws::Plugins::UserAgent
end

module Aws::Plugins
end

class Aws::ProcessCredentials
  include ::Aws::CredentialProvider
  include ::Aws::RefreshingCredentials
  def initialize(process); end
end

class Aws::ProcessCredentials
end

module Aws::Query
end

class Aws::Query::EC2ParamBuilder
  include ::Seahorse::Model::Shapes
  def apply(ref, params); end

  def initialize(param_list); end

  def params(); end
end

class Aws::Query::EC2ParamBuilder
end

class Aws::Query::Handler
  include ::Seahorse::Model::Shapes
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  METADATA_REF = ::T.let(nil, ::T.untyped)
end

class Aws::Query::Handler
end

class Aws::Query::Param
  def ==(other); end

  def initialize(name, value=T.unsafe(nil)); end

  def name(); end

  def value(); end
end

class Aws::Query::Param
end

class Aws::Query::ParamBuilder
  include ::Seahorse::Model::Shapes
  def apply(ref, params); end

  def initialize(param_list); end

  def params(); end
end

class Aws::Query::ParamBuilder
end

class Aws::Query::ParamList
  include ::Enumerable
  def [](param_name); end

  def []=(param_name, param_value=T.unsafe(nil)); end

  def delete(param_name); end

  def each(&block); end

  def empty?(); end

  def set(param_name, param_value=T.unsafe(nil)); end

  def to_a(); end

  def to_io(); end
end

class Aws::Query::ParamList::IoWrapper
  def initialize(param_list); end

  def param_list(); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end
end

class Aws::Query::ParamList::IoWrapper
end

class Aws::Query::ParamList
end

module Aws::Query
end

module Aws::RefreshingCredentials
  def credentials(); end

  def expiration(); end

  def initialize(options=T.unsafe(nil)); end

  def refresh!(); end
end

module Aws::RefreshingCredentials
end

module Aws::Resources
end

class Aws::Resources::Collection
  include ::Enumerable
  def [](*args, &block); end

  def batches(); end

  def each(&block); end

  def first(count=T.unsafe(nil)); end

  def initialize(batches, options=T.unsafe(nil)); end

  def length(); end

  def limit(limit); end

  def size(); end
end

class Aws::Resources::Collection
  extend ::Aws::Deprecations
end

module Aws::Resources
end

module Aws::Rest
end

class Aws::Rest::Handler
end

class Aws::Rest::Handler
end

module Aws::Rest::Request
end

class Aws::Rest::Request::Body
  include ::Seahorse::Model::Shapes
  def apply(http_req, params); end

  def initialize(serializer_class, rules); end
end

class Aws::Rest::Request::Body
end

class Aws::Rest::Request::Builder
  def apply(context); end
end

class Aws::Rest::Request::Builder
end

class Aws::Rest::Request::Endpoint
  def initialize(rules, request_uri_pattern); end

  def uri(base_uri, params); end
end

class Aws::Rest::Request::Endpoint
end

class Aws::Rest::Request::Headers
  include ::Seahorse::Model::Shapes
  def apply(http_req, params); end

  def initialize(rules); end
end

class Aws::Rest::Request::Headers
end

class Aws::Rest::Request::QuerystringBuilder
  include ::Seahorse::Model::Shapes
  def build(params); end
end

class Aws::Rest::Request::QuerystringBuilder
end

module Aws::Rest::Request
end

module Aws::Rest::Response
end

class Aws::Rest::Response::Body
  include ::Seahorse::Model::Shapes
  def apply(body, data); end

  def initialize(parser_class, rules); end
end

class Aws::Rest::Response::Body
end

class Aws::Rest::Response::Headers
  include ::Seahorse::Model::Shapes
  def apply(http_resp, target); end

  def cast_value(ref, value); end

  def extract_header_map(headers, name, ref, data); end

  def extract_header_value(headers, name, ref, data); end

  def extract_json_trait(value); end

  def initialize(rules); end
end

class Aws::Rest::Response::Headers
end

class Aws::Rest::Response::Parser
  def apply(response); end
end

class Aws::Rest::Response::Parser
end

class Aws::Rest::Response::StatusCode
  def apply(http_resp, data); end

  def initialize(rules); end
end

class Aws::Rest::Response::StatusCode
end

module Aws::Rest::Response
end

module Aws::Rest
end

module Aws::S3
  BUCKET_REGIONS = ::T.let(nil, ::T.untyped)
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Bucket
  def acl(); end

  def clear!(); end

  def client(); end

  def cors(); end

  def create(options=T.unsafe(nil)); end

  def creation_date(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete!(options=T.unsafe(nil)); end

  def delete_objects(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def exists?(options=T.unsafe(nil)); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def lifecycle(); end

  def lifecycle_configuration(); end

  def load(); end

  def logging(); end

  def multipart_uploads(options=T.unsafe(nil)); end

  def name(); end

  def notification(); end

  def object(key); end

  def object_versions(options=T.unsafe(nil)); end

  def objects(options=T.unsafe(nil)); end

  def policy(); end

  def presigned_post(options=T.unsafe(nil)); end

  def put_object(options=T.unsafe(nil)); end

  def reload(); end

  def request_payment(); end

  def tagging(); end

  def url(options=T.unsafe(nil)); end

  def versioning(); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_exists(options=T.unsafe(nil), &block); end

  def wait_until_not_exists(options=T.unsafe(nil), &block); end

  def website(); end
end

class Aws::S3::Bucket::Collection
end

class Aws::S3::Bucket::Collection
end

class Aws::S3::Bucket
  extend ::Aws::Deprecations
end

class Aws::S3::BucketAcl
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def grants(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def owner(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketAcl::Collection
end

class Aws::S3::BucketAcl::Collection
end

class Aws::S3::BucketAcl
  extend ::Aws::Deprecations
end

class Aws::S3::BucketCors
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def cors_rules(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketCors::Collection
end

class Aws::S3::BucketCors::Collection
end

class Aws::S3::BucketCors
  extend ::Aws::Deprecations
end

class Aws::S3::BucketLifecycle
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def rules(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketLifecycle::Collection
end

class Aws::S3::BucketLifecycle::Collection
end

class Aws::S3::BucketLifecycle
  extend ::Aws::Deprecations
end

class Aws::S3::BucketLifecycleConfiguration
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def rules(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketLifecycleConfiguration::Collection
end

class Aws::S3::BucketLifecycleConfiguration::Collection
end

class Aws::S3::BucketLifecycleConfiguration
  extend ::Aws::Deprecations
end

class Aws::S3::BucketLogging
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def logging_enabled(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketLogging::Collection
end

class Aws::S3::BucketLogging::Collection
end

class Aws::S3::BucketLogging
  extend ::Aws::Deprecations
end

class Aws::S3::BucketNotification
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def lambda_function_configurations(); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def queue_configurations(); end

  def reload(); end

  def topic_configurations(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketNotification::Collection
end

class Aws::S3::BucketNotification::Collection
end

class Aws::S3::BucketNotification
  extend ::Aws::Deprecations
end

class Aws::S3::BucketPolicy
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def policy(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketPolicy::Collection
end

class Aws::S3::BucketPolicy::Collection
end

class Aws::S3::BucketPolicy
  extend ::Aws::Deprecations
end

class Aws::S3::BucketRegionCache
  def [](bucket_name); end

  def []=(bucket_name, region_name); end

  def bucket_added(&block); end

  def clear(); end

  def to_h(); end

  def to_hash(); end
end

class Aws::S3::BucketRegionCache
end

class Aws::S3::BucketRequestPayment
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def payer(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketRequestPayment::Collection
end

class Aws::S3::BucketRequestPayment::Collection
end

class Aws::S3::BucketRequestPayment
  extend ::Aws::Deprecations
end

class Aws::S3::BucketTagging
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def tag_set(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketTagging::Collection
end

class Aws::S3::BucketTagging::Collection
end

class Aws::S3::BucketTagging
  extend ::Aws::Deprecations
end

class Aws::S3::BucketVersioning
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def enable(options=T.unsafe(nil)); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def mfa_delete(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def status(); end

  def suspend(options=T.unsafe(nil)); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketVersioning::Collection
end

class Aws::S3::BucketVersioning::Collection
end

class Aws::S3::BucketVersioning
  extend ::Aws::Deprecations
end

class Aws::S3::BucketWebsite
  def bucket(); end

  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def error_document(); end

  def identifiers(*args, &block); end

  def index_document(); end

  def initialize(*args); end

  def load(); end

  def put(options=T.unsafe(nil)); end

  def redirect_all_requests_to(); end

  def reload(); end

  def routing_rules(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::BucketWebsite::Collection
end

class Aws::S3::BucketWebsite::Collection
end

class Aws::S3::BucketWebsite
  extend ::Aws::Deprecations
end

class Aws::S3::Client
  include ::Aws::ClientStubs
  def abort_multipart_upload(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def complete_multipart_upload(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def copy_object(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_bucket(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_multipart_upload(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_analytics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_cors(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_encryption(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_inventory_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_lifecycle(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_metrics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_policy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_replication(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_bucket_website(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_object(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_object_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_objects(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_public_access_block(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_accelerate_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_acl(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_analytics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_cors(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_encryption(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_inventory_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_lifecycle(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_lifecycle_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_location(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_logging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_metrics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_notification(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_notification_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_policy(params=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def get_bucket_policy_status(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_replication(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_request_payment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_versioning(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_bucket_website(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object(params=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def get_object_acl(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object_legal_hold(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object_lock_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object_retention(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_object_torrent(params=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def get_public_access_block(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def head_bucket(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def head_object(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(*args); end

  def list_bucket_analytics_configurations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_bucket_inventory_configurations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_bucket_metrics_configurations(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_buckets(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_multipart_uploads(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_object_versions(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_objects(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_objects_v2(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_parts(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_accelerate_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_acl(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_analytics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_cors(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_encryption(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_inventory_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_lifecycle(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_lifecycle_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_logging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_metrics_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_notification(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_notification_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_policy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_replication(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_request_payment(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_versioning(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_bucket_website(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object_acl(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object_legal_hold(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object_lock_configuration(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object_retention(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_object_tagging(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def put_public_access_block(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def restore_object(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_object_content(params=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def upload_part(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def upload_part_copy(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def wait_until(waiter_name, params=T.unsafe(nil), options=T.unsafe(nil)); end

  def waiter_names(); end
end

class Aws::S3::Client
  def self.errors_module(); end

  def self.identifier(); end
end

module Aws::S3::ClientApi
  include ::Seahorse::Model
  API = ::T.let(nil, ::T.untyped)
  AbortDate = ::T.let(nil, ::T.untyped)
  AbortIncompleteMultipartUpload = ::T.let(nil, ::T.untyped)
  AbortMultipartUploadOutput = ::T.let(nil, ::T.untyped)
  AbortMultipartUploadRequest = ::T.let(nil, ::T.untyped)
  AbortRuleId = ::T.let(nil, ::T.untyped)
  AccelerateConfiguration = ::T.let(nil, ::T.untyped)
  AcceptRanges = ::T.let(nil, ::T.untyped)
  AccessControlPolicy = ::T.let(nil, ::T.untyped)
  AccessControlTranslation = ::T.let(nil, ::T.untyped)
  AccountId = ::T.let(nil, ::T.untyped)
  AllowQuotedRecordDelimiter = ::T.let(nil, ::T.untyped)
  AllowedHeader = ::T.let(nil, ::T.untyped)
  AllowedHeaders = ::T.let(nil, ::T.untyped)
  AllowedMethod = ::T.let(nil, ::T.untyped)
  AllowedMethods = ::T.let(nil, ::T.untyped)
  AllowedOrigin = ::T.let(nil, ::T.untyped)
  AllowedOrigins = ::T.let(nil, ::T.untyped)
  AnalyticsAndOperator = ::T.let(nil, ::T.untyped)
  AnalyticsConfiguration = ::T.let(nil, ::T.untyped)
  AnalyticsConfigurationList = ::T.let(nil, ::T.untyped)
  AnalyticsExportDestination = ::T.let(nil, ::T.untyped)
  AnalyticsFilter = ::T.let(nil, ::T.untyped)
  AnalyticsId = ::T.let(nil, ::T.untyped)
  AnalyticsS3BucketDestination = ::T.let(nil, ::T.untyped)
  AnalyticsS3ExportFileFormat = ::T.let(nil, ::T.untyped)
  Body = ::T.let(nil, ::T.untyped)
  Bucket = ::T.let(nil, ::T.untyped)
  BucketAccelerateStatus = ::T.let(nil, ::T.untyped)
  BucketAlreadyExists = ::T.let(nil, ::T.untyped)
  BucketAlreadyOwnedByYou = ::T.let(nil, ::T.untyped)
  BucketCannedACL = ::T.let(nil, ::T.untyped)
  BucketLifecycleConfiguration = ::T.let(nil, ::T.untyped)
  BucketLocationConstraint = ::T.let(nil, ::T.untyped)
  BucketLoggingStatus = ::T.let(nil, ::T.untyped)
  BucketLogsPermission = ::T.let(nil, ::T.untyped)
  BucketName = ::T.let(nil, ::T.untyped)
  BucketVersioningStatus = ::T.let(nil, ::T.untyped)
  Buckets = ::T.let(nil, ::T.untyped)
  BypassGovernanceRetention = ::T.let(nil, ::T.untyped)
  BytesProcessed = ::T.let(nil, ::T.untyped)
  BytesReturned = ::T.let(nil, ::T.untyped)
  BytesScanned = ::T.let(nil, ::T.untyped)
  CORSConfiguration = ::T.let(nil, ::T.untyped)
  CORSRule = ::T.let(nil, ::T.untyped)
  CORSRules = ::T.let(nil, ::T.untyped)
  CSVInput = ::T.let(nil, ::T.untyped)
  CSVOutput = ::T.let(nil, ::T.untyped)
  CacheControl = ::T.let(nil, ::T.untyped)
  CloudFunction = ::T.let(nil, ::T.untyped)
  CloudFunctionConfiguration = ::T.let(nil, ::T.untyped)
  CloudFunctionInvocationRole = ::T.let(nil, ::T.untyped)
  Code = ::T.let(nil, ::T.untyped)
  Comments = ::T.let(nil, ::T.untyped)
  CommonPrefix = ::T.let(nil, ::T.untyped)
  CommonPrefixList = ::T.let(nil, ::T.untyped)
  CompleteMultipartUploadOutput = ::T.let(nil, ::T.untyped)
  CompleteMultipartUploadRequest = ::T.let(nil, ::T.untyped)
  CompletedMultipartUpload = ::T.let(nil, ::T.untyped)
  CompletedPart = ::T.let(nil, ::T.untyped)
  CompletedPartList = ::T.let(nil, ::T.untyped)
  CompressionType = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  ConfirmRemoveSelfBucketAccess = ::T.let(nil, ::T.untyped)
  ContentDisposition = ::T.let(nil, ::T.untyped)
  ContentEncoding = ::T.let(nil, ::T.untyped)
  ContentLanguage = ::T.let(nil, ::T.untyped)
  ContentLength = ::T.let(nil, ::T.untyped)
  ContentMD5 = ::T.let(nil, ::T.untyped)
  ContentRange = ::T.let(nil, ::T.untyped)
  ContentType = ::T.let(nil, ::T.untyped)
  ContinuationEvent = ::T.let(nil, ::T.untyped)
  CopyObjectOutput = ::T.let(nil, ::T.untyped)
  CopyObjectRequest = ::T.let(nil, ::T.untyped)
  CopyObjectResult = ::T.let(nil, ::T.untyped)
  CopyPartResult = ::T.let(nil, ::T.untyped)
  CopySource = ::T.let(nil, ::T.untyped)
  CopySourceIfMatch = ::T.let(nil, ::T.untyped)
  CopySourceIfModifiedSince = ::T.let(nil, ::T.untyped)
  CopySourceIfNoneMatch = ::T.let(nil, ::T.untyped)
  CopySourceIfUnmodifiedSince = ::T.let(nil, ::T.untyped)
  CopySourceRange = ::T.let(nil, ::T.untyped)
  CopySourceSSECustomerAlgorithm = ::T.let(nil, ::T.untyped)
  CopySourceSSECustomerKey = ::T.let(nil, ::T.untyped)
  CopySourceSSECustomerKeyMD5 = ::T.let(nil, ::T.untyped)
  CopySourceVersionId = ::T.let(nil, ::T.untyped)
  CreateBucketConfiguration = ::T.let(nil, ::T.untyped)
  CreateBucketOutput = ::T.let(nil, ::T.untyped)
  CreateBucketRequest = ::T.let(nil, ::T.untyped)
  CreateMultipartUploadOutput = ::T.let(nil, ::T.untyped)
  CreateMultipartUploadRequest = ::T.let(nil, ::T.untyped)
  CreationDate = ::T.let(nil, ::T.untyped)
  Date = ::T.let(nil, ::T.untyped)
  Days = ::T.let(nil, ::T.untyped)
  DaysAfterInitiation = ::T.let(nil, ::T.untyped)
  DefaultRetention = ::T.let(nil, ::T.untyped)
  Delete = ::T.let(nil, ::T.untyped)
  DeleteBucketAnalyticsConfigurationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketCorsRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketEncryptionRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketInventoryConfigurationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketLifecycleRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketMetricsConfigurationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketPolicyRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketReplicationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketTaggingRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketWebsiteRequest = ::T.let(nil, ::T.untyped)
  DeleteMarker = ::T.let(nil, ::T.untyped)
  DeleteMarkerEntry = ::T.let(nil, ::T.untyped)
  DeleteMarkerReplication = ::T.let(nil, ::T.untyped)
  DeleteMarkerReplicationStatus = ::T.let(nil, ::T.untyped)
  DeleteMarkerVersionId = ::T.let(nil, ::T.untyped)
  DeleteMarkers = ::T.let(nil, ::T.untyped)
  DeleteObjectOutput = ::T.let(nil, ::T.untyped)
  DeleteObjectRequest = ::T.let(nil, ::T.untyped)
  DeleteObjectTaggingOutput = ::T.let(nil, ::T.untyped)
  DeleteObjectTaggingRequest = ::T.let(nil, ::T.untyped)
  DeleteObjectsOutput = ::T.let(nil, ::T.untyped)
  DeleteObjectsRequest = ::T.let(nil, ::T.untyped)
  DeletePublicAccessBlockRequest = ::T.let(nil, ::T.untyped)
  DeletedObject = ::T.let(nil, ::T.untyped)
  DeletedObjects = ::T.let(nil, ::T.untyped)
  Delimiter = ::T.let(nil, ::T.untyped)
  Description = ::T.let(nil, ::T.untyped)
  Destination = ::T.let(nil, ::T.untyped)
  DisplayName = ::T.let(nil, ::T.untyped)
  ETag = ::T.let(nil, ::T.untyped)
  EmailAddress = ::T.let(nil, ::T.untyped)
  EnableRequestProgress = ::T.let(nil, ::T.untyped)
  EncodingType = ::T.let(nil, ::T.untyped)
  Encryption = ::T.let(nil, ::T.untyped)
  EncryptionConfiguration = ::T.let(nil, ::T.untyped)
  End = ::T.let(nil, ::T.untyped)
  EndEvent = ::T.let(nil, ::T.untyped)
  Error = ::T.let(nil, ::T.untyped)
  ErrorDocument = ::T.let(nil, ::T.untyped)
  Errors = ::T.let(nil, ::T.untyped)
  Event = ::T.let(nil, ::T.untyped)
  EventList = ::T.let(nil, ::T.untyped)
  ExistingObjectReplication = ::T.let(nil, ::T.untyped)
  ExistingObjectReplicationStatus = ::T.let(nil, ::T.untyped)
  Expiration = ::T.let(nil, ::T.untyped)
  ExpirationStatus = ::T.let(nil, ::T.untyped)
  ExpiredObjectDeleteMarker = ::T.let(nil, ::T.untyped)
  Expires = ::T.let(nil, ::T.untyped)
  ExpiresString = ::T.let(nil, ::T.untyped)
  ExposeHeader = ::T.let(nil, ::T.untyped)
  ExposeHeaders = ::T.let(nil, ::T.untyped)
  Expression = ::T.let(nil, ::T.untyped)
  ExpressionType = ::T.let(nil, ::T.untyped)
  FetchOwner = ::T.let(nil, ::T.untyped)
  FieldDelimiter = ::T.let(nil, ::T.untyped)
  FileHeaderInfo = ::T.let(nil, ::T.untyped)
  FilterRule = ::T.let(nil, ::T.untyped)
  FilterRuleList = ::T.let(nil, ::T.untyped)
  FilterRuleName = ::T.let(nil, ::T.untyped)
  FilterRuleValue = ::T.let(nil, ::T.untyped)
  GetBucketAccelerateConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketAccelerateConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketAclOutput = ::T.let(nil, ::T.untyped)
  GetBucketAclRequest = ::T.let(nil, ::T.untyped)
  GetBucketAnalyticsConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketAnalyticsConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketCorsOutput = ::T.let(nil, ::T.untyped)
  GetBucketCorsRequest = ::T.let(nil, ::T.untyped)
  GetBucketEncryptionOutput = ::T.let(nil, ::T.untyped)
  GetBucketEncryptionRequest = ::T.let(nil, ::T.untyped)
  GetBucketInventoryConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketInventoryConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleOutput = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleRequest = ::T.let(nil, ::T.untyped)
  GetBucketLocationOutput = ::T.let(nil, ::T.untyped)
  GetBucketLocationRequest = ::T.let(nil, ::T.untyped)
  GetBucketLoggingOutput = ::T.let(nil, ::T.untyped)
  GetBucketLoggingRequest = ::T.let(nil, ::T.untyped)
  GetBucketMetricsConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketMetricsConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketNotificationConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketPolicyOutput = ::T.let(nil, ::T.untyped)
  GetBucketPolicyRequest = ::T.let(nil, ::T.untyped)
  GetBucketPolicyStatusOutput = ::T.let(nil, ::T.untyped)
  GetBucketPolicyStatusRequest = ::T.let(nil, ::T.untyped)
  GetBucketReplicationOutput = ::T.let(nil, ::T.untyped)
  GetBucketReplicationRequest = ::T.let(nil, ::T.untyped)
  GetBucketRequestPaymentOutput = ::T.let(nil, ::T.untyped)
  GetBucketRequestPaymentRequest = ::T.let(nil, ::T.untyped)
  GetBucketTaggingOutput = ::T.let(nil, ::T.untyped)
  GetBucketTaggingRequest = ::T.let(nil, ::T.untyped)
  GetBucketVersioningOutput = ::T.let(nil, ::T.untyped)
  GetBucketVersioningRequest = ::T.let(nil, ::T.untyped)
  GetBucketWebsiteOutput = ::T.let(nil, ::T.untyped)
  GetBucketWebsiteRequest = ::T.let(nil, ::T.untyped)
  GetObjectAclOutput = ::T.let(nil, ::T.untyped)
  GetObjectAclRequest = ::T.let(nil, ::T.untyped)
  GetObjectLegalHoldOutput = ::T.let(nil, ::T.untyped)
  GetObjectLegalHoldRequest = ::T.let(nil, ::T.untyped)
  GetObjectLockConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetObjectLockConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetObjectOutput = ::T.let(nil, ::T.untyped)
  GetObjectRequest = ::T.let(nil, ::T.untyped)
  GetObjectRetentionOutput = ::T.let(nil, ::T.untyped)
  GetObjectRetentionRequest = ::T.let(nil, ::T.untyped)
  GetObjectTaggingOutput = ::T.let(nil, ::T.untyped)
  GetObjectTaggingRequest = ::T.let(nil, ::T.untyped)
  GetObjectTorrentOutput = ::T.let(nil, ::T.untyped)
  GetObjectTorrentRequest = ::T.let(nil, ::T.untyped)
  GetPublicAccessBlockOutput = ::T.let(nil, ::T.untyped)
  GetPublicAccessBlockRequest = ::T.let(nil, ::T.untyped)
  GlacierJobParameters = ::T.let(nil, ::T.untyped)
  Grant = ::T.let(nil, ::T.untyped)
  GrantFullControl = ::T.let(nil, ::T.untyped)
  GrantRead = ::T.let(nil, ::T.untyped)
  GrantReadACP = ::T.let(nil, ::T.untyped)
  GrantWrite = ::T.let(nil, ::T.untyped)
  GrantWriteACP = ::T.let(nil, ::T.untyped)
  Grantee = ::T.let(nil, ::T.untyped)
  Grants = ::T.let(nil, ::T.untyped)
  HeadBucketRequest = ::T.let(nil, ::T.untyped)
  HeadObjectOutput = ::T.let(nil, ::T.untyped)
  HeadObjectRequest = ::T.let(nil, ::T.untyped)
  HostName = ::T.let(nil, ::T.untyped)
  HttpErrorCodeReturnedEquals = ::T.let(nil, ::T.untyped)
  HttpRedirectCode = ::T.let(nil, ::T.untyped)
  ID = ::T.let(nil, ::T.untyped)
  IfMatch = ::T.let(nil, ::T.untyped)
  IfModifiedSince = ::T.let(nil, ::T.untyped)
  IfNoneMatch = ::T.let(nil, ::T.untyped)
  IfUnmodifiedSince = ::T.let(nil, ::T.untyped)
  IndexDocument = ::T.let(nil, ::T.untyped)
  Initiated = ::T.let(nil, ::T.untyped)
  Initiator = ::T.let(nil, ::T.untyped)
  InputSerialization = ::T.let(nil, ::T.untyped)
  InventoryConfiguration = ::T.let(nil, ::T.untyped)
  InventoryConfigurationList = ::T.let(nil, ::T.untyped)
  InventoryDestination = ::T.let(nil, ::T.untyped)
  InventoryEncryption = ::T.let(nil, ::T.untyped)
  InventoryFilter = ::T.let(nil, ::T.untyped)
  InventoryFormat = ::T.let(nil, ::T.untyped)
  InventoryFrequency = ::T.let(nil, ::T.untyped)
  InventoryId = ::T.let(nil, ::T.untyped)
  InventoryIncludedObjectVersions = ::T.let(nil, ::T.untyped)
  InventoryOptionalField = ::T.let(nil, ::T.untyped)
  InventoryOptionalFields = ::T.let(nil, ::T.untyped)
  InventoryS3BucketDestination = ::T.let(nil, ::T.untyped)
  InventorySchedule = ::T.let(nil, ::T.untyped)
  IsEnabled = ::T.let(nil, ::T.untyped)
  IsLatest = ::T.let(nil, ::T.untyped)
  IsPublic = ::T.let(nil, ::T.untyped)
  IsTruncated = ::T.let(nil, ::T.untyped)
  JSONInput = ::T.let(nil, ::T.untyped)
  JSONOutput = ::T.let(nil, ::T.untyped)
  JSONType = ::T.let(nil, ::T.untyped)
  KMSContext = ::T.let(nil, ::T.untyped)
  KeyCount = ::T.let(nil, ::T.untyped)
  KeyMarker = ::T.let(nil, ::T.untyped)
  KeyPrefixEquals = ::T.let(nil, ::T.untyped)
  LambdaFunctionArn = ::T.let(nil, ::T.untyped)
  LambdaFunctionConfiguration = ::T.let(nil, ::T.untyped)
  LambdaFunctionConfigurationList = ::T.let(nil, ::T.untyped)
  LastModified = ::T.let(nil, ::T.untyped)
  LifecycleConfiguration = ::T.let(nil, ::T.untyped)
  LifecycleExpiration = ::T.let(nil, ::T.untyped)
  LifecycleRule = ::T.let(nil, ::T.untyped)
  LifecycleRuleAndOperator = ::T.let(nil, ::T.untyped)
  LifecycleRuleFilter = ::T.let(nil, ::T.untyped)
  LifecycleRules = ::T.let(nil, ::T.untyped)
  ListBucketAnalyticsConfigurationsOutput = ::T.let(nil, ::T.untyped)
  ListBucketAnalyticsConfigurationsRequest = ::T.let(nil, ::T.untyped)
  ListBucketInventoryConfigurationsOutput = ::T.let(nil, ::T.untyped)
  ListBucketInventoryConfigurationsRequest = ::T.let(nil, ::T.untyped)
  ListBucketMetricsConfigurationsOutput = ::T.let(nil, ::T.untyped)
  ListBucketMetricsConfigurationsRequest = ::T.let(nil, ::T.untyped)
  ListBucketsOutput = ::T.let(nil, ::T.untyped)
  ListMultipartUploadsOutput = ::T.let(nil, ::T.untyped)
  ListMultipartUploadsRequest = ::T.let(nil, ::T.untyped)
  ListObjectVersionsOutput = ::T.let(nil, ::T.untyped)
  ListObjectVersionsRequest = ::T.let(nil, ::T.untyped)
  ListObjectsOutput = ::T.let(nil, ::T.untyped)
  ListObjectsRequest = ::T.let(nil, ::T.untyped)
  ListObjectsV2Output = ::T.let(nil, ::T.untyped)
  ListObjectsV2Request = ::T.let(nil, ::T.untyped)
  ListPartsOutput = ::T.let(nil, ::T.untyped)
  ListPartsRequest = ::T.let(nil, ::T.untyped)
  Location = ::T.let(nil, ::T.untyped)
  LocationPrefix = ::T.let(nil, ::T.untyped)
  LoggingEnabled = ::T.let(nil, ::T.untyped)
  MFA = ::T.let(nil, ::T.untyped)
  MFADelete = ::T.let(nil, ::T.untyped)
  MFADeleteStatus = ::T.let(nil, ::T.untyped)
  Marker = ::T.let(nil, ::T.untyped)
  MaxAgeSeconds = ::T.let(nil, ::T.untyped)
  MaxKeys = ::T.let(nil, ::T.untyped)
  MaxParts = ::T.let(nil, ::T.untyped)
  MaxUploads = ::T.let(nil, ::T.untyped)
  Message = ::T.let(nil, ::T.untyped)
  Metadata = ::T.let(nil, ::T.untyped)
  MetadataDirective = ::T.let(nil, ::T.untyped)
  MetadataEntry = ::T.let(nil, ::T.untyped)
  MetadataKey = ::T.let(nil, ::T.untyped)
  MetadataValue = ::T.let(nil, ::T.untyped)
  Metrics = ::T.let(nil, ::T.untyped)
  MetricsAndOperator = ::T.let(nil, ::T.untyped)
  MetricsConfiguration = ::T.let(nil, ::T.untyped)
  MetricsConfigurationList = ::T.let(nil, ::T.untyped)
  MetricsFilter = ::T.let(nil, ::T.untyped)
  MetricsId = ::T.let(nil, ::T.untyped)
  MetricsStatus = ::T.let(nil, ::T.untyped)
  Minutes = ::T.let(nil, ::T.untyped)
  MissingMeta = ::T.let(nil, ::T.untyped)
  MultipartUpload = ::T.let(nil, ::T.untyped)
  MultipartUploadId = ::T.let(nil, ::T.untyped)
  MultipartUploadList = ::T.let(nil, ::T.untyped)
  NextKeyMarker = ::T.let(nil, ::T.untyped)
  NextMarker = ::T.let(nil, ::T.untyped)
  NextPartNumberMarker = ::T.let(nil, ::T.untyped)
  NextToken = ::T.let(nil, ::T.untyped)
  NextUploadIdMarker = ::T.let(nil, ::T.untyped)
  NextVersionIdMarker = ::T.let(nil, ::T.untyped)
  NoSuchBucket = ::T.let(nil, ::T.untyped)
  NoSuchKey = ::T.let(nil, ::T.untyped)
  NoSuchUpload = ::T.let(nil, ::T.untyped)
  NoncurrentVersionExpiration = ::T.let(nil, ::T.untyped)
  NoncurrentVersionTransition = ::T.let(nil, ::T.untyped)
  NoncurrentVersionTransitionList = ::T.let(nil, ::T.untyped)
  NotificationConfiguration = ::T.let(nil, ::T.untyped)
  NotificationConfigurationDeprecated = ::T.let(nil, ::T.untyped)
  NotificationConfigurationFilter = ::T.let(nil, ::T.untyped)
  NotificationId = ::T.let(nil, ::T.untyped)
  Object = ::T.let(nil, ::T.untyped)
  ObjectAlreadyInActiveTierError = ::T.let(nil, ::T.untyped)
  ObjectCannedACL = ::T.let(nil, ::T.untyped)
  ObjectIdentifier = ::T.let(nil, ::T.untyped)
  ObjectIdentifierList = ::T.let(nil, ::T.untyped)
  ObjectKey = ::T.let(nil, ::T.untyped)
  ObjectList = ::T.let(nil, ::T.untyped)
  ObjectLockConfiguration = ::T.let(nil, ::T.untyped)
  ObjectLockEnabled = ::T.let(nil, ::T.untyped)
  ObjectLockEnabledForBucket = ::T.let(nil, ::T.untyped)
  ObjectLockLegalHold = ::T.let(nil, ::T.untyped)
  ObjectLockLegalHoldStatus = ::T.let(nil, ::T.untyped)
  ObjectLockMode = ::T.let(nil, ::T.untyped)
  ObjectLockRetainUntilDate = ::T.let(nil, ::T.untyped)
  ObjectLockRetention = ::T.let(nil, ::T.untyped)
  ObjectLockRetentionMode = ::T.let(nil, ::T.untyped)
  ObjectLockRule = ::T.let(nil, ::T.untyped)
  ObjectLockToken = ::T.let(nil, ::T.untyped)
  ObjectNotInActiveTierError = ::T.let(nil, ::T.untyped)
  ObjectStorageClass = ::T.let(nil, ::T.untyped)
  ObjectVersion = ::T.let(nil, ::T.untyped)
  ObjectVersionId = ::T.let(nil, ::T.untyped)
  ObjectVersionList = ::T.let(nil, ::T.untyped)
  ObjectVersionStorageClass = ::T.let(nil, ::T.untyped)
  OutputLocation = ::T.let(nil, ::T.untyped)
  OutputSerialization = ::T.let(nil, ::T.untyped)
  Owner = ::T.let(nil, ::T.untyped)
  OwnerOverride = ::T.let(nil, ::T.untyped)
  ParquetInput = ::T.let(nil, ::T.untyped)
  Part = ::T.let(nil, ::T.untyped)
  PartNumber = ::T.let(nil, ::T.untyped)
  PartNumberMarker = ::T.let(nil, ::T.untyped)
  Parts = ::T.let(nil, ::T.untyped)
  PartsCount = ::T.let(nil, ::T.untyped)
  Payer = ::T.let(nil, ::T.untyped)
  Permission = ::T.let(nil, ::T.untyped)
  Policy = ::T.let(nil, ::T.untyped)
  PolicyStatus = ::T.let(nil, ::T.untyped)
  Prefix = ::T.let(nil, ::T.untyped)
  Priority = ::T.let(nil, ::T.untyped)
  Progress = ::T.let(nil, ::T.untyped)
  ProgressEvent = ::T.let(nil, ::T.untyped)
  Protocol = ::T.let(nil, ::T.untyped)
  PublicAccessBlockConfiguration = ::T.let(nil, ::T.untyped)
  PutBucketAccelerateConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketAclRequest = ::T.let(nil, ::T.untyped)
  PutBucketAnalyticsConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketCorsRequest = ::T.let(nil, ::T.untyped)
  PutBucketEncryptionRequest = ::T.let(nil, ::T.untyped)
  PutBucketInventoryConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketLifecycleConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketLifecycleRequest = ::T.let(nil, ::T.untyped)
  PutBucketLoggingRequest = ::T.let(nil, ::T.untyped)
  PutBucketMetricsConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketNotificationConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketNotificationRequest = ::T.let(nil, ::T.untyped)
  PutBucketPolicyRequest = ::T.let(nil, ::T.untyped)
  PutBucketReplicationRequest = ::T.let(nil, ::T.untyped)
  PutBucketRequestPaymentRequest = ::T.let(nil, ::T.untyped)
  PutBucketTaggingRequest = ::T.let(nil, ::T.untyped)
  PutBucketVersioningRequest = ::T.let(nil, ::T.untyped)
  PutBucketWebsiteRequest = ::T.let(nil, ::T.untyped)
  PutObjectAclOutput = ::T.let(nil, ::T.untyped)
  PutObjectAclRequest = ::T.let(nil, ::T.untyped)
  PutObjectLegalHoldOutput = ::T.let(nil, ::T.untyped)
  PutObjectLegalHoldRequest = ::T.let(nil, ::T.untyped)
  PutObjectLockConfigurationOutput = ::T.let(nil, ::T.untyped)
  PutObjectLockConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutObjectOutput = ::T.let(nil, ::T.untyped)
  PutObjectRequest = ::T.let(nil, ::T.untyped)
  PutObjectRetentionOutput = ::T.let(nil, ::T.untyped)
  PutObjectRetentionRequest = ::T.let(nil, ::T.untyped)
  PutObjectTaggingOutput = ::T.let(nil, ::T.untyped)
  PutObjectTaggingRequest = ::T.let(nil, ::T.untyped)
  PutPublicAccessBlockRequest = ::T.let(nil, ::T.untyped)
  QueueArn = ::T.let(nil, ::T.untyped)
  QueueConfiguration = ::T.let(nil, ::T.untyped)
  QueueConfigurationDeprecated = ::T.let(nil, ::T.untyped)
  QueueConfigurationList = ::T.let(nil, ::T.untyped)
  Quiet = ::T.let(nil, ::T.untyped)
  QuoteCharacter = ::T.let(nil, ::T.untyped)
  QuoteEscapeCharacter = ::T.let(nil, ::T.untyped)
  QuoteFields = ::T.let(nil, ::T.untyped)
  Range = ::T.let(nil, ::T.untyped)
  RecordDelimiter = ::T.let(nil, ::T.untyped)
  RecordsEvent = ::T.let(nil, ::T.untyped)
  Redirect = ::T.let(nil, ::T.untyped)
  RedirectAllRequestsTo = ::T.let(nil, ::T.untyped)
  ReplaceKeyPrefixWith = ::T.let(nil, ::T.untyped)
  ReplaceKeyWith = ::T.let(nil, ::T.untyped)
  ReplicaKmsKeyID = ::T.let(nil, ::T.untyped)
  ReplicationConfiguration = ::T.let(nil, ::T.untyped)
  ReplicationRule = ::T.let(nil, ::T.untyped)
  ReplicationRuleAndOperator = ::T.let(nil, ::T.untyped)
  ReplicationRuleFilter = ::T.let(nil, ::T.untyped)
  ReplicationRuleStatus = ::T.let(nil, ::T.untyped)
  ReplicationRules = ::T.let(nil, ::T.untyped)
  ReplicationStatus = ::T.let(nil, ::T.untyped)
  ReplicationTime = ::T.let(nil, ::T.untyped)
  ReplicationTimeStatus = ::T.let(nil, ::T.untyped)
  ReplicationTimeValue = ::T.let(nil, ::T.untyped)
  RequestCharged = ::T.let(nil, ::T.untyped)
  RequestPayer = ::T.let(nil, ::T.untyped)
  RequestPaymentConfiguration = ::T.let(nil, ::T.untyped)
  RequestProgress = ::T.let(nil, ::T.untyped)
  ResponseCacheControl = ::T.let(nil, ::T.untyped)
  ResponseContentDisposition = ::T.let(nil, ::T.untyped)
  ResponseContentEncoding = ::T.let(nil, ::T.untyped)
  ResponseContentLanguage = ::T.let(nil, ::T.untyped)
  ResponseContentType = ::T.let(nil, ::T.untyped)
  ResponseExpires = ::T.let(nil, ::T.untyped)
  Restore = ::T.let(nil, ::T.untyped)
  RestoreObjectOutput = ::T.let(nil, ::T.untyped)
  RestoreObjectRequest = ::T.let(nil, ::T.untyped)
  RestoreOutputPath = ::T.let(nil, ::T.untyped)
  RestoreRequest = ::T.let(nil, ::T.untyped)
  RestoreRequestType = ::T.let(nil, ::T.untyped)
  Role = ::T.let(nil, ::T.untyped)
  RoutingRule = ::T.let(nil, ::T.untyped)
  RoutingRules = ::T.let(nil, ::T.untyped)
  Rule = ::T.let(nil, ::T.untyped)
  Rules = ::T.let(nil, ::T.untyped)
  S3KeyFilter = ::T.let(nil, ::T.untyped)
  S3Location = ::T.let(nil, ::T.untyped)
  SSECustomerAlgorithm = ::T.let(nil, ::T.untyped)
  SSECustomerKey = ::T.let(nil, ::T.untyped)
  SSECustomerKeyMD5 = ::T.let(nil, ::T.untyped)
  SSEKMS = ::T.let(nil, ::T.untyped)
  SSEKMSEncryptionContext = ::T.let(nil, ::T.untyped)
  SSEKMSKeyId = ::T.let(nil, ::T.untyped)
  SSES3 = ::T.let(nil, ::T.untyped)
  ScanRange = ::T.let(nil, ::T.untyped)
  SelectObjectContentEventStream = ::T.let(nil, ::T.untyped)
  SelectObjectContentOutput = ::T.let(nil, ::T.untyped)
  SelectObjectContentRequest = ::T.let(nil, ::T.untyped)
  SelectParameters = ::T.let(nil, ::T.untyped)
  ServerSideEncryption = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionByDefault = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionConfiguration = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionRule = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionRules = ::T.let(nil, ::T.untyped)
  Setting = ::T.let(nil, ::T.untyped)
  Size = ::T.let(nil, ::T.untyped)
  SourceSelectionCriteria = ::T.let(nil, ::T.untyped)
  SseKmsEncryptedObjects = ::T.let(nil, ::T.untyped)
  SseKmsEncryptedObjectsStatus = ::T.let(nil, ::T.untyped)
  Start = ::T.let(nil, ::T.untyped)
  StartAfter = ::T.let(nil, ::T.untyped)
  Stats = ::T.let(nil, ::T.untyped)
  StatsEvent = ::T.let(nil, ::T.untyped)
  StorageClass = ::T.let(nil, ::T.untyped)
  StorageClassAnalysis = ::T.let(nil, ::T.untyped)
  StorageClassAnalysisDataExport = ::T.let(nil, ::T.untyped)
  StorageClassAnalysisSchemaVersion = ::T.let(nil, ::T.untyped)
  Suffix = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
  TagCount = ::T.let(nil, ::T.untyped)
  TagSet = ::T.let(nil, ::T.untyped)
  Tagging = ::T.let(nil, ::T.untyped)
  TaggingDirective = ::T.let(nil, ::T.untyped)
  TaggingHeader = ::T.let(nil, ::T.untyped)
  TargetBucket = ::T.let(nil, ::T.untyped)
  TargetGrant = ::T.let(nil, ::T.untyped)
  TargetGrants = ::T.let(nil, ::T.untyped)
  TargetPrefix = ::T.let(nil, ::T.untyped)
  Tier = ::T.let(nil, ::T.untyped)
  Token = ::T.let(nil, ::T.untyped)
  TopicArn = ::T.let(nil, ::T.untyped)
  TopicConfiguration = ::T.let(nil, ::T.untyped)
  TopicConfigurationDeprecated = ::T.let(nil, ::T.untyped)
  TopicConfigurationList = ::T.let(nil, ::T.untyped)
  Transition = ::T.let(nil, ::T.untyped)
  TransitionList = ::T.let(nil, ::T.untyped)
  TransitionStorageClass = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  UploadIdMarker = ::T.let(nil, ::T.untyped)
  UploadPartCopyOutput = ::T.let(nil, ::T.untyped)
  UploadPartCopyRequest = ::T.let(nil, ::T.untyped)
  UploadPartOutput = ::T.let(nil, ::T.untyped)
  UploadPartRequest = ::T.let(nil, ::T.untyped)
  UserMetadata = ::T.let(nil, ::T.untyped)
  Value = ::T.let(nil, ::T.untyped)
  VersionIdMarker = ::T.let(nil, ::T.untyped)
  VersioningConfiguration = ::T.let(nil, ::T.untyped)
  WebsiteConfiguration = ::T.let(nil, ::T.untyped)
  WebsiteRedirectLocation = ::T.let(nil, ::T.untyped)
  Years = ::T.let(nil, ::T.untyped)
end

module Aws::S3::ClientApi
end

module Aws::S3::Encryption
end

class Aws::S3::Encryption::Client
  def build_request(*args, &block); end

  def client(); end

  def config(*args, &block); end

  def delete_object(*args, &block); end

  def envelope_location(); end

  def get_object(params=T.unsafe(nil), &block); end

  def head_object(*args, &block); end

  def initialize(options=T.unsafe(nil)); end

  def instruction_file_suffix(); end

  def key_provider(); end

  def put_object(params=T.unsafe(nil)); end
end

class Aws::S3::Encryption::Client
  extend ::Aws::Deprecations
  extend ::Forwardable
end

class Aws::S3::Encryption::DecryptHandler
  POSSIBLE_ENCRYPTION_FORMATS = ::T.let(nil, ::T.untyped)
  POSSIBLE_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
  V1_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
  V2_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Encryption::DecryptHandler
end

class Aws::S3::Encryption::DefaultCipherProvider
  def decryption_cipher(envelope); end

  def encryption_cipher(); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::Encryption::DefaultCipherProvider
end

class Aws::S3::Encryption::DefaultKeyProvider
  include ::Aws::S3::Encryption::KeyProvider
  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::Encryption::DefaultKeyProvider
end

class Aws::S3::Encryption::EncryptHandler
end

class Aws::S3::Encryption::EncryptHandler
end

module Aws::S3::Encryption::Errors
end

class Aws::S3::Encryption::Errors::DecryptionError
end

class Aws::S3::Encryption::Errors::DecryptionError
end

class Aws::S3::Encryption::Errors::EncryptionError
end

class Aws::S3::Encryption::Errors::EncryptionError
end

module Aws::S3::Encryption::Errors
end

class Aws::S3::Encryption::IOAuthDecrypter
  def finalize(); end

  def initialize(options=T.unsafe(nil)); end

  def io(); end

  def write(chunk); end
end

class Aws::S3::Encryption::IOAuthDecrypter
end

class Aws::S3::Encryption::IODecrypter
  def finalize(); end

  def initialize(cipher, io); end

  def io(); end

  def size(); end

  def write(chunk); end
end

class Aws::S3::Encryption::IODecrypter
end

class Aws::S3::Encryption::IOEncrypter
  def close(); end

  def initialize(cipher, io); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end
  ONE_MEGABYTE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Encryption::IOEncrypter
end

module Aws::S3::Encryption::KeyProvider
  def encryption_materials(); end

  def key_for(materials_description); end
end

module Aws::S3::Encryption::KeyProvider
end

class Aws::S3::Encryption::KmsCipherProvider
  def decryption_cipher(envelope); end

  def encryption_cipher(); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::Encryption::KmsCipherProvider
end

class Aws::S3::Encryption::Materials
  def description(); end

  def initialize(options=T.unsafe(nil)); end

  def key(); end
end

class Aws::S3::Encryption::Materials
end

module Aws::S3::Encryption::Utils
  UNSAFE_MSG = ::T.let(nil, ::T.untyped)
end

module Aws::S3::Encryption::Utils
  def self.aes_cipher(mode, block_mode, key, iv); end

  def self.aes_decryption_cipher(block_mode, key=T.unsafe(nil), iv=T.unsafe(nil)); end

  def self.aes_encryption_cipher(block_mode, key=T.unsafe(nil), iv=T.unsafe(nil)); end

  def self.cipher_size(key); end

  def self.decrypt(key, data); end

  def self.encrypt(key, data); end
end

module Aws::S3::Encryption
end

module Aws::S3::EncryptionV2
end

class Aws::S3::EncryptionV2::Client
  def build_request(*args, &block); end

  def client(); end

  def config(*args, &block); end

  def delete_object(*args, &block); end

  def envelope_location(); end

  def get_object(params=T.unsafe(nil), &block); end

  def head_object(*args, &block); end

  def initialize(options=T.unsafe(nil)); end

  def instruction_file_suffix(); end

  def key_provider(); end

  def put_object(params=T.unsafe(nil)); end
end

class Aws::S3::EncryptionV2::Client
  extend ::Aws::Deprecations
  extend ::Forwardable
end

class Aws::S3::EncryptionV2::DecryptHandler
  POSSIBLE_ENCRYPTION_FORMATS = ::T.let(nil, ::T.untyped)
  POSSIBLE_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
  POSSIBLE_WRAPPING_FORMATS = ::T.let(nil, ::T.untyped)
  V1_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
  V2_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
  V2_OPTIONAL_KEYS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::EncryptionV2::DecryptHandler
end

class Aws::S3::EncryptionV2::DefaultCipherProvider
  def decryption_cipher(envelope, options=T.unsafe(nil)); end

  def encryption_cipher(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::EncryptionV2::DefaultCipherProvider
end

class Aws::S3::EncryptionV2::DefaultKeyProvider
  include ::Aws::S3::EncryptionV2::KeyProvider
  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::EncryptionV2::DefaultKeyProvider
end

class Aws::S3::EncryptionV2::EncryptHandler
end

class Aws::S3::EncryptionV2::EncryptHandler
end

module Aws::S3::EncryptionV2::Errors
end

class Aws::S3::EncryptionV2::Errors::DecryptionError
end

class Aws::S3::EncryptionV2::Errors::DecryptionError
end

class Aws::S3::EncryptionV2::Errors::EncryptionError
end

class Aws::S3::EncryptionV2::Errors::EncryptionError
end

module Aws::S3::EncryptionV2::Errors
end

class Aws::S3::EncryptionV2::IOAuthDecrypter
  def finalize(); end

  def initialize(options=T.unsafe(nil)); end

  def io(); end

  def write(chunk); end
end

class Aws::S3::EncryptionV2::IOAuthDecrypter
end

class Aws::S3::EncryptionV2::IODecrypter
  def finalize(); end

  def initialize(cipher, io); end

  def io(); end

  def write(chunk); end
end

class Aws::S3::EncryptionV2::IODecrypter
end

class Aws::S3::EncryptionV2::IOEncrypter
  def close(); end

  def initialize(cipher, io); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end
  ONE_MEGABYTE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::EncryptionV2::IOEncrypter
end

module Aws::S3::EncryptionV2::KeyProvider
  def encryption_materials(); end

  def key_for(materials_description); end
end

module Aws::S3::EncryptionV2::KeyProvider
end

class Aws::S3::EncryptionV2::KmsCipherProvider
  def decryption_cipher(envelope, options=T.unsafe(nil)); end

  def encryption_cipher(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::EncryptionV2::KmsCipherProvider
end

class Aws::S3::EncryptionV2::Materials
  def description(); end

  def initialize(options=T.unsafe(nil)); end

  def key(); end
end

class Aws::S3::EncryptionV2::Materials
end

module Aws::S3::EncryptionV2::Utils
  UNSAFE_MSG = ::T.let(nil, ::T.untyped)
end

module Aws::S3::EncryptionV2::Utils
  def self.aes_cipher(mode, block_mode, key, iv); end

  def self.aes_decryption_cipher(block_mode, key=T.unsafe(nil), iv=T.unsafe(nil)); end

  def self.aes_encryption_cipher(block_mode, key=T.unsafe(nil), iv=T.unsafe(nil)); end

  def self.cipher_size(key); end

  def self.decrypt(key, data); end

  def self.decrypt_aes_gcm(key, data, auth_data); end

  def self.decrypt_rsa(key, enc_data); end

  def self.encrypt(key, data); end

  def self.encrypt_aes_gcm(key, data, auth_data); end

  def self.encrypt_rsa(key, data, auth_data); end
end

module Aws::S3::EncryptionV2
end

module Aws::S3::Errors
end

class Aws::S3::Errors::BucketAlreadyExists
end

class Aws::S3::Errors::BucketAlreadyExists
end

class Aws::S3::Errors::BucketAlreadyOwnedByYou
end

class Aws::S3::Errors::BucketAlreadyOwnedByYou
end

class Aws::S3::Errors::NoSuchBucket
end

class Aws::S3::Errors::NoSuchBucket
end

class Aws::S3::Errors::NoSuchKey
end

class Aws::S3::Errors::NoSuchKey
end

class Aws::S3::Errors::NoSuchUpload
end

class Aws::S3::Errors::NoSuchUpload
end

class Aws::S3::Errors::ObjectAlreadyInActiveTierError
end

class Aws::S3::Errors::ObjectAlreadyInActiveTierError
end

class Aws::S3::Errors::ObjectNotInActiveTierError
end

class Aws::S3::Errors::ObjectNotInActiveTierError
end

class Aws::S3::Errors::ServiceError
end

class Aws::S3::Errors::ServiceError
end

module Aws::S3::Errors
  extend ::Aws::Errors::DynamicErrors
end

module Aws::S3::EventStreams
end

class Aws::S3::EventStreams::SelectObjectContentEventStream
  def event_emitter(); end

  def on_cont_event(&block); end

  def on_end_event(&block); end

  def on_error_event(&block); end

  def on_event(&block); end

  def on_initial_response_event(&block); end

  def on_progress_event(&block); end

  def on_records_event(&block); end

  def on_stats_event(&block); end

  def on_unknown_event(&block); end
end

class Aws::S3::EventStreams::SelectObjectContentEventStream
end

module Aws::S3::EventStreams
end

class Aws::S3::FileDownloader
  def client(); end

  def download(destination, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
  MAX_PARTS = ::T.let(nil, ::T.untyped)
  MIN_CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  THREAD_COUNT = ::T.let(nil, ::T.untyped)
end

class Aws::S3::FileDownloader
end

class Aws::S3::FilePart
  def close(); end

  def first_byte(); end

  def initialize(options=T.unsafe(nil)); end

  def last_byte(); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def source(); end
end

class Aws::S3::FilePart
end

class Aws::S3::FileUploader
  def client(); end

  def initialize(options=T.unsafe(nil)); end

  def multipart_threshold(); end

  def upload(source, options=T.unsafe(nil)); end
  FIFTEEN_MEGABYTES = ::T.let(nil, ::T.untyped)
end

class Aws::S3::FileUploader
end

class Aws::S3::LegacySigner
  def authorization(request); end

  def canonicalized_headers(request); end

  def canonicalized_resource(endpoint); end

  def credentials(); end

  def digest(secret, string_to_sign); end

  def hmac(key, value); end

  def initialize(credentials, params, force_path_style); end

  def params(); end

  def sign(request); end

  def signature(request); end

  def signed_querystring_params(endpoint); end

  def signing_string_date(request); end

  def string_to_sign(request); end

  def uri_escape(s); end
  SIGNED_QUERYSTRING_PARAMS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::LegacySigner
  def self.sign(context); end
end

class Aws::S3::MultipartFileUploader
  def client(); end

  def initialize(options=T.unsafe(nil)); end

  def upload(source, options=T.unsafe(nil)); end
  CREATE_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_TOO_SMALL = ::T.let(nil, ::T.untyped)
  MAX_PARTS = ::T.let(nil, ::T.untyped)
  MIN_PART_SIZE = ::T.let(nil, ::T.untyped)
  THREAD_COUNT = ::T.let(nil, ::T.untyped)
  UPLOAD_PART_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::MultipartFileUploader::PartList
  def clear!(); end

  def initialize(parts=T.unsafe(nil)); end

  def push(part); end

  def shift(); end

  def to_a(); end
end

class Aws::S3::MultipartFileUploader::PartList
end

class Aws::S3::MultipartFileUploader
end

class Aws::S3::MultipartStreamUploader
  def client(); end

  def initialize(options=T.unsafe(nil)); end

  def upload(options=T.unsafe(nil), &block); end
  CREATE_OPTIONS = ::T.let(nil, ::T.untyped)
  PART_SIZE = ::T.let(nil, ::T.untyped)
  TEMPFILE_PREIX = ::T.let(nil, ::T.untyped)
  THREAD_COUNT = ::T.let(nil, ::T.untyped)
  UPLOAD_PART_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::MultipartStreamUploader
end

class Aws::S3::MultipartUpload
  def abort(options=T.unsafe(nil)); end

  def basic_complete(options=T.unsafe(nil)); end

  def bucket_name(); end

  def client(); end

  def complete(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def initiated(); end

  def initiator(); end

  def key(); end

  def load(); end

  def object(); end

  def object_key(); end

  def owner(); end

  def part(part_number); end

  def parts(options=T.unsafe(nil)); end

  def reload(); end

  def storage_class(); end

  def upload_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::MultipartUpload::Collection
end

class Aws::S3::MultipartUpload::Collection
end

class Aws::S3::MultipartUpload
  extend ::Aws::Deprecations
end

class Aws::S3::MultipartUploadError
  def errors(); end

  def initialize(message, errors); end
end

class Aws::S3::MultipartUploadError
end

class Aws::S3::MultipartUploadPart
  def bucket_name(); end

  def client(); end

  def copy_from(options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def etag(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def last_modified(); end

  def load(); end

  def multipart_upload(); end

  def multipart_upload_id(); end

  def object_key(); end

  def part_number(); end

  def reload(); end

  def size(); end

  def upload(options=T.unsafe(nil)); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::MultipartUploadPart::Collection
end

class Aws::S3::MultipartUploadPart::Collection
end

class Aws::S3::MultipartUploadPart
  extend ::Aws::Deprecations
end

class Aws::S3::Object
  def accept_ranges(); end

  def acl(); end

  def bucket(); end

  def bucket_name(); end

  def cache_control(); end

  def client(); end

  def content_disposition(); end

  def content_encoding(); end

  def content_language(); end

  def content_length(); end

  def content_type(); end

  def copy_from(source, options=T.unsafe(nil)); end

  def copy_to(target, options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def delete_marker(); end

  def deprecated_identifiers(); end

  def download_file(destination, options=T.unsafe(nil)); end

  def etag(); end

  def exists?(options=T.unsafe(nil)); end

  def expiration(); end

  def expires(); end

  def expires_string(); end

  def get(options=T.unsafe(nil), &block); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def initiate_multipart_upload(options=T.unsafe(nil)); end

  def key(); end

  def last_modified(); end

  def load(); end

  def metadata(); end

  def missing_meta(); end

  def move_to(target, options=T.unsafe(nil)); end

  def multipart_upload(id); end

  def object_lock_legal_hold_status(); end

  def object_lock_mode(); end

  def object_lock_retain_until_date(); end

  def parts_count(); end

  def presigned_post(options=T.unsafe(nil)); end

  def presigned_url(http_method, params=T.unsafe(nil)); end

  def public_url(options=T.unsafe(nil)); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def replication_status(); end

  def request_charged(); end

  def restore(); end

  def restore_object(options=T.unsafe(nil)); end

  def server_side_encryption(); end

  def size(); end

  def sse_customer_algorithm(); end

  def sse_customer_key_md5(); end

  def ssekms_key_id(); end

  def storage_class(); end

  def upload_file(source, options=T.unsafe(nil)); end

  def upload_stream(options=T.unsafe(nil), &block); end

  def version(id); end

  def version_id(); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_exists(options=T.unsafe(nil), &block); end

  def wait_until_not_exists(options=T.unsafe(nil), &block); end

  def website_redirect_location(); end
end

class Aws::S3::Object::Collection
  def batch_delete!(options=T.unsafe(nil)); end

  def delete(*args, &block); end

  def deprecated_delete(options=T.unsafe(nil)); end
end

class Aws::S3::Object::Collection
end

class Aws::S3::Object
  extend ::Aws::Deprecations
end

class Aws::S3::ObjectAcl
  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def deprecated_identifiers(); end

  def grants(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def load(); end

  def object(); end

  def object_key(); end

  def owner(); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def request_charged(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::ObjectAcl::Collection
end

class Aws::S3::ObjectAcl::Collection
end

class Aws::S3::ObjectAcl
  extend ::Aws::Deprecations
end

class Aws::S3::ObjectCopier
  def copy_from(source, options=T.unsafe(nil)); end

  def copy_to(target, options=T.unsafe(nil)); end

  def initialize(object, options=T.unsafe(nil)); end
end

class Aws::S3::ObjectCopier
end

class Aws::S3::ObjectMultipartCopier
  def client(); end

  def copy(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
  API_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_TOO_SMALL = ::T.let(nil, ::T.untyped)
  FIVE_MB = ::T.let(nil, ::T.untyped)
  MAX_PARTS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::ObjectMultipartCopier::PartQueue
  def clear!(); end

  def initialize(parts=T.unsafe(nil)); end

  def shift(); end
end

class Aws::S3::ObjectMultipartCopier::PartQueue
end

class Aws::S3::ObjectMultipartCopier
  def self.options_for(shape_name); end
end

class Aws::S3::ObjectSummary
  def acl(); end

  def bucket(); end

  def bucket_name(); end

  def client(); end

  def content_length(); end

  def copy_from(source, options=T.unsafe(nil)); end

  def copy_to(target, options=T.unsafe(nil)); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def download_file(destination, options=T.unsafe(nil)); end

  def etag(); end

  def exists?(options=T.unsafe(nil)); end

  def get(options=T.unsafe(nil), &block); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def initiate_multipart_upload(options=T.unsafe(nil)); end

  def key(); end

  def last_modified(); end

  def load(); end

  def move_to(target, options=T.unsafe(nil)); end

  def multipart_upload(id); end

  def object(); end

  def owner(); end

  def presigned_post(options=T.unsafe(nil)); end

  def presigned_url(http_method, params=T.unsafe(nil)); end

  def public_url(options=T.unsafe(nil)); end

  def put(options=T.unsafe(nil)); end

  def reload(); end

  def restore_object(options=T.unsafe(nil)); end

  def size(); end

  def storage_class(); end

  def upload_file(source, options=T.unsafe(nil)); end

  def upload_stream(options=T.unsafe(nil), &block); end

  def version(id); end

  def wait_until(options=T.unsafe(nil), &block); end

  def wait_until_exists(options=T.unsafe(nil), &block); end

  def wait_until_not_exists(options=T.unsafe(nil), &block); end
end

class Aws::S3::ObjectSummary::Collection
  def batch_delete!(options=T.unsafe(nil)); end

  def delete(*args, &block); end

  def deprecated_delete(options=T.unsafe(nil)); end
end

class Aws::S3::ObjectSummary::Collection
end

class Aws::S3::ObjectSummary
  extend ::Aws::Deprecations
end

class Aws::S3::ObjectVersion
  def bucket_name(); end

  def client(); end

  def data(); end

  def data_loaded?(); end

  def delete(options=T.unsafe(nil)); end

  def deprecated_identifiers(); end

  def etag(); end

  def get(options=T.unsafe(nil), &block); end

  def head(options=T.unsafe(nil)); end

  def id(); end

  def identifiers(*args, &block); end

  def initialize(*args); end

  def is_latest(); end

  def key(); end

  def last_modified(); end

  def load(); end

  def object(); end

  def object_key(); end

  def owner(); end

  def reload(); end

  def size(); end

  def storage_class(); end

  def version_id(); end

  def wait_until(options=T.unsafe(nil), &block); end
end

class Aws::S3::ObjectVersion::Collection
  def batch_delete!(options=T.unsafe(nil)); end

  def delete(*args, &block); end

  def deprecated_delete(options=T.unsafe(nil)); end
end

class Aws::S3::ObjectVersion::Collection
end

class Aws::S3::ObjectVersion
  extend ::Aws::Deprecations
end

module Aws::S3::Plugins
end

class Aws::S3::Plugins::Accelerate
end

class Aws::S3::Plugins::Accelerate::AccelerateHandler
end

class Aws::S3::Plugins::Accelerate::AccelerateHandler
end

class Aws::S3::Plugins::Accelerate::OptionHandler
end

class Aws::S3::Plugins::Accelerate::OptionHandler
end

class Aws::S3::Plugins::Accelerate
end

class Aws::S3::Plugins::BucketARN
  def add_handlers(handlers, _config); end
end

class Aws::S3::Plugins::BucketARN::Handler
end

class Aws::S3::Plugins::BucketARN::Handler
end

class Aws::S3::Plugins::BucketARN
  def self.resolve_arn!(bucket_name, region, s3_use_arn_region); end

  def self.resolve_url!(url, arn, dualstack=T.unsafe(nil)); end
end

class Aws::S3::Plugins::BucketDns
end

class Aws::S3::Plugins::BucketDns::Handler
end

class Aws::S3::Plugins::BucketDns::Handler
end

class Aws::S3::Plugins::BucketDns
  def self.dns_compatible?(bucket_name, ssl); end

  def self.valid_subdomain?(bucket_name); end
end

class Aws::S3::Plugins::BucketNameRestrictions
end

class Aws::S3::Plugins::BucketNameRestrictions::Handler
end

class Aws::S3::Plugins::BucketNameRestrictions::Handler
end

class Aws::S3::Plugins::BucketNameRestrictions
end

class Aws::S3::Plugins::Dualstack
end

class Aws::S3::Plugins::Dualstack::DualstackHandler
end

class Aws::S3::Plugins::Dualstack::DualstackHandler
end

class Aws::S3::Plugins::Dualstack::OptionHandler
end

class Aws::S3::Plugins::Dualstack::OptionHandler
end

class Aws::S3::Plugins::Dualstack
end

class Aws::S3::Plugins::Expect100Continue
end

class Aws::S3::Plugins::Expect100Continue::Handler
end

class Aws::S3::Plugins::Expect100Continue::Handler
end

class Aws::S3::Plugins::Expect100Continue
end

class Aws::S3::Plugins::GetBucketLocationFix
end

class Aws::S3::Plugins::GetBucketLocationFix::Handler
end

class Aws::S3::Plugins::GetBucketLocationFix::Handler
end

class Aws::S3::Plugins::GetBucketLocationFix
end

class Aws::S3::Plugins::Http200Errors
end

class Aws::S3::Plugins::Http200Errors::Handler
  def check_for_error(context); end
end

class Aws::S3::Plugins::Http200Errors::Handler
end

class Aws::S3::Plugins::Http200Errors
end

class Aws::S3::Plugins::IADRegionalEndpoint
end

class Aws::S3::Plugins::IADRegionalEndpoint::Handler
end

class Aws::S3::Plugins::IADRegionalEndpoint::Handler
end

class Aws::S3::Plugins::IADRegionalEndpoint
  def self.legacy_host(host); end

  def self.resolve_iad_regional_endpoint(cfg); end
end

class Aws::S3::Plugins::LocationConstraint
end

class Aws::S3::Plugins::LocationConstraint::Handler
end

class Aws::S3::Plugins::LocationConstraint::Handler
end

class Aws::S3::Plugins::LocationConstraint
end

class Aws::S3::Plugins::Md5s
  OPTIONAL_OPERATIONS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Plugins::Md5s::Handler
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Plugins::Md5s::Handler
end

class Aws::S3::Plugins::Md5s
end

class Aws::S3::Plugins::Redirects
end

class Aws::S3::Plugins::Redirects::Handler
end

class Aws::S3::Plugins::Redirects::Handler
end

class Aws::S3::Plugins::Redirects
end

class Aws::S3::Plugins::RetryableBlockIO
  def initialize(block_io); end

  def read(*args, &block); end

  def rewind(); end

  def size(*args, &block); end

  def truncate(_integer); end

  def write(*args, &block); end
end

class Aws::S3::Plugins::RetryableBlockIO
  extend ::Forwardable
end

class Aws::S3::Plugins::RetryableManagedFile
  def close(*args, &block); end

  def initialize(managed_file); end

  def open?(*args, &block); end

  def read(*args, &block); end

  def rewind(); end

  def size(*args, &block); end

  def truncate(_integer); end

  def write(*args, &block); end
end

class Aws::S3::Plugins::RetryableManagedFile
  extend ::Forwardable
end

class Aws::S3::Plugins::S3HostId
end

class Aws::S3::Plugins::S3HostId::Handler
end

class Aws::S3::Plugins::S3HostId::Handler
end

class Aws::S3::Plugins::S3HostId
end

class Aws::S3::Plugins::S3Signer
  def add_handlers(handlers, cfg); end

  def add_legacy_handler(handlers); end

  def add_v4_handlers(handlers); end
end

class Aws::S3::Plugins::S3Signer::BucketRegionErrorHandler
end

class Aws::S3::Plugins::S3Signer::BucketRegionErrorHandler
end

class Aws::S3::Plugins::S3Signer::CachedBucketRegionHandler
end

class Aws::S3::Plugins::S3Signer::CachedBucketRegionHandler
end

class Aws::S3::Plugins::S3Signer::LegacyHandler
end

class Aws::S3::Plugins::S3Signer::LegacyHandler
end

class Aws::S3::Plugins::S3Signer::V4Handler
end

class Aws::S3::Plugins::S3Signer::V4Handler
end

class Aws::S3::Plugins::S3Signer
  def self.build_v4_signer(options=T.unsafe(nil)); end

  def self.new_hostname(context, region); end
end

class Aws::S3::Plugins::SseCpk
end

class Aws::S3::Plugins::SseCpk::Handler
end

class Aws::S3::Plugins::SseCpk::Handler
end

class Aws::S3::Plugins::SseCpk
end

class Aws::S3::Plugins::StreamingRetry
end

class Aws::S3::Plugins::StreamingRetry::Handler
end

class Aws::S3::Plugins::StreamingRetry::Handler
end

class Aws::S3::Plugins::StreamingRetry
end

class Aws::S3::Plugins::UrlEncodedKeys
end

class Aws::S3::Plugins::UrlEncodedKeys::Handler
end

class Aws::S3::Plugins::UrlEncodedKeys::Handler
end

class Aws::S3::Plugins::UrlEncodedKeys
end

module Aws::S3::Plugins
end

class Aws::S3::PresignedPost
  def acl(value); end

  def acl_starts_with(value); end

  def allow_any(*field_names); end

  def cache_control(value); end

  def cache_control_starts_with(value); end

  def content_disposition(value); end

  def content_disposition_starts_with(value); end

  def content_encoding(value); end

  def content_encoding_starts_with(value); end

  def content_length_range(byte_range); end

  def content_type(value); end

  def content_type_starts_with(value); end

  def expires(time); end

  def expires_starts_with(prefix); end

  def fields(); end

  def initialize(credentials, bucket_region, bucket_name, options=T.unsafe(nil)); end

  def key(key); end

  def key_starts_with(prefix); end

  def metadata(hash); end

  def metadata_starts_with(hash); end

  def server_side_encryption(value); end

  def server_side_encryption_aws_kms_key_id(value); end

  def server_side_encryption_customer_algorithm(value); end

  def server_side_encryption_customer_key(value); end

  def server_side_encryption_customer_key_starts_with(prefix); end

  def storage_class(value); end

  def success_action_redirect(value); end

  def success_action_redirect_starts_with(value); end

  def success_action_status(value); end

  def url(); end

  def website_redirect_location(value); end
end

class Aws::S3::PresignedPost
  def self.define_field(field, *args); end
end

class Aws::S3::Presigner
  def initialize(options=T.unsafe(nil)); end

  def presigned_request(method, params=T.unsafe(nil)); end

  def presigned_url(method, params=T.unsafe(nil)); end
  BLACKLISTED_HEADERS = ::T.let(nil, ::T.untyped)
  FIFTEEN_MINUTES = ::T.let(nil, ::T.untyped)
  ONE_WEEK = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Presigner
end

class Aws::S3::Resource
  def bucket(name); end

  def buckets(options=T.unsafe(nil)); end

  def client(); end

  def create_bucket(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::S3::Resource
end

module Aws::S3::Types
end

class Aws::S3::Types::AbortIncompleteMultipartUpload
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AbortIncompleteMultipartUpload
end

class Aws::S3::Types::AbortMultipartUploadOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AbortMultipartUploadOutput
end

class Aws::S3::Types::AbortMultipartUploadRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AbortMultipartUploadRequest
end

class Aws::S3::Types::AccelerateConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AccelerateConfiguration
end

class Aws::S3::Types::AccessControlPolicy
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AccessControlPolicy
end

class Aws::S3::Types::AccessControlTranslation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AccessControlTranslation
end

class Aws::S3::Types::AnalyticsAndOperator
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AnalyticsAndOperator
end

class Aws::S3::Types::AnalyticsConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AnalyticsConfiguration
end

class Aws::S3::Types::AnalyticsExportDestination
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AnalyticsExportDestination
end

class Aws::S3::Types::AnalyticsFilter
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AnalyticsFilter
end

class Aws::S3::Types::AnalyticsS3BucketDestination
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::AnalyticsS3BucketDestination
end

class Aws::S3::Types::Bucket
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Bucket
end

class Aws::S3::Types::BucketAlreadyExists
end

class Aws::S3::Types::BucketAlreadyExists
end

class Aws::S3::Types::BucketAlreadyOwnedByYou
end

class Aws::S3::Types::BucketAlreadyOwnedByYou
end

class Aws::S3::Types::BucketLifecycleConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::BucketLifecycleConfiguration
end

class Aws::S3::Types::BucketLoggingStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::BucketLoggingStatus
end

class Aws::S3::Types::CORSConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CORSConfiguration
end

class Aws::S3::Types::CORSRule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CORSRule
end

class Aws::S3::Types::CSVInput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CSVInput
end

class Aws::S3::Types::CSVOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CSVOutput
end

class Aws::S3::Types::CloudFunctionConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CloudFunctionConfiguration
end

class Aws::S3::Types::CommonPrefix
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CommonPrefix
end

class Aws::S3::Types::CompleteMultipartUploadOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CompleteMultipartUploadOutput
end

class Aws::S3::Types::CompleteMultipartUploadRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CompleteMultipartUploadRequest
end

class Aws::S3::Types::CompletedMultipartUpload
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CompletedMultipartUpload
end

class Aws::S3::Types::CompletedPart
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CompletedPart
end

class Aws::S3::Types::Condition
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Condition
end

class Aws::S3::Types::ContinuationEvent
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ContinuationEvent
end

class Aws::S3::Types::CopyObjectOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CopyObjectOutput
end

class Aws::S3::Types::CopyObjectRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CopyObjectRequest
end

class Aws::S3::Types::CopyObjectResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CopyObjectResult
end

class Aws::S3::Types::CopyPartResult
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CopyPartResult
end

class Aws::S3::Types::CreateBucketConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CreateBucketConfiguration
end

class Aws::S3::Types::CreateBucketOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CreateBucketOutput
end

class Aws::S3::Types::CreateBucketRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CreateBucketRequest
end

class Aws::S3::Types::CreateMultipartUploadOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CreateMultipartUploadOutput
end

class Aws::S3::Types::CreateMultipartUploadRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::CreateMultipartUploadRequest
end

class Aws::S3::Types::DefaultRetention
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DefaultRetention
end

class Aws::S3::Types::Delete
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Delete
end

class Aws::S3::Types::DeleteBucketAnalyticsConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketAnalyticsConfigurationRequest
end

class Aws::S3::Types::DeleteBucketCorsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketCorsRequest
end

class Aws::S3::Types::DeleteBucketEncryptionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketEncryptionRequest
end

class Aws::S3::Types::DeleteBucketInventoryConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketInventoryConfigurationRequest
end

class Aws::S3::Types::DeleteBucketLifecycleRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketLifecycleRequest
end

class Aws::S3::Types::DeleteBucketMetricsConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketMetricsConfigurationRequest
end

class Aws::S3::Types::DeleteBucketPolicyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketPolicyRequest
end

class Aws::S3::Types::DeleteBucketReplicationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketReplicationRequest
end

class Aws::S3::Types::DeleteBucketRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketRequest
end

class Aws::S3::Types::DeleteBucketTaggingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketTaggingRequest
end

class Aws::S3::Types::DeleteBucketWebsiteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteBucketWebsiteRequest
end

class Aws::S3::Types::DeleteMarkerEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteMarkerEntry
end

class Aws::S3::Types::DeleteMarkerReplication
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteMarkerReplication
end

class Aws::S3::Types::DeleteObjectOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteObjectOutput
end

class Aws::S3::Types::DeleteObjectRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteObjectRequest
end

class Aws::S3::Types::DeleteObjectTaggingOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteObjectTaggingOutput
end

class Aws::S3::Types::DeleteObjectTaggingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteObjectTaggingRequest
end

class Aws::S3::Types::DeleteObjectsOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteObjectsOutput
end

class Aws::S3::Types::DeleteObjectsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeleteObjectsRequest
end

class Aws::S3::Types::DeletePublicAccessBlockRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeletePublicAccessBlockRequest
end

class Aws::S3::Types::DeletedObject
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::DeletedObject
end

class Aws::S3::Types::Destination
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Destination
end

class Aws::S3::Types::Encryption
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Encryption
end

class Aws::S3::Types::EncryptionConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::EncryptionConfiguration
end

class Aws::S3::Types::EndEvent
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::EndEvent
end

class Aws::S3::Types::Error
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Error
end

class Aws::S3::Types::ErrorDocument
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ErrorDocument
end

class Aws::S3::Types::ExistingObjectReplication
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ExistingObjectReplication
end

class Aws::S3::Types::FilterRule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::FilterRule
end

class Aws::S3::Types::GetBucketAccelerateConfigurationOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketAccelerateConfigurationOutput
end

class Aws::S3::Types::GetBucketAccelerateConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketAccelerateConfigurationRequest
end

class Aws::S3::Types::GetBucketAclOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketAclOutput
end

class Aws::S3::Types::GetBucketAclRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketAclRequest
end

class Aws::S3::Types::GetBucketAnalyticsConfigurationOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketAnalyticsConfigurationOutput
end

class Aws::S3::Types::GetBucketAnalyticsConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketAnalyticsConfigurationRequest
end

class Aws::S3::Types::GetBucketCorsOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketCorsOutput
end

class Aws::S3::Types::GetBucketCorsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketCorsRequest
end

class Aws::S3::Types::GetBucketEncryptionOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketEncryptionOutput
end

class Aws::S3::Types::GetBucketEncryptionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketEncryptionRequest
end

class Aws::S3::Types::GetBucketInventoryConfigurationOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketInventoryConfigurationOutput
end

class Aws::S3::Types::GetBucketInventoryConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketInventoryConfigurationRequest
end

class Aws::S3::Types::GetBucketLifecycleConfigurationOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketLifecycleConfigurationOutput
end

class Aws::S3::Types::GetBucketLifecycleConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketLifecycleConfigurationRequest
end

class Aws::S3::Types::GetBucketLifecycleOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketLifecycleOutput
end

class Aws::S3::Types::GetBucketLifecycleRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketLifecycleRequest
end

class Aws::S3::Types::GetBucketLocationOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketLocationOutput
end

class Aws::S3::Types::GetBucketLocationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketLocationRequest
end

class Aws::S3::Types::GetBucketLoggingOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketLoggingOutput
end

class Aws::S3::Types::GetBucketLoggingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketLoggingRequest
end

class Aws::S3::Types::GetBucketMetricsConfigurationOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketMetricsConfigurationOutput
end

class Aws::S3::Types::GetBucketMetricsConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketMetricsConfigurationRequest
end

class Aws::S3::Types::GetBucketNotificationConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketNotificationConfigurationRequest
end

class Aws::S3::Types::GetBucketPolicyOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketPolicyOutput
end

class Aws::S3::Types::GetBucketPolicyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketPolicyRequest
end

class Aws::S3::Types::GetBucketPolicyStatusOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketPolicyStatusOutput
end

class Aws::S3::Types::GetBucketPolicyStatusRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketPolicyStatusRequest
end

class Aws::S3::Types::GetBucketReplicationOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketReplicationOutput
end

class Aws::S3::Types::GetBucketReplicationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketReplicationRequest
end

class Aws::S3::Types::GetBucketRequestPaymentOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketRequestPaymentOutput
end

class Aws::S3::Types::GetBucketRequestPaymentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketRequestPaymentRequest
end

class Aws::S3::Types::GetBucketTaggingOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketTaggingOutput
end

class Aws::S3::Types::GetBucketTaggingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketTaggingRequest
end

class Aws::S3::Types::GetBucketVersioningOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketVersioningOutput
end

class Aws::S3::Types::GetBucketVersioningRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketVersioningRequest
end

class Aws::S3::Types::GetBucketWebsiteOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketWebsiteOutput
end

class Aws::S3::Types::GetBucketWebsiteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetBucketWebsiteRequest
end

class Aws::S3::Types::GetObjectAclOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectAclOutput
end

class Aws::S3::Types::GetObjectAclRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectAclRequest
end

class Aws::S3::Types::GetObjectLegalHoldOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectLegalHoldOutput
end

class Aws::S3::Types::GetObjectLegalHoldRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectLegalHoldRequest
end

class Aws::S3::Types::GetObjectLockConfigurationOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectLockConfigurationOutput
end

class Aws::S3::Types::GetObjectLockConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectLockConfigurationRequest
end

class Aws::S3::Types::GetObjectOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectOutput
end

class Aws::S3::Types::GetObjectRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectRequest
end

class Aws::S3::Types::GetObjectRetentionOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectRetentionOutput
end

class Aws::S3::Types::GetObjectRetentionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectRetentionRequest
end

class Aws::S3::Types::GetObjectTaggingOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectTaggingOutput
end

class Aws::S3::Types::GetObjectTaggingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectTaggingRequest
end

class Aws::S3::Types::GetObjectTorrentOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectTorrentOutput
end

class Aws::S3::Types::GetObjectTorrentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetObjectTorrentRequest
end

class Aws::S3::Types::GetPublicAccessBlockOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetPublicAccessBlockOutput
end

class Aws::S3::Types::GetPublicAccessBlockRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GetPublicAccessBlockRequest
end

class Aws::S3::Types::GlacierJobParameters
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::GlacierJobParameters
end

class Aws::S3::Types::Grant
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Grant
end

class Aws::S3::Types::Grantee
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Grantee
end

class Aws::S3::Types::HeadBucketRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::HeadBucketRequest
end

class Aws::S3::Types::HeadObjectOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::HeadObjectOutput
end

class Aws::S3::Types::HeadObjectRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::HeadObjectRequest
end

class Aws::S3::Types::IndexDocument
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::IndexDocument
end

class Aws::S3::Types::Initiator
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Initiator
end

class Aws::S3::Types::InputSerialization
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::InputSerialization
end

class Aws::S3::Types::InventoryConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::InventoryConfiguration
end

class Aws::S3::Types::InventoryDestination
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::InventoryDestination
end

class Aws::S3::Types::InventoryEncryption
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::InventoryEncryption
end

class Aws::S3::Types::InventoryFilter
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::InventoryFilter
end

class Aws::S3::Types::InventoryS3BucketDestination
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::InventoryS3BucketDestination
end

class Aws::S3::Types::InventorySchedule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::InventorySchedule
end

class Aws::S3::Types::JSONInput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::JSONInput
end

class Aws::S3::Types::JSONOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::JSONOutput
end

class Aws::S3::Types::LambdaFunctionConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::LambdaFunctionConfiguration
end

class Aws::S3::Types::LifecycleConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::LifecycleConfiguration
end

class Aws::S3::Types::LifecycleExpiration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::LifecycleExpiration
end

class Aws::S3::Types::LifecycleRule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::LifecycleRule
end

class Aws::S3::Types::LifecycleRuleAndOperator
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::LifecycleRuleAndOperator
end

class Aws::S3::Types::LifecycleRuleFilter
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::LifecycleRuleFilter
end

class Aws::S3::Types::ListBucketAnalyticsConfigurationsOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListBucketAnalyticsConfigurationsOutput
end

class Aws::S3::Types::ListBucketAnalyticsConfigurationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListBucketAnalyticsConfigurationsRequest
end

class Aws::S3::Types::ListBucketInventoryConfigurationsOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListBucketInventoryConfigurationsOutput
end

class Aws::S3::Types::ListBucketInventoryConfigurationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListBucketInventoryConfigurationsRequest
end

class Aws::S3::Types::ListBucketMetricsConfigurationsOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListBucketMetricsConfigurationsOutput
end

class Aws::S3::Types::ListBucketMetricsConfigurationsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListBucketMetricsConfigurationsRequest
end

class Aws::S3::Types::ListBucketsOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListBucketsOutput
end

class Aws::S3::Types::ListMultipartUploadsOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListMultipartUploadsOutput
end

class Aws::S3::Types::ListMultipartUploadsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListMultipartUploadsRequest
end

class Aws::S3::Types::ListObjectVersionsOutput
  include ::Aws::Structure
  def versions_delete_markers(); end
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListObjectVersionsOutput
end

class Aws::S3::Types::ListObjectVersionsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListObjectVersionsRequest
end

class Aws::S3::Types::ListObjectsOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListObjectsOutput
end

class Aws::S3::Types::ListObjectsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListObjectsRequest
end

class Aws::S3::Types::ListObjectsV2Output
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListObjectsV2Output
end

class Aws::S3::Types::ListObjectsV2Request
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListObjectsV2Request
end

class Aws::S3::Types::ListPartsOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListPartsOutput
end

class Aws::S3::Types::ListPartsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ListPartsRequest
end

class Aws::S3::Types::LoggingEnabled
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::LoggingEnabled
end

class Aws::S3::Types::MetadataEntry
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::MetadataEntry
end

class Aws::S3::Types::Metrics
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Metrics
end

class Aws::S3::Types::MetricsAndOperator
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::MetricsAndOperator
end

class Aws::S3::Types::MetricsConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::MetricsConfiguration
end

class Aws::S3::Types::MetricsFilter
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::MetricsFilter
end

class Aws::S3::Types::MultipartUpload
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::MultipartUpload
end

class Aws::S3::Types::NoSuchBucket
end

class Aws::S3::Types::NoSuchBucket
end

class Aws::S3::Types::NoSuchKey
end

class Aws::S3::Types::NoSuchKey
end

class Aws::S3::Types::NoSuchUpload
end

class Aws::S3::Types::NoSuchUpload
end

class Aws::S3::Types::NoncurrentVersionExpiration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::NoncurrentVersionExpiration
end

class Aws::S3::Types::NoncurrentVersionTransition
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::NoncurrentVersionTransition
end

class Aws::S3::Types::NotificationConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::NotificationConfiguration
end

class Aws::S3::Types::NotificationConfigurationDeprecated
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::NotificationConfigurationDeprecated
end

class Aws::S3::Types::NotificationConfigurationFilter
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::NotificationConfigurationFilter
end

class Aws::S3::Types::Object
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Object
end

class Aws::S3::Types::ObjectAlreadyInActiveTierError
end

class Aws::S3::Types::ObjectAlreadyInActiveTierError
end

class Aws::S3::Types::ObjectIdentifier
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ObjectIdentifier
end

class Aws::S3::Types::ObjectLockConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ObjectLockConfiguration
end

class Aws::S3::Types::ObjectLockLegalHold
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ObjectLockLegalHold
end

class Aws::S3::Types::ObjectLockRetention
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ObjectLockRetention
end

class Aws::S3::Types::ObjectLockRule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ObjectLockRule
end

class Aws::S3::Types::ObjectNotInActiveTierError
end

class Aws::S3::Types::ObjectNotInActiveTierError
end

class Aws::S3::Types::ObjectVersion
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ObjectVersion
end

class Aws::S3::Types::OutputLocation
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::OutputLocation
end

class Aws::S3::Types::OutputSerialization
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::OutputSerialization
end

class Aws::S3::Types::Owner
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Owner
end

class Aws::S3::Types::ParquetInput
end

class Aws::S3::Types::ParquetInput
end

class Aws::S3::Types::Part
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Part
end

class Aws::S3::Types::PolicyStatus
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PolicyStatus
end

class Aws::S3::Types::Progress
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Progress
end

class Aws::S3::Types::ProgressEvent
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ProgressEvent
end

class Aws::S3::Types::PublicAccessBlockConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PublicAccessBlockConfiguration
end

class Aws::S3::Types::PutBucketAccelerateConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketAccelerateConfigurationRequest
end

class Aws::S3::Types::PutBucketAclRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketAclRequest
end

class Aws::S3::Types::PutBucketAnalyticsConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketAnalyticsConfigurationRequest
end

class Aws::S3::Types::PutBucketCorsRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketCorsRequest
end

class Aws::S3::Types::PutBucketEncryptionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketEncryptionRequest
end

class Aws::S3::Types::PutBucketInventoryConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketInventoryConfigurationRequest
end

class Aws::S3::Types::PutBucketLifecycleConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketLifecycleConfigurationRequest
end

class Aws::S3::Types::PutBucketLifecycleRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketLifecycleRequest
end

class Aws::S3::Types::PutBucketLoggingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketLoggingRequest
end

class Aws::S3::Types::PutBucketMetricsConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketMetricsConfigurationRequest
end

class Aws::S3::Types::PutBucketNotificationConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketNotificationConfigurationRequest
end

class Aws::S3::Types::PutBucketNotificationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketNotificationRequest
end

class Aws::S3::Types::PutBucketPolicyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketPolicyRequest
end

class Aws::S3::Types::PutBucketReplicationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketReplicationRequest
end

class Aws::S3::Types::PutBucketRequestPaymentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketRequestPaymentRequest
end

class Aws::S3::Types::PutBucketTaggingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketTaggingRequest
end

class Aws::S3::Types::PutBucketVersioningRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketVersioningRequest
end

class Aws::S3::Types::PutBucketWebsiteRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutBucketWebsiteRequest
end

class Aws::S3::Types::PutObjectAclOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectAclOutput
end

class Aws::S3::Types::PutObjectAclRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectAclRequest
end

class Aws::S3::Types::PutObjectLegalHoldOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectLegalHoldOutput
end

class Aws::S3::Types::PutObjectLegalHoldRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectLegalHoldRequest
end

class Aws::S3::Types::PutObjectLockConfigurationOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectLockConfigurationOutput
end

class Aws::S3::Types::PutObjectLockConfigurationRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectLockConfigurationRequest
end

class Aws::S3::Types::PutObjectOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectOutput
end

class Aws::S3::Types::PutObjectRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectRequest
end

class Aws::S3::Types::PutObjectRetentionOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectRetentionOutput
end

class Aws::S3::Types::PutObjectRetentionRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectRetentionRequest
end

class Aws::S3::Types::PutObjectTaggingOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectTaggingOutput
end

class Aws::S3::Types::PutObjectTaggingRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutObjectTaggingRequest
end

class Aws::S3::Types::PutPublicAccessBlockRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::PutPublicAccessBlockRequest
end

class Aws::S3::Types::QueueConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::QueueConfiguration
end

class Aws::S3::Types::QueueConfigurationDeprecated
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::QueueConfigurationDeprecated
end

class Aws::S3::Types::RecordsEvent
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::RecordsEvent
end

class Aws::S3::Types::Redirect
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Redirect
end

class Aws::S3::Types::RedirectAllRequestsTo
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::RedirectAllRequestsTo
end

class Aws::S3::Types::ReplicationConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ReplicationConfiguration
end

class Aws::S3::Types::ReplicationRule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ReplicationRule
end

class Aws::S3::Types::ReplicationRuleAndOperator
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ReplicationRuleAndOperator
end

class Aws::S3::Types::ReplicationRuleFilter
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ReplicationRuleFilter
end

class Aws::S3::Types::ReplicationTime
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ReplicationTime
end

class Aws::S3::Types::ReplicationTimeValue
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ReplicationTimeValue
end

class Aws::S3::Types::RequestPaymentConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::RequestPaymentConfiguration
end

class Aws::S3::Types::RequestProgress
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::RequestProgress
end

class Aws::S3::Types::RestoreObjectOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::RestoreObjectOutput
end

class Aws::S3::Types::RestoreObjectRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::RestoreObjectRequest
end

class Aws::S3::Types::RestoreRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::RestoreRequest
end

class Aws::S3::Types::RoutingRule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::RoutingRule
end

class Aws::S3::Types::Rule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Rule
end

class Aws::S3::Types::S3KeyFilter
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::S3KeyFilter
end

class Aws::S3::Types::S3Location
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::S3Location
end

class Aws::S3::Types::SSEKMS
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::SSEKMS
end

class Aws::S3::Types::SSES3
end

class Aws::S3::Types::SSES3
end

class Aws::S3::Types::ScanRange
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ScanRange
end

class Aws::S3::Types::SelectObjectContentEventStream
  def event_types(); end
end

class Aws::S3::Types::SelectObjectContentEventStream
end

class Aws::S3::Types::SelectObjectContentOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::SelectObjectContentOutput
end

class Aws::S3::Types::SelectObjectContentRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::SelectObjectContentRequest
end

class Aws::S3::Types::SelectParameters
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::SelectParameters
end

class Aws::S3::Types::ServerSideEncryptionByDefault
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ServerSideEncryptionByDefault
end

class Aws::S3::Types::ServerSideEncryptionConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ServerSideEncryptionConfiguration
end

class Aws::S3::Types::ServerSideEncryptionRule
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::ServerSideEncryptionRule
end

class Aws::S3::Types::SourceSelectionCriteria
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::SourceSelectionCriteria
end

class Aws::S3::Types::SseKmsEncryptedObjects
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::SseKmsEncryptedObjects
end

class Aws::S3::Types::Stats
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Stats
end

class Aws::S3::Types::StatsEvent
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::StatsEvent
end

class Aws::S3::Types::StorageClassAnalysis
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::StorageClassAnalysis
end

class Aws::S3::Types::StorageClassAnalysisDataExport
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::StorageClassAnalysisDataExport
end

class Aws::S3::Types::Tag
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Tag
end

class Aws::S3::Types::Tagging
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Tagging
end

class Aws::S3::Types::TargetGrant
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::TargetGrant
end

class Aws::S3::Types::TopicConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::TopicConfiguration
end

class Aws::S3::Types::TopicConfigurationDeprecated
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::TopicConfigurationDeprecated
end

class Aws::S3::Types::Transition
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::Transition
end

class Aws::S3::Types::UploadPartCopyOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::UploadPartCopyOutput
end

class Aws::S3::Types::UploadPartCopyRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::UploadPartCopyRequest
end

class Aws::S3::Types::UploadPartOutput
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::UploadPartOutput
end

class Aws::S3::Types::UploadPartRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::UploadPartRequest
end

class Aws::S3::Types::VersioningConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::VersioningConfiguration
end

class Aws::S3::Types::WebsiteConfiguration
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Types::WebsiteConfiguration
end

module Aws::S3::Types
end

module Aws::S3::Waiters
end

class Aws::S3::Waiters::BucketExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::S3::Waiters::BucketExists
end

class Aws::S3::Waiters::BucketNotExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::S3::Waiters::BucketNotExists
end

class Aws::S3::Waiters::ObjectExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::S3::Waiters::ObjectExists
end

class Aws::S3::Waiters::ObjectNotExists
  def initialize(options); end

  def wait(params=T.unsafe(nil)); end

  def waiter(); end
end

class Aws::S3::Waiters::ObjectNotExists
end

module Aws::S3::Waiters
end

module Aws::S3
end

module Aws::STS
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Client
  include ::Aws::ClientStubs
  def assume_role(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def assume_role_with_saml(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def assume_role_with_web_identity(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def decode_authorization_message(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_access_key_info(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_caller_identity(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_federation_token(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def get_session_token(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(*args); end

  def waiter_names(); end
end

class Aws::STS::Client
  def self.errors_module(); end

  def self.identifier(); end
end

module Aws::STS::ClientApi
  include ::Seahorse::Model
  API = ::T.let(nil, ::T.untyped)
  AssumeRoleRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleResponse = ::T.let(nil, ::T.untyped)
  AssumeRoleWithSAMLRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleWithSAMLResponse = ::T.let(nil, ::T.untyped)
  AssumeRoleWithWebIdentityRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleWithWebIdentityResponse = ::T.let(nil, ::T.untyped)
  AssumedRoleUser = ::T.let(nil, ::T.untyped)
  Audience = ::T.let(nil, ::T.untyped)
  Credentials = ::T.let(nil, ::T.untyped)
  DecodeAuthorizationMessageRequest = ::T.let(nil, ::T.untyped)
  DecodeAuthorizationMessageResponse = ::T.let(nil, ::T.untyped)
  ExpiredTokenException = ::T.let(nil, ::T.untyped)
  FederatedUser = ::T.let(nil, ::T.untyped)
  GetAccessKeyInfoRequest = ::T.let(nil, ::T.untyped)
  GetAccessKeyInfoResponse = ::T.let(nil, ::T.untyped)
  GetCallerIdentityRequest = ::T.let(nil, ::T.untyped)
  GetCallerIdentityResponse = ::T.let(nil, ::T.untyped)
  GetFederationTokenRequest = ::T.let(nil, ::T.untyped)
  GetFederationTokenResponse = ::T.let(nil, ::T.untyped)
  GetSessionTokenRequest = ::T.let(nil, ::T.untyped)
  GetSessionTokenResponse = ::T.let(nil, ::T.untyped)
  IDPCommunicationErrorException = ::T.let(nil, ::T.untyped)
  IDPRejectedClaimException = ::T.let(nil, ::T.untyped)
  InvalidAuthorizationMessageException = ::T.let(nil, ::T.untyped)
  InvalidIdentityTokenException = ::T.let(nil, ::T.untyped)
  Issuer = ::T.let(nil, ::T.untyped)
  MalformedPolicyDocumentException = ::T.let(nil, ::T.untyped)
  NameQualifier = ::T.let(nil, ::T.untyped)
  PackedPolicyTooLargeException = ::T.let(nil, ::T.untyped)
  PolicyDescriptorType = ::T.let(nil, ::T.untyped)
  RegionDisabledException = ::T.let(nil, ::T.untyped)
  SAMLAssertionType = ::T.let(nil, ::T.untyped)
  Subject = ::T.let(nil, ::T.untyped)
  SubjectType = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
end

module Aws::STS::ClientApi
end

module Aws::STS::Errors
end

class Aws::STS::Errors::ExpiredTokenException
end

class Aws::STS::Errors::ExpiredTokenException
end

class Aws::STS::Errors::IDPCommunicationErrorException
end

class Aws::STS::Errors::IDPCommunicationErrorException
end

class Aws::STS::Errors::IDPRejectedClaimException
end

class Aws::STS::Errors::IDPRejectedClaimException
end

class Aws::STS::Errors::InvalidAuthorizationMessageException
end

class Aws::STS::Errors::InvalidAuthorizationMessageException
end

class Aws::STS::Errors::InvalidIdentityTokenException
end

class Aws::STS::Errors::InvalidIdentityTokenException
end

class Aws::STS::Errors::MalformedPolicyDocumentException
end

class Aws::STS::Errors::MalformedPolicyDocumentException
end

class Aws::STS::Errors::PackedPolicyTooLargeException
end

class Aws::STS::Errors::PackedPolicyTooLargeException
end

class Aws::STS::Errors::RegionDisabledException
end

class Aws::STS::Errors::RegionDisabledException
end

class Aws::STS::Errors::ServiceError
end

class Aws::STS::Errors::ServiceError
end

module Aws::STS::Errors
  extend ::Aws::Errors::DynamicErrors
end

module Aws::STS::Plugins
end

class Aws::STS::Plugins::STSRegionalEndpoints
end

class Aws::STS::Plugins::STSRegionalEndpoints
  def self.resolve_sts_regional_endpoints(cfg); end
end

module Aws::STS::Plugins
end

class Aws::STS::Presigner
  def get_caller_identity_presigned_url(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::STS::Presigner
end

class Aws::STS::Resource
  def client(); end

  def initialize(options=T.unsafe(nil)); end
end

class Aws::STS::Resource
end

module Aws::STS::Types
end

class Aws::STS::Types::AssumeRoleRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleRequest
end

class Aws::STS::Types::AssumeRoleResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleResponse
end

class Aws::STS::Types::AssumeRoleWithSAMLRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleWithSAMLRequest
end

class Aws::STS::Types::AssumeRoleWithSAMLResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleWithSAMLResponse
end

class Aws::STS::Types::AssumeRoleWithWebIdentityRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleWithWebIdentityRequest
end

class Aws::STS::Types::AssumeRoleWithWebIdentityResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleWithWebIdentityResponse
end

class Aws::STS::Types::AssumedRoleUser
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumedRoleUser
end

class Aws::STS::Types::Credentials
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::Credentials
end

class Aws::STS::Types::DecodeAuthorizationMessageRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::DecodeAuthorizationMessageRequest
end

class Aws::STS::Types::DecodeAuthorizationMessageResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::DecodeAuthorizationMessageResponse
end

class Aws::STS::Types::ExpiredTokenException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::ExpiredTokenException
end

class Aws::STS::Types::FederatedUser
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::FederatedUser
end

class Aws::STS::Types::GetAccessKeyInfoRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetAccessKeyInfoRequest
end

class Aws::STS::Types::GetAccessKeyInfoResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetAccessKeyInfoResponse
end

class Aws::STS::Types::GetCallerIdentityRequest
end

class Aws::STS::Types::GetCallerIdentityRequest
end

class Aws::STS::Types::GetCallerIdentityResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetCallerIdentityResponse
end

class Aws::STS::Types::GetFederationTokenRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetFederationTokenRequest
end

class Aws::STS::Types::GetFederationTokenResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetFederationTokenResponse
end

class Aws::STS::Types::GetSessionTokenRequest
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetSessionTokenRequest
end

class Aws::STS::Types::GetSessionTokenResponse
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetSessionTokenResponse
end

class Aws::STS::Types::IDPCommunicationErrorException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::IDPCommunicationErrorException
end

class Aws::STS::Types::IDPRejectedClaimException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::IDPRejectedClaimException
end

class Aws::STS::Types::InvalidAuthorizationMessageException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::InvalidAuthorizationMessageException
end

class Aws::STS::Types::InvalidIdentityTokenException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::InvalidIdentityTokenException
end

class Aws::STS::Types::MalformedPolicyDocumentException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::MalformedPolicyDocumentException
end

class Aws::STS::Types::PackedPolicyTooLargeException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::PackedPolicyTooLargeException
end

class Aws::STS::Types::PolicyDescriptorType
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::PolicyDescriptorType
end

class Aws::STS::Types::RegionDisabledException
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::RegionDisabledException
end

class Aws::STS::Types::Tag
  include ::Aws::Structure
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::Tag
end

module Aws::STS::Types
end

module Aws::STS
end

class Aws::SharedConfig
  def adaptive_retry_wait_to_fill(opts=T.unsafe(nil)); end

  def assume_role_credentials_from_config(opts=T.unsafe(nil)); end

  def assume_role_web_identity_credentials_from_config(opts=T.unsafe(nil)); end

  def config_enabled?(); end

  def config_path(); end

  def correct_clock_skew(opts=T.unsafe(nil)); end

  def credential_process(opts=T.unsafe(nil)); end

  def credentials(opts=T.unsafe(nil)); end

  def credentials_path(); end

  def csm_client_id(opts=T.unsafe(nil)); end

  def csm_enabled(opts=T.unsafe(nil)); end

  def csm_host(opts=T.unsafe(nil)); end

  def csm_port(opts=T.unsafe(nil)); end

  def endpoint_discovery_enabled(opts=T.unsafe(nil)); end

  def fresh(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def loadable?(path); end

  def max_attempts(opts=T.unsafe(nil)); end

  def profile_name(); end

  def region(opts=T.unsafe(nil)); end

  def retry_mode(opts=T.unsafe(nil)); end

  def s3_us_east_1_regional_endpoint(opts=T.unsafe(nil)); end

  def s3_use_arn_region(opts=T.unsafe(nil)); end

  def sts_regional_endpoints(opts=T.unsafe(nil)); end
end

class Aws::SharedConfig
  def self.config_reader(*attrs); end
end

class Aws::SharedCredentials
  include ::Aws::CredentialProvider
  def initialize(options=T.unsafe(nil)); end

  def loadable?(); end

  def path(); end

  def profile_name(); end
  KEY_MAP = ::T.let(nil, ::T.untyped)
end

class Aws::SharedCredentials
end

module Aws::Sigv4
end

class Aws::Sigv4::Credentials
  def access_key_id(); end

  def initialize(options=T.unsafe(nil)); end

  def secret_access_key(); end

  def session_token(); end

  def set?(); end
end

class Aws::Sigv4::Credentials
end

module Aws::Sigv4::Errors
end

class Aws::Sigv4::Errors::MissingCredentialsError
  def initialize(msg=T.unsafe(nil)); end
end

class Aws::Sigv4::Errors::MissingCredentialsError
end

class Aws::Sigv4::Errors::MissingRegionError
  def initialize(*args); end
end

class Aws::Sigv4::Errors::MissingRegionError
end

module Aws::Sigv4::Errors
end

class Aws::Sigv4::Signature
  def canonical_request(); end

  def canonical_request=(canonical_request); end

  def content_sha256(); end

  def content_sha256=(content_sha256); end

  def headers(); end

  def headers=(headers); end

  def initialize(options); end

  def string_to_sign(); end

  def string_to_sign=(string_to_sign); end
end

class Aws::Sigv4::Signature
end

class Aws::Sigv4::Signer
  def apply_checksum_header(); end

  def credentials_provider(); end

  def initialize(options=T.unsafe(nil)); end

  def presign_url(options); end

  def region(); end

  def service(); end

  def sign_event(prior_signature, payload, encoder); end

  def sign_request(request); end

  def unsigned_headers(); end
end

class Aws::Sigv4::Signer
  def self.uri_escape(string); end

  def self.uri_escape_path(path); end
end

class Aws::Sigv4::StaticCredentialsProvider
  def credentials(); end

  def initialize(options=T.unsafe(nil)); end

  def set?(); end
end

class Aws::Sigv4::StaticCredentialsProvider
end

module Aws::Sigv4
end

module Aws::Structure
  def empty?(); end

  def initialize(values=T.unsafe(nil)); end

  def key?(member_name); end

  def to_h(obj=T.unsafe(nil)); end

  def to_hash(obj=T.unsafe(nil)); end

  def to_s(obj=T.unsafe(nil)); end
end

module Aws::Structure
  def self.new(*args); end
end

module Aws::Stubbing
end

class Aws::Stubbing::DataApplicator
  include ::Seahorse::Model::Shapes
  def apply_data(data, stub); end

  def initialize(rules); end
end

class Aws::Stubbing::DataApplicator
end

class Aws::Stubbing::EmptyStub
  include ::Seahorse::Model::Shapes
  def initialize(rules); end

  def stub(); end
end

class Aws::Stubbing::EmptyStub
end

module Aws::Stubbing::Protocols
end

class Aws::Stubbing::Protocols::ApiGateway
end

class Aws::Stubbing::Protocols::ApiGateway
end

class Aws::Stubbing::Protocols::EC2
  def stub_data(api, operation, data); end

  def stub_error(error_code); end
end

class Aws::Stubbing::Protocols::EC2
end

class Aws::Stubbing::Protocols::Json
  def stub_data(api, operation, data); end

  def stub_error(error_code); end
end

class Aws::Stubbing::Protocols::Json
end

class Aws::Stubbing::Protocols::Query
  def stub_data(api, operation, data); end

  def stub_error(error_code); end
end

class Aws::Stubbing::Protocols::Query
end

class Aws::Stubbing::Protocols::Rest
  include ::Seahorse::Model::Shapes
  def stub_data(api, operation, data); end
end

class Aws::Stubbing::Protocols::Rest
end

class Aws::Stubbing::Protocols::RestJson
  def body_for(_, _, rules, data); end

  def stub_error(error_code); end
end

class Aws::Stubbing::Protocols::RestJson
end

class Aws::Stubbing::Protocols::RestXml
  def body_for(api, operation, rules, data); end

  def stub_error(error_code); end

  def xmlns(api); end
end

class Aws::Stubbing::Protocols::RestXml
end

module Aws::Stubbing::Protocols
end

class Aws::Stubbing::StubData
  def initialize(operation); end

  def stub(data=T.unsafe(nil)); end
end

class Aws::Stubbing::StubData
end

class Aws::Stubbing::XmlError
  def initialize(error_code); end

  def to_xml(); end
end

class Aws::Stubbing::XmlError
end

module Aws::Stubbing
end

class Aws::TypeBuilder
  def build_type(shape, shapes); end

  def initialize(svc_module); end
end

class Aws::TypeBuilder
end

module Aws::Util
end

module Aws::Util
  def self.copy_hash(hash); end

  def self.deep_copy(obj); end

  def self.deep_merge(left, right); end

  def self.monotonic_milliseconds(); end

  def self.monotonic_seconds(); end

  def self.str_2_bool(str); end
end

module Aws::Waiters
end

module Aws::Waiters::Errors
end

class Aws::Waiters::Errors::FailureStateError
  def initialize(response); end

  def response(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::FailureStateError
end

class Aws::Waiters::Errors::NoSuchWaiterError
  def initialize(waiter_name, waiter_names); end
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::NoSuchWaiterError
end

class Aws::Waiters::Errors::TooManyAttemptsError
  def attempts(); end

  def initialize(attempts); end
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::TooManyAttemptsError
end

class Aws::Waiters::Errors::UnexpectedError
  def error(); end

  def initialize(error); end
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::UnexpectedError
end

class Aws::Waiters::Errors::WaiterFailed
end

class Aws::Waiters::Errors::WaiterFailed
end

module Aws::Waiters::Errors
end

class Aws::Waiters::Poller
  def call(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def operation_name(); end
end

Aws::Waiters::Poller::RAISE_HANDLER = Seahorse::Client::Plugins::RaiseResponseErrors::Handler

class Aws::Waiters::Poller
end

class Aws::Waiters::Waiter
  def before_attempt(&block); end

  def before_wait(&block); end

  def delay(); end

  def delay=(delay); end

  def initialize(options=T.unsafe(nil)); end

  def interval(); end

  def interval=(interval); end

  def max_attempts(); end

  def max_attempts=(max_attempts); end

  def poller(); end

  def wait(options); end
end

Aws::Waiters::Waiter::RAISE_HANDLER = Seahorse::Client::Plugins::RaiseResponseErrors::Handler

class Aws::Waiters::Waiter
end

module Aws::Waiters
end

module Aws::Xml
end

class Aws::Xml::Builder
  include ::Seahorse::Model::Shapes
  def initialize(rules, options=T.unsafe(nil)); end

  def serialize(params); end

  def to_xml(params); end
end

class Aws::Xml::Builder
end

class Aws::Xml::DefaultList
end

class Aws::Xml::DefaultList
end

class Aws::Xml::DefaultMap
end

class Aws::Xml::DefaultMap
end

class Aws::Xml::DocBuilder
  def initialize(options=T.unsafe(nil)); end

  def node(name, *args, &block); end

  def target(); end
end

class Aws::Xml::DocBuilder
end

class Aws::Xml::ErrorHandler
end

class Aws::Xml::ErrorHandler
end

class Aws::Xml::Parser
  include ::Seahorse::Model::Shapes
  def initialize(rules, options=T.unsafe(nil)); end

  def parse(xml, target=T.unsafe(nil), &unhandled_callback); end
  FRAME_CLASSES = ::T.let(nil, ::T.untyped)
end

class Aws::Xml::Parser::BlobFrame
end

class Aws::Xml::Parser::BlobFrame
end

class Aws::Xml::Parser::BooleanFrame
end

class Aws::Xml::Parser::BooleanFrame
end

class Aws::Xml::Parser::FlatListFrame
  def initialize(xml_name, *args); end
end

class Aws::Xml::Parser::FlatListFrame
end

class Aws::Xml::Parser::FloatFrame
end

class Aws::Xml::Parser::FloatFrame
end

class Aws::Xml::Parser::Frame
  include ::Seahorse::Model::Shapes
  def child_frame(xml_name); end

  def consume_child_frame(child); end

  def initialize(path, parent, ref, result); end

  def parent(); end

  def path(); end

  def ref(); end

  def result(); end

  def set_text(value); end

  def yield_unhandled_value(path, value); end
end

class Aws::Xml::Parser::Frame
  def self.new(path, parent, ref, result=T.unsafe(nil)); end
end

class Aws::Xml::Parser::IntegerFrame
end

class Aws::Xml::Parser::IntegerFrame
end

class Aws::Xml::Parser::ListFrame
  def initialize(*args); end
end

class Aws::Xml::Parser::ListFrame
end

class Aws::Xml::Parser::MapEntryFrame
  def initialize(xml_name, *args); end

  def key(); end

  def value(); end
end

class Aws::Xml::Parser::MapEntryFrame
end

class Aws::Xml::Parser::MapFrame
  def initialize(*args); end
end

class Aws::Xml::Parser::MapFrame
end

class Aws::Xml::Parser::NokogiriEngine
  def characters(chars); end

  def comment(*args); end

  def end_document(); end

  def end_element_namespace(*ignored); end

  def error(msg); end

  def initialize(stack); end

  def parse(xml); end

  def start_document(); end

  def start_element_namespace(element_name, attributes=T.unsafe(nil), *ignored); end

  def xmldecl(*args); end
end

class Aws::Xml::Parser::NokogiriEngine
end

class Aws::Xml::Parser::NullFrame
end

class Aws::Xml::Parser::NullFrame
  def self.new(xml_name, parent); end
end

class Aws::Xml::Parser::ParsingError
  def column(); end

  def initialize(msg, line, column); end

  def line(); end
end

class Aws::Xml::Parser::ParsingError
end

class Aws::Xml::Parser::Stack
  def attr(name, value); end

  def child_frame(name); end

  def consume_child_frame(frame); end

  def end_element(*args); end

  def error(msg, line=T.unsafe(nil), column=T.unsafe(nil)); end

  def frame(); end

  def initialize(ref, result=T.unsafe(nil), &unhandled_callback); end

  def result(); end

  def start_element(name); end

  def text(value); end

  def yield_unhandled_value(path, value); end
end

class Aws::Xml::Parser::Stack
end

class Aws::Xml::Parser::StringFrame
end

class Aws::Xml::Parser::StringFrame
end

class Aws::Xml::Parser::StructureFrame
  def initialize(xml_name, parent, ref, result=T.unsafe(nil)); end
end

class Aws::Xml::Parser::StructureFrame
end

class Aws::Xml::Parser::TimestampFrame
  def parse(value); end
end

class Aws::Xml::Parser::TimestampFrame
end

class Aws::Xml::Parser
  def self.engine(); end

  def self.engine=(engine); end

  def self.set_default_engine(); end
end

module Aws::Xml
end

module Aws
  def self.config(); end

  def self.config=(config); end

  def self.eager_autoload!(*args); end

  def self.empty_connection_pools!(); end

  def self.partition(partition_name); end

  def self.partitions(); end

  def self.shared_config(); end

  def self.use_bundled_cert!(); end
end

module BCrypt
end

class BCrypt::Engine
  DEFAULT_COST = ::T.let(nil, ::T.untyped)
  MAX_SALT_LENGTH = ::T.let(nil, ::T.untyped)
  MIN_COST = ::T.let(nil, ::T.untyped)
end

class BCrypt::Engine
  def self.autodetect_cost(salt); end

  def self.calibrate(upper_time_limit_in_ms); end

  def self.cost(); end

  def self.cost=(cost); end

  def self.generate_salt(cost=T.unsafe(nil)); end

  def self.hash_secret(secret, salt, _=T.unsafe(nil)); end

  def self.valid_salt?(salt); end

  def self.valid_secret?(secret); end
end

class BCrypt::Error
end

class BCrypt::Error
end

module BCrypt::Errors
end

class BCrypt::Errors::InvalidCost
end

class BCrypt::Errors::InvalidCost
end

class BCrypt::Errors::InvalidHash
end

class BCrypt::Errors::InvalidHash
end

class BCrypt::Errors::InvalidSalt
end

class BCrypt::Errors::InvalidSalt
end

class BCrypt::Errors::InvalidSecret
end

class BCrypt::Errors::InvalidSecret
end

module BCrypt::Errors
end

class BCrypt::Password
  def ==(secret); end

  def checksum(); end

  def cost(); end

  def initialize(raw_hash); end

  def is_password?(secret); end

  def salt(); end

  def version(); end
end

class BCrypt::Password
  def self.create(secret, options=T.unsafe(nil)); end

  def self.valid_hash?(h); end
end

module BCrypt
end

class BasicObject
  def __binding__(); end

  def as_null_object(); end

  def null_object?(); end

  def received_message?(message, *args, &block); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not_receive(message, &block); end

  def should_receive(message, opts=T.unsafe(nil), &block); end

  def stub(message_or_hash, opts=T.unsafe(nil), &block); end

  def stub_chain(*chain, &blk); end

  def unstub(message); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def to_a(); end
end

module BetterErrors
  POSSIBLE_EDITOR_PRESETS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BetterErrors::CodeFormatter
  def coderay_scanner(); end

  def context(); end

  def context_lines(); end

  def each_line_of(lines, &blk); end

  def filename(); end

  def formatted_code(); end

  def highlighted_lines(); end

  def initialize(filename, line, context=T.unsafe(nil)); end

  def line(); end

  def line_range(); end

  def output(); end

  def source_lines(); end
  FILE_TYPES = ::T.let(nil, ::T.untyped)
end

class BetterErrors::CodeFormatter::HTML
  def formatted_lines(); end

  def formatted_nums(); end

  def source_unavailable(); end
end

class BetterErrors::CodeFormatter::HTML
end

class BetterErrors::CodeFormatter::Text
  def formatted_lines(); end

  def source_unavailable(); end
end

class BetterErrors::CodeFormatter::Text
end

class BetterErrors::CodeFormatter
end

class BetterErrors::ErrorPage
  def application_frames(); end

  def backtrace_frames(); end

  def do_eval(opts); end

  def do_variables(opts); end

  def env(); end

  def exception(); end

  def exception_message(); end

  def exception_type(); end

  def first_frame(); end

  def id(); end

  def initialize(exception, env); end

  def render(template_name=T.unsafe(nil)); end

  def repls(); end
end

class BetterErrors::ErrorPage
  def self.template(template_name); end

  def self.template_path(template_name); end
end

module BetterErrors::ExceptionExtension
  def __better_errors_bindings_stack(); end

  def set_backtrace(*_); end
end

module BetterErrors::ExceptionExtension
end

class BetterErrors::InspectableValue
  def initialize(value); end

  def to_html(); end
end

class BetterErrors::InspectableValue
end

class BetterErrors::Middleware
  def call(env); end

  def initialize(app, handler=T.unsafe(nil)); end
  ALLOWED_IPS = ::T.let(nil, ::T.untyped)
end

class BetterErrors::Middleware
  def self.allow_ip!(addr); end
end

module BetterErrors::REPL
  PROVIDERS = ::T.let(nil, ::T.untyped)
end

module BetterErrors::REPL
  def self.detect(); end

  def self.provider(); end

  def self.provider=(prov); end

  def self.test_provider(provider); end
end

class BetterErrors::Railtie
  def app(); end

  def insert_middleware(); end

  def use_better_errors?(); end
end

class BetterErrors::Railtie
end

class BetterErrors::RaisedException
  def backtrace(); end

  def exception(); end

  def initialize(exception); end

  def message(); end

  def type(); end
end

class BetterErrors::RaisedException
end

class BetterErrors::StackFrame
  def application?(); end

  def application_path(); end

  def class_name(); end

  def context(); end

  def filename(); end

  def frame_binding(); end

  def gem?(); end

  def gem_path(); end

  def initialize(filename, line, name, frame_binding=T.unsafe(nil)); end

  def line(); end

  def local_variable(name); end

  def method_name(); end

  def name(); end

  def pretty_path(); end

  def visible_instance_variables(); end
end

class BetterErrors::StackFrame
  def self.from_exception(exception); end
end

class BetterErrors::ValueLargerThanConfiguredMaximum
end

class BetterErrors::ValueLargerThanConfiguredMaximum
end

module BetterErrors
  def self.application_root(); end

  def self.application_root=(application_root); end

  def self.binding_of_caller_available(); end

  def self.binding_of_caller_available=(binding_of_caller_available); end

  def self.binding_of_caller_available?(); end

  def self.default_editor(); end

  def self.editor(); end

  def self.editor=(editor); end

  def self.ignored_classes(); end

  def self.ignored_classes=(ignored_classes); end

  def self.ignored_instance_variables(); end

  def self.ignored_instance_variables=(ignored_instance_variables); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.maximum_variable_inspect_size(); end

  def self.maximum_variable_inspect_size=(maximum_variable_inspect_size); end

  def self.use_pry!(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  include ::ActiveSupport::NumericWithFormat
  def clone(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  include ::BindingOfCaller::BindingExtensions
  def clone(); end

  def irb(); end
end

module BindingOfCaller
end

module BindingOfCaller::BindingExtensions
  def callers(); end

  def frame_count(); end

  def frame_description(); end

  def frame_type(); end

  def of_caller(n); end
end

module BindingOfCaller::BindingExtensions
end

module BindingOfCaller
end

module Bootsnap
  def bundler?(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Bootsnap::CompileCache
end

class Bootsnap::CompileCache::Error
end

class Bootsnap::CompileCache::Error
end

module Bootsnap::CompileCache::ISeq
end

module Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
  def compile_option=(hash); end

  def load_iseq(path); end
end

module Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
end

module Bootsnap::CompileCache::ISeq
  def self.cache_dir(); end

  def self.cache_dir=(cache_dir); end

  def self.compile_option_updated(); end

  def self.input_to_output(_); end

  def self.input_to_storage(_, path); end

  def self.install!(cache_dir); end

  def self.storage_to_output(binary); end
end

module Bootsnap::CompileCache::Native
end

module Bootsnap::CompileCache::Native
  def self.compile_option_crc32=(compile_option_crc32); end

  def self.coverage_running?(); end

  def self.fetch(_, _1, _2); end
end

class Bootsnap::CompileCache::PermissionError
end

class Bootsnap::CompileCache::PermissionError
end

class Bootsnap::CompileCache::Uncompilable
end

class Bootsnap::CompileCache::Uncompilable
end

module Bootsnap::CompileCache::YAML
end

module Bootsnap::CompileCache::YAML
  def self.input_to_output(data); end

  def self.input_to_storage(contents, _); end

  def self.install!(cache_dir); end

  def self.msgpack_factory(); end

  def self.msgpack_factory=(msgpack_factory); end

  def self.storage_to_output(data); end
end

module Bootsnap::CompileCache
  def self.permission_error(path); end

  def self.setup(cache_dir:, iseq:, yaml:); end

  def self.supported?(); end
end

module Bootsnap::ExplicitRequire
  ARCHDIR = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  RUBYLIBDIR = ::T.let(nil, ::T.untyped)
end

module Bootsnap::ExplicitRequire
  def self.from_archdir(feature); end

  def self.from_rubylibdir(feature); end

  def self.from_self(feature); end

  def self.with_gems(*gems); end
end

class Bootsnap::InvalidConfiguration
end

class Bootsnap::InvalidConfiguration
end

module Bootsnap::LoadPathCache
  CACHED_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  DLEXT2 = ::T.let(nil, ::T.untyped)
  DL_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DOT_RB = ::T.let(nil, ::T.untyped)
  DOT_SO = ::T.let(nil, ::T.untyped)
  ERROR_TAG_IVAR = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Cache
  def absolute_path?(path); end

  def find(feature); end

  def initialize(store, path_obj, development_mode: T.unsafe(nil)); end

  def load_dir(dir); end

  def push_paths(sender, *paths); end

  def reinitialize(path_obj=T.unsafe(nil)); end

  def unshift_paths(sender, *paths); end
  AGE_THRESHOLD = ::T.let(nil, ::T.untyped)
  BUILTIN_FEATURES = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Cache
end

module Bootsnap::LoadPathCache::ChangeObserver
end

module Bootsnap::LoadPathCache::ChangeObserver::ArrayMixin
  def <<(entry); end

  def []=(*args, &block); end

  def clear(*args, &block); end

  def collect!(*args, &block); end

  def compact!(*args, &block); end

  def concat(entries); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def fill(*args, &block); end

  def flatten!(*args, &block); end

  def insert(*args, &block); end

  def keep_if(*args, &block); end

  def map!(*args, &block); end

  def pop(*args, &block); end

  def push(*entries); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse!(*args, &block); end

  def rotate!(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def shuffle!(*args, &block); end

  def slice!(*args, &block); end

  def sort!(*args, &block); end

  def sort_by!(*args, &block); end

  def uniq!(*args); end

  def unshift(*entries); end
end

module Bootsnap::LoadPathCache::ChangeObserver::ArrayMixin
end

module Bootsnap::LoadPathCache::ChangeObserver
  def self.register(observer, arr); end
end

module Bootsnap::LoadPathCache::CoreExt
end

module Bootsnap::LoadPathCache::CoreExt::ActiveSupport
end

module Bootsnap::LoadPathCache::CoreExt::ActiveSupport::ClassMethods
  def autoload_paths=(o); end

  def autoloadable_module?(path_suffix); end

  def depend_on(*_); end

  def load_missing_constant(from_mod, const_name); end

  def remove_constant(const); end

  def require_or_load(*_); end

  def search_for_file(path); end
end

module Bootsnap::LoadPathCache::CoreExt::ActiveSupport::ClassMethods
end

module Bootsnap::LoadPathCache::CoreExt::ActiveSupport
  def self.allow_bootsnap_retry(allowed); end

  def self.without_bootsnap_cache(); end
end

module Bootsnap::LoadPathCache::CoreExt
  def self.make_load_error(path); end
end

class Bootsnap::LoadPathCache::FallbackScan
end

class Bootsnap::LoadPathCache::FallbackScan
end

class Bootsnap::LoadPathCache::LoadedFeaturesIndex
  def key?(feature); end

  def purge(feature); end

  def purge_multi(features); end

  def register(short, long=T.unsafe(nil)); end
end

class Bootsnap::LoadPathCache::LoadedFeaturesIndex
end

class Bootsnap::LoadPathCache::Path
  def entries_and_dirs(store); end

  def expanded_path(); end

  def initialize(path); end

  def non_directory?(); end

  def path(); end

  def relative?(); end

  def stable?(); end

  def volatile?(); end
  RUBY_LIBDIR = ::T.let(nil, ::T.untyped)
  RUBY_SITEDIR = ::T.let(nil, ::T.untyped)
  STABLE = ::T.let(nil, ::T.untyped)
  VOLATILE = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Path
end

module Bootsnap::LoadPathCache::PathScanner
  ALL_FILES = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_NATIVE_EXTENSIONS_PATTERN = ::T.let(nil, ::T.untyped)
  BUNDLE_PATH = ::T.let(nil, ::T.untyped)
  NORMALIZE_NATIVE_EXTENSIONS = ::T.let(nil, ::T.untyped)
  REQUIRABLE_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache::PathScanner
  def self.call(path); end
end

class Bootsnap::LoadPathCache::RealpathCache
  def call(*key); end
end

class Bootsnap::LoadPathCache::RealpathCache
end

class Bootsnap::LoadPathCache::ReturnFalse
end

class Bootsnap::LoadPathCache::ReturnFalse
end

class Bootsnap::LoadPathCache::Store
  def fetch(key); end

  def get(key); end

  def initialize(store_path); end

  def set(key, value); end

  def transaction(); end
end

class Bootsnap::LoadPathCache::Store::NestedTransactionError
end

class Bootsnap::LoadPathCache::Store::NestedTransactionError
end

class Bootsnap::LoadPathCache::Store::SetOutsideTransactionNotAllowed
end

class Bootsnap::LoadPathCache::Store::SetOutsideTransactionNotAllowed
end

class Bootsnap::LoadPathCache::Store
end

module Bootsnap::LoadPathCache
  def self.autoload_paths_cache(); end

  def self.load_path_cache(); end

  def self.loaded_features_index(); end

  def self.realpath_cache(); end

  def self.setup(cache_path:, development_mode:, active_support: T.unsafe(nil)); end

  def self.supported?(); end
end

module Bootsnap
  extend ::Bootsnap
  def self.setup(cache_dir:, development_mode: T.unsafe(nil), load_path_cache: T.unsafe(nil), autoload_paths_cache: T.unsafe(nil), disable_trace: T.unsafe(nil), compile_cache_iseq: T.unsafe(nil), compile_cache_yaml: T.unsafe(nil)); end

  def self.setup_disable_trace(); end
end

class BufferedTokenizer
  def extract(data); end

  def flush(); end

  def initialize(delimiter=T.unsafe(nil)); end
end

class BufferedTokenizer
end

module Bugsnag
  INTEGRATIONS = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
  NIL_EXCEPTION_DESCRIPTION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Bugsnag::Breadcrumbs
  ERROR_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  LOG_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  MANUAL_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  MAX_NAME_LENGTH = ::T.let(nil, ::T.untyped)
  NAVIGATION_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  PROCESS_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  REQUEST_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  STATE_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  USER_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  VALID_BREADCRUMB_TYPES = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Breadcrumbs::Breadcrumb
  def auto(); end

  def ignore!(); end

  def ignore?(); end

  def initialize(name, type, meta_data, auto); end

  def meta_data(); end

  def meta_data=(meta_data); end

  def name(); end

  def name=(name); end

  def timestamp(); end

  def to_h(); end

  def type(); end

  def type=(type); end
end

class Bugsnag::Breadcrumbs::Breadcrumb
end

class Bugsnag::Breadcrumbs::Validator
  def initialize(configuration); end

  def validate(breadcrumb); end
end

class Bugsnag::Breadcrumbs::Validator
end

module Bugsnag::Breadcrumbs
end

class Bugsnag::Cleaner
  def clean_object(obj); end

  def clean_string(str); end

  def clean_url(url); end

  def initialize(filters); end

  def traverse_object(obj, seen, scope); end
  FILTERED = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  RAISED = ::T.let(nil, ::T.untyped)
  RECURSION = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Cleaner
  def self.clean_object_encoding(obj); end
end

class Bugsnag::Configuration
  def api_key(); end

  def api_key=(api_key); end

  def app_type(); end

  def app_type=(app_type); end

  def app_version(); end

  def app_version=(app_version); end

  def auto_capture_sessions(); end

  def auto_capture_sessions=(auto_capture_sessions); end

  def auto_notify(); end

  def auto_notify=(auto_notify); end

  def before_breadcrumb_callbacks(); end

  def before_breadcrumb_callbacks=(before_breadcrumb_callbacks); end

  def breadcrumbs(); end

  def ca_file(); end

  def ca_file=(ca_file); end

  def clear_request_data(); end

  def debug(message); end

  def default_delivery_method=(delivery_method); end

  def delivery_method(); end

  def delivery_method=(delivery_method); end

  def disable_sessions(); end

  def enable_sessions(); end

  def enabled_automatic_breadcrumb_types(); end

  def enabled_automatic_breadcrumb_types=(enabled_automatic_breadcrumb_types); end

  def endpoint(); end

  def endpoint=(new_notify_endpoint); end

  def hostname(); end

  def hostname=(hostname); end

  def ignore_classes(); end

  def ignore_classes=(ignore_classes); end

  def info(message); end

  def internal_middleware(); end

  def internal_middleware=(internal_middleware); end

  def logger(); end

  def logger=(logger); end

  def max_breadcrumbs(); end

  def max_breadcrumbs=(new_max_breadcrumbs); end

  def meta_data_filters(); end

  def meta_data_filters=(meta_data_filters); end

  def middleware(); end

  def middleware=(middleware); end

  def notify_endpoint(); end

  def notify_release_stages(); end

  def notify_release_stages=(notify_release_stages); end

  def parse_proxy(uri); end

  def project_root(); end

  def project_root=(project_root); end

  def proxy_host(); end

  def proxy_host=(proxy_host); end

  def proxy_password(); end

  def proxy_password=(proxy_password); end

  def proxy_port(); end

  def proxy_port=(proxy_port); end

  def proxy_user(); end

  def proxy_user=(proxy_user); end

  def release_stage(); end

  def release_stage=(release_stage); end

  def request_data(); end

  def runtime_versions(); end

  def runtime_versions=(runtime_versions); end

  def send_code(); end

  def send_code=(send_code); end

  def send_environment(); end

  def send_environment=(send_environment); end

  def session_endpoint(); end

  def session_endpoint=(new_session_endpoint); end

  def set_endpoints(new_notify_endpoint, new_session_endpoint); end

  def set_request_data(key, value); end

  def should_notify_release_stage?(); end

  def timeout(); end

  def timeout=(timeout); end

  def track_sessions(); end

  def track_sessions=(track_sessions); end

  def unset_request_data(key, value); end

  def valid_api_key?(); end

  def vendor_path(); end

  def vendor_path=(vendor_path); end

  def warn(message); end
  API_KEY_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_ENDPOINT = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_BREADCRUMBS = ::T.let(nil, ::T.untyped)
  DEFAULT_META_DATA_FILTERS = ::T.let(nil, ::T.untyped)
  DEFAULT_NOTIFY_ENDPOINT = ::T.let(nil, ::T.untyped)
  DEFAULT_SESSION_ENDPOINT = ::T.let(nil, ::T.untyped)
  DEFAULT_VENDOR_PATH = ::T.let(nil, ::T.untyped)
  PROG_NAME = ::T.let(nil, ::T.untyped)
  THREAD_LOCAL_NAME = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Configuration
end

module Bugsnag::Delivery
end

class Bugsnag::Delivery::Synchronous
end

class Bugsnag::Delivery::Synchronous
  def self.deliver(url, body, configuration, options=T.unsafe(nil)); end
end

class Bugsnag::Delivery::ThreadQueue
  MAX_OUTSTANDING_REQUESTS = ::T.let(nil, ::T.untyped)
  MUTEX = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Delivery::ThreadQueue
end

module Bugsnag::Delivery
  def self.[](name); end

  def self.register(name, delivery_method); end
end

module Bugsnag::Helpers
  MAX_ARRAY_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_PAYLOAD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_STRING_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_TRIM_STACK_FRAMES = ::T.let(nil, ::T.untyped)
  RAW_DATA_TYPES = ::T.let(nil, ::T.untyped)
  TRUNCATION_INFO = ::T.let(nil, ::T.untyped)
end

module Bugsnag::Helpers
  def self.deep_merge(l_hash, r_hash); end

  def self.deep_merge!(l_hash, r_hash); end

  def self.extract_exception(payload); end

  def self.get_payload_length(value); end

  def self.is_json_raw_type?(value); end

  def self.payload_too_long?(value); end

  def self.remove_metadata_from_events(object); end

  def self.trim_as_string(text); end

  def self.trim_if_needed(value); end

  def self.trim_metadata(payload); end

  def self.trim_stacktrace_code(payload); end

  def self.trim_stacktrace_functions(payload); end

  def self.trim_strings_in_array(collection); end

  def self.trim_strings_in_hash(hash); end

  def self.trim_strings_in_value(value); end

  def self.truncate_array(array); end

  def self.truncate_arrays_in_hash(hash); end

  def self.truncate_arrays_in_value(value); end
end

module Bugsnag::MetaData
  def bugsnag_context(); end

  def bugsnag_context=(bugsnag_context); end

  def bugsnag_grouping_hash(); end

  def bugsnag_grouping_hash=(bugsnag_grouping_hash); end

  def bugsnag_meta_data(); end

  def bugsnag_meta_data=(bugsnag_meta_data); end

  def bugsnag_user_id(); end

  def bugsnag_user_id=(bugsnag_user_id); end
end

module Bugsnag::MetaData
end

module Bugsnag::Middleware
end

class Bugsnag::Middleware::Breadcrumbs
  def call(report); end

  def initialize(next_callable); end
end

class Bugsnag::Middleware::Breadcrumbs
end

class Bugsnag::Middleware::Callbacks
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::Callbacks
end

class Bugsnag::Middleware::ClassifyError
  def call(report); end

  def initialize(bugsnag); end
  INFO_CLASSES = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::ClassifyError
end

class Bugsnag::Middleware::ClearanceUser
  def call(report); end

  def initialize(bugsnag); end
  COMMON_USER_FIELDS = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::ClearanceUser
end

class Bugsnag::Middleware::DelayedJob
  def call(report); end

  def construct_job_payload(payload); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::DelayedJob
end

class Bugsnag::Middleware::ExceptionMetaData
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::ExceptionMetaData
end

class Bugsnag::Middleware::IgnoreErrorClass
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::IgnoreErrorClass
end

class Bugsnag::Middleware::Mailman
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::Mailman
end

class Bugsnag::Middleware::RackRequest
  def call(report); end

  def initialize(bugsnag); end
  SPOOF = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::RackRequest
end

class Bugsnag::Middleware::Rails3Request
  def call(report); end

  def initialize(bugsnag); end
  SPOOF = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::Rails3Request
end

class Bugsnag::Middleware::Rake
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::Rake
end

class Bugsnag::Middleware::SessionData
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::SessionData
end

class Bugsnag::Middleware::Sidekiq
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::Sidekiq
end

class Bugsnag::Middleware::SuggestionData
  def call(report); end

  def initialize(bugsnag); end
  CAPTURE_REGEX = ::T.let(nil, ::T.untyped)
  DELIMITER = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::SuggestionData
end

class Bugsnag::Middleware::WardenUser
  def call(report); end

  def initialize(bugsnag); end
  COMMON_USER_FIELDS = ::T.let(nil, ::T.untyped)
  SCOPE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::WardenUser
end

module Bugsnag::Middleware
end

class Bugsnag::MiddlewareStack
  def disable(*middlewares); end

  def insert_after(after, new_middleware); end

  def insert_before(before, new_middleware); end

  def method_missing(method, *args, &block); end

  def run(report); end

  def use(new_middleware); end
end

class Bugsnag::MiddlewareStack
end

class Bugsnag::Rack
  def call(env); end

  def initialize(app); end
  FRAMEWORK_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Rack
end

module Bugsnag::Rails
  DEFAULT_RAILS_BREADCRUMBS = ::T.let(nil, ::T.untyped)
end

module Bugsnag::Rails::ActiveRecordRescue
  def run_callbacks(kind, *args, &block); end
  FRAMEWORK_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  KINDS = ::T.let(nil, ::T.untyped)
end

module Bugsnag::Rails::ActiveRecordRescue
end

module Bugsnag::Rails::ControllerMethods
end

module Bugsnag::Rails::ControllerMethods
  def self.included(base); end
end

module Bugsnag::Rails
end

class Bugsnag::Railtie
  def event_subscription(event); end
  FRAMEWORK_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Railtie
end

class Bugsnag::Report
  def add_tab(name, value); end

  def api_key(); end

  def api_key=(api_key); end

  def app_type(); end

  def app_type=(app_type); end

  def app_version(); end

  def app_version=(app_version); end

  def as_json(); end

  def breadcrumbs(); end

  def breadcrumbs=(breadcrumbs); end

  def configuration(); end

  def configuration=(configuration); end

  def context(); end

  def context=(context); end

  def delivery_method(); end

  def delivery_method=(delivery_method); end

  def exceptions(); end

  def exceptions=(exceptions); end

  def grouping_hash(); end

  def grouping_hash=(grouping_hash); end

  def headers(); end

  def hostname(); end

  def hostname=(hostname); end

  def ignore!(); end

  def ignore?(); end

  def initialize(exception, passed_configuration, auto_notify=T.unsafe(nil)); end

  def meta_data(); end

  def meta_data=(meta_data); end

  def raw_exceptions(); end

  def raw_exceptions=(raw_exceptions); end

  def release_stage(); end

  def release_stage=(release_stage); end

  def remove_tab(name); end

  def request_data(); end

  def runtime_versions(); end

  def runtime_versions=(runtime_versions); end

  def session(); end

  def session=(session); end

  def severity(); end

  def severity=(severity); end

  def severity_reason(); end

  def severity_reason=(severity_reason); end

  def summary(); end

  def unhandled(); end

  def user(); end

  def user=(user); end
  CURRENT_PAYLOAD_VERSION = ::T.let(nil, ::T.untyped)
  ERROR_CLASS = ::T.let(nil, ::T.untyped)
  HANDLED_EXCEPTION = ::T.let(nil, ::T.untyped)
  MAX_EXCEPTIONS_TO_UNWRAP = ::T.let(nil, ::T.untyped)
  NOTIFIER_NAME = ::T.let(nil, ::T.untyped)
  NOTIFIER_URL = ::T.let(nil, ::T.untyped)
  NOTIFIER_VERSION = ::T.let(nil, ::T.untyped)
  UNHANDLED_EXCEPTION = ::T.let(nil, ::T.untyped)
  UNHANDLED_EXCEPTION_MIDDLEWARE = ::T.let(nil, ::T.untyped)
  USER_CALLBACK_SET_SEVERITY = ::T.let(nil, ::T.untyped)
  USER_SPECIFIED_SEVERITY = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Report
end

class Bugsnag::SessionTracker
  def create_session(); end

  def send_sessions(); end

  def session_counts(); end

  def start_session(); end
  MUTEX = ::T.let(nil, ::T.untyped)
  SESSION_PAYLOAD_VERSION = ::T.let(nil, ::T.untyped)
  THREAD_SESSION = ::T.let(nil, ::T.untyped)
end

class Bugsnag::SessionTracker
  def self.get_current_session(); end

  def self.set_current_session(session); end
end

class Bugsnag::Sidekiq
  def call(worker, msg, queue); end
  FRAMEWORK_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Sidekiq
  def self.configure_server(server); end

  def self.notify(exception); end

  def self.sidekiq_supports_error_handlers(); end
end

class Bugsnag::Stacktrace
  def initialize(backtrace, configuration); end

  def to_a(); end
  BACKTRACE_LINE_REGEX = ::T.let(nil, ::T.untyped)
  JAVA_BACKTRACE_REGEX = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Stacktrace
end

module Bugsnag::Utility
end

class Bugsnag::Utility::CircularBuffer
  include ::Enumerable
  def <<(item); end

  def each(&block); end

  def initialize(max_items=T.unsafe(nil)); end

  def max_items(); end

  def max_items=(new_max_items); end
end

class Bugsnag::Utility::CircularBuffer
end

module Bugsnag::Utility
end

module Bugsnag
  def self.at_exit_handler_installed?(); end

  def self.before_notify_callbacks(); end

  def self.configuration(); end

  def self.configure(validate_api_key=T.unsafe(nil)); end

  def self.leave_breadcrumb(name, meta_data=T.unsafe(nil), type=T.unsafe(nil), auto=T.unsafe(nil)); end

  def self.load_integration(integration); end

  def self.load_integrations(); end

  def self.notify(exception, auto_notify=T.unsafe(nil), &block); end

  def self.register_at_exit(); end

  def self.session_tracker(); end

  def self.start_session(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end

  def global_path_appends_ruby_scope?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration::MoreFuture
  def backport_ext_builder_monitor(); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module Capybara
  VERSION = ::T.let(nil, ::T.untyped)
end

class Capybara::Ambiguous
end

class Capybara::Ambiguous
end

class Capybara::CapybaraError
end

class Capybara::CapybaraError
end

class Capybara::Config
  def allow_gumbo(); end

  def allow_gumbo=(allow_gumbo); end

  def always_include_port(*args, &block); end

  def always_include_port=(*args, &block); end

  def app(); end

  def app=(app); end

  def app_host(*args, &block); end

  def app_host=(*args, &block); end

  def asset_host(*args, &block); end

  def asset_host=(*args, &block); end

  def automatic_label_click(*args, &block); end

  def automatic_label_click=(*args, &block); end

  def automatic_reload(*args, &block); end

  def automatic_reload=(*args, &block); end

  def default_driver(); end

  def default_driver=(default_driver); end

  def default_host(*args, &block); end

  def default_host=(*args, &block); end

  def default_max_wait_time(*args, &block); end

  def default_max_wait_time=(*args, &block); end

  def default_normalize_ws(*args, &block); end

  def default_normalize_ws=(*args, &block); end

  def default_selector(*args, &block); end

  def default_selector=(*args, &block); end

  def default_set_options(*args, &block); end

  def default_set_options=(*args, &block); end

  def deprecate(method, alternate_method, once=T.unsafe(nil)); end

  def disable_animation(*args, &block); end

  def disable_animation=(*args, &block); end

  def enable_aria_label(*args, &block); end

  def enable_aria_label=(*args, &block); end

  def enable_aria_role(*args, &block); end

  def enable_aria_role=(*args, &block); end

  def exact(*args, &block); end

  def exact=(*args, &block); end

  def exact_text(*args, &block); end

  def exact_text=(*args, &block); end

  def ignore_hidden_elements(*args, &block); end

  def ignore_hidden_elements=(*args, &block); end

  def javascript_driver(); end

  def javascript_driver=(javascript_driver); end

  def match(*args, &block); end

  def match=(*args, &block); end

  def predicates_wait(*args, &block); end

  def predicates_wait=(*args, &block); end

  def raise_server_errors(*args, &block); end

  def raise_server_errors=(*args, &block); end

  def reuse_server(); end

  def reuse_server=(reuse_server); end

  def run_server(*args, &block); end

  def run_server=(*args, &block); end

  def save_path(*args, &block); end

  def save_path=(*args, &block); end

  def server(); end

  def server=(name); end

  def server_errors(*args, &block); end

  def server_errors=(*args, &block); end

  def server_host(*args, &block); end

  def server_host=(*args, &block); end

  def server_port(*args, &block); end

  def server_port=(*args, &block); end

  def session_options(); end

  def test_id(*args, &block); end

  def test_id=(*args, &block); end

  def threadsafe(); end

  def threadsafe=(bool); end

  def visible_text_only(*args, &block); end

  def visible_text_only=(*args, &block); end

  def w3c_click_offset(*args, &block); end

  def w3c_click_offset=(*args, &block); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::Config
  extend ::Forwardable
end

module Capybara::DSL
  def accept_alert(*args, &block); end

  def accept_confirm(*args, &block); end

  def accept_prompt(*args, &block); end

  def all(*args, &block); end

  def assert_all_of_selectors(*args, &block); end

  def assert_any_of_selectors(*args, &block); end

  def assert_current_path(*args, &block); end

  def assert_no_current_path(*args, &block); end

  def assert_no_selector(*args, &block); end

  def assert_no_text(*args, &block); end

  def assert_no_title(*args, &block); end

  def assert_none_of_selectors(*args, &block); end

  def assert_selector(*args, &block); end

  def assert_text(*args, &block); end

  def assert_title(*args, &block); end

  def attach_file(*args, &block); end

  def body(*args, &block); end

  def check(*args, &block); end

  def choose(*args, &block); end

  def click_button(*args, &block); end

  def click_link(*args, &block); end

  def click_link_or_button(*args, &block); end

  def click_on(*args, &block); end

  def current_host(*args, &block); end

  def current_path(*args, &block); end

  def current_scope(*args, &block); end

  def current_url(*args, &block); end

  def current_window(*args, &block); end

  def dismiss_confirm(*args, &block); end

  def dismiss_prompt(*args, &block); end

  def evaluate_script(*args, &block); end

  def execute_script(*args, &block); end

  def fill_in(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_button(*args, &block); end

  def find_by_id(*args, &block); end

  def find_field(*args, &block); end

  def find_link(*args, &block); end

  def first(*args, &block); end

  def go_back(*args, &block); end

  def go_forward(*args, &block); end

  def has_button?(*args, &block); end

  def has_checked_field?(*args, &block); end

  def has_content?(*args, &block); end

  def has_css?(*args, &block); end

  def has_current_path?(*args, &block); end

  def has_field?(*args, &block); end

  def has_link?(*args, &block); end

  def has_no_button?(*args, &block); end

  def has_no_checked_field?(*args, &block); end

  def has_no_content?(*args, &block); end

  def has_no_css?(*args, &block); end

  def has_no_current_path?(*args, &block); end

  def has_no_field?(*args, &block); end

  def has_no_link?(*args, &block); end

  def has_no_select?(*args, &block); end

  def has_no_selector?(*args, &block); end

  def has_no_table?(*args, &block); end

  def has_no_text?(*args, &block); end

  def has_no_title?(*args, &block); end

  def has_no_unchecked_field?(*args, &block); end

  def has_no_xpath?(*args, &block); end

  def has_select?(*args, &block); end

  def has_selector?(*args, &block); end

  def has_table?(*args, &block); end

  def has_text?(*args, &block); end

  def has_title?(*args, &block); end

  def has_unchecked_field?(*args, &block); end

  def has_xpath?(*args, &block); end

  def html(*args, &block); end

  def open_new_window(*args, &block); end

  def page(); end

  def query(*args, &block); end

  def refresh(*args, &block); end

  def refute_selector(*args, &block); end

  def reset_session!(*args, &block); end

  def response_headers(*args, &block); end

  def save_and_open_page(*args, &block); end

  def save_and_open_screenshot(*args, &block); end

  def save_page(*args, &block); end

  def save_screenshot(*args, &block); end

  def scroll_by(*args, &block); end

  def scroll_to(*args, &block); end

  def select(*args, &block); end

  def source(*args, &block); end

  def status_code(*args, &block); end

  def switch_to_frame(*args, &block); end

  def switch_to_window(*args, &block); end

  def text(*args, &block); end

  def title(*args, &block); end

  def uncheck(*args, &block); end

  def unselect(*args, &block); end

  def using_session(name_or_session, &block); end

  def using_wait_time(seconds, &block); end

  def visit(*args, &block); end

  def window_opened_by(*args, &block); end

  def windows(*args, &block); end

  def within(*args, &block); end

  def within_element(*args, &block); end

  def within_fieldset(*args, &block); end

  def within_frame(*args, &block); end

  def within_table(*args, &block); end

  def within_window(*args, &block); end
end

module Capybara::DSL
  def self.extended(base); end

  def self.included(base); end
end

module Capybara::Driver
end

class Capybara::Driver::Base
  def accept_modal(type, **options, &blk); end

  def close_window(handle); end

  def current_url(); end

  def current_window_handle(); end

  def dismiss_modal(type, **options, &blk); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def find_css(query, **options); end

  def find_xpath(query, **options); end

  def frame_title(); end

  def frame_url(); end

  def fullscreen_window(handle); end

  def go_back(); end

  def go_forward(); end

  def html(); end

  def invalid_element_errors(); end

  def maximize_window(handle); end

  def needs_server?(); end

  def no_such_window_error(); end

  def open_new_window(); end

  def refresh(); end

  def reset!(); end

  def resize_window_to(handle, width, height); end

  def response_headers(); end

  def save_screenshot(path, **options); end

  def session=(session); end

  def session_options(); end

  def status_code(); end

  def switch_to_frame(frame); end

  def switch_to_window(handle); end

  def visit(path); end

  def wait?(); end

  def window_handles(); end

  def window_size(handle); end
end

class Capybara::Driver::Base
end

class Capybara::Driver::Node
  def ==(other); end

  def [](name); end

  def all_text(); end

  def checked?(); end

  def click(keys=T.unsafe(nil), **options); end

  def disabled?(); end

  def double_click(keys=T.unsafe(nil), **options); end

  def drag_to(element, **options); end

  def driver(); end

  def drop(*args); end

  def hover(); end

  def initial_cache(); end

  def initialize(driver, native, initial_cache=T.unsafe(nil)); end

  def multiple?(); end

  def native(); end

  def obscured?(); end

  def path(); end

  def readonly?(); end

  def rect(); end

  def right_click(keys=T.unsafe(nil), **options); end

  def scroll_by(x, y); end

  def scroll_to(element, alignment, position=T.unsafe(nil)); end

  def select_option(); end

  def selected?(); end

  def send_keys(*args); end

  def set(value, **options); end

  def style(styles); end

  def tag_name(); end

  def trigger(event); end

  def unselect_option(); end

  def value(); end

  def visible?(); end

  def visible_text(); end
end

class Capybara::Driver::Node
end

module Capybara::Driver
end

class Capybara::DriverNotFoundError
end

class Capybara::DriverNotFoundError
end

class Capybara::ElementNotFound
end

class Capybara::ElementNotFound
end

class Capybara::ExpectationNotMet
end

class Capybara::ExpectationNotMet
end

class Capybara::FileNotFound
end

class Capybara::FileNotFound
end

class Capybara::FrozenInTime
end

class Capybara::FrozenInTime
end

module Capybara::Helpers
end

class Capybara::Helpers::Timer
  def expired?(); end

  def initialize(expire_in); end

  def stalled?(); end
end

class Capybara::Helpers::Timer
end

module Capybara::Helpers
  def self.declension(singular, plural, count); end

  def self.inject_asset_host(html, host: T.unsafe(nil)); end

  def self.monotonic_time(); end

  def self.normalize_whitespace(text); end

  def self.timer(expire_in:); end

  def self.to_regexp(text, exact: T.unsafe(nil), all_whitespace: T.unsafe(nil), options: T.unsafe(nil)); end
end

class Capybara::InfiniteRedirectError
end

class Capybara::InfiniteRedirectError
end

module Capybara::Minitest
end

module Capybara::Minitest::Assertions
  def assert_all_of_selectors(*args, &optional_filter_block); end

  def assert_ancestor(*args, &optional_filter_block); end

  def assert_any_of_selectors(*args, &optional_filter_block); end

  def assert_button(*args, &optional_filter_block); end

  def assert_checked_field(*args, &optional_filter_block); end

  def assert_content(*args, **kwargs); end

  def assert_css(*args, &optional_filter_block); end

  def assert_current_path(*args, **kwargs); end

  def assert_field(*args, &optional_filter_block); end

  def assert_link(*args, &optional_filter_block); end

  def assert_matches_css(*args, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_matches_style(*args, &optional_filter_block); end

  def assert_matches_xpath(*args, &optional_filter_block); end

  def assert_no_ancestor(*args, &optional_filter_block); end

  def assert_no_button(*args, &optional_filter_block); end

  def assert_no_checked_field(*args, &optional_filter_block); end

  def assert_no_content(*args, **kwargs); end

  def assert_no_css(*args, &optional_filter_block); end

  def assert_no_current_path(*args, **kwargs); end

  def assert_no_field(*args, &optional_filter_block); end

  def assert_no_link(*args, &optional_filter_block); end

  def assert_no_select(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_sibling(*args, &optional_filter_block); end

  def assert_no_table(*args, &optional_filter_block); end

  def assert_no_text(*args, **kwargs); end

  def assert_no_title(*args, **kwargs); end

  def assert_no_unchecked_field(*args, &optional_filter_block); end

  def assert_no_xpath(*args, &optional_filter_block); end

  def assert_none_of_selectors(*args, &optional_filter_block); end

  def assert_not_matches_css(*args, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_not_matches_xpath(*args, &optional_filter_block); end

  def assert_select(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_sibling(*args, &optional_filter_block); end

  def assert_table(*args, &optional_filter_block); end

  def assert_text(*args, **kwargs); end

  def assert_title(*args, **kwargs); end

  def assert_unchecked_field(*args, &optional_filter_block); end

  def assert_xpath(*args, &optional_filter_block); end

  def refute_ancestor(*args, &optional_filter_block); end

  def refute_button(*args, &optional_filter_block); end

  def refute_checked_field(*args, &optional_filter_block); end

  def refute_content(*args, **kwargs); end

  def refute_css(*args, &optional_filter_block); end

  def refute_current_path(*args, **kwargs); end

  def refute_field(*args, &optional_filter_block); end

  def refute_link(*args, &optional_filter_block); end

  def refute_matches_css(*args, &optional_filter_block); end

  def refute_matches_selector(*args, &optional_filter_block); end

  def refute_matches_xpath(*args, &optional_filter_block); end

  def refute_select(*args, &optional_filter_block); end

  def refute_selector(*args, &optional_filter_block); end

  def refute_sibling(*args, &optional_filter_block); end

  def refute_table(*args, &optional_filter_block); end

  def refute_text(*args, **kwargs); end

  def refute_title(*args, **kwargs); end

  def refute_unchecked_field(*args, &optional_filter_block); end

  def refute_xpath(*args, &optional_filter_block); end
end

module Capybara::Minitest::Assertions
end

module Capybara::Minitest
end

class Capybara::ModalNotFound
end

class Capybara::ModalNotFound
end

module Capybara::Node
end

module Capybara::Node::Actions
  def attach_file(locator=T.unsafe(nil), paths, make_visible: T.unsafe(nil), **options); end

  def check(locator=T.unsafe(nil), **options); end

  def choose(locator=T.unsafe(nil), **options); end

  def click_button(locator=T.unsafe(nil), **options); end

  def click_link(locator=T.unsafe(nil), **options); end

  def click_link_or_button(locator=T.unsafe(nil), **options); end

  def click_on(locator=T.unsafe(nil), **options); end

  def fill_in(locator=T.unsafe(nil), with:, currently_with: T.unsafe(nil), fill_options: T.unsafe(nil), **find_options); end

  def select(value=T.unsafe(nil), from: T.unsafe(nil), **options); end

  def uncheck(locator=T.unsafe(nil), **options); end

  def unselect(value=T.unsafe(nil), from: T.unsafe(nil), **options); end
  CAPTURE_FILE_ELEMENT_SCRIPT = ::T.let(nil, ::T.untyped)
  DATALIST_OPTIONS_SCRIPT = ::T.let(nil, ::T.untyped)
  RESET_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
  UPDATE_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

module Capybara::Node::Actions
end

class Capybara::Node::Base
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Actions
  include ::Capybara::Node::Matchers
  def base(); end

  def catch_error?(error, errors=T.unsafe(nil)); end

  def driver(); end

  def find_css(css, **options); end

  def find_xpath(xpath, **options); end

  def initialize(session, base); end

  def query_scope(); end

  def reload(); end

  def session(); end

  def session_options(); end

  def synchronize(seconds=T.unsafe(nil), errors: T.unsafe(nil)); end

  def to_capybara_node(); end
end

class Capybara::Node::Base
end

class Capybara::Node::Document
  include ::Capybara::Node::DocumentMatchers
  def evaluate_script(*args); end

  def execute_script(*args); end

  def scroll_to(*args, **options); end

  def text(type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def title(); end
end

class Capybara::Node::Document
end

module Capybara::Node::DocumentMatchers
  def assert_no_title(title, **options); end

  def assert_title(title, **options); end

  def has_no_title?(title, **options); end

  def has_title?(title, **options); end
end

module Capybara::Node::DocumentMatchers
end

class Capybara::Node::Element
  def [](attribute); end

  def allow_reload!(idx=T.unsafe(nil)); end

  def checked?(); end

  def click(*keys, **options); end

  def disabled?(); end

  def double_click(*keys, **options); end

  def drag_to(node, **options); end

  def drop(*args); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def flash(); end

  def hover(); end

  def initial_cache(); end

  def initialize(session, base, query_scope, query); end

  def multiple?(); end

  def native(); end

  def obscured?(); end

  def path(); end

  def readonly?(); end

  def rect(); end

  def right_click(*keys, **options); end

  def scroll_to(pos_or_el_or_x, y=T.unsafe(nil), align: T.unsafe(nil), offset: T.unsafe(nil)); end

  def select_option(wait: T.unsafe(nil)); end

  def selected?(); end

  def send_keys(*args); end

  def set(value, **options); end

  def style(*styles); end

  def tag_name(); end

  def text(type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def trigger(event); end

  def unselect_option(wait: T.unsafe(nil)); end

  def value(); end

  def visible?(); end
  STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Element
end

module Capybara::Node::Finders
  def all(*args, allow_reload: T.unsafe(nil), **options, &optional_filter_block); end

  def ancestor(*args, **options, &optional_filter_block); end

  def find(*args, **options, &optional_filter_block); end

  def find_all(*args, allow_reload: T.unsafe(nil), **options, &optional_filter_block); end

  def find_button(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def find_by_id(id, **options, &optional_filter_block); end

  def find_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def find_link(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def first(*args, **options, &optional_filter_block); end

  def sibling(*args, **options, &optional_filter_block); end
end

module Capybara::Node::Finders
end

module Capybara::Node::Matchers
  def ==(other); end

  def assert_all_of_selectors(*args, **options, &optional_filter_block); end

  def assert_ancestor(*args, &optional_filter_block); end

  def assert_any_of_selectors(*args, wait: T.unsafe(nil), **options, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_matches_style(styles, **options); end

  def assert_no_ancestor(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_sibling(*args, &optional_filter_block); end

  def assert_no_text(type_or_text, *args, **opts); end

  def assert_none_of_selectors(*args, **options, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_sibling(*args, &optional_filter_block); end

  def assert_style(styles, **options); end

  def assert_text(type_or_text, *args, **opts); end

  def has_ancestor?(*args, **options, &optional_filter_block); end

  def has_button?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_checked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_content?(*args, **options); end

  def has_css?(path, **options, &optional_filter_block); end

  def has_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_link?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_ancestor?(*args, **options, &optional_filter_block); end

  def has_no_button?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_checked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_content?(*args, **options); end

  def has_no_css?(path, **options, &optional_filter_block); end

  def has_no_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_link?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_select?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_selector?(*args, **options, &optional_filter_block); end

  def has_no_sibling?(*args, **options, &optional_filter_block); end

  def has_no_table?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_text?(*args, **options); end

  def has_no_unchecked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_xpath?(path, **options, &optional_filter_block); end

  def has_select?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_selector?(*args, **options, &optional_filter_block); end

  def has_sibling?(*args, **options, &optional_filter_block); end

  def has_style?(styles, **options); end

  def has_table?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_text?(*args, **options); end

  def has_unchecked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_xpath?(path, **options, &optional_filter_block); end

  def matches_css?(css, **options, &optional_filter_block); end

  def matches_selector?(*args, **options, &optional_filter_block); end

  def matches_style?(styles, **options); end

  def matches_xpath?(xpath, **options, &optional_filter_block); end

  def not_matches_css?(css, **options, &optional_filter_block); end

  def not_matches_selector?(*args, **options, &optional_filter_block); end

  def not_matches_xpath?(xpath, **options, &optional_filter_block); end
end

module Capybara::Node::Matchers
end

class Capybara::Node::Simple
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Matchers
  include ::Capybara::Node::DocumentMatchers
  def [](name); end

  def allow_reload!(*_); end

  def checked?(); end

  def disabled?(); end

  def find_css(css, **_options); end

  def find_xpath(xpath, **_options); end

  def initial_cache(); end

  def initialize(native); end

  def multiple?(); end

  def native(); end

  def path(); end

  def selected?(); end

  def session_options(); end

  def synchronize(_seconds=T.unsafe(nil)); end

  def tag_name(); end

  def text(_type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def title(); end

  def value(); end

  def visible?(check_ancestors=T.unsafe(nil)); end
  VISIBILITY_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Simple
end

module Capybara::Node
end

class Capybara::NotSupportedByDriverError
end

class Capybara::NotSupportedByDriverError
end

module Capybara::Queries
end

class Capybara::Queries::AncestorQuery
  def description(applied=T.unsafe(nil)); end
end

class Capybara::Queries::AncestorQuery
end

class Capybara::Queries::BaseQuery
  def expects_none?(); end

  def failure_message(); end

  def initialize(options); end

  def matches_count?(count); end

  def negative_failure_message(); end

  def options(); end

  def session_options(); end

  def session_options=(session_options); end

  def wait(); end
  COUNT_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::BaseQuery
  def self.wait(options, default=T.unsafe(nil)); end
end

class Capybara::Queries::CurrentPathQuery
  def initialize(expected_path, **options); end

  def resolves_for?(session); end
end

class Capybara::Queries::CurrentPathQuery
end

class Capybara::Queries::MatchQuery
end

class Capybara::Queries::MatchQuery
end

class Capybara::Queries::SelectorQuery
  def applied_description(); end

  def css(); end

  def description(only_applied=T.unsafe(nil)); end

  def exact?(); end

  def expression(); end

  def initialize(*args, session_options:, enable_aria_label: T.unsafe(nil), enable_aria_role: T.unsafe(nil), test_id: T.unsafe(nil), selector_format: T.unsafe(nil), order: T.unsafe(nil), **options, &filter_block); end

  def label(); end

  def locator(); end

  def match(); end

  def matches_filters?(node, node_filter_errors=T.unsafe(nil)); end

  def name(); end

  def resolve_for(node, exact=T.unsafe(nil)); end

  def selector(); end

  def supports_exact?(); end

  def visible(); end

  def xpath(exact=T.unsafe(nil)); end
  SPATIAL_KEYS = ::T.let(nil, ::T.untyped)
  VALID_KEYS = ::T.let(nil, ::T.untyped)
  VALID_MATCH = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::SelectorQuery
end

class Capybara::Queries::SiblingQuery
  def description(applied=T.unsafe(nil)); end
end

class Capybara::Queries::SiblingQuery
end

class Capybara::Queries::StyleQuery
  def initialize(expected_styles, session_options:, **options); end

  def resolves_for?(node); end
end

class Capybara::Queries::StyleQuery
end

class Capybara::Queries::TextQuery
  def description(); end

  def initialize(type=T.unsafe(nil), expected_text, session_options:, **options); end

  def resolve_for(node); end
end

class Capybara::Queries::TextQuery
end

class Capybara::Queries::TitleQuery
  def initialize(expected_title, **options); end

  def resolves_for?(node); end
end

class Capybara::Queries::TitleQuery
end

module Capybara::Queries
end

module Capybara::RackTest
end

class Capybara::RackTest::Browser
  include ::Rack::Test::Methods
  def app(); end

  def build_uri(path); end

  def current_host(); end

  def current_host=(current_host); end

  def current_url(); end

  def dom(); end

  def driver(); end

  def find(format, selector); end

  def follow(method, path, **attributes); end

  def html(); end

  def initialize(driver); end

  def options(); end

  def process(method, path, attributes=T.unsafe(nil), env=T.unsafe(nil)); end

  def process_and_follow_redirects(method, path, attributes=T.unsafe(nil), env=T.unsafe(nil)); end

  def refresh(); end

  def request_path(); end

  def reset_cache!(); end

  def reset_host!(); end

  def submit(method, path, attributes); end

  def title(); end

  def visit(path, **attributes); end
end

class Capybara::RackTest::Browser
end

class Capybara::RackTest::CSSHandlers
  include ::Kernel
  def disabled(list); end

  def enabled(list); end
end

class Capybara::RackTest::CSSHandlers
end

class Capybara::RackTest::Driver
  def app(); end

  def browser(); end

  def delete(*args, &block); end

  def dom(); end

  def find_css(selector); end

  def find_xpath(selector); end

  def follow(method, path, **attributes); end

  def follow_redirects?(); end

  def get(*args, &block); end

  def header(key, value); end

  def initialize(app, **options); end

  def options(); end

  def post(*args, &block); end

  def put(*args, &block); end

  def redirect_limit(); end

  def request(); end

  def response(); end

  def submit(method, path, attributes); end

  def title(); end

  def visit(path, **attributes); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Driver
end

module Capybara::RackTest::Errors
end

class Capybara::RackTest::Errors::StaleElementReferenceError
end

class Capybara::RackTest::Errors::StaleElementReferenceError
end

module Capybara::RackTest::Errors
end

class Capybara::RackTest::Form
  def multipart?(); end

  def params(button); end

  def submit(button); end
end

class Capybara::RackTest::Form::NilUploadedFile
  def initialize(); end

  def read(); end

  def size(); end
end

class Capybara::RackTest::Form::NilUploadedFile
end

class Capybara::RackTest::Form::ParamsHash
  def to_params_hash(); end
end

class Capybara::RackTest::Form::ParamsHash
end

class Capybara::RackTest::Form
end

class Capybara::RackTest::Node
  def [](*args); end

  def all_text(*args); end

  def checkbox?(); end

  def checkbox_or_radio?(field=T.unsafe(nil)); end

  def checked?(*args); end

  def click(*args); end

  def disabled?(*args); end

  def displayed_text(check_ancestor: T.unsafe(nil)); end

  def find_css(*args); end

  def find_xpath(*args); end

  def input_field?(); end

  def path(*args); end

  def radio?(); end

  def range?(); end

  def select_option(*args); end

  def selected?(*args); end

  def set(*args); end

  def style(*args); end

  def tag_name(*args); end

  def text_or_password?(); end

  def textarea?(); end

  def unselect_option(*args); end

  def value(*args); end

  def visible?(*args); end

  def visible_text(*args); end
  BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  DISABLED_BY_FIELDSET_XPATH = ::T.let(nil, ::T.untyped)
  OPTION_OWNER_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Node
end

module Capybara::RackTest
end

class Capybara::ReadOnlyElementError
end

class Capybara::ReadOnlyElementError
end

class Capybara::ReadOnlySessionConfig
  def always_include_port=(_); end

  def app_host=(_); end

  def asset_host=(_); end

  def automatic_label_click=(_); end

  def automatic_reload=(_); end

  def default_host=(_); end

  def default_max_wait_time=(_); end

  def default_normalize_ws=(_); end

  def default_selector=(_); end

  def default_set_options=(_); end

  def disable_animation=(_); end

  def enable_aria_label=(_); end

  def enable_aria_role=(_); end

  def exact=(_); end

  def exact_text=(_); end

  def ignore_hidden_elements=(_); end

  def match=(_); end

  def predicates_wait=(_); end

  def raise_server_errors=(_); end

  def run_server=(_); end

  def save_path=(_); end

  def server_errors=(_); end

  def server_host=(_); end

  def server_port=(_); end

  def test_id=(_); end

  def visible_text_only=(_); end

  def w3c_click_offset=(_); end
end

class Capybara::ReadOnlySessionConfig
end

class Capybara::RegistrationContainer
  def [](name); end

  def []=(name, value); end

  def method_missing(method_name, *args, **options, &block); end

  def names(); end
end

class Capybara::RegistrationContainer
end

class Capybara::Result
  include ::Enumerable
  def [](*args); end

  def allow_reload!(); end

  def at(*args); end

  def compare_count(); end

  def each(&block); end

  def empty?(); end

  def failure_message(); end

  def index(*_); end

  def initialize(elements, query); end

  def inspect(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def matches_count?(); end

  def negative_failure_message(); end

  def sample(*args, &block); end

  def size(*args, &block); end

  def unfiltered_size(); end

  def values_at(*args, &block); end
end

class Capybara::Result
  extend ::Forwardable
end

class Capybara::ScopeError
end

class Capybara::ScopeError
end

class Capybara::Selector
  def add_error(error_msg); end

  def builder(expr=T.unsafe(nil)); end

  def call(locator, **options); end

  def current_format(); end

  def enable_aria_label(); end

  def enable_aria_role(); end

  def errors(); end

  def expression_for(name, locator, config: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def format(); end

  def initialize(definition, config:, format:); end

  def test_id(); end

  def with_filter_errors(errors); end
end

class Capybara::Selector::CSS
  ESCAPE = ::T.let(nil, ::T.untyped)
  H = ::T.let(nil, ::T.untyped)
  NMSTART = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector::CSS::Splitter
  def split(css); end
end

class Capybara::Selector::CSS::Splitter
end

class Capybara::Selector::CSS
  def self.escape(str); end

  def self.escape_char(char); end

  def self.split(css); end
end

class Capybara::Selector::CSSBuilder
  def add_attribute_conditions(**attributes); end

  def expression(); end

  def initialize(expression); end
end

class Capybara::Selector::CSSBuilder
end

class Capybara::Selector::Definition
  def css(*allowed_filters, &block); end

  def custom_filters(); end

  def default_format(); end

  def default_visibility(fallback=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe(*args, &block); end

  def describe_all_expression_filters(**opts); end

  def describe_expression_filters(&block); end

  def describe_node_filters(&block); end

  def description(*args, &block); end

  def expression_filter(*args, &block); end

  def expression_filters(); end

  def expressions(); end

  def filter(*args, &block); end

  def filter_set(name, filters_to_use=T.unsafe(nil)); end

  def initialize(name, locator_type: T.unsafe(nil), raw_locator: T.unsafe(nil), supports_exact: T.unsafe(nil), &block); end

  def label(label=T.unsafe(nil)); end

  def locator_filter(*types, **options, &block); end

  def locator_types(); end

  def match(&block); end

  def match?(locator); end

  def name(); end

  def node_filter(*args, &block); end

  def node_filters(); end

  def raw_locator?(); end

  def supports_exact?(); end

  def visible(default_visibility=T.unsafe(nil), &block); end

  def xpath(*allowed_filters, &block); end
end

class Capybara::Selector::Definition
  extend ::Forwardable
end

class Capybara::Selector::FilterSet
  def describe(what=T.unsafe(nil), &block); end

  def description(node_filters: T.unsafe(nil), expression_filters: T.unsafe(nil), **options); end

  def descriptions(); end

  def expression_filter(name, *types, **options, &block); end

  def expression_filter_descriptions(); end

  def expression_filters(); end

  def filter(names, *types, **options, &block); end

  def import(name, filters=T.unsafe(nil)); end

  def initialize(name, &block); end

  def node_filter(names, *types, **options, &block); end

  def node_filter_descriptions(); end

  def node_filters(); end

  def undeclared_descriptions(); end
end

class Capybara::Selector::FilterSet
  def self.[](name); end

  def self.add(name, &block); end

  def self.all(); end

  def self.remove(name); end
end

module Capybara::Selector::Filters
end

class Capybara::Selector::Filters::Base
  def boolean?(); end

  def default(); end

  def default?(); end

  def format(); end

  def handles_option?(option_name); end

  def initialize(name, matcher, block, **options); end

  def matcher?(); end

  def skip?(value); end
end

class Capybara::Selector::Filters::Base
end

class Capybara::Selector::Filters::ExpressionFilter
  def apply_filter(expr, name, value, selector); end
end

class Capybara::Selector::Filters::ExpressionFilter
end

class Capybara::Selector::Filters::IdentityExpressionFilter
  def apply_filter(expr, _name, _value, _ctx); end

  def initialize(name); end
end

class Capybara::Selector::Filters::IdentityExpressionFilter
end

class Capybara::Selector::Filters::LocatorFilter
  def initialize(block, **options); end

  def matches?(node, value, context=T.unsafe(nil), exact:); end
end

class Capybara::Selector::Filters::LocatorFilter
end

class Capybara::Selector::Filters::NodeFilter
  def matches?(node, name, value, context=T.unsafe(nil)); end
end

class Capybara::Selector::Filters::NodeFilter
end

module Capybara::Selector::Filters
end

class Capybara::Selector::RegexpDisassembler
  def alternated_substrings(); end

  def initialize(regexp); end

  def substrings(); end
end

class Capybara::Selector::RegexpDisassembler
end

class Capybara::Selector::XPathBuilder
  def add_attribute_conditions(**conditions); end

  def expression(); end

  def initialize(expression); end
end

class Capybara::Selector::XPathBuilder
end

class Capybara::Selector
  def self.[](name); end

  def self.add(name, **options, &block); end

  def self.all(); end

  def self.for(locator); end

  def self.remove(name); end

  def self.update(name, &block); end
end

module Capybara::Selenium
end

module Capybara::Selenium::ChromeLogs
  def available_log_types(); end

  def commands(command); end

  def log(type); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  LOG_MSG = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::ChromeLogs
end

class Capybara::Selenium::ChromeNode
  include ::Capybara::Selenium::Node::Html5Drag
  include ::Capybara::Selenium::Node::FileInputClickEmulation
  def click(*_, **_1); end

  def drop(*args); end

  def set_text(value, clear: T.unsafe(nil), **_unused); end
end

class Capybara::Selenium::ChromeNode
end

class Capybara::Selenium::Driver
  include ::Capybara::Selenium::Find
  def accept_modal(_type, **options); end

  def app(); end

  def browser(); end

  def dismiss_modal(_type, **options); end

  def frame_obscured_at?(x:, y:); end

  def initialize(app, **options); end

  def open_new_window(kind=T.unsafe(nil)); end

  def options(); end

  def quit(); end

  def save_screenshot(path, **_options); end

  def title(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  SPECIAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Driver::ChromeDriver
  def fullscreen_window(handle); end

  def reset!(); end

  def resize_window_to(handle, width, height); end
end

module Capybara::Selenium::Driver::ChromeDriver
  def self.extended(base); end
end

module Capybara::Selenium::Driver::EdgeDriver
  def download_path=(path); end

  def fullscreen_window(handle); end

  def reset!(); end

  def resize_window_to(handle, width, height); end
end

module Capybara::Selenium::Driver::EdgeDriver
  def self.extended(base); end
end

module Capybara::Selenium::Driver::FirefoxDriver
end

module Capybara::Selenium::Driver::FirefoxDriver
  def self.extended(driver); end

  def self.w3c?(driver); end
end

module Capybara::Selenium::Driver::InternetExplorerDriver
  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::InternetExplorerDriver
end

module Capybara::Selenium::Driver::SafariDriver
  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::SafariDriver
end

module Capybara::Selenium::Driver::W3CFirefoxDriver
  def refresh(); end

  def reset!(); end

  def resize_window_to(handle, width, height); end

  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::W3CFirefoxDriver
  def self.extended(driver); end

  def self.pause_broken?(sel_driver); end
end

class Capybara::Selenium::Driver
  def self.load_selenium(); end

  def self.register_specialization(browser_name, specialization); end

  def self.specializations(); end
end

class Capybara::Selenium::EdgeNode
  include ::Capybara::Selenium::Node::Html5Drag
  def click(*_); end

  def drop(*args); end

  def set_text(value, clear: T.unsafe(nil), **_unused); end
end

class Capybara::Selenium::EdgeNode
end

module Capybara::Selenium::Find
  def find_css(selector, uses_visibility: T.unsafe(nil), texts: T.unsafe(nil), styles: T.unsafe(nil), position: T.unsafe(nil), **_options); end

  def find_xpath(selector, uses_visibility: T.unsafe(nil), styles: T.unsafe(nil), position: T.unsafe(nil), **_options); end
end

module Capybara::Selenium::Find
end

class Capybara::Selenium::FirefoxNode
  include ::Capybara::Selenium::Node::Html5Drag
  include ::Capybara::Selenium::Node::FileInputClickEmulation
  def drop(*args); end
end

class Capybara::Selenium::FirefoxNode
end

class Capybara::Selenium::IENode
end

class Capybara::Selenium::IENode
end

class Capybara::Selenium::Node
  include ::Capybara::Selenium::Find
  include ::Capybara::Selenium::Scroll
  def content_editable?(); end

  def drag_to(element, drop_modifiers: T.unsafe(nil), **_); end

  def drop(*_); end

  def obscured?(x: T.unsafe(nil), y: T.unsafe(nil)); end

  def scroll_if_needed(); end

  def scroll_to_center(); end
  GET_XPATH_SCRIPT = ::T.let(nil, ::T.untyped)
  OBSCURED_OR_OFFSET_SCRIPT = ::T.let(nil, ::T.untyped)
  RAPID_APPEND_TEXT = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Node::FileInputClickEmulation
  def click(keys=T.unsafe(nil), **options); end
end

module Capybara::Selenium::Node::FileInputClickEmulation
end

module Capybara::Selenium::Node::Html5Drag
  def drag_to(element, html5: T.unsafe(nil), delay: T.unsafe(nil), drop_modifiers: T.unsafe(nil)); end
  ATTACH_FILE = ::T.let(nil, ::T.untyped)
  DROP_FILE = ::T.let(nil, ::T.untyped)
  DROP_STRING = ::T.let(nil, ::T.untyped)
  HTML5_DRAG_DROP_SCRIPT = ::T.let(nil, ::T.untyped)
  LEGACY_DRAG_CHECK = ::T.let(nil, ::T.untyped)
  MOUSEDOWN_TRACKER = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Node::Html5Drag
end

class Capybara::Selenium::Node::ModifierKeysStack
  def include?(key); end

  def pop(); end

  def press(key); end

  def push(); end
end

class Capybara::Selenium::Node::ModifierKeysStack
end

class Capybara::Selenium::Node
end

class Capybara::Selenium::SafariNode
  def set_text(value, clear: T.unsafe(nil), **_unused); end
  MODIFIER_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::SafariNode
end

module Capybara::Selenium::Scroll
  def scroll_by(x, y); end

  def scroll_to(element, location, position=T.unsafe(nil)); end
end

module Capybara::Selenium::Scroll
end

module Capybara::Selenium
end

class Capybara::Server
  def app(); end

  def base_url(); end

  def boot(); end

  def error(); end

  def host(); end

  def initialize(app, *deprecated_options, port: T.unsafe(nil), host: T.unsafe(nil), reportable_errors: T.unsafe(nil), extra_middleware: T.unsafe(nil)); end

  def port(); end

  def reset_error!(); end

  def responsive?(); end

  def using_ssl?(); end

  def wait_for_pending_requests(); end
end

class Capybara::Server::AnimationDisabler
  def call(env); end

  def initialize(app); end
  DISABLE_MARKUP_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::AnimationDisabler
  def self.selector_for(css_or_bool); end
end

class Capybara::Server::Checker
  def initialize(host, port); end

  def request(&block); end

  def ssl?(); end
  TRY_HTTPS_ERRORS = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::Checker
end

class Capybara::Server::Middleware
  def call(env); end

  def clear_error(); end

  def error(); end

  def initialize(app, server_errors, extra_middleware=T.unsafe(nil)); end

  def pending_requests(); end

  def pending_requests?(); end
end

class Capybara::Server::Middleware::Counter
  def decrement(uri); end

  def increment(uri); end

  def positive?(); end

  def value(); end
end

class Capybara::Server::Middleware::Counter
end

class Capybara::Server::Middleware
end

class Capybara::Server
  def self.ports(); end
end

class Capybara::Session
  include ::Capybara::SessionMatchers
  def accept_alert(text=T.unsafe(nil), **options, &blk); end

  def accept_confirm(text=T.unsafe(nil), **options, &blk); end

  def accept_prompt(text=T.unsafe(nil), **options, &blk); end

  def all(*args, &block); end

  def app(); end

  def assert_all_of_selectors(*args, &block); end

  def assert_any_of_selectors(*args, &block); end

  def assert_no_selector(*args, &block); end

  def assert_no_text(*args, &block); end

  def assert_no_title(*args, &block); end

  def assert_none_of_selectors(*args, &block); end

  def assert_selector(*args, &block); end

  def assert_text(*args, &block); end

  def assert_title(*args, &block); end

  def attach_file(*args, &block); end

  def body(); end

  def check(*args, &block); end

  def choose(*args, &block); end

  def cleanup!(); end

  def click_button(*args, &block); end

  def click_link(*args, &block); end

  def click_link_or_button(*args, &block); end

  def click_on(*args, &block); end

  def config(); end

  def configure(); end

  def current_host(); end

  def current_path(); end

  def current_scope(); end

  def current_url(); end

  def current_window(); end

  def dismiss_confirm(text=T.unsafe(nil), **options, &blk); end

  def dismiss_prompt(text=T.unsafe(nil), **options, &blk); end

  def document(); end

  def driver(); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def fill_in(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_button(*args, &block); end

  def find_by_id(*args, &block); end

  def find_field(*args, &block); end

  def find_link(*args, &block); end

  def first(*args, &block); end

  def go_back(); end

  def go_forward(); end

  def has_button?(*args, &block); end

  def has_checked_field?(*args, &block); end

  def has_content?(*args, &block); end

  def has_css?(*args, &block); end

  def has_field?(*args, &block); end

  def has_link?(*args, &block); end

  def has_no_button?(*args, &block); end

  def has_no_checked_field?(*args, &block); end

  def has_no_content?(*args, &block); end

  def has_no_css?(*args, &block); end

  def has_no_field?(*args, &block); end

  def has_no_link?(*args, &block); end

  def has_no_select?(*args, &block); end

  def has_no_selector?(*args, &block); end

  def has_no_table?(*args, &block); end

  def has_no_text?(*args, &block); end

  def has_no_title?(*args, &block); end

  def has_no_unchecked_field?(*args, &block); end

  def has_no_xpath?(*args, &block); end

  def has_select?(*args, &block); end

  def has_selector?(*args, &block); end

  def has_table?(*args, &block); end

  def has_text?(*args, &block); end

  def has_title?(*args, &block); end

  def has_unchecked_field?(*args, &block); end

  def has_xpath?(*args, &block); end

  def html(); end

  def initialize(mode, app=T.unsafe(nil)); end

  def mode(); end

  def open_new_window(kind=T.unsafe(nil)); end

  def query(*args, &block); end

  def quit(); end

  def raise_server_error!(); end

  def refresh(); end

  def refute_selector(*args, &block); end

  def reset!(); end

  def reset_session!(); end

  def response_headers(); end

  def save_and_open_page(path=T.unsafe(nil)); end

  def save_and_open_screenshot(path=T.unsafe(nil), **options); end

  def save_page(path=T.unsafe(nil)); end

  def save_screenshot(path=T.unsafe(nil), **options); end

  def scroll_by(*args, &block); end

  def scroll_to(*args, &block); end

  def select(*args, &block); end

  def server(); end

  def server_url(); end

  def source(); end

  def status_code(); end

  def switch_to_frame(frame); end

  def switch_to_window(window=T.unsafe(nil), **options, &window_locator); end

  def synchronized(); end

  def synchronized=(synchronized); end

  def text(*args, &block); end

  def title(*args, &block); end

  def uncheck(*args, &block); end

  def unselect(*args, &block); end

  def using_wait_time(seconds); end

  def visit(visit_uri); end

  def window_opened_by(**options); end

  def windows(); end

  def within(*args, **kw_args); end

  def within_element(*args, **kw_args); end

  def within_fieldset(locator); end

  def within_frame(*args, **kw_args); end

  def within_table(locator); end

  def within_window(window_or_proc); end
  DOCUMENT_METHODS = ::T.let(nil, ::T.untyped)
  DSL_METHODS = ::T.let(nil, ::T.untyped)
  MODAL_METHODS = ::T.let(nil, ::T.untyped)
  NODE_METHODS = ::T.let(nil, ::T.untyped)
  SESSION_METHODS = ::T.let(nil, ::T.untyped)
end

class Capybara::Session
  def self.instance_created?(); end
end

class Capybara::SessionConfig
  def always_include_port(); end

  def always_include_port=(always_include_port); end

  def app_host(); end

  def app_host=(url); end

  def asset_host(); end

  def asset_host=(asset_host); end

  def automatic_label_click(); end

  def automatic_label_click=(automatic_label_click); end

  def automatic_reload(); end

  def automatic_reload=(automatic_reload); end

  def default_host(); end

  def default_host=(url); end

  def default_max_wait_time(); end

  def default_max_wait_time=(default_max_wait_time); end

  def default_normalize_ws(); end

  def default_normalize_ws=(default_normalize_ws); end

  def default_selector(); end

  def default_selector=(default_selector); end

  def default_set_options(); end

  def default_set_options=(default_set_options); end

  def disable_animation(); end

  def disable_animation=(disable_animation); end

  def enable_aria_label(); end

  def enable_aria_label=(enable_aria_label); end

  def enable_aria_role(); end

  def enable_aria_role=(enable_aria_role); end

  def exact(); end

  def exact=(exact); end

  def exact_text(); end

  def exact_text=(exact_text); end

  def ignore_hidden_elements(); end

  def ignore_hidden_elements=(ignore_hidden_elements); end

  def match(); end

  def match=(match); end

  def predicates_wait(); end

  def predicates_wait=(predicates_wait); end

  def raise_server_errors(); end

  def raise_server_errors=(raise_server_errors); end

  def run_server(); end

  def run_server=(run_server); end

  def save_path(); end

  def save_path=(save_path); end

  def server_errors(); end

  def server_errors=(errors); end

  def server_host(); end

  def server_host=(server_host); end

  def server_port(); end

  def server_port=(server_port); end

  def test_id(); end

  def test_id=(id); end

  def visible_text_only(); end

  def visible_text_only=(visible_text_only); end

  def w3c_click_offset(); end

  def w3c_click_offset=(w3c_click_offset); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::SessionConfig
end

module Capybara::SessionMatchers
  def assert_current_path(path, **options); end

  def assert_no_current_path(path, **options); end

  def has_current_path?(path, **options); end

  def has_no_current_path?(path, **options); end
end

module Capybara::SessionMatchers
end

class Capybara::UnselectNotAllowed
end

class Capybara::UnselectNotAllowed
end

class Capybara::Window
  def ==(other); end

  def close(); end

  def closed?(); end

  def current?(); end

  def eql?(other); end

  def exists?(); end

  def fullscreen(); end

  def handle(); end

  def initialize(session, handle); end

  def maximize(); end

  def resize_to(width, height); end

  def session(); end

  def size(); end
end

class Capybara::Window
end

class Capybara::WindowError
end

class Capybara::WindowError
end

module Capybara
  extend ::Capybara::DSL
  def self.HTML(html); end

  def self.add_selector(name, **options, &block); end

  def self.allow_gumbo(*args, &block); end

  def self.allow_gumbo=(*args, &block); end

  def self.always_include_port(*args, &block); end

  def self.always_include_port=(*args, &block); end

  def self.app(*args, &block); end

  def self.app=(*args, &block); end

  def self.app_host(*args, &block); end

  def self.app_host=(*args, &block); end

  def self.asset_host(*args, &block); end

  def self.asset_host=(*args, &block); end

  def self.automatic_label_click(*args, &block); end

  def self.automatic_label_click=(*args, &block); end

  def self.automatic_reload(*args, &block); end

  def self.automatic_reload=(*args, &block); end

  def self.configure(); end

  def self.current_driver(); end

  def self.current_driver=(name); end

  def self.current_session(); end

  def self.default_driver(*args, &block); end

  def self.default_driver=(*args, &block); end

  def self.default_host(*args, &block); end

  def self.default_host=(*args, &block); end

  def self.default_max_wait_time(*args, &block); end

  def self.default_max_wait_time=(*args, &block); end

  def self.default_normalize_ws(*args, &block); end

  def self.default_normalize_ws=(*args, &block); end

  def self.default_selector(*args, &block); end

  def self.default_selector=(*args, &block); end

  def self.default_set_options(*args, &block); end

  def self.default_set_options=(*args, &block); end

  def self.disable_animation(*args, &block); end

  def self.disable_animation=(*args, &block); end

  def self.drivers(); end

  def self.enable_aria_label(*args, &block); end

  def self.enable_aria_label=(*args, &block); end

  def self.enable_aria_role(*args, &block); end

  def self.enable_aria_role=(*args, &block); end

  def self.exact(*args, &block); end

  def self.exact=(*args, &block); end

  def self.exact_text(*args, &block); end

  def self.exact_text=(*args, &block); end

  def self.ignore_hidden_elements(*args, &block); end

  def self.ignore_hidden_elements=(*args, &block); end

  def self.javascript_driver(*args, &block); end

  def self.javascript_driver=(*args, &block); end

  def self.match(*args, &block); end

  def self.match=(*args, &block); end

  def self.mode(); end

  def self.modify_selector(name, &block); end

  def self.predicates_wait(*args, &block); end

  def self.predicates_wait=(*args, &block); end

  def self.raise_server_errors(*args, &block); end

  def self.raise_server_errors=(*args, &block); end

  def self.register_driver(name, &block); end

  def self.register_server(name, &block); end

  def self.reset!(); end

  def self.reset_sessions!(); end

  def self.reuse_server(*args, &block); end

  def self.reuse_server=(*args, &block); end

  def self.run_default_server(app, port); end

  def self.run_server(*args, &block); end

  def self.run_server=(*args, &block); end

  def self.save_path(*args, &block); end

  def self.save_path=(*args, &block); end

  def self.server(*args, &block); end

  def self.server=(*args, &block); end

  def self.server_errors(*args, &block); end

  def self.server_errors=(*args, &block); end

  def self.server_host(*args, &block); end

  def self.server_host=(*args, &block); end

  def self.server_port(*args, &block); end

  def self.server_port=(*args, &block); end

  def self.servers(); end

  def self.session_name(); end

  def self.session_name=(name); end

  def self.session_options(); end

  def self.string(html); end

  def self.test_id(*args, &block); end

  def self.test_id=(*args, &block); end

  def self.threadsafe(*args, &block); end

  def self.threadsafe=(*args, &block); end

  def self.use_default_driver(); end

  def self.using_driver(driver); end

  def self.using_wait_time(seconds); end

  def self.visible_text_only(*args, &block); end

  def self.visible_text_only=(*args, &block); end

  def self.w3c_click_offset(*args, &block); end

  def self.w3c_click_offset=(*args, &block); end
end

module ChildProcess
  VERSION = ::T.let(nil, ::T.untyped)
end

class ChildProcess::AbstractIO
  def _stdin=(io); end

  def inherit!(); end

  def stderr(); end

  def stderr=(io); end

  def stdin(); end

  def stdout(); end

  def stdout=(io); end
end

class ChildProcess::AbstractIO
end

class ChildProcess::AbstractProcess
  def alive?(); end

  def crashed?(); end

  def cwd(); end

  def cwd=(cwd); end

  def detach(); end

  def detach=(detach); end

  def duplex(); end

  def duplex=(duplex); end

  def environment(); end

  def exit_code(); end

  def exited?(); end

  def initialize(args); end

  def io(); end

  def leader(); end

  def leader=(leader); end

  def pid(); end

  def poll_for_exit(timeout); end

  def start(); end

  def started?(); end

  def stop(timeout=T.unsafe(nil)); end

  def wait(); end
  POLL_INTERVAL = ::T.let(nil, ::T.untyped)
end

class ChildProcess::AbstractProcess
end

class ChildProcess::Error
end

class ChildProcess::Error
end

class ChildProcess::InvalidEnvironmentVariable
end

class ChildProcess::InvalidEnvironmentVariable
end

class ChildProcess::LaunchError
end

class ChildProcess::LaunchError
end

class ChildProcess::MissingFFIError
  def initialize(); end
end

class ChildProcess::MissingFFIError
end

class ChildProcess::MissingPlatformError
  def initialize(); end
end

class ChildProcess::MissingPlatformError
end

class ChildProcess::SubclassResponsibility
end

class ChildProcess::SubclassResponsibility
end

class ChildProcess::TimeoutError
end

class ChildProcess::TimeoutError
end

module ChildProcess::Unix
end

class ChildProcess::Unix::ForkExecProcess
end

class ChildProcess::Unix::ForkExecProcess
end

class ChildProcess::Unix::IO
end

class ChildProcess::Unix::IO
end

class ChildProcess::Unix::Process
end

class ChildProcess::Unix::Process
end

module ChildProcess::Unix
end

module ChildProcess
  def self.arch(); end

  def self.build(*args); end

  def self.close_on_exec(file); end

  def self.jruby?(); end

  def self.linux?(); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.new(*args); end

  def self.os(); end

  def self.platform(); end

  def self.platform_name(); end

  def self.posix_spawn=(bool); end

  def self.posix_spawn?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class Class
  def any_instance(); end

  def class_attribute(*attrs, instance_accessor: T.unsafe(nil), instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_predicate: T.unsafe(nil), default: T.unsafe(nil)); end

  def descendants(); end

  def json_creatable?(); end

  def subclasses(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*_); end
end

module CodeRay::Encoders
end

class CodeRay::Encoders::Encoder
  def <<(token); end

  def begin_group(kind); end

  def begin_line(kind); end

  def compile(tokens, options=T.unsafe(nil)); end

  def encode(code, lang, options=T.unsafe(nil)); end

  def encode_tokens(tokens, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def file_extension(); end

  def finish(options); end

  def get_output(options); end

  def highlight(code, lang, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output(data); end

  def scanner(); end

  def scanner=(scanner); end

  def setup(options); end

  def text_token(text, kind); end

  def token(content, kind); end

  def tokens(tokens, options=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Encoder
  extend ::CodeRay::Plugin
  def self.const_missing(sym); end

  def self.file_extension(); end
end

class CodeRay::Encoders::HTML
  def break_lines(text, style); end

  def check_group_nesting(name, kind); end

  def check_options!(options); end

  def close_span(); end

  def css(); end

  def css_class_for_kinds(kinds); end

  def make_span_for_kinds(method, hint); end

  def style_for_kinds(kinds); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_EXTENSION = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
  TOKEN_KIND_TO_INFO = ::T.let(nil, ::T.untyped)
  TRANSPARENT_TOKEN_KINDS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def get_style_for_css_classes(css_classes); end

  def initialize(style=T.unsafe(nil)); end

  def stylesheet(); end
  CSS_CLASS_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def self.load_stylesheet(style=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Numbering
end

module CodeRay::Encoders::HTML::Numbering
  def self.number!(output, mode=T.unsafe(nil), options=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Output
  def apply_title!(title); end

  def css(); end

  def css=(css); end

  def stylesheet(in_tag=T.unsafe(nil)); end

  def wrap!(element, *args); end

  def wrap_in!(template); end

  def wrapped_in(); end

  def wrapped_in=(wrapped_in); end

  def wrapped_in?(element); end
  DIV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  SPAN = ::T.let(nil, ::T.untyped)
  TABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::Output::Template
  def apply(target, replacement); end
end

class CodeRay::Encoders::HTML::Output::Template
  def self.wrap!(str, template, target); end
end

module CodeRay::Encoders::HTML::Output
  def self.extended(o); end

  def self.make_stylesheet(css, in_tag=T.unsafe(nil)); end

  def self.page_template_for_css(css); end
end

class CodeRay::Encoders::HTML
  def self.make_html_escape_hash(); end

  def self.token_path_to_hint(hint, kinds); end
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
end

module CodeRay::Encoders
  extend ::CodeRay::PluginHost
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::Plugin
  def aliases(); end

  def plugin_host(host=T.unsafe(nil)); end

  def plugin_id(); end

  def register_for(id); end

  def title(title=T.unsafe(nil)); end
end

module CodeRay::Plugin
end

module CodeRay::PluginHost
  def [](id, *args, &blk); end

  def all_plugins(); end

  def const_missing(const); end

  def default(id=T.unsafe(nil)); end

  def list(); end

  def load(id, *args, &blk); end

  def load_all(); end

  def load_plugin_map(); end

  def make_plugin_hash(); end

  def map(hash); end

  def path_to(plugin_id); end

  def plugin_hash(); end

  def plugin_path(*args); end

  def register(plugin, id); end

  def validate_id(id); end
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

module CodeRay::PluginHost
  def self.extended(mod); end
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Java
  def scan_tokens(encoder, options); end
  CONSTANTS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MAGIC_VARIABLES = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  STRING_CONTENT_PATTERN = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
  List = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
end

class CodeRay::Scanners::Java
end

class CodeRay::Scanners::Ruby
  def interpreted_string_state(); end

  def scan_tokens(encoder, options); end
end

module CodeRay::Scanners::Ruby::Patterns
  BINARY = ::T.let(nil, ::T.untyped)
  CHARACTER = ::T.let(nil, ::T.untyped)
  CLASS_VARIABLE = ::T.let(nil, ::T.untyped)
  CONTROL_META_ESCAPE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FANCY_STRING_INTERPRETED = ::T.let(nil, ::T.untyped)
  FANCY_STRING_KIND = ::T.let(nil, ::T.untyped)
  FANCY_STRING_START = ::T.let(nil, ::T.untyped)
  FLOAT_OR_INT = ::T.let(nil, ::T.untyped)
  FLOAT_SUFFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_VARIABLE = ::T.let(nil, ::T.untyped)
  HEREDOC_OPEN = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_EXPECTING_VALUE = ::T.let(nil, ::T.untyped)
  KEYWORD_NEW_STATE = ::T.let(nil, ::T.untyped)
  METHOD_AFTER_DOT = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME_EX = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OPERATOR = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OR_SYMBOL = ::T.let(nil, ::T.untyped)
  METHOD_SUFFIX = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  OBJECT_VARIABLE = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
  PREDEFINED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREFIX_VARIABLE = ::T.let(nil, ::T.untyped)
  QUOTE_TO_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP_MODIFIERS = ::T.let(nil, ::T.untyped)
  RUBYDOC = ::T.let(nil, ::T.untyped)
  RUBYDOC_OR_DATA = ::T.let(nil, ::T.untyped)
  SIMPLE_ESCAPE = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  VALUE_FOLLOWS = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Ruby::Patterns
end

class CodeRay::Scanners::Ruby::StringState
  def heredoc_pattern(delim, interpreted, indented); end

  def initialize(kind, interpreted, delim, heredoc=T.unsafe(nil)); end
  CLOSING_PAREN = ::T.let(nil, ::T.untyped)
  STRING_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  def self.simple_key_pattern(delim); end
end

class CodeRay::Scanners::Ruby
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*_); end

  def to_s(); end

  def tokens(*_); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

class CodeRay::WordList
  def add(words, value=T.unsafe(nil)); end

  def initialize(default=T.unsafe(nil)); end
end

class CodeRay::WordList::CaseIgnoring
  def [](key); end

  def []=(key, value); end
end

class CodeRay::WordList::CaseIgnoring
end

class CodeRay::WordList
end

module CodeRay
  def self.coderay_path(*path); end

  def self.encode(code, lang, format, options=T.unsafe(nil)); end

  def self.encode_file(filename, format, options=T.unsafe(nil)); end

  def self.encode_tokens(tokens, format, options=T.unsafe(nil)); end

  def self.encoder(format, options=T.unsafe(nil)); end

  def self.get_scanner_options(options); end

  def self.highlight(code, lang, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.highlight_file(filename, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.scan(code, lang, options=T.unsafe(nil), &block); end

  def self.scan_file(filename, lang=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.scanner(lang, options=T.unsafe(nil), &block); end
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExchanger
  def exchange(value, timeout=T.unsafe(nil)); end

  def exchange!(value, timeout=T.unsafe(nil)); end

  def try_exchange(value, timeout=T.unsafe(nil)); end
end

class Concurrent::AbstractExchanger
end

class Concurrent::AbstractExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Deprecation
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def auto_terminate=(value); end

  def auto_terminate?(); end

  def fallback_policy(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def kill(); end

  def name(); end

  def running?(); end

  def shutdown(); end

  def shutdown?(); end

  def shuttingdown?(); end

  def wait_for_termination(timeout=T.unsafe(nil)); end
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
end

class Concurrent::AbstractThreadLocalVar
  def allocate_storage(); end

  def bind(value, &block); end

  def default(); end

  def initialize(default=T.unsafe(nil), &default_block); end

  def value(); end

  def value=(value); end
end

class Concurrent::AbstractThreadLocalVar
end

class Concurrent::Agent
  include ::Concurrent::Concern::Observable
  def <<(action); end

  def await(); end

  def await_for(timeout); end

  def await_for!(timeout); end

  def deref(); end

  def error(); end

  def error_mode(); end

  def failed?(); end

  def initialize(initial, opts=T.unsafe(nil)); end

  def post(*args, &action); end

  def reason(); end

  def restart(new_value, opts=T.unsafe(nil)); end

  def send(*args, &action); end

  def send!(*args, &action); end

  def send_off(*args, &action); end

  def send_off!(*args, &action); end

  def send_via(executor, *args, &action); end

  def send_via!(executor, *args, &action); end

  def stopped?(); end

  def value(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
  def initialize(message=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent
  def self.await(*agents); end

  def self.await_for(timeout, *agents); end

  def self.await_for!(timeout, *agents); end
end

class Concurrent::Array
end

class Concurrent::Array
end

module Concurrent::Async
  def async(); end

  def await(); end

  def call(); end

  def cast(); end

  def init_synchronization(); end
end

module Concurrent::Async
  def self.included(base); end

  def self.validate_argc(obj, method, *args); end
end

class Concurrent::Atom
  include ::Concurrent::Concern::Observable
  def compare_and_set(old_value, new_value); end

  def deref(); end

  def initialize(value, opts=T.unsafe(nil)); end

  def reset(new_value); end

  def swap(*args); end

  def value(); end
end

class Concurrent::Atom
  def self.new(*args, &block); end
end

class Concurrent::AtomicBoolean
end

class Concurrent::AtomicBoolean
end

module Concurrent::AtomicDirectUpdate
  def try_update(); end

  def try_update!(); end

  def update(); end
end

module Concurrent::AtomicDirectUpdate
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicMarkableReference
  def compare_and_set(expected_val, new_val, expected_mark, new_mark); end

  def compare_and_swap(expected_val, new_val, expected_mark, new_mark); end

  def get(); end

  def initialize(value=T.unsafe(nil), mark=T.unsafe(nil)); end

  def mark(); end

  def marked?(); end

  def set(new_val, new_mark); end

  def try_update(); end

  def try_update!(); end

  def update(); end

  def value(); end
end

class Concurrent::AtomicMarkableReference
  def self.new(*args, &block); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
  def compare_and_set(old_value, new_value); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
end

class Concurrent::AtomicReference
end

class Concurrent::AtomicReference
end

class Concurrent::CachedThreadPool
end

class Concurrent::CachedThreadPool
end

class Concurrent::CancelledOperationError
end

class Concurrent::CancelledOperationError
end

module Concurrent::Collection
end

class Concurrent::Collection::CopyOnNotifyObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnNotifyObserverSet
end

class Concurrent::Collection::CopyOnWriteObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnWriteObserverSet
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::NonConcurrentMapBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
end

class Concurrent::Collection::NonConcurrentMapBackend
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def <<(item); end

  def clear(); end

  def delete(item); end

  def deq(); end

  def empty?(); end

  def enq(item); end

  def has_priority?(item); end

  def include?(item); end

  def initialize(opts=T.unsafe(nil)); end

  def length(); end

  def peek(); end

  def pop(); end

  def push(item); end

  def shift(); end

  def size(); end
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def self.from_list(list, opts=T.unsafe(nil)); end
end

module Concurrent::Collection
end

module Concurrent::Concern
end

module Concurrent::Concern::Deprecation
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def deprecated(message, strip=T.unsafe(nil)); end

  def deprecated_method(old_name, new_name); end
end

module Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
end

module Concurrent::Concern::Dereferenceable
  def apply_deref_options(value); end

  def deref(); end

  def ns_set_deref_options(opts); end

  def set_deref_options(opts=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
end

module Concurrent::Concern::Dereferenceable
end

module Concurrent::Concern::Logging
  include ::Logger::Severity
  def log(level, progname, message=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Logging
end

module Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def compare_and_set_state(next_state, *expected_current); end

  def complete?(); end

  def event(); end

  def exception(*args); end

  def fulfilled?(); end

  def get_arguments_from(opts=T.unsafe(nil)); end

  def if_state(*expected_states); end

  def incomplete?(); end

  def init_obligation(); end

  def no_error!(timeout=T.unsafe(nil)); end

  def ns_check_state?(expected); end

  def ns_set_state(value); end

  def pending?(); end

  def realized?(); end

  def reason(); end

  def rejected?(); end

  def set_state(success, value, reason); end

  def state(); end

  def state=(value); end

  def unscheduled?(); end

  def value(timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end
end

module Concurrent::Concern::Obligation
end

module Concurrent::Concern::Observable
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def observers(); end

  def observers=(observers); end

  def with_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Observable
end

module Concurrent::Concern
end

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::ConcurrentUpdateError
end

class Concurrent::ConfigurationError
end

class Concurrent::ConfigurationError
end

class Concurrent::CountDownLatch
end

class Concurrent::CountDownLatch
end

class Concurrent::CyclicBarrier
  def broken?(); end

  def initialize(parties, &block); end

  def ns_generation_done(generation, status, continue=T.unsafe(nil)); end

  def ns_initialize(parties, &block); end

  def ns_next_generation(); end

  def number_waiting(); end

  def parties(); end

  def reset(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::CyclicBarrier
end

class Concurrent::Delay
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def initialize(opts=T.unsafe(nil), &block); end

  def ns_initialize(opts, &block); end

  def reconfigure(&block); end
end

class Concurrent::Delay
end

class Concurrent::DependencyCounter
  def initialize(count, &block); end

  def update(time, value, reason); end
end

class Concurrent::DependencyCounter
end

class Concurrent::Error
end

class Concurrent::Error
end

class Concurrent::Event
  def initialize(); end

  def ns_initialize(); end

  def ns_set(); end

  def reset(); end

  def set(); end

  def set?(); end

  def try?(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Event
end

class Concurrent::Exchanger
end

class Concurrent::Exchanger
end

module Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def <<(task); end

  def can_overflow?(); end

  def post(*args, &task); end

  def serialized?(); end
end

module Concurrent::ExecutorService
end

class Concurrent::FixedThreadPool
  def initialize(num_threads, opts=T.unsafe(nil)); end
end

class Concurrent::FixedThreadPool
end

class Concurrent::Future
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def set(value=T.unsafe(nil), &block); end

  def wait_or_cancel(timeout); end
end

class Concurrent::Future
  def self.execute(opts=T.unsafe(nil), &block); end
end

class Concurrent::Hash
end

class Concurrent::Hash
end

class Concurrent::IVar
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def check_for_block_or_value!(block_given, value); end

  def complete(success, value, reason); end

  def complete_without_notification(success, value, reason); end

  def fail(reason=T.unsafe(nil)); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def notify_observers(value, reason); end

  def ns_complete_without_notification(success, value, reason); end

  def ns_initialize(value, opts); end

  def safe_execute(task, args=T.unsafe(nil)); end

  def set(value=T.unsafe(nil)); end

  def try_set(value=T.unsafe(nil), &block); end
end

class Concurrent::IVar
end

class Concurrent::IllegalOperationError
end

class Concurrent::IllegalOperationError
end

class Concurrent::ImmediateExecutor
  include ::Concurrent::SerialExecutorService
  def initialize(); end
end

class Concurrent::ImmediateExecutor
end

class Concurrent::ImmutabilityError
end

class Concurrent::ImmutabilityError
end

module Concurrent::ImmutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::ImmutableStruct
  def self.included(base); end

  def self.new(*args, &block); end
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::InitializationError
end

class Concurrent::InitializationError
end

class Concurrent::LifecycleError
end

class Concurrent::LifecycleError
end

class Concurrent::LockFreeStack
  include ::Enumerable
  def clear(); end

  def clear_each(&block); end

  def clear_if(head); end

  def compare_and_clear(head); end

  def compare_and_pop(head); end

  def compare_and_push(head, value); end

  def each(head=T.unsafe(nil), &blk); end

  def empty?(head=T.unsafe(nil)); end

  def initialize(head=T.unsafe(nil)); end

  def peek(); end

  def pop(); end

  def push(value); end

  def replace_if(head, new_head); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack::Node
  def initialize(value, next_node); end

  def next_node(); end

  def value(); end

  def value=(value); end
end

class Concurrent::LockFreeStack::Node
  def self.[](*_); end
end

class Concurrent::LockFreeStack
  def self.new(*args, &block); end

  def self.of1(value); end

  def self.of2(value1, value2); end
end

class Concurrent::MVar
  include ::Concurrent::Concern::Dereferenceable
  def borrow(timeout=T.unsafe(nil)); end

  def empty?(); end

  def full?(); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil)); end

  def modify(timeout=T.unsafe(nil)); end

  def modify!(); end

  def put(value, timeout=T.unsafe(nil)); end

  def set!(value); end

  def synchronize(&block); end

  def take(timeout=T.unsafe(nil)); end

  def try_put!(value); end

  def try_take!(); end
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  def self.new(*args, &block); end
end

class Concurrent::Map
  def each(&blk); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def value?(value); end

  def values(); end
end

class Concurrent::Map
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::Maybe
  include ::Comparable
  def fulfilled?(); end

  def initialize(just, nothing); end

  def just(); end

  def just?(); end

  def nothing(); end

  def nothing?(); end

  def or(other); end

  def reason(); end

  def rejected?(); end

  def value(); end
  NONE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  def self.from(*args); end

  def self.just(value); end

  def self.nothing(error=T.unsafe(nil)); end
end

class Concurrent::MultipleAssignmentError
  def initialize(message=T.unsafe(nil), inspection_data=T.unsafe(nil)); end

  def inspection_data(); end
end

class Concurrent::MultipleAssignmentError
end

class Concurrent::MultipleErrors
  def errors(); end

  def initialize(errors, message=T.unsafe(nil)); end
end

class Concurrent::MultipleErrors
end

module Concurrent::MutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::MutableStruct
  def self.new(*args, &block); end
end

class Concurrent::MutexAtomicBoolean
  def false?(); end

  def initialize(initial=T.unsafe(nil)); end

  def make_false(); end

  def make_true(); end

  def ns_initialize(initial); end

  def true?(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicBoolean
end

class Concurrent::MutexAtomicFixnum
  def compare_and_set(expect, update); end

  def decrement(delta=T.unsafe(nil)); end

  def down(delta=T.unsafe(nil)); end

  def increment(delta=T.unsafe(nil)); end

  def initialize(initial=T.unsafe(nil)); end

  def ns_initialize(initial); end

  def up(delta=T.unsafe(nil)); end

  def update(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicFixnum
end

class Concurrent::MutexAtomicReference
  include ::Concurrent::AtomicDirectUpdate
  include ::Concurrent::AtomicNumericCompareAndSetWrapper
  def _compare_and_set(old_value, new_value); end

  def compare_and_swap(old_value, new_value); end

  def get(); end

  def get_and_set(new_value); end

  def initialize(value=T.unsafe(nil)); end

  def ns_initialize(value); end

  def set(new_value); end

  def swap(new_value); end

  def value(); end

  def value=(new_value); end
end

class Concurrent::MutexAtomicReference
end

class Concurrent::MutexCountDownLatch
  def count(); end

  def count_down(); end

  def initialize(count=T.unsafe(nil)); end

  def ns_initialize(count); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::MutexCountDownLatch
end

class Concurrent::MutexSemaphore
  def acquire(permits=T.unsafe(nil)); end

  def available_permits(); end

  def drain_permits(); end

  def initialize(count); end

  def ns_initialize(count); end

  def reduce_permits(reduction); end

  def release(permits=T.unsafe(nil)); end

  def try_acquire(permits=T.unsafe(nil), timeout=T.unsafe(nil)); end
end

class Concurrent::MutexSemaphore
end

module Concurrent::Options
end

module Concurrent::Options
  def self.executor(executor_identifier); end

  def self.executor_from_options(opts=T.unsafe(nil)); end
end

class Concurrent::Promise
  def catch(&block); end

  def execute(); end

  def flat_map(&block); end

  def initialize(opts=T.unsafe(nil), &block); end

  def notify_child(child); end

  def on_error(&block); end

  def on_fulfill(result); end

  def on_reject(reason); end

  def on_success(&block); end

  def realize(task); end

  def rescue(&block); end

  def root?(); end

  def set(value=T.unsafe(nil), &block); end

  def set_pending(); end

  def set_state!(success, value, reason); end

  def synchronized_set_state!(success, value, reason); end

  def then(*args, &block); end

  def zip(*others); end
end

class Concurrent::Promise
  def self.aggregate(method, *promises); end

  def self.all?(*promises); end

  def self.any?(*promises); end

  def self.execute(opts=T.unsafe(nil), &block); end

  def self.fulfill(value, opts=T.unsafe(nil)); end

  def self.reject(reason, opts=T.unsafe(nil)); end

  def self.zip(*promises); end
end

class Concurrent::PromiseExecutionError
end

class Concurrent::PromiseExecutionError
end

module Concurrent::Promises
end

class Concurrent::Promises::AbstractEventFuture
  include ::Concurrent::Promises::InternalStates
  def add_callback_clear_delayed_node(node); end

  def add_callback_notify_blocked(promise, index); end

  def blocks(); end

  def callbacks(); end

  def chain(*args, &task); end

  def chain_on(executor, *args, &task); end

  def chain_resolvable(resolvable); end

  def default_executor(); end

  def initialize(promise, default_executor); end

  def internal_state(); end

  def on_resolution(*args, &callback); end

  def on_resolution!(*args, &callback); end

  def on_resolution_using(executor, *args, &callback); end

  def pending?(); end

  def promise(); end

  def resolve_with(state, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolved?(); end

  def state(); end

  def tangle(resolvable); end

  def touch(); end

  def touched?(); end

  def wait(timeout=T.unsafe(nil)); end

  def waiting_threads(); end

  def with_default_executor(executor); end

  def with_hidden_resolvable(); end
end

class Concurrent::Promises::AbstractEventFuture
  def self.new(*args, &block); end
end

class Concurrent::Promises::Event
  def &(other); end

  def any(event_or_future); end

  def delay(); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def to_event(); end

  def to_future(); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Event
end

module Concurrent::Promises::FactoryMethods
  include ::Concurrent::Promises::FactoryMethods::Configuration
  def any(*futures_and_or_events); end

  def any_event(*futures_and_or_events); end

  def any_event_on(default_executor, *futures_and_or_events); end

  def any_fulfilled_future(*futures_and_or_events); end

  def any_fulfilled_future_on(default_executor, *futures_and_or_events); end

  def any_resolved_future(*futures_and_or_events); end

  def any_resolved_future_on(default_executor, *futures_and_or_events); end

  def delay(*args, &task); end

  def delay_on(default_executor, *args, &task); end

  def fulfilled_future(value, default_executor=T.unsafe(nil)); end

  def future(*args, &task); end

  def future_on(default_executor, *args, &task); end

  def make_future(argument=T.unsafe(nil), default_executor=T.unsafe(nil)); end

  def rejected_future(reason, default_executor=T.unsafe(nil)); end

  def resolvable_event(); end

  def resolvable_event_on(default_executor=T.unsafe(nil)); end

  def resolvable_future(); end

  def resolvable_future_on(default_executor=T.unsafe(nil)); end

  def resolved_event(default_executor=T.unsafe(nil)); end

  def resolved_future(fulfilled, value, reason, default_executor=T.unsafe(nil)); end

  def schedule(intended_time, *args, &task); end

  def schedule_on(default_executor, intended_time, *args, &task); end

  def zip(*futures_and_or_events); end

  def zip_events(*futures_and_or_events); end

  def zip_events_on(default_executor, *futures_and_or_events); end

  def zip_futures(*futures_and_or_events); end

  def zip_futures_on(default_executor, *futures_and_or_events); end
end

module Concurrent::Promises::FactoryMethods::Configuration
  def default_executor(); end
end

module Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::Promises::FactoryMethods
  extend ::Concurrent::ReInclude
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

class Concurrent::Promises::Future
  def &(other); end

  def any(event_or_future); end

  def apply(args, block); end

  def delay(); end

  def exception(*args); end

  def flat(level=T.unsafe(nil)); end

  def flat_event(); end

  def flat_future(level=T.unsafe(nil)); end

  def fulfilled?(); end

  def on_fulfillment(*args, &callback); end

  def on_fulfillment!(*args, &callback); end

  def on_fulfillment_using(executor, *args, &callback); end

  def on_rejection(*args, &callback); end

  def on_rejection!(*args, &callback); end

  def on_rejection_using(executor, *args, &callback); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def rejected?(); end

  def rescue(*args, &task); end

  def rescue_on(executor, *args, &task); end

  def result(timeout=T.unsafe(nil)); end

  def run(run_test=T.unsafe(nil)); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def then_on(executor, *args, &task); end

  def to_event(); end

  def to_future(); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Future
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
  include ::Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
end

class Concurrent::Promises::ResolvableEvent
  include ::Concurrent::Promises::Resolvable
  def resolve(raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableEvent
end

class Concurrent::Promises::ResolvableFuture
  include ::Concurrent::Promises::Resolvable
  def evaluate_to(*args, &block); end

  def evaluate_to!(*args, &block); end

  def fulfill(value, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def reject(reason, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolve(fulfilled=T.unsafe(nil), value=T.unsafe(nil), reason=T.unsafe(nil), raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def result(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableFuture
end

module Concurrent::Promises
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::ReInclude
  def extended(base); end

  def include(*modules); end

  def included(base); end
end

module Concurrent::ReInclude
end

class Concurrent::ReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def has_waiters?(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end

  def write_locked?(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::ReentrantReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def try_read_lock(); end

  def try_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::RejectedExecutionError
end

class Concurrent::RejectedExecutionError
end

class Concurrent::ResourceLimitError
end

class Concurrent::ResourceLimitError
end

class Concurrent::RubyExchanger
  def compare_and_set_slot(expected, value); end

  def slot(); end

  def slot=(value); end

  def swap_slot(value); end

  def update_slot(&block); end
end

class Concurrent::RubyExchanger
  def self.new(*args, &block); end
end

class Concurrent::RubyExecutorService
  def initialize(*args, &block); end
end

class Concurrent::RubyExecutorService
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubyThreadLocalVar
end

class Concurrent::RubyThreadLocalVar
  def self.thread_finalizer(id); end

  def self.thread_local_finalizer(index); end
end

class Concurrent::RubyThreadPoolExecutor
  def completed_task_count(); end

  def idletime(); end

  def initialize(opts=T.unsafe(nil)); end

  def largest_length(); end

  def length(); end

  def max_length(); end

  def max_queue(); end

  def min_length(); end

  def queue_length(); end

  def ready_worker(worker); end

  def remaining_capacity(); end

  def remove_busy_worker(worker); end

  def scheduled_task_count(); end

  def worker_died(worker); end

  def worker_not_old_enough(worker); end

  def worker_task_completed(); end
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
end

class Concurrent::SafeTaskExecutor
  def execute(*args); end

  def initialize(task, opts=T.unsafe(nil)); end
end

class Concurrent::SafeTaskExecutor
end

class Concurrent::ScheduledTask
  include ::Comparable
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def executor(); end

  def initial_delay(); end

  def initialize(delay, opts=T.unsafe(nil), &task); end

  def ns_reschedule(delay); end

  def ns_schedule(delay); end

  def process_task(); end

  def processing?(); end

  def reschedule(delay); end

  def reset(); end

  def schedule_time(); end
end

class Concurrent::ScheduledTask
  def self.execute(delay, opts=T.unsafe(nil), &task); end
end

class Concurrent::Semaphore
end

class Concurrent::Semaphore
end

module Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def serialized?(); end
end

module Concurrent::SerialExecutorService
end

class Concurrent::SerializedExecution
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(); end

  def post(executor, *args, &task); end

  def posts(posts); end
end

class Concurrent::SerializedExecution::Job
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def call(); end

  def executor(); end

  def executor=(_); end
end

class Concurrent::SerializedExecution::Job
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::SerializedExecution
end

class Concurrent::SerializedExecutionDelegator
  include ::Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(executor); end
end

class Concurrent::SerializedExecutionDelegator
end

class Concurrent::Set
end

class Concurrent::Set
end

module Concurrent::SettableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::SettableStruct
  def self.new(*args, &block); end
end

class Concurrent::SimpleExecutorService
end

class Concurrent::SimpleExecutorService
  def self.<<(task); end

  def self.post(*args); end
end

class Concurrent::SingleThreadExecutor
end

class Concurrent::SingleThreadExecutor
end

module Concurrent::Synchronization
end

class Concurrent::Synchronization::AbstractLockableObject
  def ns_broadcast(); end

  def ns_signal(); end

  def ns_wait(timeout=T.unsafe(nil)); end

  def ns_wait_until(timeout=T.unsafe(nil), &condition); end

  def synchronize(); end
end

class Concurrent::Synchronization::AbstractLockableObject
end

class Concurrent::Synchronization::AbstractObject
  def full_memory_barrier(); end
end

class Concurrent::Synchronization::AbstractObject
  def self.attr_volatile(*names); end
end

module Concurrent::Synchronization::AbstractStruct
  def initialize(*values); end

  def length(); end

  def members(); end

  def ns_each(); end

  def ns_each_pair(); end

  def ns_equality(other); end

  def ns_get(member); end

  def ns_initialize_copy(); end

  def ns_inspect(); end

  def ns_merge(other, &block); end

  def ns_select(); end

  def ns_to_h(); end

  def ns_values(); end

  def ns_values_at(indexes); end

  def pr_underscore(clazz); end

  def size(); end
end

module Concurrent::Synchronization::AbstractStruct
  def self.define_struct_class(parent, base, name, members, &block); end
end

class Concurrent::Synchronization::Condition
  def broadcast(); end

  def initialize(lock); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Condition
  def self.private_new(*args, &block); end
end

module Concurrent::Synchronization::ConditionSignalling
  def ns_broadcast(); end

  def ns_signal(); end
end

module Concurrent::Synchronization::ConditionSignalling
end

class Concurrent::Synchronization::Lock
  def broadcast(); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Lock
end

class Concurrent::Synchronization::LockableObject
  def new_condition(); end
end

class Concurrent::Synchronization::LockableObject
end

class Concurrent::Synchronization::MonitorLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MonitorLockableObject
  def self.new(*args, &block); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::MriObject
  include ::Concurrent::Synchronization::MriAttrVolatile
end

class Concurrent::Synchronization::MriObject
end

class Concurrent::Synchronization::MutexLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MutexLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::Object
end

class Concurrent::Synchronization::Object
  def self.atomic_attribute?(name); end

  def self.atomic_attributes(inherited=T.unsafe(nil)); end

  def self.attr_atomic(*names); end

  def self.ensure_safe_initialization_when_final_fields_are_present(); end

  def self.safe_initialization!(); end

  def self.safe_initialization?(); end
end

module Concurrent::Synchronization::RbxAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::RbxAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::RbxLockableObject
  def initialize(*defaults); end

  def synchronize(&block); end
end

class Concurrent::Synchronization::RbxLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::RbxObject
  include ::Concurrent::Synchronization::RbxAttrVolatile
end

class Concurrent::Synchronization::RbxObject
  extend ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::TruffleRubyObject
  include ::Concurrent::Synchronization::TruffleRubyAttrVolatile
end

class Concurrent::Synchronization::TruffleRubyObject
  extend ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

module Concurrent::Synchronization
end

class Concurrent::SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
end

class Concurrent::SynchronizedDelegator
end

class Concurrent::TVar
  def initialize(value); end

  def unsafe_increment_version(); end

  def unsafe_lock(); end

  def unsafe_value(); end

  def unsafe_value=(value); end

  def unsafe_version(); end

  def value(); end

  def value=(value); end
end

class Concurrent::TVar
  def self.new(*args, &block); end
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadPoolExecutor
end

class Concurrent::ThreadPoolExecutor
end

module Concurrent::ThreadSafe
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
end

module Concurrent::ThreadSafe
end

class Concurrent::TimeoutError
end

class Concurrent::TimeoutError
end

class Concurrent::TimerSet
  def initialize(opts=T.unsafe(nil)); end

  def post(delay, *args, &task); end
end

class Concurrent::TimerSet
end

class Concurrent::TimerTask
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def execute(); end

  def execution_interval(); end

  def execution_interval=(value); end

  def initialize(opts=T.unsafe(nil), &task); end

  def timeout_interval(); end

  def timeout_interval=(value); end
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  def self.execute(opts=T.unsafe(nil), &task); end
end

class Concurrent::Transaction
  def abort(); end

  def commit(); end

  def read(tvar); end

  def unlock(); end

  def valid?(); end

  def write(tvar, value); end
  ABORTED = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::ReadLogEntry
  def tvar(); end

  def tvar=(_); end

  def version(); end

  def version=(_); end
end

class Concurrent::Transaction::ReadLogEntry
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::Transaction
  def self.current(); end

  def self.current=(transaction); end
end

class Concurrent::Tuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def get(i); end

  def initialize(size); end

  def set(i, value); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class Concurrent::Tuple
end

module Concurrent::Utility
end

module Concurrent::Utility::EngineDetector
  def on_cruby?(); end

  def on_jruby?(); end

  def on_jruby_9000?(); end

  def on_linux?(); end

  def on_osx?(); end

  def on_rbx?(); end

  def on_truffleruby?(); end

  def on_windows?(); end

  def ruby_engine(); end

  def ruby_version(version=T.unsafe(nil), comparison, major, minor, patch); end
end

module Concurrent::Utility::EngineDetector
end

module Concurrent::Utility::NativeExtensionLoader
  def allow_c_extensions?(); end

  def c_extensions_loaded?(); end

  def java_extensions_loaded?(); end

  def load_native_extensions(); end
end

module Concurrent::Utility::NativeExtensionLoader
end

module Concurrent::Utility::NativeInteger
  def ensure_integer(value); end

  def ensure_integer_and_bounds(value); end

  def ensure_lower_bound(value); end

  def ensure_positive(value); end

  def ensure_positive_and_no_zero(value); end

  def ensure_upper_bound(value); end
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  extend ::Concurrent::Utility::NativeInteger
end

class Concurrent::Utility::ProcessorCounter
  def physical_processor_count(); end

  def processor_count(); end
end

class Concurrent::Utility::ProcessorCounter
end

module Concurrent::Utility
end

module Concurrent
  extend ::Concurrent::Utility::EngineDetector
  extend ::Concurrent::Utility::NativeExtensionLoader
  extend ::Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
  def self.abort_transaction(); end

  def self.atomically(); end

  def self.call_dataflow(method, executor, *inputs, &block); end

  def self.create_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.create_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.dataflow(*inputs, &block); end

  def self.dataflow!(*inputs, &block); end

  def self.dataflow_with(executor, *inputs, &block); end

  def self.dataflow_with!(executor, *inputs, &block); end

  def self.disable_at_exit_handlers!(); end

  def self.executor(executor_identifier); end

  def self.global_fast_executor(); end

  def self.global_immediate_executor(); end

  def self.global_io_executor(); end

  def self.global_logger(); end

  def self.global_logger=(value); end

  def self.global_timer_set(); end

  def self.leave_transaction(); end

  def self.monotonic_time(); end

  def self.new_fast_executor(opts=T.unsafe(nil)); end

  def self.new_io_executor(opts=T.unsafe(nil)); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.processor_counter(); end

  def self.use_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.use_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end
end

class ConnectionPool
  def available(); end

  def checkin(); end

  def checkout(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &block); end

  def shutdown(&block); end

  def size(); end

  def with(options=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ConnectionPool::Error
end

class ConnectionPool::Error
end

class ConnectionPool::PoolShuttingDownError
end

class ConnectionPool::PoolShuttingDownError
end

class ConnectionPool::TimedStack
  def <<(obj, options=T.unsafe(nil)); end

  def empty?(); end

  def initialize(size=T.unsafe(nil), &block); end

  def length(); end

  def max(); end

  def pop(timeout=T.unsafe(nil), options=T.unsafe(nil)); end

  def push(obj, options=T.unsafe(nil)); end

  def shutdown(&block); end
end

class ConnectionPool::TimedStack
end

class ConnectionPool::TimeoutError
end

class ConnectionPool::TimeoutError
end

class ConnectionPool::Wrapper
  def initialize(options=T.unsafe(nil), &block); end

  def method_missing(name, *args, &block); end

  def pool_available(); end

  def pool_shutdown(&block); end

  def pool_size(); end

  def respond_to?(id, *args); end

  def with(&block); end

  def wrapped_pool(); end
  METHODS = ::T.let(nil, ::T.untyped)
end

class ConnectionPool::Wrapper
end

class ConnectionPool
  def self.wrap(options, &block); end
end

module Crass
end

class Crass::Parser
  def consume_at_rule(input=T.unsafe(nil)); end

  def consume_component_value(input=T.unsafe(nil)); end

  def consume_declaration(input=T.unsafe(nil)); end

  def consume_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def consume_function(input=T.unsafe(nil)); end

  def consume_qualified_rule(input=T.unsafe(nil)); end

  def consume_rules(flags=T.unsafe(nil)); end

  def consume_simple_block(input=T.unsafe(nil)); end

  def create_node(type, properties=T.unsafe(nil)); end

  def create_selector(input); end

  def create_style_rule(rule); end

  def initialize(input, options=T.unsafe(nil)); end

  def parse_component_value(input=T.unsafe(nil)); end

  def parse_component_values(input=T.unsafe(nil)); end

  def parse_declaration(input=T.unsafe(nil)); end

  def parse_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def parse_properties(input=T.unsafe(nil)); end

  def parse_rule(input=T.unsafe(nil)); end

  def parse_value(nodes); end

  def tokens(); end
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  def self.parse_properties(input, options=T.unsafe(nil)); end

  def self.parse_rules(input, options=T.unsafe(nil)); end

  def self.parse_stylesheet(input, options=T.unsafe(nil)); end

  def self.stringify(nodes, options=T.unsafe(nil)); end
end

class Crass::Scanner
  def consume(); end

  def consume_rest(); end

  def current(); end

  def eos?(); end

  def initialize(input); end

  def mark(); end

  def marked(); end

  def marker(); end

  def marker=(marker); end

  def peek(length=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def reconsume(); end

  def reset(); end

  def scan(pattern); end

  def scan_until(pattern); end

  def string(); end
end

class Crass::Scanner
end

class Crass::TokenScanner
  def collect(); end

  def consume(); end

  def current(); end

  def initialize(tokens); end

  def peek(); end

  def pos(); end

  def reconsume(); end

  def reset(); end

  def tokens(); end
end

class Crass::TokenScanner
end

class Crass::Tokenizer
  def consume(); end

  def consume_bad_url(); end

  def consume_comments(); end

  def consume_escaped(); end

  def consume_ident(); end

  def consume_name(); end

  def consume_number(); end

  def consume_numeric(); end

  def consume_string(ending=T.unsafe(nil)); end

  def consume_unicode_range(); end

  def consume_url(); end

  def convert_string_to_number(str); end

  def create_token(type, properties=T.unsafe(nil)); end

  def initialize(input, options=T.unsafe(nil)); end

  def preprocess(input); end

  def start_identifier?(text=T.unsafe(nil)); end

  def start_number?(text=T.unsafe(nil)); end

  def tokenize(); end

  def valid_escape?(text=T.unsafe(nil)); end
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  def self.tokenize(input, options=T.unsafe(nil)); end
end

module Crass
  def self.parse(input, options=T.unsafe(nil)); end

  def self.parse_properties(input, options=T.unsafe(nil)); end
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket
  def initialize(uri, soc, config=T.unsafe(nil), server_mode=T.unsafe(nil)); end
  Max_try = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def self.temp_server(); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  def acts_like_date?(); end

  def ago(seconds); end

  def at_beginning_of_day(); end

  def at_end_of_day(); end

  def at_midday(); end

  def at_middle_of_day(); end

  def at_midnight(); end

  def at_noon(); end

  def beginning_of_day(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def default_inspect(); end

  def end_of_day(); end

  def in(seconds); end

  def midday(); end

  def middle_of_day(); end

  def midnight(); end

  def minus_with_duration(other); end

  def minus_without_duration(_); end

  def noon(); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def readable_inspect(); end

  def since(seconds); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date
  def self.beginning_of_week(); end

  def self.beginning_of_week=(week_start); end

  def self.beginning_of_week_default(); end

  def self.beginning_of_week_default=(beginning_of_week_default); end

  def self.current(); end

  def self.find_beginning_of_week!(week_start); end

  def self.tomorrow(); end

  def self.yesterday(); end
end

module DateAndTime
end

module DateAndTime::Calculations
  def after?(date_or_time); end

  def all_day(); end

  def all_month(); end

  def all_quarter(); end

  def all_week(start_day=T.unsafe(nil)); end

  def all_year(); end

  def at_beginning_of_month(); end

  def at_beginning_of_quarter(); end

  def at_beginning_of_week(start_day=T.unsafe(nil)); end

  def at_beginning_of_year(); end

  def at_end_of_month(); end

  def at_end_of_quarter(); end

  def at_end_of_week(start_day=T.unsafe(nil)); end

  def at_end_of_year(); end

  def before?(date_or_time); end

  def beginning_of_month(); end

  def beginning_of_quarter(); end

  def beginning_of_week(start_day=T.unsafe(nil)); end

  def beginning_of_year(); end

  def days_ago(days); end

  def days_since(days); end

  def days_to_week_start(start_day=T.unsafe(nil)); end

  def end_of_month(); end

  def end_of_quarter(); end

  def end_of_week(start_day=T.unsafe(nil)); end

  def end_of_year(); end

  def future?(); end

  def last_month(); end

  def last_quarter(); end

  def last_week(start_day=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def last_weekday(); end

  def last_year(); end

  def monday(); end

  def months_ago(months); end

  def months_since(months); end

  def next_occurring(day_of_week); end

  def next_quarter(); end

  def next_week(given_day_in_next_week=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def next_weekday(); end

  def on_weekday?(); end

  def on_weekend?(); end

  def past?(); end

  def prev_occurring(day_of_week); end

  def prev_quarter(); end

  def prev_week(start_day=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def prev_weekday(); end

  def sunday(); end

  def today?(); end

  def tomorrow(); end

  def weeks_ago(weeks); end

  def weeks_since(weeks); end

  def years_ago(years); end

  def years_since(years); end

  def yesterday(); end
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
  WEEKEND_DAYS = ::T.let(nil, ::T.untyped)
end

module DateAndTime::Calculations
end

module DateAndTime::Compatibility
  def preserve_timezone(); end
end

module DateAndTime::Compatibility
  def self.preserve_timezone(); end

  def self.preserve_timezone=(obj); end
end

module DateAndTime::Zones
  def in_time_zone(zone=T.unsafe(nil)); end
end

module DateAndTime::Zones
end

module DateAndTime
end

class DateTime
  include ::DateAndTime::Compatibility
  def acts_like_time?(); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmtime(); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def nsec(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def subsec(); end

  def to_f(); end

  def to_i(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end
end

class DateTime
  def self.civil_from_format(utc_or_local, year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), min=T.unsafe(nil), sec=T.unsafe(nil)); end
end

class Delegator
  include ::ActiveSupport::Tryable
end

module Devise
  def allow_unconfirmed_access_for(); end

  def allow_unconfirmed_access_for=(obj); end

  def authentication_keys(); end

  def authentication_keys=(obj); end

  def case_insensitive_keys(); end

  def case_insensitive_keys=(obj); end

  def clean_up_csrf_token_on_authentication(); end

  def clean_up_csrf_token_on_authentication=(obj); end

  def confirm_within(); end

  def confirm_within=(obj); end

  def confirmation_keys(); end

  def confirmation_keys=(obj); end

  def default_scope(); end

  def default_scope=(obj); end

  def email_regexp(); end

  def email_regexp=(obj); end

  def expire_all_remember_me_on_sign_out(); end

  def expire_all_remember_me_on_sign_out=(obj); end

  def extend_remember_period(); end

  def extend_remember_period=(obj); end

  def helpers(); end

  def http_authenticatable(); end

  def http_authenticatable=(obj); end

  def http_authenticatable_on_xhr(); end

  def http_authenticatable_on_xhr=(obj); end

  def http_authentication_key(); end

  def http_authentication_key=(obj); end

  def http_authentication_realm(); end

  def http_authentication_realm=(obj); end

  def last_attempt_warning(); end

  def last_attempt_warning=(obj); end

  def lock_strategy(); end

  def lock_strategy=(obj); end

  def mailer_sender(); end

  def mailer_sender=(obj); end

  def mappings(); end

  def maximum_attempts(); end

  def maximum_attempts=(obj); end

  def navigational_formats(); end

  def navigational_formats=(obj); end

  def omniauth_configs(); end

  def omniauth_path_prefix(); end

  def omniauth_path_prefix=(obj); end

  def params_authenticatable(); end

  def params_authenticatable=(obj); end

  def paranoid(); end

  def paranoid=(obj); end

  def parent_controller(); end

  def parent_controller=(obj); end

  def parent_mailer(); end

  def parent_mailer=(obj); end

  def password_length(); end

  def password_length=(obj); end

  def pepper(); end

  def pepper=(obj); end

  def reconfirmable(); end

  def reconfirmable=(obj); end

  def reload_routes(); end

  def reload_routes=(obj); end

  def remember_for(); end

  def remember_for=(obj); end

  def rememberable_options(); end

  def rememberable_options=(obj); end

  def request_keys(); end

  def request_keys=(obj); end

  def reset_password_keys(); end

  def reset_password_keys=(obj); end

  def reset_password_within(); end

  def reset_password_within=(obj); end

  def router_name(); end

  def router_name=(obj); end

  def scoped_views(); end

  def scoped_views=(obj); end

  def secret_key(); end

  def secret_key=(obj); end

  def send_email_changed_notification(); end

  def send_email_changed_notification=(obj); end

  def send_password_change_notification(); end

  def send_password_change_notification=(obj); end

  def sign_in_after_change_password(); end

  def sign_in_after_change_password=(obj); end

  def sign_in_after_reset_password(); end

  def sign_in_after_reset_password=(obj); end

  def sign_out_all_scopes(); end

  def sign_out_all_scopes=(obj); end

  def sign_out_via(); end

  def sign_out_via=(obj); end

  def skip_session_storage(); end

  def skip_session_storage=(obj); end

  def stretches(); end

  def stretches=(obj); end

  def strip_whitespace_keys(); end

  def strip_whitespace_keys=(obj); end

  def timeout_in(); end

  def timeout_in=(obj); end

  def token_generator(); end

  def token_generator=(obj); end

  def unlock_in(); end

  def unlock_in=(obj); end

  def unlock_keys(); end

  def unlock_keys=(obj); end

  def unlock_strategy(); end

  def unlock_strategy=(obj); end

  def warden_config(); end

  def warden_config=(obj); end
  ALL = ::T.let(nil, ::T.untyped)
  CONTROLLERS = ::T.let(nil, ::T.untyped)
  NO_INPUT = ::T.let(nil, ::T.untyped)
  ROUTES = ::T.let(nil, ::T.untyped)
  STRATEGIES = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
  URL_HELPERS = ::T.let(nil, ::T.untyped)
end

class Devise::ConfirmationsController
  def after_confirmation_path_for(resource_name, resource); end

  def after_resending_confirmation_instructions_path_for(resource_name); end

  def create(); end

  def new(); end

  def show(); end
end

class Devise::ConfirmationsController
end

module Devise::Controllers
end

module Devise::Controllers::Helpers
  include ::Devise::Controllers::SignInOut
  include ::Devise::Controllers::StoreLocation
  def after_sign_in_path_for(resource_or_scope); end

  def after_sign_out_path_for(resource_or_scope); end

  def allow_params_authentication!(); end

  def authenticate_user!(opts=T.unsafe(nil)); end

  def current_user(); end

  def devise_controller?(); end

  def devise_parameter_sanitizer(); end

  def handle_unverified_request(); end

  def is_flashing_format?(); end

  def is_navigational_format?(); end

  def request_format(); end

  def sign_in_and_redirect(resource_or_scope, *args); end

  def sign_out_and_redirect(resource_or_scope); end

  def signed_in_root_path(resource_or_scope); end

  def user_session(); end

  def user_signed_in?(); end

  def warden(); end
end

module Devise::Controllers::Helpers
  extend ::ActiveSupport::Concern
  def self.define_helpers(mapping); end
end

module Devise::Controllers::Rememberable
  def forget_cookie_values(resource); end

  def forget_me(resource); end

  def remember_cookie_values(resource); end

  def remember_key(resource, scope); end

  def remember_me(resource); end

  def remember_me_is_active?(resource); end
end

module Devise::Controllers::Rememberable
  def self.cookie_values(); end
end

module Devise::Controllers::ScopedViews
end

module Devise::Controllers::ScopedViews
  extend ::ActiveSupport::Concern
end

module Devise::Controllers::SignInOut
  def bypass_sign_in(resource, scope: T.unsafe(nil)); end

  def sign_in(resource_or_scope, *args); end

  def sign_out(resource_or_scope=T.unsafe(nil)); end

  def sign_out_all_scopes(lock=T.unsafe(nil)); end

  def signed_in?(scope=T.unsafe(nil)); end
end

module Devise::Controllers::SignInOut
end

module Devise::Controllers::StoreLocation
  def store_location_for(resource_or_scope, location); end

  def stored_location_for(resource_or_scope); end
end

module Devise::Controllers::StoreLocation
end

module Devise::Controllers::UrlHelpers
  def cancel_registration_path(resource_or_scope, *args); end

  def cancel_registration_url(resource_or_scope, *args); end

  def destroy_session_path(resource_or_scope, *args); end

  def destroy_session_url(resource_or_scope, *args); end

  def edit_password_path(resource_or_scope, *args); end

  def edit_password_url(resource_or_scope, *args); end

  def edit_registration_path(resource_or_scope, *args); end

  def edit_registration_url(resource_or_scope, *args); end

  def new_password_path(resource_or_scope, *args); end

  def new_password_url(resource_or_scope, *args); end

  def new_registration_path(resource_or_scope, *args); end

  def new_registration_url(resource_or_scope, *args); end

  def new_session_path(resource_or_scope, *args); end

  def new_session_url(resource_or_scope, *args); end

  def password_path(resource_or_scope, *args); end

  def password_url(resource_or_scope, *args); end

  def registration_path(resource_or_scope, *args); end

  def registration_url(resource_or_scope, *args); end

  def session_path(resource_or_scope, *args); end

  def session_url(resource_or_scope, *args); end
end

module Devise::Controllers::UrlHelpers
  def self.generate_helpers!(routes=T.unsafe(nil)); end

  def self.remove_helpers!(); end
end

module Devise::Controllers
end

class Devise::Delegator
  def call(env); end

  def failure_app(env); end
end

class Devise::Delegator
end

module Devise::Encryptor
end

module Devise::Encryptor
  def self.compare(klass, hashed_password, password); end

  def self.digest(klass, password); end
end

class Devise::Engine
end

class Devise::Engine
end

class Devise::FailureApp
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::Devise::Controllers::StoreLocation
  def attempted_path(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def flash(*args, &block); end

  def http_auth(); end

  def http_auth?(); end

  def http_auth_body(); end

  def http_auth_header?(); end

  def i18n_message(default=T.unsafe(nil)); end

  def i18n_options(options); end

  def is_flashing_format?(); end

  def is_navigational_format?(); end

  def logger(); end

  def logger=(value); end

  def recall(); end

  def recall_app(app); end

  def redirect(); end

  def redirect_url(); end

  def relative_url_root(); end

  def relative_url_root?(); end

  def request_format(); end

  def respond(); end

  def route(scope); end

  def scope(); end

  def scope_class(); end

  def scope_url(); end

  def skip_format?(); end

  def store_location!(); end

  def warden(); end

  def warden_message(); end

  def warden_options(); end
end

class Devise::FailureApp
  extend ::AbstractController::UrlFor::ClassMethods
  def self.call(env); end

  def self.default_url_options(*args); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.logger(); end

  def self.logger=(value); end
end

class Devise::Getter
  def get(); end

  def initialize(name); end
end

class Devise::Getter
end

module Devise::Hooks
end

class Devise::Hooks::Proxy
  include ::Devise::Controllers::Rememberable
  include ::Devise::Controllers::SignInOut
  def cookies(*args, &block); end

  def initialize(warden); end

  def request(*args, &block); end

  def session(); end

  def warden(); end
end

class Devise::Hooks::Proxy
end

module Devise::Hooks
end

class Devise::Mailer
  include ::Devise::Mailers::Helpers
  include ::Devise::Controllers::ScopedViews
  def confirmation_instructions(record, token, opts=T.unsafe(nil)); end

  def email_changed(record, opts=T.unsafe(nil)); end

  def password_change(record, opts=T.unsafe(nil)); end

  def reset_password_instructions(record, token, opts=T.unsafe(nil)); end

  def unlock_instructions(record, token, opts=T.unsafe(nil)); end
end

class Devise::Mailer
end

module Devise::Mailers
end

module Devise::Mailers::Helpers
  def devise_mail(record, action, opts=T.unsafe(nil), &block); end

  def devise_mapping(); end

  def headers_for(action, opts); end

  def initialize_from_record(record); end

  def mailer_from(mapping); end

  def mailer_reply_to(mapping); end

  def mailer_sender(mapping, sender=T.unsafe(nil)); end

  def resource(); end

  def scope_name(); end

  def subject_for(key); end

  def template_paths(); end
end

module Devise::Mailers::Helpers
  extend ::ActiveSupport::Concern
end

module Devise::Mailers
end

class Devise::Mapping
  def authenticatable?(); end

  def class_name(); end

  def confirmable?(); end

  def controllers(); end

  def database_authenticatable?(); end

  def failure_app(); end

  def format(); end

  def fullpath(); end

  def initialize(name, options); end

  def lockable?(); end

  def modules(); end

  def name(); end

  def no_input_strategies(); end

  def omniauthable?(); end

  def path(); end

  def path_names(); end

  def recoverable?(); end

  def registerable?(); end

  def rememberable?(); end

  def router_name(); end

  def routes(); end

  def scoped_path(); end

  def sign_out_via(); end

  def singular(); end

  def strategies(); end

  def timeoutable?(); end

  def to(); end

  def trackable?(); end

  def used_helpers(); end

  def used_routes(); end

  def validatable?(); end
end

class Devise::Mapping
  def self.add_module(m); end

  def self.find_by_path!(path, path_type=T.unsafe(nil)); end

  def self.find_scope!(obj); end
end

class Devise::MissingWarden
  def initialize(); end
end

class Devise::MissingWarden
end

module Devise::Models
  def devise(*modules); end

  def devise_modules_hook!(); end
end

module Devise::Models::Authenticatable
  def active_for_authentication?(); end

  def apply_to_attribute_or_variable(attr, method); end

  def authenticatable_salt(); end

  def devise_mailer(); end

  def downcase_keys(); end

  def inactive_message(); end

  def inspect(); end

  def send_devise_notification(notification, *args); end

  def serializable_hash(options=T.unsafe(nil)); end

  def strip_whitespace(); end

  def unauthenticated_message(); end

  def valid_for_authentication?(); end
  BLACKLIST_FOR_SERIALIZATION = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Authenticatable::ClassMethods
  def authentication_keys(); end

  def authentication_keys=(value); end

  def case_insensitive_keys(); end

  def case_insensitive_keys=(value); end

  def devise_parameter_filter(); end

  def find_first_by_auth_conditions(tainted_conditions, opts=T.unsafe(nil)); end

  def find_for_authentication(tainted_conditions); end

  def find_or_initialize_with_error_by(attribute, value, error=T.unsafe(nil)); end

  def find_or_initialize_with_errors(required_attributes, attributes, error=T.unsafe(nil)); end

  def http_authenticatable(); end

  def http_authenticatable=(value); end

  def http_authenticatable?(strategy); end

  def http_authentication_key(); end

  def http_authentication_key=(value); end

  def params_authenticatable(); end

  def params_authenticatable=(value); end

  def params_authenticatable?(strategy); end

  def request_keys(); end

  def request_keys=(value); end

  def serialize_from_session(key, salt); end

  def serialize_into_session(record); end

  def skip_session_storage(); end

  def skip_session_storage=(value); end

  def strip_whitespace_keys(); end

  def strip_whitespace_keys=(value); end
end

module Devise::Models::Authenticatable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Authenticatable
  extend ::ActiveSupport::Concern
  def self.required_fields(klass); end
end

module Devise::Models::Confirmable
  def active_for_authentication?(); end

  def after_confirmation(); end

  def confirm(args=T.unsafe(nil)); end

  def confirmation_period_expired?(); end

  def confirmation_period_valid?(); end

  def confirmation_required?(); end

  def confirmed?(); end

  def generate_confirmation_token(); end

  def generate_confirmation_token!(); end

  def inactive_message(); end

  def initialize(*args, &block); end

  def pending_any_confirmation(); end

  def pending_reconfirmation?(); end

  def postpone_email_change?(); end

  def postpone_email_change_until_confirmation_and_regenerate_confirmation_token(); end

  def reconfirmation_required?(); end

  def resend_confirmation_instructions(); end

  def send_confirmation_instructions(); end

  def send_confirmation_notification?(); end

  def send_email_changed_notification?(); end

  def send_on_create_confirmation_instructions(); end

  def send_reconfirmation_instructions(); end

  def skip_confirmation!(); end

  def skip_confirmation_notification!(); end

  def skip_reconfirmation!(); end

  def skip_reconfirmation_in_callback!(); end
end

module Devise::Models::Confirmable::ClassMethods
  def allow_unconfirmed_access_for(); end

  def allow_unconfirmed_access_for=(value); end

  def confirm_by_token(confirmation_token); end

  def confirm_within(); end

  def confirm_within=(value); end

  def confirmation_keys(); end

  def confirmation_keys=(value); end

  def find_by_unconfirmed_email_with_errors(attributes=T.unsafe(nil)); end

  def reconfirmable(); end

  def reconfirmable=(value); end

  def send_confirmation_instructions(attributes=T.unsafe(nil)); end
end

module Devise::Models::Confirmable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Confirmable
  extend ::ActiveSupport::Concern
  def self.required_fields(klass); end
end

module Devise::Models::DatabaseAuthenticatable
  def after_database_authentication(); end

  def authenticatable_salt(); end

  def clean_up_passwords(); end

  def destroy_with_password(current_password); end

  def initialize(*args, &block); end

  def password=(new_password); end

  def password_digest(password); end

  def send_email_changed_notification(); end

  def send_email_changed_notification?(); end

  def send_password_change_notification(); end

  def send_password_change_notification?(); end

  def skip_email_changed_notification!(); end

  def skip_password_change_notification!(); end

  def update_with_password(params, *options); end

  def update_without_password(params, *options); end

  def valid_password?(password); end
end

module Devise::Models::DatabaseAuthenticatable::ClassMethods
  def find_for_database_authentication(conditions); end

  def pepper(); end

  def pepper=(value); end

  def send_email_changed_notification(); end

  def send_email_changed_notification=(value); end

  def send_password_change_notification(); end

  def send_password_change_notification=(value); end

  def stretches(); end

  def stretches=(value); end
end

module Devise::Models::DatabaseAuthenticatable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::DatabaseAuthenticatable
  extend ::ActiveSupport::Concern
  def self.required_fields(klass); end
end

module Devise::Models::Lockable
  def access_locked?(); end

  def active_for_authentication?(); end

  def attempts_exceeded?(); end

  def if_access_locked(); end

  def inactive_message(); end

  def increment_failed_attempts(); end

  def last_attempt?(); end

  def lock_access!(opts=T.unsafe(nil)); end

  def lock_expired?(); end

  def lock_strategy_enabled?(*args, &block); end

  def resend_unlock_instructions(); end

  def send_unlock_instructions(); end

  def unauthenticated_message(); end

  def unlock_access!(); end

  def unlock_strategy_enabled?(*args, &block); end

  def valid_for_authentication?(); end
end

module Devise::Models::Lockable::ClassMethods
  def last_attempt_warning(); end

  def last_attempt_warning=(value); end

  def lock_strategy(); end

  def lock_strategy=(value); end

  def lock_strategy_enabled?(strategy); end

  def maximum_attempts(); end

  def maximum_attempts=(value); end

  def send_unlock_instructions(attributes=T.unsafe(nil)); end

  def unlock_access_by_token(unlock_token); end

  def unlock_in(); end

  def unlock_in=(value); end

  def unlock_keys(); end

  def unlock_keys=(value); end

  def unlock_strategy(); end

  def unlock_strategy=(value); end

  def unlock_strategy_enabled?(strategy); end
  BOTH_STRATEGIES = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Lockable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Lockable
  extend ::ActiveSupport::Concern
  def self.required_fields(klass); end
end

class Devise::Models::MissingAttribute
  def initialize(attributes); end
end

class Devise::Models::MissingAttribute
end

module Devise::Models::Recoverable
  def clear_reset_password_token(); end

  def clear_reset_password_token?(); end

  def reset_password(new_password, new_password_confirmation); end

  def reset_password_period_valid?(); end

  def send_reset_password_instructions(); end

  def send_reset_password_instructions_notification(token); end

  def set_reset_password_token(); end
end

module Devise::Models::Recoverable::ClassMethods
  def reset_password_by_token(attributes=T.unsafe(nil)); end

  def reset_password_keys(); end

  def reset_password_keys=(value); end

  def reset_password_within(); end

  def reset_password_within=(value); end

  def send_reset_password_instructions(attributes=T.unsafe(nil)); end

  def sign_in_after_reset_password(); end

  def sign_in_after_reset_password=(value); end

  def with_reset_password_token(token); end
end

module Devise::Models::Recoverable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Recoverable
  extend ::ActiveSupport::Concern
  def self.required_fields(klass); end
end

module Devise::Models::Registerable
end

module Devise::Models::Registerable::ClassMethods
  def new_with_session(params, session); end

  def sign_in_after_change_password(); end

  def sign_in_after_change_password=(value); end
end

module Devise::Models::Registerable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Registerable
  extend ::ActiveSupport::Concern
  def self.required_fields(klass); end
end

module Devise::Models::Rememberable
  def after_remembered(); end

  def extend_remember_period(); end

  def forget_me!(); end

  def remember_expires_at(); end

  def remember_me(); end

  def remember_me!(); end

  def remember_me=(remember_me); end

  def remember_me?(token, generated_at); end

  def rememberable_options(); end

  def rememberable_value(); end
end

module Devise::Models::Rememberable::ClassMethods
  def expire_all_remember_me_on_sign_out(); end

  def expire_all_remember_me_on_sign_out=(value); end

  def extend_remember_period(); end

  def extend_remember_period=(value); end

  def remember_for(); end

  def remember_for=(value); end

  def remember_token(); end

  def rememberable_options(); end

  def rememberable_options=(value); end

  def serialize_from_cookie(*args); end

  def serialize_into_cookie(record); end
end

module Devise::Models::Rememberable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Rememberable
  extend ::ActiveSupport::Concern
  def self.required_fields(klass); end
end

module Devise::Models::Timeoutable
  def timedout?(last_access); end

  def timeout_in(); end
end

module Devise::Models::Timeoutable::ClassMethods
  def timeout_in(); end

  def timeout_in=(value); end
end

module Devise::Models::Timeoutable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Timeoutable
  extend ::ActiveSupport::Concern
  def self.required_fields(klass); end
end

module Devise::Models::Trackable
  def extract_ip_from(request); end

  def update_tracked_fields(request); end

  def update_tracked_fields!(request); end
end

module Devise::Models::Trackable
  def self.required_fields(klass); end
end

module Devise::Models::Validatable
  def email_required?(); end

  def password_required?(); end
  VALIDATIONS = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Validatable::ClassMethods
  def email_regexp(); end

  def email_regexp=(value); end

  def password_length(); end

  def password_length=(value); end
end

module Devise::Models::Validatable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Validatable
  def self.assert_validations_api!(base); end

  def self.included(base); end

  def self.required_fields(klass); end
end

module Devise::Models
  def self.check_fields!(klass); end

  def self.config(mod, *accessors); end
end

class Devise::OmniauthCallbacksController
  def after_omniauth_failure_path_for(scope); end

  def failed_strategy(); end

  def failure(); end

  def failure_message(); end

  def passthru(); end
end

class Devise::OmniauthCallbacksController
end

class Devise::ParameterFilter
  def filter(conditions); end

  def filtered_hash_by_method_for_given_keys(conditions, method, condition_keys); end

  def initialize(case_insensitive_keys, strip_whitespace_keys); end

  def stringify_params(conditions); end
end

class Devise::ParameterFilter
end

class Devise::ParameterSanitizer
  def initialize(resource_class, resource_name, params); end

  def permit(action, keys: T.unsafe(nil), except: T.unsafe(nil), &block); end

  def sanitize(action); end
  DEFAULT_PERMITTED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Devise::ParameterSanitizer
end

class Devise::PasswordsController
  def after_resetting_password_path_for(resource); end

  def after_sending_reset_password_instructions_path_for(resource_name); end

  def assert_reset_token_passed(); end

  def create(); end

  def edit(); end

  def new(); end

  def unlockable?(resource); end

  def update(); end
end

class Devise::PasswordsController
end

class Devise::RegistrationsController
  def account_update_params(); end

  def after_inactive_sign_up_path_for(resource); end

  def after_sign_up_path_for(resource); end

  def after_update_path_for(resource); end

  def authenticate_scope!(); end

  def build_resource(hash=T.unsafe(nil)); end

  def cancel(); end

  def create(); end

  def destroy(); end

  def edit(); end

  def new(); end

  def sign_up(resource_name, resource); end

  def sign_up_params(); end

  def update(); end

  def update_needs_confirmation?(resource, previous); end

  def update_resource(resource, params); end
end

class Devise::RegistrationsController
end

module Devise::RouteSet
  def finalize!(); end
end

module Devise::RouteSet
end

class Devise::SecretKeyFinder
  def find(); end

  def initialize(application); end
end

class Devise::SecretKeyFinder
end

class Devise::SessionsController
  def auth_options(); end

  def create(); end

  def destroy(); end

  def new(); end

  def serialize_options(resource); end

  def sign_in_params(); end
end

class Devise::SessionsController
end

module Devise::Strategies
end

class Devise::Strategies::Authenticatable
  def authentication_hash(); end

  def authentication_hash=(authentication_hash); end

  def authentication_type(); end

  def authentication_type=(authentication_type); end

  def clean_up_csrf?(); end

  def password(); end

  def password=(password); end
end

class Devise::Strategies::Authenticatable
end

class Devise::Strategies::Base
  def mapping(); end
end

class Devise::Strategies::Base
end

class Devise::Strategies::DatabaseAuthenticatable
  def authenticate!(); end
end

class Devise::Strategies::DatabaseAuthenticatable
end

class Devise::Strategies::Rememberable
  def authenticate!(); end
end

class Devise::Strategies::Rememberable
end

module Devise::Strategies
end

module Devise::Test
end

module Devise::Test::ControllerHelpers
  def _catch_warden(&block); end

  def _process_unauthenticated(env, options=T.unsafe(nil)); end

  def process(*_); end

  def setup_controller_for_warden(); end

  def sign_in(resource, deprecated=T.unsafe(nil), scope: T.unsafe(nil)); end

  def sign_out(resource_or_scope); end

  def warden(); end
end

module Devise::Test::ControllerHelpers
  extend ::ActiveSupport::Concern
end

module Devise::Test::IntegrationHelpers
  def setup_integration_for_devise(); end

  def sign_in(resource, scope: T.unsafe(nil)); end

  def sign_out(resource_or_scope); end

  def teardown_integration_for_devise(); end
end

module Devise::Test::IntegrationHelpers
  def self.included(base); end
end

module Devise::Test
end

module Devise::TestHelpers
end

module Devise::TestHelpers
  def self.included(base); end
end

class Devise::TimeInflector
  include ::ActionView::Helpers::DateHelper
end

class Devise::TimeInflector
  def self.instance(); end

  def self.time_ago_in_words(*args, &block); end
end

class Devise::TokenGenerator
  def digest(klass, column, value); end

  def generate(klass, column); end

  def initialize(key_generator, digest=T.unsafe(nil)); end
end

class Devise::TokenGenerator
end

class Devise::UnlocksController
  def after_sending_unlock_instructions_path_for(resource); end

  def after_unlock_path_for(resource); end

  def create(); end

  def new(); end

  def show(); end
end

class Devise::UnlocksController
end

module Devise
  def self.activerecord51?(); end

  def self.add_mapping(resource, options); end

  def self.add_module(module_name, options=T.unsafe(nil)); end

  def self.allow_unconfirmed_access_for(); end

  def self.allow_unconfirmed_access_for=(obj); end

  def self.authentication_keys(); end

  def self.authentication_keys=(obj); end

  def self.available_router_name(); end

  def self.case_insensitive_keys(); end

  def self.case_insensitive_keys=(obj); end

  def self.clean_up_csrf_token_on_authentication(); end

  def self.clean_up_csrf_token_on_authentication=(obj); end

  def self.configure_warden!(); end

  def self.confirm_within(); end

  def self.confirm_within=(obj); end

  def self.confirmation_keys(); end

  def self.confirmation_keys=(obj); end

  def self.default_scope(); end

  def self.default_scope=(obj); end

  def self.email_regexp(); end

  def self.email_regexp=(obj); end

  def self.expire_all_remember_me_on_sign_out(); end

  def self.expire_all_remember_me_on_sign_out=(obj); end

  def self.extend_remember_period(); end

  def self.extend_remember_period=(obj); end

  def self.friendly_token(length=T.unsafe(nil)); end

  def self.helpers(); end

  def self.http_authenticatable(); end

  def self.http_authenticatable=(obj); end

  def self.http_authenticatable_on_xhr(); end

  def self.http_authenticatable_on_xhr=(obj); end

  def self.http_authentication_key(); end

  def self.http_authentication_key=(obj); end

  def self.http_authentication_realm(); end

  def self.http_authentication_realm=(obj); end

  def self.include_helpers(scope); end

  def self.last_attempt_warning(); end

  def self.last_attempt_warning=(obj); end

  def self.lock_strategy(); end

  def self.lock_strategy=(obj); end

  def self.mailer(); end

  def self.mailer=(class_name); end

  def self.mailer_sender(); end

  def self.mailer_sender=(obj); end

  def self.mappings(); end

  def self.maximum_attempts(); end

  def self.maximum_attempts=(obj); end

  def self.navigational_formats(); end

  def self.navigational_formats=(obj); end

  def self.omniauth(provider, *args); end

  def self.omniauth_configs(); end

  def self.omniauth_path_prefix(); end

  def self.omniauth_path_prefix=(obj); end

  def self.omniauth_providers(); end

  def self.params_authenticatable(); end

  def self.params_authenticatable=(obj); end

  def self.paranoid(); end

  def self.paranoid=(obj); end

  def self.parent_controller(); end

  def self.parent_controller=(obj); end

  def self.parent_mailer(); end

  def self.parent_mailer=(obj); end

  def self.password_length(); end

  def self.password_length=(obj); end

  def self.pepper(); end

  def self.pepper=(obj); end

  def self.reconfirmable(); end

  def self.reconfirmable=(obj); end

  def self.ref(arg); end

  def self.regenerate_helpers!(); end

  def self.reload_routes(); end

  def self.reload_routes=(obj); end

  def self.remember_for(); end

  def self.remember_for=(obj); end

  def self.rememberable_options(); end

  def self.rememberable_options=(obj); end

  def self.request_keys(); end

  def self.request_keys=(obj); end

  def self.reset_password_keys(); end

  def self.reset_password_keys=(obj); end

  def self.reset_password_within(); end

  def self.reset_password_within=(obj); end

  def self.router_name(); end

  def self.router_name=(obj); end

  def self.scoped_views(); end

  def self.scoped_views=(obj); end

  def self.secret_key(); end

  def self.secret_key=(obj); end

  def self.secure_compare(a, b); end

  def self.send_email_changed_notification(); end

  def self.send_email_changed_notification=(obj); end

  def self.send_password_change_notification(); end

  def self.send_password_change_notification=(obj); end

  def self.setup(); end

  def self.sign_in_after_change_password(); end

  def self.sign_in_after_change_password=(obj); end

  def self.sign_in_after_reset_password(); end

  def self.sign_in_after_reset_password=(obj); end

  def self.sign_out_all_scopes(); end

  def self.sign_out_all_scopes=(obj); end

  def self.sign_out_via(); end

  def self.sign_out_via=(obj); end

  def self.skip_session_storage(); end

  def self.skip_session_storage=(obj); end

  def self.stretches(); end

  def self.stretches=(obj); end

  def self.strip_whitespace_keys(); end

  def self.strip_whitespace_keys=(obj); end

  def self.timeout_in(); end

  def self.timeout_in=(obj); end

  def self.token_generator(); end

  def self.token_generator=(obj); end

  def self.unlock_in(); end

  def self.unlock_in=(obj); end

  def self.unlock_keys(); end

  def self.unlock_keys=(obj); end

  def self.unlock_strategy(); end

  def self.unlock_strategy=(obj); end

  def self.warden(&block); end

  def self.warden_config(); end

  def self.warden_config=(obj); end
end

module DeviseBootstrapViews
end

class DeviseBootstrapViews::Engine
end

class DeviseBootstrapViews::Engine
end

class DeviseBootstrapViews::Railtie
end

class DeviseBootstrapViews::Railtie
  def self.pattern_from(args); end
end

module DeviseBootstrapViews
end

module DeviseBootstrapViewsHelper
  def bootstrap_devise_error_messages!(); end
end

module DeviseBootstrapViewsHelper
end

class DeviseController
  include ::Devise::Controllers::ScopedViews
  def assert_is_devise_resource!(); end

  def clean_up_passwords(object); end

  def devise_i18n_options(options); end

  def devise_mapping(); end

  def find_message(kind, options=T.unsafe(nil)); end

  def navigational_formats(); end

  def require_no_authentication(); end

  def resource(); end

  def resource=(new_resource); end

  def resource_class(); end

  def resource_name(); end

  def resource_params(); end

  def respond_with_navigational(*args, &block); end

  def scope_name(); end

  def set_flash_message(key, kind, options=T.unsafe(nil)); end

  def set_flash_message!(key, kind, options=T.unsafe(nil)); end

  def set_minimum_password_length(); end

  def signed_in_resource(); end

  def successfully_sent?(resource); end

  def translation_scope(); end

  def unknown_action!(msg); end
end

class DeviseController
end

module DeviseHelper
  def devise_error_messages!(); end
end

module DeviseHelper
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

module Diff
end

module Diff::LCS
  def diff(other, callbacks=T.unsafe(nil), &block); end

  def lcs(other, &block); end

  def patch(patchset); end

  def patch!(patchset); end

  def patch_me(patchset); end

  def sdiff(other, callbacks=T.unsafe(nil), &block); end

  def traverse_balanced(other, callbacks=T.unsafe(nil), &block); end

  def traverse_sequences(other, callbacks=T.unsafe(nil), &block); end

  def unpatch(patchset); end

  def unpatch!(patchset); end

  def unpatch_me(patchset); end
  VERSION = ::T.let(nil, ::T.untyped)
end

Diff::LCS::BalancedCallbacks = Diff::LCS::DefaultCallbacks

class Diff::LCS::Block
  def changes(); end

  def diff_size(); end

  def initialize(chunk); end

  def insert(); end

  def op(); end

  def remove(); end
end

class Diff::LCS::Block
end

class Diff::LCS::Change
  include ::Comparable
  def ==(other); end

  def action(); end

  def adding?(); end

  def changed?(); end

  def deleting?(); end

  def element(); end

  def finished_a?(); end

  def finished_b?(); end

  def initialize(*args); end

  def inspect(*_args); end

  def position(); end

  def to_a(); end

  def to_ary(); end

  def unchanged?(); end
  VALID_ACTIONS = ::T.let(nil, ::T.untyped)
end

Diff::LCS::Change::IntClass = Integer

class Diff::LCS::Change
  def self.from_a(arr); end

  def self.valid_action?(action); end
end

class Diff::LCS::ContextChange
  def new_element(); end

  def new_position(); end

  def old_element(); end

  def old_position(); end
end

class Diff::LCS::ContextChange
  def self.simplify(event); end
end

class Diff::LCS::ContextDiffCallbacks
  def change(event); end
end

class Diff::LCS::ContextDiffCallbacks
end

class Diff::LCS::DefaultCallbacks
end

class Diff::LCS::DefaultCallbacks
  def self.change(event); end

  def self.discard_a(event); end

  def self.discard_b(event); end

  def self.match(event); end
end

class Diff::LCS::DiffCallbacks
  def diffs(); end

  def discard_a(event); end

  def discard_b(event); end

  def finish(); end

  def match(_event); end
end

class Diff::LCS::DiffCallbacks
end

class Diff::LCS::Hunk
  def blocks(); end

  def diff(format, last=T.unsafe(nil)); end

  def end_new(); end

  def end_old(); end

  def file_length_difference(); end

  def flag_context(); end

  def flag_context=(context); end

  def initialize(data_old, data_new, piece, flag_context, file_length_difference); end

  def merge(hunk); end

  def missing_last_newline?(data); end

  def overlaps?(hunk); end

  def start_new(); end

  def start_old(); end

  def unshift(hunk); end
end

class Diff::LCS::Hunk
end

module Diff::LCS::Internals
end

module Diff::LCS::Internals
  def self.analyze_patchset(patchset, depth=T.unsafe(nil)); end

  def self.intuit_diff_direction(src, patchset, limit=T.unsafe(nil)); end

  def self.lcs(a, b); end
end

class Diff::LCS::SDiffCallbacks
  def change(event); end

  def diffs(); end

  def discard_a(event); end

  def discard_b(event); end

  def match(event); end
end

class Diff::LCS::SDiffCallbacks
end

Diff::LCS::SequenceCallbacks = Diff::LCS::DefaultCallbacks

module Diff::LCS
  def self.LCS(seq1, seq2, &block); end

  def self.callbacks_for(callbacks); end

  def self.diff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.lcs(seq1, seq2, &block); end

  def self.patch(src, patchset, direction=T.unsafe(nil)); end

  def self.patch!(src, patchset); end

  def self.sdiff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.traverse_balanced(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.traverse_sequences(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.unpatch!(src, patchset); end
end

module Diff
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  def self.uuid_from_hash(hash_class, uuid_namespace, name); end

  def self.uuid_v3(uuid_namespace, name); end

  def self.uuid_v4(); end

  def self.uuid_v5(uuid_namespace, name); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.exists?(_); end

end

module Docile
  VERSION = ::T.let(nil, ::T.untyped)
end

class Docile::ChainingFallbackContextProxy
end

class Docile::ChainingFallbackContextProxy
end

module Docile::Execution
end

module Docile::Execution
  def self.exec_in_proxy_context(dsl, proxy_type, *args, &block); end
end

class Docile::FallbackContextProxy
  def initialize(receiver, fallback); end

  def method_missing(method, *args, &block); end
  NON_FALLBACK_METHODS = ::T.let(nil, ::T.untyped)
  NON_PROXIED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  NON_PROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class Docile::FallbackContextProxy
end

module Docile
  extend ::Docile::Execution
  def self.dsl_eval(dsl, *args, &block); end

  def self.dsl_eval_immutable(dsl, *args, &block); end

  def self.dsl_eval_with_block_return(dsl, *args, &block); end
end

module Dry
end

module Dry::Configurable
  include ::Dry::Core::Constants
  def enable_test_interface(); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class Dry::Configurable::AlreadyIncluded
end

class Dry::Configurable::AlreadyIncluded
end

module Dry::Configurable::ClassMethods
  include ::Dry::Configurable::Methods
  def __config_dsl__(); end

  def __config_reader__(); end

  def _settings(); end

  def config(); end

  def inherited(klass); end

  def setting(*args, &block); end

  def settings(); end
end

module Dry::Configurable::ClassMethods
end

class Dry::Configurable::Compiler
  def call(ast); end

  def visit(node); end

  def visit_constructor(node); end

  def visit_nested(node); end

  def visit_setting(node); end
end

class Dry::Configurable::Compiler
end

class Dry::Configurable::Config
  include ::Dry::Equalizer::Methods
  def [](name); end

  def []=(name, value); end

  def _resolved(); end

  def _settings(); end

  def finalize!(); end

  def initialize(settings); end

  def pristine(); end

  def to_h(); end

  def to_hash(); end

  def update(values); end

  def values(); end
end

class Dry::Configurable::Config
end

class Dry::Configurable::DSL
  def ast(); end

  def compiler(); end

  def initialize(&block); end

  def setting(name, *args, &block); end
  VALID_NAME = ::T.let(nil, ::T.untyped)
end

class Dry::Configurable::DSL::Args
  def args(); end

  def default(); end

  def ensure_valid_options(); end

  def initialize(args); end

  def options(); end

  def opts(); end

  def size(); end

  def to_ary(); end
end

class Dry::Configurable::DSL::Args
end

class Dry::Configurable::DSL
end

class Dry::Configurable::Error
end

class Dry::Configurable::Error
end

class Dry::Configurable::FrozenConfig
end

class Dry::Configurable::FrozenConfig
end

module Dry::Configurable::InstanceMethods
  include ::Dry::Configurable::Methods
  def config(); end

  def finalize!(); end

  def initialize(*_); end
end

module Dry::Configurable::InstanceMethods
end

module Dry::Configurable::Methods
  def configure(&block); end

  def finalize!(); end
end

module Dry::Configurable::Methods
end

class Dry::Configurable::Setting
  include ::Dry::Equalizer::Methods
  def clonable_value?(); end

  def constructor(); end

  def default(); end

  def evaluated?(); end

  def initialize(name, input: T.unsafe(nil), default: T.unsafe(nil), **options); end

  def input(); end

  def input_defined?(); end

  def name(); end

  def nested(settings); end

  def options(); end

  def pristine(); end

  def reader?(); end

  def value(); end

  def with(new_opts); end

  def writer?(meth); end

  def writer_name(); end
  CLONABLE_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  DEFAULT_CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Dry::Configurable::Setting::Nested
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
end

class Dry::Configurable::Setting::Nested
end

class Dry::Configurable::Setting
end

class Dry::Configurable::Settings
  include ::Dry::Equalizer::Methods
  include ::Enumerable
  def <<(setting); end

  def [](name); end

  def each(&block); end

  def elements(); end

  def initialize(elements=T.unsafe(nil)); end

  def key?(name); end

  def keys(); end

  def pristine(); end
end

class Dry::Configurable::Settings
end

module Dry::Configurable::TestInterface
  def reset_config(); end
end

module Dry::Configurable::TestInterface
end

module Dry::Configurable
  def self.extended(klass); end

  def self.included(klass); end
end

module Dry::Core
  VERSION = ::T.let(nil, ::T.untyped)
end

module Dry::Core::Constants
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

module Dry::Core::Constants
  def self.included(base); end
end

module Dry::Core
end

class Dry::Equalizer
  def initialize(*keys, **options); end
end

module Dry::Equalizer::Methods
  def ==(other); end

  def eql?(other); end
end

module Dry::Equalizer::Methods
end

class Dry::Equalizer
end

module Dry
  def self.Equalizer(*keys, **options); end
end

EM = EventMachine

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  def self.html_escape_once(s); end

  def self.json_escape(s); end

  def self.unwrapped_html_escape(s); end
end

class Ec2::Instance
  include ::Ec2::Instance::GeneratedAttributeMethods
  include ::Ec2::Instance::GeneratedAssociationMethods
  def autosave_associated_records_for_run(*args); end
end

module Ec2::Instance::GeneratedAssociationMethods
  def build_run(*args, &block); end

  def create_run(*args, &block); end

  def create_run!(*args, &block); end

  def reload_run(); end

  def run(); end

  def run=(value); end
end

module Ec2::Instance::GeneratedAssociationMethods
end

module Ec2::Instance::GeneratedAttributeMethods
end

module Ec2::Instance::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def as_json(options=T.unsafe(nil)); end

  def chain(*_); end

  def exclude?(object); end

  def excluding(*elements); end

  def including(*elements); end

  def index_with(default=T.unsafe(nil)); end

  def many?(); end

  def pluck(*keys); end

  def sum(identity=T.unsafe(nil), &block); end

  def without(*elements); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

module Equatable
  def attr_reader(*args); end

  def comparison_attrs(); end

  def inherited(subclass); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Equatable::Methods
  def ==(other); end

  def eql?(other); end
end

module Equatable::Methods
end

module Equatable
  def self.included(base); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Erubi
  RANGE_ALL = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  TEXT_END = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Erubi::Engine
  def bufvar(); end

  def filename(); end

  def initialize(input, properties=T.unsafe(nil)); end

  def src(); end
end

class Erubi::Engine
end

module Erubi
  def self.h(value); end
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

module EventMachine
  ConnectionAccepted = ::T.let(nil, ::T.untyped)
  ConnectionCompleted = ::T.let(nil, ::T.untyped)
  ConnectionData = ::T.let(nil, ::T.untyped)
  ConnectionNotifyReadable = ::T.let(nil, ::T.untyped)
  ConnectionNotifyWritable = ::T.let(nil, ::T.untyped)
  ConnectionUnbound = ::T.let(nil, ::T.untyped)
  EM_PROTO_SSLv2 = ::T.let(nil, ::T.untyped)
  EM_PROTO_SSLv3 = ::T.let(nil, ::T.untyped)
  EM_PROTO_TLSv1 = ::T.let(nil, ::T.untyped)
  EM_PROTO_TLSv1_1 = ::T.let(nil, ::T.untyped)
  EM_PROTO_TLSv1_2 = ::T.let(nil, ::T.untyped)
  ERRNOS = ::T.let(nil, ::T.untyped)
  LoopbreakSignalled = ::T.let(nil, ::T.untyped)
  SslHandshakeCompleted = ::T.let(nil, ::T.untyped)
  SslVerify = ::T.let(nil, ::T.untyped)
  TimerFired = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class EventMachine::Channel
  def <<(*items); end

  def num_subscribers(); end

  def pop(*a, &b); end

  def push(*items); end

  def subscribe(*a, &b); end

  def unsubscribe(name); end
end

class EventMachine::Channel
end

class EventMachine::Completion
  include ::EventMachine::Deferrable
  def callback(*a, &b); end

  def cancel_callback(*a, &b); end

  def cancel_errback(*a, &b); end

  def change_state(state, *args); end

  def completed?(); end

  def completion(*a, &b); end

  def completion_states(); end

  def errback(*a, &b); end

  def set_deferred_status(state, *args); end

  def state(); end

  def stateback(state, *a, &b); end

  def timeout(time, *args); end

  def value(); end
end

class EventMachine::Completion
end

class EventMachine::Connection
  def associate_callback_target(_); end

  def close_connection(after_writing=T.unsafe(nil)); end

  def close_connection_after_writing(); end

  def comm_inactivity_timeout(); end

  def comm_inactivity_timeout=(value); end

  def connection_completed(); end

  def detach(); end

  def error?(); end

  def get_cipher_bits(); end

  def get_cipher_name(); end

  def get_cipher_protocol(); end

  def get_idle_time(); end

  def get_outbound_data_size(); end

  def get_peer_cert(); end

  def get_peername(); end

  def get_pid(); end

  def get_proxied_bytes(); end

  def get_sni_hostname(); end

  def get_sock_opt(level, option); end

  def get_sockname(); end

  def get_status(); end

  def initialize(*args); end

  def notify_readable=(mode); end

  def notify_readable?(); end

  def notify_writable=(mode); end

  def notify_writable?(); end

  def original_method(_); end

  def pause(); end

  def paused?(); end

  def pending_connect_timeout(); end

  def pending_connect_timeout=(value); end

  def post_init(); end

  def proxy_completed(); end

  def proxy_incoming_to(conn, bufsize=T.unsafe(nil)); end

  def proxy_target_unbound(); end

  def receive_data(data); end

  def reconnect(server, port); end

  def resume(); end

  def send_data(data); end

  def send_datagram(data, recipient_address, recipient_port); end

  def send_file_data(filename); end

  def set_comm_inactivity_timeout(value); end

  def set_pending_connect_timeout(value); end

  def set_sock_opt(level, optname, optval); end

  def signature(); end

  def signature=(signature); end

  def ssl_handshake_completed(); end

  def ssl_verify_peer(cert); end

  def start_tls(args=T.unsafe(nil)); end

  def stop_proxying(); end

  def stream_file_data(filename, args=T.unsafe(nil)); end

  def unbind(); end
end

class EventMachine::Connection
  def self.new(sig, *args); end
end

class EventMachine::ConnectionError
end

class EventMachine::ConnectionError
end

class EventMachine::ConnectionNotBound
end

class EventMachine::ConnectionNotBound
end

module EventMachine::DNS
end

class EventMachine::DNS::Request
  include ::EventMachine::Deferrable
  def initialize(socket, hostname); end

  def max_tries(); end

  def max_tries=(max_tries); end

  def receive_answer(msg); end

  def retry_interval(); end

  def retry_interval=(retry_interval); end

  def tick(); end
end

class EventMachine::DNS::Request
end

class EventMachine::DNS::RequestIdAlreadyUsed
end

class EventMachine::DNS::RequestIdAlreadyUsed
end

class EventMachine::DNS::Resolver
  HOSTS_FILE = ::T.let(nil, ::T.untyped)
end

class EventMachine::DNS::Resolver
  def self.hosts(); end

  def self.nameserver(); end

  def self.nameservers(); end

  def self.nameservers=(ns); end

  def self.resolve(hostname); end

  def self.socket(); end

  def self.windows?(); end
end

class EventMachine::DNS::Socket
  def deregister_request(id, req); end

  def initialize(); end

  def nameserver(); end

  def nameserver=(ns); end

  def register_request(id, req); end

  def send_packet(pkt); end

  def start_timer(); end

  def stop_timer(); end

  def tick(); end
end

class EventMachine::DNS::Socket
  def self.open(); end
end

module EventMachine::DNS
end

class EventMachine::DefaultDeferrable
  include ::EventMachine::Deferrable
end

class EventMachine::DefaultDeferrable
end

module EventMachine::Deferrable
  def callback(&block); end

  def cancel_callback(block); end

  def cancel_errback(block); end

  def cancel_timeout(); end

  def errback(&block); end

  def fail(*args); end

  def set_deferred_failure(*args); end

  def set_deferred_status(status, *args); end

  def set_deferred_success(*args); end

  def succeed(*args); end

  def timeout(seconds, *args); end
end

EventMachine::Deferrable::Pool = EventMachine::Pool

module EventMachine::Deferrable
  def self.future(arg, cb=T.unsafe(nil), eb=T.unsafe(nil), &blk); end
end

class EventMachine::DeferrableChildProcess
  include ::EventMachine::Deferrable
  def initialize(); end
end

class EventMachine::DeferrableChildProcess
  def self.open(cmd); end
end

class EventMachine::FileNotFoundException
end

class EventMachine::FileNotFoundException
end

class EventMachine::FileStreamer
  include ::EventMachine::Deferrable
  def initialize(connection, filename, args=T.unsafe(nil)); end

  def stream_one_chunk(); end
  BackpressureLevel = ::T.let(nil, ::T.untyped)
  ChunkSize = ::T.let(nil, ::T.untyped)
  MappingThreshold = ::T.let(nil, ::T.untyped)
end

class EventMachine::FileStreamer
end

class EventMachine::FileWatch
  def file_deleted(); end

  def file_modified(); end

  def file_moved(); end

  def path(); end

  def stop_watching(); end
  Cdeleted = ::T.let(nil, ::T.untyped)
  Cmodified = ::T.let(nil, ::T.untyped)
  Cmoved = ::T.let(nil, ::T.untyped)
end

class EventMachine::FileWatch
end

class EventMachine::InvalidSignature
end

class EventMachine::InvalidSignature
end

class EventMachine::Iterator
  def concurrency(); end

  def concurrency=(val); end

  def each(foreach=T.unsafe(nil), after=T.unsafe(nil), &blk); end

  def initialize(list, concurrency=T.unsafe(nil)); end

  def inject(obj, foreach, after); end

  def map(foreach, after); end
  Stop = ::T.let(nil, ::T.untyped)
end

class EventMachine::Iterator
end

class EventMachine::NoHandlerForAcceptedConnection
end

class EventMachine::NoHandlerForAcceptedConnection
end

EventMachine::P = EventMachine::Protocols

class EventMachine::PeriodicTimer
  def cancel(); end

  def fire(); end

  def initialize(interval, callback=T.unsafe(nil), &block); end

  def interval(); end

  def interval=(interval); end

  def schedule(); end
end

class EventMachine::PeriodicTimer
end

class EventMachine::Pool
  def add(resource); end

  def completion(deferrable, resource); end

  def contents(); end

  def failure(resource); end

  def num_waiting(); end

  def on_error(*a, &b); end

  def perform(*a, &b); end

  def process(work, resource); end

  def remove(resource); end

  def removed?(resource); end

  def requeue(resource); end

  def reschedule(*a, &b); end
end

class EventMachine::Pool
end

class EventMachine::ProcessWatch
  def pid(); end

  def process_exited(); end

  def process_forked(); end

  def stop_watching(); end
  Cexit = ::T.let(nil, ::T.untyped)
  Cfork = ::T.let(nil, ::T.untyped)
end

class EventMachine::ProcessWatch
end

module EventMachine::Protocols
end

class EventMachine::Protocols::HeaderAndContentProtocol
  include ::EventMachine::Protocols::LineText2
  def headers_2_hash(hdrs); end

  def receive_binary_data(text); end

  def receive_line(line); end
  ContentLengthPattern = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::HeaderAndContentProtocol
  def self.headers_2_hash(hdrs); end
end

class EventMachine::Protocols::HttpClient
  include ::EventMachine::Deferrable
  def dispatch_response(); end

  def initialize(); end

  def send_request(args); end
  MaxPostContentLength = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::HttpClient
  def self.request(args=T.unsafe(nil)); end
end

class EventMachine::Protocols::HttpClient2
  include ::EventMachine::Protocols::LineText2
  def get(args); end

  def initialize(); end

  def pop_request(); end

  def post(args); end

  def receive_binary_data(text); end

  def request(args); end

  def set_default_host_header(host, port, ssl); end
end

class EventMachine::Protocols::HttpClient2::Request
  include ::EventMachine::Deferrable
  def content(); end

  def header_lines(); end

  def headers(); end

  def initialize(conn, args); end

  def internal_error(); end

  def receive_chunk_header(ln); end

  def receive_chunk_trailer(ln); end

  def receive_chunked_text(text); end

  def receive_header_line(ln); end

  def receive_line(ln); end

  def receive_sized_text(text); end

  def receive_text(text); end

  def send_request(); end

  def status(); end

  def version(); end
  ChunkedRE = ::T.let(nil, ::T.untyped)
  ClenRE = ::T.let(nil, ::T.untyped)
  ColonRE = ::T.let(nil, ::T.untyped)
  HttpResponseRE = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::HttpClient2::Request
end

class EventMachine::Protocols::HttpClient2
  def self.connect(*args); end
end

class EventMachine::Protocols::LineAndTextProtocol
  def set_binary_mode(size=T.unsafe(nil)); end
  MaxBinaryLength = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::LineAndTextProtocol
end

module EventMachine::Protocols::LineProtocol
  def receive_data(data); end

  def receive_line(line); end
end

module EventMachine::Protocols::LineProtocol
end

module EventMachine::Protocols::LineText2
  def receive_binary_data(data); end

  def receive_data(data); end

  def receive_end_of_binary_data(); end

  def receive_line(ln); end

  def set_binary_mode(size=T.unsafe(nil)); end

  def set_delimiter(delim); end

  def set_line_mode(data=T.unsafe(nil)); end

  def set_text_mode(size=T.unsafe(nil)); end

  def unbind(); end
  MaxBinaryLength = ::T.let(nil, ::T.untyped)
end

module EventMachine::Protocols::LineText2
end

module EventMachine::Protocols::Memcache
  include ::EventMachine::Deferrable
  def connection_completed(); end

  def del(key, expires=T.unsafe(nil), &cb); end

  def delete(key, expires=T.unsafe(nil), &cb); end

  def get(*keys); end

  def get_hash(*keys); end

  def initialize(host, port=T.unsafe(nil)); end

  def process_cmd(line); end

  def receive_data(data); end

  def set(key, val, exptime=T.unsafe(nil), &cb); end

  def unbind(); end
  Cdeleted = ::T.let(nil, ::T.untyped)
  Cdelimiter = ::T.let(nil, ::T.untyped)
  Cempty = ::T.let(nil, ::T.untyped)
  Cend = ::T.let(nil, ::T.untyped)
  Cerror = ::T.let(nil, ::T.untyped)
  Cstored = ::T.let(nil, ::T.untyped)
  Cunknown = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::Memcache::ParserError
end

class EventMachine::Protocols::Memcache::ParserError
end

module EventMachine::Protocols::Memcache
  def self.connect(host=T.unsafe(nil), port=T.unsafe(nil)); end
end

module EventMachine::Protocols::ObjectProtocol
  def receive_data(data); end

  def receive_object(obj); end

  def send_object(obj); end

  def serializer(); end
end

module EventMachine::Protocols::ObjectProtocol
end

module EventMachine::Protocols::SASLauth
  def post_init(); end

  def receive_data(data); end

  def validate(username, psw, sysname, realm); end
  MaxFieldSize = ::T.let(nil, ::T.untyped)
end

module EventMachine::Protocols::SASLauth
end

class EventMachine::Protocols::SmtpClient
  include ::EventMachine::Deferrable
  include ::EventMachine::Protocols::LineText2
  def args=(args); end

  def initialize(); end
end

class EventMachine::Protocols::SmtpClient
  def self.send(args=T.unsafe(nil)); end
end

class EventMachine::Protocols::SmtpServer
  include ::EventMachine::Protocols::LineText2
  def connection_ended(); end

  def get_server_domain(); end

  def get_server_greeting(); end

  def init_protocol_state(); end

  def parms=(parms=T.unsafe(nil)); end

  def process_auth(str); end

  def process_auth_line(line); end

  def process_data(); end

  def process_data_line(ln); end

  def process_ehlo(domain); end

  def process_expn(); end

  def process_helo(domain); end

  def process_help(); end

  def process_mail_from(sender); end

  def process_noop(); end

  def process_quit(); end

  def process_rcpt_to(rcpt); end

  def process_rset(); end

  def process_starttls(); end

  def process_unknown(); end

  def process_vrfy(); end

  def receive_data_chunk(data); end

  def receive_data_command(); end

  def receive_ehlo_domain(domain); end

  def receive_message(); end

  def receive_plain_auth(user, password); end

  def receive_recipient(rcpt); end

  def receive_reset(); end

  def receive_sender(sender); end

  def receive_transaction(); end

  def reset_protocol_state(); end

  def send_server_greeting(); end
  AuthRegex = ::T.let(nil, ::T.untyped)
  DataRegex = ::T.let(nil, ::T.untyped)
  EhloRegex = ::T.let(nil, ::T.untyped)
  ExpnRegex = ::T.let(nil, ::T.untyped)
  HeloRegex = ::T.let(nil, ::T.untyped)
  HelpRegex = ::T.let(nil, ::T.untyped)
  MailFromRegex = ::T.let(nil, ::T.untyped)
  NoopRegex = ::T.let(nil, ::T.untyped)
  QuitRegex = ::T.let(nil, ::T.untyped)
  RcptToRegex = ::T.let(nil, ::T.untyped)
  RsetRegex = ::T.let(nil, ::T.untyped)
  StarttlsRegex = ::T.let(nil, ::T.untyped)
  VrfyRegex = ::T.let(nil, ::T.untyped)
end

class EventMachine::Protocols::SmtpServer
  def self.parms=(parms=T.unsafe(nil)); end
end

class EventMachine::Protocols::Socks4
  def initialize(host, port); end

  def restore_methods(); end

  def setup_methods(); end

  def socks_post_init(); end

  def socks_receive_data(data); end
end

class EventMachine::Protocols::Socks4
end

module EventMachine::Protocols::Stomp
  include ::EventMachine::Protocols::LineText2
  def ack(msgid); end

  def connect(parms=T.unsafe(nil)); end

  def init_message_reader(); end

  def receive_binary_data(data); end

  def receive_line(line); end

  def receive_msg(msg); end

  def send(destination, body, parms=T.unsafe(nil)); end

  def send_frame(verb, headers=T.unsafe(nil), body=T.unsafe(nil)); end

  def subscribe(dest, ack=T.unsafe(nil)); end
end

class EventMachine::Protocols::Stomp::Message
  def body(); end

  def body=(body); end

  def command(); end

  def command=(command); end

  def consume_line(line); end

  def header(); end

  def header=(header); end

  def headers(); end
end

class EventMachine::Protocols::Stomp::Message
end

module EventMachine::Protocols::Stomp
end

class EventMachine::Protocols::TcpConnectTester
  include ::EventMachine::Deferrable
end

class EventMachine::Protocols::TcpConnectTester
  def self.test(host, port); end
end

module EventMachine::Protocols
end

class EventMachine::Queue
  def <<(*items); end

  def empty?(); end

  def num_waiting(); end

  def pop(*a, &b); end

  def push(*items); end

  def size(); end
end

class EventMachine::Queue
end

class EventMachine::SpawnedProcess
  def notify(*x); end

  def resume(*x); end

  def run(*x); end

  def set_receiver(blk); end
end

class EventMachine::SpawnedProcess
end

class EventMachine::SystemCmd
  def initialize(cb); end
end

class EventMachine::SystemCmd
end

class EventMachine::ThreadedResource
  def dispatch(); end

  def shutdown(); end
end

class EventMachine::ThreadedResource
end

class EventMachine::TickLoop
  def initialize(*a, &b); end

  def on_stop(*a, &b); end

  def start(); end

  def stop(); end

  def stopped?(); end
end

class EventMachine::TickLoop
end

class EventMachine::Timer
  def cancel(); end

  def initialize(interval, callback=T.unsafe(nil), &block); end
end

class EventMachine::Timer
end

class EventMachine::UnknownTimerFired
end

class EventMachine::UnknownTimerFired
end

class EventMachine::Unsupported
end

class EventMachine::Unsupported
end

module EventMachine::WebSocket
end

module EventMachine::WebSocket::Close03
  def close_websocket(code, body); end

  def supports_close_codes?(); end
end

module EventMachine::WebSocket::Close03
end

module EventMachine::WebSocket::Close05
  def close_websocket(code, body); end

  def supports_close_codes?(); end
end

module EventMachine::WebSocket::Close05
end

module EventMachine::WebSocket::Close06
  def close_websocket(code, body); end

  def supports_close_codes?(); end
end

module EventMachine::WebSocket::Close06
end

module EventMachine::WebSocket::Close75
  def close_websocket(code, body); end

  def supports_close_codes?(); end
end

module EventMachine::WebSocket::Close75
end

class EventMachine::WebSocket::Connection
  include ::EventMachine::WebSocket::Debugger
  def close(code=T.unsafe(nil), body=T.unsafe(nil)); end

  def close_timeout(); end

  def close_websocket(code=T.unsafe(nil), body=T.unsafe(nil)); end

  def dispatch(data); end

  def initialize(options); end

  def max_frame_size(); end

  def max_frame_size=(max_frame_size); end

  def onbinary(&blk); end

  def onclose(&blk); end

  def onerror(&blk); end

  def onmessage(&blk); end

  def onopen(&blk); end

  def onping(&blk); end

  def onpong(&blk); end

  def ping(body=T.unsafe(nil)); end

  def pingable?(); end

  def pong(body=T.unsafe(nil)); end

  def send(data); end

  def send_binary(data); end

  def send_flash_cross_domain_file(); end

  def send_text(data); end

  def state(); end

  def supports_close_codes?(); end

  def trigger_on_binary(msg); end

  def trigger_on_close(event=T.unsafe(nil)); end

  def trigger_on_error(reason); end

  def trigger_on_message(msg); end

  def trigger_on_open(handshake); end

  def trigger_on_ping(data); end

  def trigger_on_pong(data); end
  BINARY = ::T.let(nil, ::T.untyped)
  ENCODING_SUPPORTED = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class EventMachine::WebSocket::Connection
end

module EventMachine::WebSocket::Debugger
end

module EventMachine::WebSocket::Debugger
end

module EventMachine::WebSocket::Framing03
  def initialize_framing(); end

  def process_data(); end

  def send_frame(frame_type, application_data); end

  def send_text_frame(data); end
  DATA_FRAMES = ::T.let(nil, ::T.untyped)
  FRAME_TYPES = ::T.let(nil, ::T.untyped)
  FRAME_TYPES_INVERSE = ::T.let(nil, ::T.untyped)
end

module EventMachine::WebSocket::Framing03
end

module EventMachine::WebSocket::Framing04
  include ::EventMachine::WebSocket::Framing03
end

module EventMachine::WebSocket::Framing04
end

module EventMachine::WebSocket::Framing05
  def initialize_framing(); end

  def process_data(); end

  def send_frame(frame_type, application_data); end

  def send_text_frame(data); end
  DATA_FRAMES = ::T.let(nil, ::T.untyped)
  FRAME_TYPES = ::T.let(nil, ::T.untyped)
  FRAME_TYPES_INVERSE = ::T.let(nil, ::T.untyped)
end

module EventMachine::WebSocket::Framing05
end

module EventMachine::WebSocket::Framing07
  def initialize_framing(); end

  def process_data(); end

  def send_frame(frame_type, application_data); end

  def send_text_frame(data); end
  DATA_FRAMES = ::T.let(nil, ::T.untyped)
  FRAME_TYPES = ::T.let(nil, ::T.untyped)
  FRAME_TYPES_INVERSE = ::T.let(nil, ::T.untyped)
end

module EventMachine::WebSocket::Framing07
end

module EventMachine::WebSocket::Framing76
  def initialize_framing(); end

  def process_data(); end

  def send_text_frame(data); end
end

module EventMachine::WebSocket::Framing76
end

class EventMachine::WebSocket::Handler
  include ::EventMachine::WebSocket::Debugger
  def close_websocket(code, body); end

  def fail_websocket(e); end

  def initialize(connection, debug=T.unsafe(nil)); end

  def ping(); end

  def pingable?(); end

  def receive_data(data); end

  def request(); end

  def start_close_timeout(); end

  def state(); end

  def unbind(); end
end

class EventMachine::WebSocket::Handler
  def self.klass_factory(version); end
end

class EventMachine::WebSocket::Handler03
  include ::EventMachine::WebSocket::Framing03
  include ::EventMachine::WebSocket::MessageProcessor03
  include ::EventMachine::WebSocket::Close03
end

class EventMachine::WebSocket::Handler03
end

class EventMachine::WebSocket::Handler05
  include ::EventMachine::WebSocket::Framing05
  include ::EventMachine::WebSocket::MessageProcessor03
  include ::EventMachine::WebSocket::Close05
end

class EventMachine::WebSocket::Handler05
end

class EventMachine::WebSocket::Handler06
  include ::EventMachine::WebSocket::Framing05
  include ::EventMachine::WebSocket::MessageProcessor06
  include ::EventMachine::WebSocket::Close06
end

class EventMachine::WebSocket::Handler06
end

class EventMachine::WebSocket::Handler07
  include ::EventMachine::WebSocket::Framing07
  include ::EventMachine::WebSocket::MessageProcessor06
  include ::EventMachine::WebSocket::Close06
end

class EventMachine::WebSocket::Handler07
end

class EventMachine::WebSocket::Handler08
  include ::EventMachine::WebSocket::Framing07
  include ::EventMachine::WebSocket::MessageProcessor06
  include ::EventMachine::WebSocket::Close06
end

class EventMachine::WebSocket::Handler08
end

class EventMachine::WebSocket::Handler13
  include ::EventMachine::WebSocket::Framing07
  include ::EventMachine::WebSocket::MessageProcessor06
  include ::EventMachine::WebSocket::Close06
end

class EventMachine::WebSocket::Handler13
end

class EventMachine::WebSocket::Handler75
  include ::EventMachine::WebSocket::Handshake75
  include ::EventMachine::WebSocket::Framing76
  include ::EventMachine::WebSocket::Close75
end

class EventMachine::WebSocket::Handler75
end

class EventMachine::WebSocket::Handler76
  include ::EventMachine::WebSocket::Handshake76
  include ::EventMachine::WebSocket::Framing76
  include ::EventMachine::WebSocket::Close75
  TERMINATE_STRING = ::T.let(nil, ::T.untyped)
end

class EventMachine::WebSocket::Handler76
end

class EventMachine::WebSocket::Handshake
  include ::EventMachine::Deferrable
  def headers(); end

  def headers_downcased(); end

  def initialize(secure); end

  def origin(); end

  def parser(); end

  def path(); end

  def protocol_version(); end

  def query(); end

  def query_string(); end

  def receive_data(data); end

  def secure?(); end
end

class EventMachine::WebSocket::Handshake
end

module EventMachine::WebSocket::Handshake04
end

module EventMachine::WebSocket::Handshake04
  def self.handshake(headers, _, __); end
end

module EventMachine::WebSocket::Handshake75
end

module EventMachine::WebSocket::Handshake75
  def self.handshake(headers, path, secure); end
end

module EventMachine::WebSocket::Handshake76
end

module EventMachine::WebSocket::Handshake76
  def self.handshake(headers, path, secure); end
end

class EventMachine::WebSocket::HandshakeError
end

class EventMachine::WebSocket::HandshakeError
end

class EventMachine::WebSocket::InvalidDataError
end

class EventMachine::WebSocket::InvalidDataError
end

class EventMachine::WebSocket::MaskedString
  def getbyte(index); end

  def getbytes(start_index, count); end

  def read_mask(); end

  def unset_mask(); end
end

class EventMachine::WebSocket::MaskedString
end

module EventMachine::WebSocket::MessageProcessor03
  def message(message_type, extension_data, application_data); end

  def pingable?(); end
end

module EventMachine::WebSocket::MessageProcessor03
end

module EventMachine::WebSocket::MessageProcessor06
  def message(message_type, extension_data, application_data); end

  def pingable?(); end
end

module EventMachine::WebSocket::MessageProcessor06
end

class EventMachine::WebSocket::WSMessageTooBigError
end

class EventMachine::WebSocket::WSMessageTooBigError
end

class EventMachine::WebSocket::WSProtocolError
  def code(); end
end

class EventMachine::WebSocket::WSProtocolError
end

class EventMachine::WebSocket::WebSocketError
end

class EventMachine::WebSocket::WebSocketError
end

module EventMachine::WebSocket
  def self.close_timeout(); end

  def self.close_timeout=(close_timeout); end

  def self.max_frame_size(); end

  def self.max_frame_size=(max_frame_size); end

  def self.run(options); end

  def self.start(options, &blk); end

  def self.stop(); end
end

class EventMachine::YieldBlockFromSpawnedProcess
  def initialize(block, notify); end

  def pull_out_yield_block(); end
end

class EventMachine::YieldBlockFromSpawnedProcess
end

module EventMachine
  def self.Callback(object=T.unsafe(nil), method=T.unsafe(nil), &blk); end

  def self._open_file_for_writing(filename, handler=T.unsafe(nil)); end

  def self.add_oneshot_timer(_); end

  def self.add_periodic_timer(*args, &block); end

  def self.add_shutdown_hook(&block); end

  def self.add_timer(*args, &block); end

  def self.attach(io, handler=T.unsafe(nil), *args, &blk); end

  def self.attach_fd(_, _1); end

  def self.attach_io(io, watch_mode, handler=T.unsafe(nil), *args); end

  def self.attach_sd(_); end

  def self.attach_server(sock, handler=T.unsafe(nil), *args, &block); end

  def self.bind_connect(bind_addr, bind_port, server, port=T.unsafe(nil), handler=T.unsafe(nil), *args); end

  def self.bind_connect_server(_, _1, _2, _3); end

  def self.cancel_timer(timer_or_sig); end

  def self.cleanup_machine(); end

  def self.close_connection(_, _1); end

  def self.connect(server, port=T.unsafe(nil), handler=T.unsafe(nil), *args, &blk); end

  def self.connect_server(_, _1); end

  def self.connect_unix_domain(socketname, *args, &blk); end

  def self.connect_unix_server(_); end

  def self.connection_count(); end

  def self.connection_paused?(_); end

  def self.current_time(); end

  def self.defer(op=T.unsafe(nil), callback=T.unsafe(nil), errback=T.unsafe(nil), &blk); end

  def self.defers_finished?(); end

  def self.detach_fd(_); end

  def self.disable_proxy(from); end

  def self.enable_proxy(from, to, bufsize=T.unsafe(nil), length=T.unsafe(nil)); end

  def self.epoll(); end

  def self.epoll=(epoll); end

  def self.epoll?(); end

  def self.error_handler(cb=T.unsafe(nil), &blk); end

  def self.event_callback(conn_binding, opcode, data); end

  def self.fork_reactor(&block); end

  def self.get_cipher_bits(_); end

  def self.get_cipher_name(_); end

  def self.get_cipher_protocol(_); end

  def self.get_comm_inactivity_timeout(_); end

  def self.get_connection_count(); end

  def self.get_file_descriptor(_); end

  def self.get_heartbeat_interval(); end

  def self.get_idle_time(_); end

  def self.get_max_timer_count(); end

  def self.get_max_timers(); end

  def self.get_peer_cert(_); end

  def self.get_peername(_); end

  def self.get_pending_connect_timeout(_); end

  def self.get_proxied_bytes(_); end

  def self.get_simultaneous_accept_count(); end

  def self.get_sni_hostname(_); end

  def self.get_sock_opt(_, _1, _2); end

  def self.get_sockname(_); end

  def self.get_subprocess_pid(_); end

  def self.get_subprocess_status(_); end

  def self.heartbeat_interval(); end

  def self.heartbeat_interval=(time); end

  def self.initialize_event_machine(); end

  def self.invoke_popen(_); end

  def self.is_notify_readable(_); end

  def self.is_notify_writable(_); end

  def self.klass_from_handler(klass=T.unsafe(nil), handler=T.unsafe(nil), *args); end

  def self.kqueue(); end

  def self.kqueue=(kqueue); end

  def self.kqueue?(); end

  def self.library_type(); end

  def self.next_tick(pr=T.unsafe(nil), &block); end

  def self.num_close_scheduled(); end

  def self.open_datagram_socket(address, port, handler=T.unsafe(nil), *args); end

  def self.open_keyboard(handler=T.unsafe(nil), *args); end

  def self.open_udp_socket(_, _1); end

  def self.pause_connection(_); end

  def self.popen(cmd, handler=T.unsafe(nil), *args); end

  def self.reactor_running?(); end

  def self.reactor_thread(); end

  def self.reactor_thread?(); end

  def self.read_keyboard(); end

  def self.reconnect(server, port, handler); end

  def self.release_machine(); end

  def self.report_connection_error_status(_); end

  def self.resume_connection(_); end

  def self.run(blk=T.unsafe(nil), tail=T.unsafe(nil), &block); end

  def self.run_block(&block); end

  def self.run_deferred_callbacks(); end

  def self.run_machine(); end

  def self.run_machine_once(); end

  def self.run_machine_without_threads(); end

  def self.schedule(*a, &b); end

  def self.send_data(_, _1, _2); end

  def self.send_datagram(_, _1, _2, _3, _4); end

  def self.send_file_data(_, _1); end

  def self.set_comm_inactivity_timeout(_, _1); end

  def self.set_descriptor_table_size(n_descriptors=T.unsafe(nil)); end

  def self.set_effective_user(username); end

  def self.set_heartbeat_interval(_); end

  def self.set_max_timer_count(_); end

  def self.set_max_timers(ct); end

  def self.set_notify_readable(_, _1); end

  def self.set_notify_writable(_, _1); end

  def self.set_pending_connect_timeout(_, _1); end

  def self.set_quantum(mills); end

  def self.set_rlimit_nofile(_); end

  def self.set_simultaneous_accept_count(_); end

  def self.set_sock_opt(_, _1, _2, _3); end

  def self.set_timer_quantum(_); end

  def self.set_tls_parms(_, _1, _2, _3, _4, _5, _6, _7, _8, _9); end

  def self.setuid_string(_); end

  def self.signal_loopbreak(); end

  def self.spawn(&block); end

  def self.spawn_threadpool(); end

  def self.ssl?(); end

  def self.start_proxy(_, _1, _2, _3); end

  def self.start_server(server, port=T.unsafe(nil), handler=T.unsafe(nil), *args, &block); end

  def self.start_tcp_server(_, _1); end

  def self.start_tls(_); end

  def self.start_unix_domain_server(filename, *args, &block); end

  def self.start_unix_server(_); end

  def self.stop(); end

  def self.stop_event_loop(); end

  def self.stop_proxy(_); end

  def self.stop_server(signature); end

  def self.stop_tcp_server(_); end

  def self.stopping?(); end

  def self.system(cmd, *args, &cb); end

  def self.threadpool(); end

  def self.threadpool_size(); end

  def self.threadpool_size=(threadpool_size); end

  def self.tick_loop(*a, &b); end

  def self.unwatch_filename(_); end

  def self.unwatch_pid(_); end

  def self.watch(io, handler=T.unsafe(nil), *args, &blk); end

  def self.watch_file(filename, handler=T.unsafe(nil), *args); end

  def self.watch_filename(_); end

  def self.watch_pid(_); end

  def self.watch_process(pid, handler=T.unsafe(nil), *args); end

  def self.yield(&block); end

  def self.yield_and_notify(&block); end
end

class Exception
  include ::ActiveSupport::Dependencies::Blamable
  include ::BetterErrors::ExceptionExtension
end

module Exception2MessageMapper
  def bind(cl); end

end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

module ExceptionForMatrix
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
end

class ExceptionForMatrix::ErrDimensionMismatch
end

class ExceptionForMatrix::ErrDimensionMismatch
end

class ExceptionForMatrix::ErrNotRegular
end

class ExceptionForMatrix::ErrNotRegular
end

class ExceptionForMatrix::ErrOperationNotDefined
end

class ExceptionForMatrix::ErrOperationNotDefined
end

class ExceptionForMatrix::ErrOperationNotImplemented
end

class ExceptionForMatrix::ErrOperationNotImplemented
end

module ExceptionForMatrix
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

module ExecJS
  VERSION = ::T.let(nil, ::T.untyped)
end

class ExecJS::DisabledRuntime
end

class ExecJS::DisabledRuntime
end

class ExecJS::DuktapeRuntime
end

class ExecJS::DuktapeRuntime::Context
  def call(identifier, *args); end
end

class ExecJS::DuktapeRuntime::Context
end

class ExecJS::DuktapeRuntime
end

module ExecJS::Encoding
  def encode(string); end
end

module ExecJS::Encoding
end

class ExecJS::Error
end

class ExecJS::Error
end

class ExecJS::ExternalRuntime
  def encode_source(source); end

  def encode_unicode_codepoints(str); end

  def exec_runtime(filename); end

  def exec_runtime_error(output); end

  def generate_compile_method(path); end

  def initialize(options); end

  def json2_source(); end

  def which(command); end
end

class ExecJS::ExternalRuntime::Context
  def call(identifier, *args); end

  def create_tempfile(basename); end

  def extract_result(output, filename); end

  def write_to_tempfile(contents); end
end

class ExecJS::ExternalRuntime::Context
end

class ExecJS::ExternalRuntime
end

class ExecJS::MiniRacerRuntime
end

class ExecJS::MiniRacerRuntime::Context
  def call(identifier, *args); end
end

class ExecJS::MiniRacerRuntime::Context
end

class ExecJS::MiniRacerRuntime
end

class ExecJS::ProgramError
end

class ExecJS::ProgramError
end

class ExecJS::RubyRacerRuntime
end

class ExecJS::RubyRacerRuntime::Context
  def unbox(value); end
end

class ExecJS::RubyRacerRuntime::Context
end

class ExecJS::RubyRacerRuntime
end

class ExecJS::RubyRhinoRuntime
end

class ExecJS::RubyRhinoRuntime::Context
  def unbox(value); end

  def wrap_error(e); end
end

class ExecJS::RubyRhinoRuntime::Context
end

class ExecJS::RubyRhinoRuntime
end

class ExecJS::Runtime
  def available?(); end

  def compile(source, options=T.unsafe(nil)); end

  def context_class(); end

  def deprecated?(); end

  def eval(source, options=T.unsafe(nil)); end

  def exec(source, options=T.unsafe(nil)); end

  def name(); end
end

class ExecJS::Runtime::Context
  include ::ExecJS::Encoding
  def call(properties, *args); end

  def eval(source, options=T.unsafe(nil)); end

  def exec(source, options=T.unsafe(nil)); end

  def initialize(runtime, source=T.unsafe(nil), options=T.unsafe(nil)); end
end

class ExecJS::Runtime::Context
end

class ExecJS::Runtime
end

class ExecJS::RuntimeError
end

class ExecJS::RuntimeError
end

class ExecJS::RuntimeUnavailable
end

class ExecJS::RuntimeUnavailable
end

module ExecJS::Runtimes
  Disabled = ::T.let(nil, ::T.untyped)
  Duktape = ::T.let(nil, ::T.untyped)
  JScript = ::T.let(nil, ::T.untyped)
  JavaScriptCore = ::T.let(nil, ::T.untyped)
  MiniRacer = ::T.let(nil, ::T.untyped)
  Node = ::T.let(nil, ::T.untyped)
  RubyRacer = ::T.let(nil, ::T.untyped)
  RubyRhino = ::T.let(nil, ::T.untyped)
  SpiderMonkey = ::T.let(nil, ::T.untyped)
  Spidermonkey = ::T.let(nil, ::T.untyped)
  V8 = ::T.let(nil, ::T.untyped)
end

module ExecJS::Runtimes
  def self.autodetect(); end

  def self.best_available(); end

  def self.from_environment(); end

  def self.names(); end

  def self.runtimes(); end
end

module ExecJS
  def self.compile(source, options=T.unsafe(nil)); end

  def self.cygwin?(); end

  def self.eval(source, options=T.unsafe(nil)); end

  def self.exec(source, options=T.unsafe(nil)); end

  def self.root(); end

  def self.runtime(); end

  def self.runtime=(runtime); end

  def self.runtimes(); end

  def self.windows?(); end
end

class ExitCalledError
end

class ExitCalledError
end

module FFI
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  SizeTypes = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
  USE_THIS_PROCESS_AS_LIBRARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FFI::AbstractMemory
  def [](_); end

  def __copy_from__(_, _1); end

  def clear(); end

  def get(_, _1); end

  def get_array_of_char(_, _1); end

  def get_array_of_double(_, _1); end

  def get_array_of_float(_, _1); end

  def get_array_of_float32(_, _1); end

  def get_array_of_float64(_, _1); end

  def get_array_of_int(_, _1); end

  def get_array_of_int16(_, _1); end

  def get_array_of_int32(_, _1); end

  def get_array_of_int64(_, _1); end

  def get_array_of_int8(_, _1); end

  def get_array_of_long(_, _1); end

  def get_array_of_long_long(_, _1); end

  def get_array_of_pointer(_, _1); end

  def get_array_of_short(_, _1); end

  def get_array_of_string(*_); end

  def get_array_of_uchar(_, _1); end

  def get_array_of_uint(_, _1); end

  def get_array_of_uint16(_, _1); end

  def get_array_of_uint32(_, _1); end

  def get_array_of_uint64(_, _1); end

  def get_array_of_uint8(_, _1); end

  def get_array_of_ulong(_, _1); end

  def get_array_of_ulong_long(_, _1); end

  def get_array_of_ushort(_, _1); end

  def get_bytes(_, _1); end

  def get_char(_); end

  def get_double(_); end

  def get_float(_); end

  def get_float32(_); end

  def get_float64(_); end

  def get_int(_); end

  def get_int16(_); end

  def get_int32(_); end

  def get_int64(_); end

  def get_int8(_); end

  def get_long(_); end

  def get_long_long(_); end

  def get_pointer(_); end

  def get_short(_); end

  def get_string(*_); end

  def get_uchar(_); end

  def get_uint(_); end

  def get_uint16(_); end

  def get_uint32(_); end

  def get_uint64(_); end

  def get_uint8(_); end

  def get_ulong(_); end

  def get_ulong_long(_); end

  def get_ushort(_); end

  def put(_, _1, _2); end

  def put_array_of_char(_, _1); end

  def put_array_of_double(_, _1); end

  def put_array_of_float(_, _1); end

  def put_array_of_float32(_, _1); end

  def put_array_of_float64(_, _1); end

  def put_array_of_int(_, _1); end

  def put_array_of_int16(_, _1); end

  def put_array_of_int32(_, _1); end

  def put_array_of_int64(_, _1); end

  def put_array_of_int8(_, _1); end

  def put_array_of_long(_, _1); end

  def put_array_of_long_long(_, _1); end

  def put_array_of_pointer(_, _1); end

  def put_array_of_short(_, _1); end

  def put_array_of_uchar(_, _1); end

  def put_array_of_uint(_, _1); end

  def put_array_of_uint16(_, _1); end

  def put_array_of_uint32(_, _1); end

  def put_array_of_uint64(_, _1); end

  def put_array_of_uint8(_, _1); end

  def put_array_of_ulong(_, _1); end

  def put_array_of_ulong_long(_, _1); end

  def put_array_of_ushort(_, _1); end

  def put_bytes(*_); end

  def put_char(_, _1); end

  def put_double(_, _1); end

  def put_float(_, _1); end

  def put_float32(_, _1); end

  def put_float64(_, _1); end

  def put_int(_, _1); end

  def put_int16(_, _1); end

  def put_int32(_, _1); end

  def put_int64(_, _1); end

  def put_int8(_, _1); end

  def put_long(_, _1); end

  def put_long_long(_, _1); end

  def put_pointer(_, _1); end

  def put_short(_, _1); end

  def put_string(_, _1); end

  def put_uchar(_, _1); end

  def put_uint(_, _1); end

  def put_uint16(_, _1); end

  def put_uint32(_, _1); end

  def put_uint64(_, _1); end

  def put_uint8(_, _1); end

  def put_ulong(_, _1); end

  def put_ulong_long(_, _1); end

  def put_ushort(_, _1); end

  def read_array_of_char(_); end

  def read_array_of_double(_); end

  def read_array_of_float(_); end

  def read_array_of_int(_); end

  def read_array_of_int16(_); end

  def read_array_of_int32(_); end

  def read_array_of_int64(_); end

  def read_array_of_int8(_); end

  def read_array_of_long(_); end

  def read_array_of_long_long(_); end

  def read_array_of_pointer(_); end

  def read_array_of_short(_); end

  def read_array_of_uchar(_); end

  def read_array_of_uint(_); end

  def read_array_of_uint16(_); end

  def read_array_of_uint32(_); end

  def read_array_of_uint64(_); end

  def read_array_of_uint8(_); end

  def read_array_of_ulong(_); end

  def read_array_of_ulong_long(_); end

  def read_array_of_ushort(_); end

  def read_bytes(_); end

  def read_char(); end

  def read_double(); end

  def read_float(); end

  def read_int(); end

  def read_int16(); end

  def read_int32(); end

  def read_int64(); end

  def read_int8(); end

  def read_long(); end

  def read_long_long(); end

  def read_pointer(); end

  def read_short(); end

  def read_uchar(); end

  def read_uint(); end

  def read_uint16(); end

  def read_uint32(); end

  def read_uint64(); end

  def read_uint8(); end

  def read_ulong(); end

  def read_ulong_long(); end

  def read_ushort(); end

  def size(); end

  def total(); end

  def type_size(); end

  def write_array_of_char(_); end

  def write_array_of_double(_); end

  def write_array_of_float(_); end

  def write_array_of_int(_); end

  def write_array_of_int16(_); end

  def write_array_of_int32(_); end

  def write_array_of_int64(_); end

  def write_array_of_int8(_); end

  def write_array_of_long(_); end

  def write_array_of_long_long(_); end

  def write_array_of_pointer(_); end

  def write_array_of_short(_); end

  def write_array_of_uchar(_); end

  def write_array_of_uint(_); end

  def write_array_of_uint16(_); end

  def write_array_of_uint32(_); end

  def write_array_of_uint64(_); end

  def write_array_of_uint8(_); end

  def write_array_of_ulong(_); end

  def write_array_of_ulong_long(_); end

  def write_array_of_ushort(_); end

  def write_bytes(*_); end

  def write_char(_); end

  def write_double(_); end

  def write_float(_); end

  def write_int(_); end

  def write_int16(_); end

  def write_int32(_); end

  def write_int64(_); end

  def write_int8(_); end

  def write_long(_); end

  def write_long_long(_); end

  def write_pointer(_); end

  def write_short(_); end

  def write_uchar(_); end

  def write_uint(_); end

  def write_uint16(_); end

  def write_uint32(_); end

  def write_uint64(_); end

  def write_uint8(_); end

  def write_ulong(_); end

  def write_ulong_long(_); end

  def write_ushort(_); end
end

class FFI::AbstractMemory
end

class FFI::ArrayType
  def elem_type(); end

  def initialize(_, _1); end

  def length(); end
end

class FFI::ArrayType
end

class FFI::AutoPointer
  def autorelease=(autorelease); end

  def initialize(ptr, proc=T.unsafe(nil), &block); end
end

class FFI::AutoPointer::CallableReleaser
  def release(ptr); end
end

class FFI::AutoPointer::CallableReleaser
end

class FFI::AutoPointer::DefaultReleaser
  def release(ptr); end
end

class FFI::AutoPointer::DefaultReleaser
end

class FFI::AutoPointer::Releaser
  def autorelease(); end

  def autorelease=(autorelease); end

  def call(*args); end

  def free(); end

  def initialize(ptr, proc); end
end

class FFI::AutoPointer::Releaser
end

class FFI::AutoPointer
  extend ::FFI::DataConverter
  def self.from_native(val, ctx); end

  def self.native_type(); end
end

class FFI::Bitmask
  def [](*query); end

  def to_native(query, ctx); end
end

class FFI::Bitmask
end

class FFI::Buffer
  def +(_); end

  def initialize(*_); end

  def length(); end

  def order(*_); end

  def slice(_, _1); end
end

class FFI::Buffer
  def self.alloc_in(*_); end

  def self.alloc_inout(*_); end

  def self.alloc_out(*_); end

  def self.new_in(*_); end

  def self.new_inout(*_); end

  def self.new_out(*_); end
end

FFI::CallbackInfo = FFI::FunctionType

module FFI::DataConverter
  def from_native(value, ctx); end

  def native_type(type=T.unsafe(nil)); end

  def to_native(value, ctx); end
end

module FFI::DataConverter
end

class FFI::DynamicLibrary
  def find_function(_); end

  def find_symbol(_); end

  def find_variable(_); end

  def initialize(_, _1); end

  def last_error(); end

  def name(); end
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary
  def self.last_error(); end

  def self.open(_, _1); end
end

class FFI::Enum
  include ::FFI::DataConverter
  def [](query); end

  def find(query); end

  def from_native(val, ctx); end

  def initialize(*args); end

  def native_type(); end

  def symbol_map(); end

  def symbols(); end

  def tag(); end

  def to_h(); end

  def to_hash(); end

  def to_native(val, ctx); end
end

class FFI::Enum
end

class FFI::Enums
  def <<(enum); end

  def __map_symbol(symbol); end

  def find(query); end
end

class FFI::Enums
end

class FFI::Function
  def attach(_, _1); end

  def autorelease(); end

  def call(*_); end
end

class FFI::Function
end

FFI::FunctionInfo = FFI::FunctionType

class FFI::FunctionType
  def initialize(*_); end

  def param_types(); end

  def result_type(); end
end

class FFI::FunctionType
end

module FFI::IO
end

module FFI::IO
  def self.for_fd(fd, mode=T.unsafe(nil)); end

  def self.native_read(io, buf, len); end
end

module FFI::LastError
end

module FFI::LastError
  def self.error(); end

  def self.error=(error); end
end

module FFI::Library
  def attach_function(name, func, args, returns=T.unsafe(nil), options=T.unsafe(nil)); end

  def attach_variable(mname, a1, a2=T.unsafe(nil)); end

  def bitmask(*args); end

  def callback(*args); end

  def enum(*args); end

  def enum_type(name); end

  def enum_value(symbol); end

  def ffi_convention(convention=T.unsafe(nil)); end

  def ffi_lib(*names); end

  def ffi_lib_flags(*flags); end

  def ffi_libraries(); end

  def find_type(t); end

  def function_names(name, arg_types); end

  def typedef(old, add, info=T.unsafe(nil)); end
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  FlagsMap = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
end

module FFI::Library
  def self.extended(mod); end
end

class FFI::ManagedStruct
  def initialize(pointer=T.unsafe(nil)); end
end

class FFI::ManagedStruct
end

class FFI::MemoryPointer
end

class FFI::MemoryPointer
  def self.from_string(_); end
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
end

class FFI::NotFoundError
  def initialize(function, *libraries); end
end

class FFI::NotFoundError
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  ARCH = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  CONF_DIR = ::T.let(nil, ::T.untyped)
  CPU = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  IS_BSD = ::T.let(nil, ::T.untyped)
  IS_DRAGONFLYBSD = ::T.let(nil, ::T.untyped)
  IS_FREEBSD = ::T.let(nil, ::T.untyped)
  IS_GNU = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MAC = ::T.let(nil, ::T.untyped)
  IS_NETBSD = ::T.let(nil, ::T.untyped)
  IS_OPENBSD = ::T.let(nil, ::T.untyped)
  IS_SOLARIS = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
  LIBPREFIX = ::T.let(nil, ::T.untyped)
  LIBSUFFIX = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  OSVERSION = ::T.let(nil, ::T.untyped)
end

module FFI::Platform
  def self.bsd?(); end

  def self.is_os(os); end

  def self.mac?(); end

  def self.solaris?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class FFI::PlatformError
end

class FFI::PlatformError
end

class FFI::Pointer
  def +(_); end

  def address(); end

  def autorelease=(autorelease); end

  def autorelease?(); end

  def free(); end

  def initialize(*_); end

  def null?(); end

  def order(*_); end

  def read(type); end

  def read_array_of_type(type, reader, length); end

  def read_string(len=T.unsafe(nil)); end

  def read_string_length(len); end

  def read_string_to_null(); end

  def slice(_, _1); end

  def to_i(); end

  def to_ptr(); end

  def write(type, value); end

  def write_array_of_type(type, writer, ary); end

  def write_string(str, len=T.unsafe(nil)); end

  def write_string_length(str, len); end
  NULL = ::T.let(nil, ::T.untyped)
  SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Pointer
  def self.size(); end
end

class FFI::StrPtrConverter
end

class FFI::StrPtrConverter
  extend ::FFI::DataConverter
  def self.from_native(val, ctx); end
end

class FFI::Struct
  def [](_); end

  def []=(_, _1); end

  def align(); end

  def alignment(); end

  def clear(); end

  def initialize(*_); end

  def layout(); end

  def members(); end

  def null?(); end

  def offset_of(name); end

  def offsets(); end

  def order(*_); end

  def pointer(); end

  def size(); end

  def to_ptr(); end

  def values(); end
end

class FFI::Struct::InlineArray
  include ::Enumerable
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def initialize(_, _1); end

  def size(); end

  def to_a(); end

  def to_ptr(); end
end

class FFI::Struct::InlineArray
end

class FFI::Struct::ManagedStructConverter
  def from_native(ptr, ctx); end
end

class FFI::Struct::ManagedStructConverter
end

class FFI::Struct
  def self.align(alignment=T.unsafe(nil)); end

  def self.aligned(alignment=T.unsafe(nil)); end

  def self.alignment(); end

  def self.alloc_in(*_); end

  def self.alloc_inout(*_); end

  def self.alloc_out(*_); end

  def self.auto_ptr(); end

  def self.by_ref(flags=T.unsafe(nil)); end

  def self.by_value(); end

  def self.callback(params, ret); end

  def self.enclosing_module(); end

  def self.find_field_type(type, mod=T.unsafe(nil)); end

  def self.find_type(type, mod=T.unsafe(nil)); end

  def self.in(); end

  def self.layout(*spec); end

  def self.members(); end

  def self.new_in(*_); end

  def self.new_inout(*_); end

  def self.new_out(*_); end

  def self.offset_of(name); end

  def self.offsets(); end

  def self.out(); end

  def self.pack(packed=T.unsafe(nil)); end

  def self.packed(packed=T.unsafe(nil)); end

  def self.ptr(flags=T.unsafe(nil)); end

  def self.size(); end

  def self.size=(size); end

  def self.val(); end
end

class FFI::StructByReference
  include ::FFI::DataConverter
  def initialize(struct_class); end

  def native_type(); end

  def struct_class(); end
end

class FFI::StructByReference
end

class FFI::StructByValue
  def layout(); end

  def struct_class(); end
end

class FFI::StructByValue
end

class FFI::StructLayout
  def [](_); end

  def __union!(); end

  def fields(); end

  def initialize(_, _1, _2); end

  def members(); end

  def offset_of(field_name); end

  def offsets(); end

  def to_a(); end
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::CharArray
  def to_str(); end
end

class FFI::StructLayout::CharArray
end

class FFI::StructLayout::Enum
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::Enum
end

class FFI::StructLayout::Field
  def alignment(); end

  def get(_); end

  def initialize(*_); end

  def name(); end

  def offset(); end

  def put(_, _1); end

  def size(); end

  def type(); end
end

class FFI::StructLayout::Field
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::InnerStruct
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::InnerStruct
end

class FFI::StructLayout::Mapped
  def get(ptr); end

  def initialize(name, offset, type, orig_field); end

  def put(ptr, value); end
end

class FFI::StructLayout::Mapped
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::StructLayout
end

class FFI::StructLayoutBuilder
  def add(name, type, offset=T.unsafe(nil)); end

  def add_array(name, type, count, offset=T.unsafe(nil)); end

  def add_field(name, type, offset=T.unsafe(nil)); end

  def add_struct(name, type, offset=T.unsafe(nil)); end

  def alignment(); end

  def alignment=(align); end

  def build(); end

  def packed=(packed); end

  def size(); end

  def size=(size); end

  def union=(is_union); end

  def union?(); end
  NUMBER_TYPES = ::T.let(nil, ::T.untyped)
end

class FFI::StructLayoutBuilder
end

class FFI::Type
  def alignment(); end

  def initialize(_); end

  def size(); end
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

class FFI::Type::Builtin
end

class FFI::Type::Builtin
end

FFI::Type::Function = FFI::FunctionType

class FFI::Type::Mapped
  def from_native(*_); end

  def native_type(); end

  def to_native(*_); end

  def type(); end
end

class FFI::Type::Mapped
end

FFI::Type::Struct = FFI::StructByValue

class FFI::Type
end

class FFI::Union
end

class FFI::Union
  def self.builder(); end
end

class FFI::VariadicInvoker
  def attach(mod, mname); end

  def call(*args, &block); end

  def init(arg_types, type_map); end

  def initialize(_, _1, _2, _3); end

  def invoke(_, _1); end
end

class FFI::VariadicInvoker
end

module FFI
  def self.add_typedef(old, add); end

  def self.errno(); end

  def self.errno=(error); end

  def self.find_type(name, type_map=T.unsafe(nil)); end

  def self.map_library_name(lib); end

  def self.type_size(type); end

  def self.typedef(old, add); end
end

class FSEvent
  def callback(); end

  def initialize(args=T.unsafe(nil), &block); end

  def open_pipe(); end

  def paths(); end

  def process_running?(pid); end

  def run(); end

  def stop(); end

  def watch(watch_paths, options=T.unsafe(nil), &block); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class FSEvent
  def self.root_path(); end

  def self.watcher_path(); end
end

class FaIconParser
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ParseMethods
  def attrs(); end

  def classes(); end

  def data(); end

  def get_content_tag(); end

  def icon(); end

  def initialize(icon, options); end

  def options(); end

  def right(); end

  def sizes(); end

  def style(); end

  def text(); end

  def title(); end
end

class FaIconParser
end

class FaLayeredIconParser
  include ::ParseMethods
  def aligned(); end

  def classes(); end

  def initialize(options); end

  def size(); end

  def style(); end

  def title(); end
end

class FaLayeredIconParser
end

class FaStackedIconParser
  include ::ParseMethods
  def first_icon_classes(); end

  def initialize(icon, options); end

  def options(); end

  def reverse(); end

  def second_icon_classes(); end

  def span_classes(); end

  def text(); end

  def title(); end
end

class FaStackedIconParser
end

module FactoryBot
  Deprecation = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FactoryBot::AssociationDefinitionError
end

class FactoryBot::AssociationDefinitionError
end

class FactoryBot::Attribute
  def alias_for?(attr); end

  def association?(); end

  def ignored(); end

  def initialize(name, ignored); end

  def name(); end

  def to_proc(); end
end

class FactoryBot::Attribute::Association
  def factory(); end

  def initialize(name, factory, overrides); end
end

class FactoryBot::Attribute::Association
end

class FactoryBot::Attribute::Dynamic
  def initialize(name, ignored, block); end
end

class FactoryBot::Attribute::Dynamic
end

class FactoryBot::Attribute::Sequence
  def initialize(name, sequence, ignored); end
end

class FactoryBot::Attribute::Sequence
end

class FactoryBot::Attribute
end

class FactoryBot::AttributeAssigner
  def initialize(evaluator, build_class, &instance_builder); end

  def object(); end
end

class FactoryBot::AttributeAssigner
end

class FactoryBot::AttributeDefinitionError
end

class FactoryBot::AttributeDefinitionError
end

class FactoryBot::AttributeList
  include ::Enumerable
  def apply_attributes(attributes_to_apply); end

  def associations(); end

  def define_attribute(attribute); end

  def each(&block); end

  def ignored(); end

  def initialize(name=T.unsafe(nil), attributes=T.unsafe(nil)); end

  def names(); end

  def non_ignored(); end
end

class FactoryBot::AttributeList
end

class FactoryBot::Callback
  def ==(other); end

  def block(); end

  def initialize(name, block); end

  def name(); end

  def run(instance, evaluator); end
end

class FactoryBot::Callback
end

class FactoryBot::CallbacksObserver
  def initialize(callbacks, evaluator); end

  def update(name, result_instance); end
end

class FactoryBot::CallbacksObserver
end

class FactoryBot::Configuration
  def after(*args, &block); end

  def before(*args, &block); end

  def callback(*args, &block); end

  def callback_names(); end

  def callbacks(*args, &block); end

  def constructor(*args, &block); end

  def factories(); end

  def initialize_with(&block); end

  def inline_sequences(); end

  def sequences(); end

  def skip_create(*args, &block); end

  def strategies(); end

  def to_create(*args, &block); end

  def traits(); end
end

class FactoryBot::Configuration
end

class FactoryBot::Declaration
  def ignored(); end

  def initialize(name, ignored=T.unsafe(nil)); end

  def name(); end

  def to_attributes(); end
end

class FactoryBot::Declaration::Association
  def ==(other); end

  def initialize(name, *options); end

  def options(); end
end

class FactoryBot::Declaration::Association
end

class FactoryBot::Declaration::Dynamic
  def ==(other); end

  def block(); end

  def initialize(name, ignored=T.unsafe(nil), block=T.unsafe(nil)); end
end

class FactoryBot::Declaration::Dynamic
end

class FactoryBot::Declaration::Implicit
  def ==(other); end

  def factory(); end

  def initialize(name, factory=T.unsafe(nil), ignored=T.unsafe(nil)); end
end

class FactoryBot::Declaration::Implicit
end

class FactoryBot::Declaration
end

class FactoryBot::DeclarationList
  include ::Enumerable
  def attributes(); end

  def declare_attribute(declaration); end

  def each(&block); end

  def initialize(name=T.unsafe(nil)); end

  def overridable(); end
end

class FactoryBot::DeclarationList
end

class FactoryBot::Decorator
  def initialize(component); end

  def method_missing(name, *args, &block); end

  def send(symbol, *args, &block); end
end

class FactoryBot::Decorator::AttributeHash
  def attributes(); end

  def initialize(component, attributes=T.unsafe(nil)); end
end

class FactoryBot::Decorator::AttributeHash
end

class FactoryBot::Decorator::DisallowsDuplicatesRegistry
  def register(name, item); end
end

class FactoryBot::Decorator::DisallowsDuplicatesRegistry
end

class FactoryBot::Decorator::InvocationTracker
  def __invoked_methods__(); end
end

class FactoryBot::Decorator::InvocationTracker
end

class FactoryBot::Decorator::NewConstructor
  def initialize(component, build_class); end

  def new(*args, &block); end
end

class FactoryBot::Decorator::NewConstructor
end

class FactoryBot::Decorator
  def self.const_missing(name); end
end

class FactoryBot::Definition
  def add_callback(callback); end

  def after(*names, &block); end

  def append_traits(new_traits); end

  def attributes(); end

  def before(*names, &block); end

  def callback(*names, &block); end

  def callbacks(); end

  def compile(klass=T.unsafe(nil)); end

  def constructor(); end

  def declarations(); end

  def declare_attribute(*args, &block); end

  def define_constructor(&block); end

  def define_trait(trait); end

  def defined_traits(); end

  def inherit_traits(new_traits); end

  def initialize(name, base_traits=T.unsafe(nil)); end

  def name(); end

  def overridable(); end

  def register_enum(enum); end

  def registered_enums(); end

  def skip_create(); end

  def to_create(&block); end
end

class FactoryBot::Definition
end

class FactoryBot::DefinitionHierarchy
  def callbacks(*args, &block); end

  def constructor(*args, &block); end

  def to_create(*args, &block); end
end

class FactoryBot::DefinitionHierarchy
  def self.build_from_definition(definition); end
end

class FactoryBot::DefinitionProxy
  def add_attribute(name, &block); end

  def after(*args, &block); end

  def association(name, *options); end

  def before(*args, &block); end

  def callback(*args, &block); end

  def child_factories(); end

  def factory(name, options=T.unsafe(nil), &block); end

  def initialize(definition, ignore=T.unsafe(nil)); end

  def initialize_with(&block); end

  def method_missing(name, *args, &block); end

  def sequence(name, *args, &block); end

  def singleton_method_added(name); end

  def skip_create(); end

  def to_create(&block); end

  def trait(name, &block); end

  def traits_for_enum(attribute_name, values=T.unsafe(nil)); end

  def transient(&block); end
  UNPROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class FactoryBot::DefinitionProxy
end

class FactoryBot::DuplicateDefinitionError
end

class FactoryBot::DuplicateDefinitionError
end

class FactoryBot::Enum
  def build_traits(klass); end

  def initialize(attribute_name, values=T.unsafe(nil)); end
end

class FactoryBot::Enum
end

class FactoryBot::Evaluation
  include ::Observable
  def create(result_instance); end

  def hash(*args, &block); end

  def initialize(evaluator, attribute_assigner, to_create); end

  def notify(name, result_instance); end

  def object(*args, &block); end
end

class FactoryBot::Evaluation
end

class FactoryBot::Evaluator
  def __override_names__(); end

  def association(factory_name, *traits_and_overrides); end

  def attribute_lists(); end

  def attribute_lists=(val); end

  def attribute_lists?(); end

  def increment_sequence(sequence); end

  def initialize(build_strategy, overrides=T.unsafe(nil)); end

  def instance=(instance); end

  def method_missing(method_name, *args, &block); end
end

class FactoryBot::Evaluator
  def self.attribute_list(); end

  def self.attribute_lists(); end

  def self.attribute_lists=(val); end

  def self.attribute_lists?(); end

  def self.define_attribute(name, &block); end
end

class FactoryBot::EvaluatorClassDefiner
  def evaluator_class(); end

  def initialize(attributes, parent_class); end
end

class FactoryBot::EvaluatorClassDefiner
end

class FactoryBot::Factory
  def add_callback(*args, &block); end

  def append_traits(*args, &block); end

  def associations(); end

  def attributes(); end

  def build_class(); end

  def build_hierarchy(); end

  def callbacks(); end

  def class_name(); end

  def compile(); end

  def compiled_constructor(); end

  def compiled_to_create(); end

  def constructor(*args, &block); end

  def declare_attribute(*args, &block); end

  def define_trait(*args, &block); end

  def defined_traits(*args, &block); end

  def definition(); end

  def evaluator_class(); end

  def hierarchy_class(); end

  def hierarchy_instance(); end

  def human_names(); end

  def inherit_traits(*args, &block); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def names(); end

  def run(build_strategy, overrides, &block); end

  def to_create(*args, &block); end

  def with_traits(traits); end
end

class FactoryBot::Factory
end

class FactoryBot::FactoryRunner
  def initialize(name, strategy, traits_and_overrides); end

  def run(runner_strategy=T.unsafe(nil), &block); end
end

class FactoryBot::FactoryRunner
end

module FactoryBot::Internal
end

module FactoryBot::Internal
  def self.after(*args, &block); end

  def self.before(*args, &block); end

  def self.callbacks(*args, &block); end

  def self.configuration(); end

  def self.constructor(*args, &block); end

  def self.factories(*args, &block); end

  def self.factory_by_name(name); end

  def self.initialize_with(*args, &block); end

  def self.inline_sequences(*args, &block); end

  def self.register_default_strategies(); end

  def self.register_factory(factory); end

  def self.register_inline_sequence(sequence); end

  def self.register_sequence(sequence); end

  def self.register_strategy(strategy_name, strategy_class); end

  def self.register_trait(trait); end

  def self.reset_configuration(); end

  def self.rewind_inline_sequences(); end

  def self.rewind_sequences(); end

  def self.sequence_by_name(name); end

  def self.sequences(*args, &block); end

  def self.skip_create(*args, &block); end

  def self.strategies(*args, &block); end

  def self.strategy_by_name(name); end

  def self.to_create(*args, &block); end

  def self.trait_by_name(name); end

  def self.traits(*args, &block); end
end

class FactoryBot::InvalidCallbackNameError
end

class FactoryBot::InvalidCallbackNameError
end

class FactoryBot::InvalidFactoryError
end

class FactoryBot::InvalidFactoryError
end

class FactoryBot::Linter
  def initialize(factories, strategy: T.unsafe(nil), traits: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def lint!(); end
end

class FactoryBot::Linter::FactoryError
  def initialize(wrapped_error, factory); end

  def location(); end

  def message(); end

  def verbose_message(); end
end

class FactoryBot::Linter::FactoryError
end

class FactoryBot::Linter::FactoryTraitError
  def initialize(wrapped_error, factory, trait_name); end
end

class FactoryBot::Linter::FactoryTraitError
end

class FactoryBot::Linter
end

class FactoryBot::MethodDefinitionError
end

class FactoryBot::MethodDefinitionError
end

class FactoryBot::NullFactory
  def attributes(*args, &block); end

  def callbacks(*args, &block); end

  def class_name(); end

  def compile(); end

  def constructor(*args, &block); end

  def defined_traits(*args, &block); end

  def definition(); end

  def evaluator_class(); end

  def hierarchy_class(); end

  def to_create(*args, &block); end
end

class FactoryBot::NullFactory
end

class FactoryBot::NullObject
  def initialize(methods_to_respond_to); end

  def method_missing(name, *args, &block); end

  def respond_to?(method); end
end

class FactoryBot::NullObject
end

class FactoryBot::Registry
  include ::Enumerable
  def [](name); end

  def clear(); end

  def each(&block); end

  def find(name); end

  def initialize(name); end

  def name(); end

  def register(name, item); end

  def registered?(name); end
end

class FactoryBot::Registry
end

class FactoryBot::Sequence
  def initialize(name, *args, &proc); end

  def name(); end

  def names(); end

  def next(scope=T.unsafe(nil)); end

  def rewind(); end
end

class FactoryBot::Sequence::EnumeratorAdapter
  def initialize(value); end

  def next(); end

  def peek(); end

  def rewind(); end
end

class FactoryBot::Sequence::EnumeratorAdapter
end

class FactoryBot::Sequence
end

class FactoryBot::SequenceAbuseError
end

class FactoryBot::SequenceAbuseError
end

module FactoryBot::Strategy
end

class FactoryBot::Strategy::AttributesFor
  def association(runner); end

  def result(evaluation); end
end

class FactoryBot::Strategy::AttributesFor
end

class FactoryBot::Strategy::Build
  def association(runner); end

  def result(evaluation); end
end

class FactoryBot::Strategy::Build
end

class FactoryBot::Strategy::Create
  def association(runner); end

  def result(evaluation); end
end

class FactoryBot::Strategy::Create
end

class FactoryBot::Strategy::Null
  def association(runner); end

  def result(evaluation); end
end

class FactoryBot::Strategy::Null
end

class FactoryBot::Strategy::Stub
  def association(runner); end

  def result(evaluation); end
  DISABLED_PERSISTENCE_METHODS = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Strategy::Stub
  def self.next_id=(id); end
end

module FactoryBot::Strategy
end

class FactoryBot::StrategyCalculator
  def initialize(name_or_object); end

  def strategy(); end
end

class FactoryBot::StrategyCalculator
end

class FactoryBot::StrategySyntaxMethodRegistrar
  def define_strategy_methods(); end

  def initialize(strategy_name); end
end

class FactoryBot::StrategySyntaxMethodRegistrar
  def self.with_index(block, index); end
end

module FactoryBot::Syntax
end

module FactoryBot::Syntax::Default
  include ::FactoryBot::Syntax::Methods
  def define(&block); end

  def modify(&block); end
end

class FactoryBot::Syntax::Default::DSL
  def after(*args, &block); end

  def before(*args, &block); end

  def callback(*args, &block); end

  def factory(name, options=T.unsafe(nil), &block); end

  def initialize_with(*args, &block); end

  def sequence(name, *args, &block); end

  def skip_create(*args, &block); end

  def to_create(*args, &block); end

  def trait(name, &block); end
end

class FactoryBot::Syntax::Default::DSL
  def self.run(block); end
end

class FactoryBot::Syntax::Default::ModifyDSL
  def factory(name, _options=T.unsafe(nil), &block); end
end

class FactoryBot::Syntax::Default::ModifyDSL
  def self.run(block); end
end

module FactoryBot::Syntax::Default
end

module FactoryBot::Syntax::Methods
  def attributes_for(name, *traits_and_overrides, &block); end

  def attributes_for_list(name, amount, *traits_and_overrides, &block); end

  def attributes_for_pair(name, *traits_and_overrides, &block); end

  def build(name, *traits_and_overrides, &block); end

  def build_list(name, amount, *traits_and_overrides, &block); end

  def build_pair(name, *traits_and_overrides, &block); end

  def build_stubbed(name, *traits_and_overrides, &block); end

  def build_stubbed_list(name, amount, *traits_and_overrides, &block); end

  def build_stubbed_pair(name, *traits_and_overrides, &block); end

  def create(name, *traits_and_overrides, &block); end

  def create_list(name, amount, *traits_and_overrides, &block); end

  def create_pair(name, *traits_and_overrides, &block); end

  def generate(name); end

  def generate_list(name, count); end

  def null(name, *traits_and_overrides, &block); end

  def null_list(name, amount, *traits_and_overrides, &block); end

  def null_pair(name, *traits_and_overrides, &block); end
end

module FactoryBot::Syntax::Methods
end

module FactoryBot::Syntax
end

class FactoryBot::SyntaxRunner
  include ::FactoryBot::Syntax::Methods
end

class FactoryBot::SyntaxRunner
end

class FactoryBot::Trait
  def ==(other); end

  def add_callback(*args, &block); end

  def attributes(*args, &block); end

  def block(); end

  def callbacks(*args, &block); end

  def constructor(*args, &block); end

  def declare_attribute(*args, &block); end

  def define_trait(*args, &block); end

  def definition(); end

  def initialize(name, &block); end

  def name(); end

  def names(); end

  def to_create(*args, &block); end
end

class FactoryBot::Trait
end

class FactoryBot::TraitDefinitionError
end

class FactoryBot::TraitDefinitionError
end

module FactoryBot
  extend ::FactoryBot::Syntax::Default
  extend ::FactoryBot::Syntax::Methods
  def self.aliases(); end

  def self.aliases=(aliases); end

  def self.aliases_for(attribute); end

  def self.automatically_define_enum_traits(); end

  def self.automatically_define_enum_traits=(obj); end

  def self.build_stubbed_starting_id=(starting_id); end

  def self.definition_file_paths(); end

  def self.definition_file_paths=(definition_file_paths); end

  def self.factories(*args, &block); end

  def self.find_definitions(); end

  def self.lint(*args); end

  def self.register_strategy(*args, &block); end

  def self.reload(); end

  def self.rewind_sequences(*args, &block); end

  def self.strategy_by_name(*args, &block); end

  def self.use_parent_strategy(); end

  def self.use_parent_strategy=(obj); end
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  include ::MessagePack::CoreExt
end

class Fiber
  def transfer(*_); end
end

class Fiber
  def self.current(); end
end

class File
  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.exists?(_); end

  def self.probe_stat_in(dir); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, **options, &block); end

  def safe_ln(*args, **options); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  include ::MessagePack::CoreExt
  include ::ActiveSupport::NumericWithFormat
end

module FontAwesome5
end

module FontAwesome5::Rails
end

module FontAwesome5::Rails::IconHelper
  def fa5_icon(icon, options=T.unsafe(nil)); end

  def fa5_stacked_icon(icon, options=T.unsafe(nil)); end

  def fa_icon(icon, options=T.unsafe(nil)); end

  def fa_layered_icon(options=T.unsafe(nil), &block); end

  def fa_stacked_icon(icon, options=T.unsafe(nil)); end

  def fab_icon(icon, options=T.unsafe(nil)); end

  def fab_stacked_icon(icon, options=T.unsafe(nil)); end

  def fad_icon(icon, options=T.unsafe(nil)); end

  def fad_stacked_icon(icon, options=T.unsafe(nil)); end

  def fal_icon(icon, options=T.unsafe(nil)); end

  def fal_stacked_icon(icon, options=T.unsafe(nil)); end

  def far_icon(icon, options=T.unsafe(nil)); end

  def far_stacked_icon(icon, options=T.unsafe(nil)); end

  def fas_icon(icon, options=T.unsafe(nil)); end

  def fas_stacked_icon(icon, options=T.unsafe(nil)); end
end

module FontAwesome5::Rails::IconHelper
end

module FontAwesome5::Rails
end

module FontAwesome5
end

module FontAwesome5Rails
  FA_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FontAwesome5Rails::Engine
end

class FontAwesome5Rails::Engine
end

module FontAwesome5Rails
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  USE_BUNDLER_FOR_GEMDEPS = ::T.let(nil, ::T.untyped)
end

class Gem::DependencyInstaller
  def _deprecated_add_found_dependencies(to_do, dependency_list); end

  def _deprecated_gather_dependencies(); end

  def add_found_dependencies(*args, &block); end

  def gather_dependencies(*args, &block); end
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  def self.redirector(); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::RemoteFetcher
  def correct_for_windows_path(path); end

  def s3_expiration(); end

  def sign_s3_url(uri, expiration=T.unsafe(nil)); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Resolver::ActivationRequest
  def others_possible?(); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

Gem::Resolver::DependencyConflict = Gem::Resolver::Conflict

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def to_ruby(); end
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.remove_spec(spec); end
end

class Gem::SpecificationPolicy
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.default_gems_use_full_paths?(); end

  def self.remove_unresolved_default_spec(spec); end
end

class GlobalID
  def ==(other); end

  def app(*args, &block); end

  def eql?(other); end

  def find(options=T.unsafe(nil)); end

  def initialize(gid, options=T.unsafe(nil)); end

  def model_class(); end

  def model_id(*args, &block); end

  def model_name(*args, &block); end

  def params(*args, &block); end

  def to_s(*args, &block); end

  def uri(); end
end

module GlobalID::Identification
  def to_gid(options=T.unsafe(nil)); end

  def to_gid_param(options=T.unsafe(nil)); end

  def to_global_id(options=T.unsafe(nil)); end

  def to_sgid(options=T.unsafe(nil)); end

  def to_sgid_param(options=T.unsafe(nil)); end

  def to_signed_global_id(options=T.unsafe(nil)); end
end

module GlobalID::Identification
  extend ::ActiveSupport::Concern
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

class GlobalID::Railtie
end

class GlobalID::Railtie
end

class GlobalID::Verifier
end

class GlobalID::Verifier
end

class GlobalID
  extend ::ActiveSupport::Autoload
  def self.app(); end

  def self.app=(app); end

  def self.create(model, options=T.unsafe(nil)); end

  def self.find(gid, options=T.unsafe(nil)); end

  def self.parse(gid, options=T.unsafe(nil)); end
end

module Guard
end

module Guard::Compat
end

module Guard::Compat::UI
end

module Guard::Compat::UI
  def self.color(text, *colors); end

  def self.color_enabled?(); end

  def self.debug(message, options=T.unsafe(nil)); end

  def self.deprecation(message, options=T.unsafe(nil)); end

  def self.error(message, options=T.unsafe(nil)); end

  def self.info(message, options=T.unsafe(nil)); end

  def self.notify(msg, options=T.unsafe(nil)); end

  def self.warning(message, options=T.unsafe(nil)); end
end

module Guard::Compat
  def self.matching_files(plugin, files); end

  def self.watched_directories(); end
end

class Guard::Config
  def initialize(); end

  def silence_deprecations?(); end
end

class Guard::Config
end

module Guard::Deprecated
end

module Guard::Deprecated::Dsl
  MORE_INFO_ON_UPGRADING_TO_GUARD_2 = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Dsl::ClassMethods
  def evaluate_guardfile(options=T.unsafe(nil)); end
  EVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Dsl::ClassMethods
end

module Guard::Deprecated::Dsl
  def self.add_deprecated(dsl_klass); end
end

module Guard::Deprecated::Evaluator
  def evaluate_guardfile(); end

  def reevaluate_guardfile(); end
  EVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
  REEVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Evaluator
  def self.add_deprecated(klass); end
end

module Guard::Deprecated::Guard
end

module Guard::Deprecated::Guard::ClassMethods
  def add_group(name, options=T.unsafe(nil)); end

  def add_guard(*args); end

  def add_plugin(name, options=T.unsafe(nil)); end

  def evaluate_guardfile(); end

  def evaluator(); end

  def get_guard_class(name, fail_gracefully=T.unsafe(nil)); end

  def group(filter); end

  def groups(filter); end

  def guard_gem_names(); end

  def guards(filter=T.unsafe(nil)); end

  def listener=(_); end

  def locate_guard(name); end

  def lock(); end

  def options(); end

  def plugin(filter); end

  def plugins(filter); end

  def reset_evaluator(_options); end

  def runner(); end

  def running(); end

  def scope(); end

  def scope=(scope); end
  ADD_GROUP = ::T.let(nil, ::T.untyped)
  ADD_GUARD = ::T.let(nil, ::T.untyped)
  ADD_PLUGIN = ::T.let(nil, ::T.untyped)
  EVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
  EVALUATOR = ::T.let(nil, ::T.untyped)
  GET_GUARD_CLASS = ::T.let(nil, ::T.untyped)
  GROUP = ::T.let(nil, ::T.untyped)
  GROUPS = ::T.let(nil, ::T.untyped)
  GUARDS = ::T.let(nil, ::T.untyped)
  GUARD_GEM_NAMES = ::T.let(nil, ::T.untyped)
  LISTENER_ASSIGN = ::T.let(nil, ::T.untyped)
  LOCATE_GUARD = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
  MORE_INFO_ON_UPGRADING_TO_GUARD_2 = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PLUGIN = ::T.let(nil, ::T.untyped)
  PLUGINS = ::T.let(nil, ::T.untyped)
  RESET_EVALUATOR = ::T.let(nil, ::T.untyped)
  RUNNER = ::T.let(nil, ::T.untyped)
  RUNNING = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_ASSIGN = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Guard::ClassMethods
end

module Guard::Deprecated::Guard
  def self.add_deprecated(klass); end
end

module Guard::Deprecated::Watcher
end

module Guard::Deprecated::Watcher::ClassMethods
  def match_guardfile?(files); end
  MATCH_GUARDFILE = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Watcher::ClassMethods
end

module Guard::Deprecated::Watcher
  def self.add_deprecated(klass); end
end

module Guard::Deprecated
end

class Guard::Dsl
  def callback(*args, &block); end

  def clearing(on); end

  def directories(directories); end

  def evaluate(contents, filename, lineno); end

  def filter(*regexps); end

  def filter!(*regexps); end

  def group(*args); end

  def guard(name, options=T.unsafe(nil)); end

  def ignore(*regexps); end

  def ignore!(*regexps); end

  def interactor(options); end

  def logger(options); end

  def notification(notifier, opts=T.unsafe(nil)); end

  def scope(scope=T.unsafe(nil)); end

  def watch(pattern, &action); end
  WARN_INVALID_LOG_LEVEL = ::T.let(nil, ::T.untyped)
  WARN_INVALID_LOG_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Guard::Dsl::Error
end

class Guard::Dsl::Error
end

class Guard::Dsl
  extend ::Guard::Deprecated::Dsl::ClassMethods
end

class Guard::DslReader
  def callback(*_args, &_block); end

  def clearing(_on); end

  def directories(_directories); end

  def group(*_args); end

  def guard(name, _options=T.unsafe(nil)); end

  def ignore(*_regexps); end

  def ignore!(*_regexps); end

  def interactor(_options); end

  def logger(_options); end

  def notification(_notifier, _opts=T.unsafe(nil)); end

  def plugin_names(); end

  def scope(_scope=T.unsafe(nil)); end

  def watch(_pattern, &_action); end
end

class Guard::DslReader
end

class Guard::Group
  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def title(); end
end

class Guard::Group
end

module Guard::Guardfile
end

class Guard::Guardfile::Evaluator
  include ::Guard::Deprecated::Evaluator
  def custom?(); end

  def evaluate(); end

  def guardfile_contents(); end

  def guardfile_include?(plugin_name); end

  def guardfile_path(); end

  def guardfile_source(); end

  def initialize(opts=T.unsafe(nil)); end

  def inline?(); end

  def options(); end

  def path(); end
  DEFAULT_GUARDFILES = ::T.let(nil, ::T.untyped)
  ERROR_NO_GUARDFILE = ::T.let(nil, ::T.untyped)
  ERROR_NO_PLUGINS = ::T.let(nil, ::T.untyped)
end

class Guard::Guardfile::Evaluator::Error
end

class Guard::Guardfile::Evaluator::Error
end

class Guard::Guardfile::Evaluator::NoCustomGuardfile
end

class Guard::Guardfile::Evaluator::NoCustomGuardfile
end

class Guard::Guardfile::Evaluator::NoGuardfileError
end

class Guard::Guardfile::Evaluator::NoGuardfileError
end

class Guard::Guardfile::Evaluator::NoPluginsError
end

class Guard::Guardfile::Evaluator::NoPluginsError
end

class Guard::Guardfile::Evaluator
end

module Guard::Guardfile
end

class Guard::Interactor
  def background(*args, &block); end

  def foreground(*args, &block); end

  def handle_interrupt(*args, &block); end

  def initialize(no_interaction=T.unsafe(nil)); end

  def interactive?(); end
end

class Guard::Interactor
  extend ::Forwardable
  def self.enabled(); end

  def self.enabled=(enabled); end

  def self.enabled?(); end

  def self.options(); end

  def self.options=(options); end
end

module Guard::Internals
end

class Guard::Internals::Debugging
end

class Guard::Internals::Debugging
  def self.start(); end

  def self.stop(); end
end

class Guard::Internals::Groups
  def add(name, options=T.unsafe(nil)); end

  def all(filter=T.unsafe(nil)); end
  DEFAULT_GROUPS = ::T.let(nil, ::T.untyped)
end

class Guard::Internals::Groups
end

module Guard::Internals::Helpers
  def _relative_pathname(path); end
end

module Guard::Internals::Helpers
end

class Guard::Internals::Plugins
  def add(name, options); end

  def all(filter=T.unsafe(nil)); end

  def remove(plugin); end
end

class Guard::Internals::Plugins
end

class Guard::Internals::Queue
  def <<(changes); end

  def initialize(commander); end

  def pending?(); end

  def process(); end
end

class Guard::Internals::Queue
end

class Guard::Internals::Scope
  def from_interactor(scope); end

  def grouped_plugins(scope=T.unsafe(nil)); end

  def titles(scope=T.unsafe(nil)); end

  def to_hash(); end
end

class Guard::Internals::Scope
end

class Guard::Internals::Session
  def clear?(); end

  def clearing(on); end

  def clearing?(); end

  def cmdline_groups(); end

  def cmdline_plugins(); end

  def convert_scope(entries); end

  def debug?(); end

  def evaluator_options(); end

  def groups(); end

  def guardfile_group_scope(); end

  def guardfile_ignore(); end

  def guardfile_ignore=(ignores); end

  def guardfile_ignore_bang(); end

  def guardfile_ignore_bang=(guardfile_ignore_bang); end

  def guardfile_notification=(config); end

  def guardfile_plugin_scope(); end

  def guardfile_scope(scope); end

  def initialize(new_options); end

  def interactor_name(); end

  def listener_args(); end

  def notify_options(); end

  def plugins(); end

  def watchdirs(); end

  def watchdirs=(dirs); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Guard::Internals::Session
end

class Guard::Internals::State
  def initialize(cmdline_opts); end

  def scope(); end

  def session(); end
end

class Guard::Internals::State
end

module Guard::Internals::Tracing
end

module Guard::Internals::Tracing
  def self.trace(mod, meth); end

  def self.untrace(mod, meth); end
end

module Guard::Internals::Traps
end

module Guard::Internals::Traps
  def self.handle(signal, &block); end
end

module Guard::Internals
end

class Guard::LiveReload
  def reactor(); end

  def reactor=(reactor); end

  def run_on_modifications(paths); end

  def start(); end

  def stop(); end
end

class Guard::LiveReload::Reactor
  def connections_count(); end

  def initialize(options); end

  def options(); end

  def reload_browser(paths=T.unsafe(nil)); end

  def stop(); end

  def thread(); end

  def web_sockets(); end
end

class Guard::LiveReload::Reactor
end

class Guard::LiveReload::Snippet
  def initialize(template, options); end

  def options(); end

  def path(); end
end

class Guard::LiveReload::Snippet
end

class Guard::LiveReload::WebSocket
  HTTP_DATA_FORBIDDEN = ::T.let(nil, ::T.untyped)
  HTTP_DATA_NOT_FOUND = ::T.let(nil, ::T.untyped)
end

class Guard::LiveReload::WebSocket
end

class Guard::LiveReload
end

class Guard::Notifier
  DEPRECATED_IMPLICIT_CONNECT = ::T.let(nil, ::T.untyped)
end

class Guard::Notifier
  def self.connect(options=T.unsafe(nil)); end

  def self.detected(); end

  def self.disconnect(); end

  def self.notify(message, options=T.unsafe(nil)); end

  def self.supported(); end

  def self.toggle(); end

  def self.turn_on(); end
end

class Guard::Options
  def fetch(name); end

  def initialize(opts=T.unsafe(nil), default_opts=T.unsafe(nil)); end
end

class Guard::Options
end

class Guard::Plugin
  def callbacks(); end

  def callbacks=(callbacks); end

  def group(); end

  def group=(group); end

  def hook(event, *args); end

  def initialize(options=T.unsafe(nil)); end

  def name(); end

  def options(); end

  def options=(options); end

  def title(); end

  def watchers(); end

  def watchers=(watchers); end
  TEMPLATE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Guard::Plugin
  def self.add_callback(listener, guard_plugin, events); end

  def self.callbacks(); end

  def self.non_namespaced_classname(); end

  def self.non_namespaced_name(); end

  def self.notify(guard_plugin, event, *args); end

  def self.reset_callbacks!(); end

  def self.template(plugin_location); end
end

class Guard::PluginUtil
  def add_to_guardfile(); end

  def initialize(name); end

  def initialize_plugin(options); end

  def name(); end

  def name=(name); end

  def plugin_class(options=T.unsafe(nil)); end

  def plugin_location(); end
  ERROR_NO_GUARD_OR_CLASS = ::T.let(nil, ::T.untyped)
  INFO_ADDED_GUARD_TO_GUARDFILE = ::T.let(nil, ::T.untyped)
end

class Guard::PluginUtil
  def self._gem_valid?(gem); end

  def self.plugin_names(); end
end

class Guard::Runner
  def _supervise(plugin, task, *args); end

  def run(task, scope_hash=T.unsafe(nil)); end

  def run_on_changes(modified, added, removed); end
  ADDITION_TASKS = ::T.let(nil, ::T.untyped)
  MODIFICATION_TASKS = ::T.let(nil, ::T.untyped)
  PLUGIN_FAILED = ::T.let(nil, ::T.untyped)
  REMOVAL_TASKS = ::T.let(nil, ::T.untyped)
end

class Guard::Runner
  def self.stopping_symbol_for(guard); end
end

class Guard::Terminal
end

class Guard::Terminal
  def self.clear(); end
end

module Guard::UI
  include ::Guard::UI::Colors
end

module Guard::UI::Colors
  ANSI_ESCAPE_BGBLACK = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGBLUE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGCYAN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGGREEN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGMAGENTA = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGRED = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGWHITE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGYELLOW = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BLACK = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BLUE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BRIGHT = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_CYAN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_GREEN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_MAGENTA = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_RED = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_WHITE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_YELLOW = ::T.let(nil, ::T.untyped)
end

module Guard::UI::Colors
end

class Guard::UI::Config
  def [](name); end

  def device(); end

  def except(); end

  def initialize(options=T.unsafe(nil)); end

  def logger_config(); end

  def only(); end

  def with_progname(name); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEPRECATED_OPTS = ::T.let(nil, ::T.untyped)
end

class Guard::UI::Config
end

class Guard::UI::Logger
end

class Guard::UI::Logger::Config
  def initialize(options=T.unsafe(nil)); end

  def level=(value); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Guard::UI::Logger::Config
end

class Guard::UI::Logger
end

module Guard::UI
  def self.action_with_scopes(action, scope); end

  def self.clear(opts=T.unsafe(nil)); end

  def self.clearable(); end

  def self.debug(message, options=T.unsafe(nil)); end

  def self.deprecation(message, options=T.unsafe(nil)); end

  def self.error(message, options=T.unsafe(nil)); end

  def self.info(message, options=T.unsafe(nil)); end

  def self.level=(new_level); end

  def self.logger(); end

  def self.options(); end

  def self.options=(options); end

  def self.reset_and_clear(); end

  def self.reset_line(); end

  def self.reset_logger(); end

  def self.warning(message, options=T.unsafe(nil)); end
end

class Guard::Watcher
  def ==(other); end

  def action(); end

  def action=(action); end

  def call_action(matches); end

  def initialize(pattern, action=T.unsafe(nil)); end

  def match(string_or_pathname); end

  def pattern(); end

  def pattern=(pattern); end
end

class Guard::Watcher::Pattern
end

class Guard::Watcher::Pattern::DeprecatedRegexp
  def deprecated?(); end

  def initialize(pattern); end
end

class Guard::Watcher::Pattern::DeprecatedRegexp
  def self.convert(pattern); end

  def self.show_deprecation(pattern); end
end

class Guard::Watcher::Pattern::MatchResult
  def [](index); end

  def initialize(match_result, original_value); end
end

class Guard::Watcher::Pattern::MatchResult
end

class Guard::Watcher::Pattern::Matcher
  def ==(other); end

  def initialize(obj); end

  def match(string_or_pathname); end

  def matcher(); end
end

class Guard::Watcher::Pattern::Matcher
end

class Guard::Watcher::Pattern::PathnamePath
end

class Guard::Watcher::Pattern::PathnamePath
end

class Guard::Watcher::Pattern::SimplePath
  def initialize(string_or_pathname); end

  def match(string_or_pathname); end

  def normalize(string_or_pathname); end
end

class Guard::Watcher::Pattern::SimplePath
end

class Guard::Watcher::Pattern
  def self.create(pattern); end
end

class Guard::Watcher
  extend ::Guard::Deprecated::Watcher::ClassMethods
  def self.match_files(guard, files); end
end

module Guard
  extend ::Guard::Deprecated::Guard::ClassMethods
  extend ::Guard::Internals::Helpers
  def self.async_queue_add(changes); end

  def self.init(cmdline_options); end

  def self.interactor(); end

  def self.listener(); end

  def self.queue(); end

  def self.setup(cmdline_options=T.unsafe(nil)); end

  def self.state(); end
end

class HTMLSelector
  def context(); end

  def css_selector(); end

  def initialize(values, previous_selection=T.unsafe(nil), &root_fallback); end

  def message(); end

  def select(); end

  def selecting_no_body?(); end

  def tests(); end
  NO_STRIP = ::T.let(nil, ::T.untyped)
end

class HTMLSelector
  def self.context(); end
end

module HTTP
end

class HTTP::Parser
  def <<(_); end

  def header_value_type(); end

  def header_value_type=(header_value_type); end

  def headers(); end

  def http_major(); end

  def http_method(); end

  def http_minor(); end

  def http_version(); end

  def initialize(*_); end

  def keep_alive?(); end

  def on_body=(on_body); end

  def on_headers_complete=(on_headers_complete); end

  def on_message_begin=(on_message_begin); end

  def on_message_complete=(on_message_complete); end

  def request_url(); end

  def reset!(); end

  def status_code(); end

  def upgrade?(); end

  def upgrade_data(); end
end

class HTTP::Parser::Error
end

class HTTP::Parser::Error
end

class HTTP::Parser
  def self.default_header_value_type(); end

  def self.default_header_value_type=(val); end

  def self.strict?(); end
end

class HTTP::RequestParser
end

class HTTP::RequestParser
end

class HTTP::ResponseParser
end

class HTTP::ResponseParser
end

module HTTP
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::MessagePack::CoreExt
  def assert_valid_keys(*valid_keys); end

  def deep_merge(other_hash, &block); end

  def deep_merge!(other_hash, &block); end

  def deep_transform_values(&block); end

  def deep_transform_values!(&block); end

  def except(*keys); end

  def except!(*keys); end

  def extract!(*keys); end

  def extractable_options?(); end

  def nested_under_indifferent_access(); end

  def reverse_merge(other_hash); end

  def reverse_merge!(other_hash); end

  def reverse_update(other_hash); end

  def slice!(*keys); end

  def to_options!(); end

  def to_param(namespace=T.unsafe(nil)); end

  def to_query(namespace=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def with_defaults(other_hash); end

  def with_defaults!(other_hash); end

  def with_indifferent_access(); end
end

class Hash
  def self.from_trusted_xml(xml); end

  def self.from_xml(xml, disallowed_types=T.unsafe(nil)); end

  def self.ruby2_keywords_hash(hash); end

  def self.ruby2_keywords_hash?(hash); end

  def self.try_convert(_); end
end

HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

Http = HTTP

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class I18n::ArgumentError
end

class I18n::ArgumentError
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key, options=T.unsafe(nil)); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Base
  def available_locales(); end

  def available_locales=(value); end

  def available_locales_initialized?(); end

  def backend(); end

  def backend=(value); end

  def config(); end

  def config=(value); end

  def default_locale(); end

  def default_locale=(value); end

  def default_separator(); end

  def default_separator=(value); end

  def eager_load!(); end

  def enforce_available_locales(); end

  def enforce_available_locales!(locale); end

  def enforce_available_locales=(value); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exists?(key, _locale=T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def l(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def load_path(); end

  def load_path=(value); end

  def locale(); end

  def locale=(value); end

  def locale_available?(locale); end

  def localize(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def normalize_keys(locale, key, scope, separator=T.unsafe(nil)); end

  def reload!(); end

  def t(key=T.unsafe(nil), *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def t!(key, options=T.unsafe(nil)); end

  def translate(key=T.unsafe(nil), *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def translate!(key, options=T.unsafe(nil)); end

  def transliterate(key, *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), replacement: T.unsafe(nil), **options); end

  def with_locale(tmp_locale=T.unsafe(nil)); end
end

module I18n::Base
end

class I18n::Config
  def available_locales(); end

  def available_locales=(locales); end

  def available_locales_initialized?(); end

  def available_locales_set(); end

  def backend(); end

  def backend=(backend); end

  def clear_available_locales_set(); end

  def default_locale(); end

  def default_locale=(locale); end

  def default_separator(); end

  def default_separator=(separator); end

  def enforce_available_locales(); end

  def enforce_available_locales=(enforce_available_locales); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def interpolation_patterns(); end

  def interpolation_patterns=(interpolation_patterns); end

  def load_path(); end

  def load_path=(load_path); end

  def locale(); end

  def locale=(locale); end

  def missing_interpolation_argument_handler(); end

  def missing_interpolation_argument_handler=(exception_handler); end
end

class I18n::Config
end

class I18n::Disabled
  def initialize(method); end
end

class I18n::Disabled
end

class I18n::ExceptionHandler
  def call(exception, _locale, _key, _options); end
end

class I18n::ExceptionHandler
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::HashRefinements
end

module I18n::HashRefinements
end

class I18n::InvalidLocale
  def initialize(locale); end

  def locale(); end
end

class I18n::InvalidLocale
end

class I18n::InvalidLocaleData
  def filename(); end

  def initialize(filename, exception_message); end
end

class I18n::InvalidLocaleData
end

class I18n::InvalidPluralizationData
  def count(); end

  def entry(); end

  def initialize(entry, count, key); end

  def key(); end
end

class I18n::InvalidPluralizationData
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

class I18n::MissingInterpolationArgument
  def initialize(key, values, string); end

  def key(); end

  def string(); end

  def values(); end
end

class I18n::MissingInterpolationArgument
end

class I18n::MissingTranslation
  include ::I18n::MissingTranslation::Base
end

module I18n::MissingTranslation::Base
  def initialize(locale, key, options=T.unsafe(nil)); end

  def key(); end

  def keys(); end

  def locale(); end

  def message(); end

  def options(); end

  def to_exception(); end

  def to_s(); end
end

module I18n::MissingTranslation::Base
end

class I18n::MissingTranslation
end

class I18n::MissingTranslationData
  include ::I18n::MissingTranslation::Base
end

class I18n::MissingTranslationData
end

class I18n::Railtie
end

class I18n::Railtie
  def self.include_fallbacks_module(); end

  def self.init_fallbacks(fallbacks); end

  def self.initialize_i18n(app); end

  def self.validate_fallbacks(fallbacks); end

  def self.watched_dirs_with_extensions(paths); end
end

class I18n::ReservedInterpolationKey
  def initialize(key, string); end

  def key(); end

  def string(); end
end

class I18n::ReservedInterpolationKey
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

class I18n::UnknownFileType
  def filename(); end

  def initialize(type, filename); end

  def type(); end
end

class I18n::UnknownFileType
end

module I18n
  extend ::I18n::Base
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.interpolate(string, values); end

  def self.interpolate_hash(string, values); end

  def self.new_double_nested_cache(); end

  def self.perform_caching?(); end
end

module INotify
  VERSION = ::T.let(nil, ::T.untyped)
end

module INotify::Native
end

class INotify::Native::Event
end

class INotify::Native::Event
end

module INotify::Native
  extend ::FFI::Library
end

module INotify
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  include ::MessagePack::CoreExt
  include ::ActiveSupport::NumericWithFormat
  def multiple_of?(number); end

  def ordinal(); end

  def ordinalize(); end

  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

module JMESPath
  VERSION = ::T.let(nil, ::T.untyped)
end

class JMESPath::CachingParser
  def initialize(options=T.unsafe(nil)); end

  def parse(expression); end
end

class JMESPath::CachingParser
end

module JMESPath::Errors
end

class JMESPath::Errors::Error
end

class JMESPath::Errors::Error
end

class JMESPath::Errors::InvalidArityError
end

class JMESPath::Errors::InvalidArityError
end

class JMESPath::Errors::InvalidTypeError
end

class JMESPath::Errors::InvalidTypeError
end

class JMESPath::Errors::InvalidValueError
end

class JMESPath::Errors::InvalidValueError
end

class JMESPath::Errors::RuntimeError
end

class JMESPath::Errors::RuntimeError
end

class JMESPath::Errors::SyntaxError
end

class JMESPath::Errors::SyntaxError
end

class JMESPath::Errors::UnknownFunctionError
end

class JMESPath::Errors::UnknownFunctionError
end

module JMESPath::Errors
end

class JMESPath::Lexer
  def tokenize(expression); end
  NUMBERS = ::T.let(nil, ::T.untyped)
  SIMPLE_TOKENS = ::T.let(nil, ::T.untyped)
  STATE_AND = ::T.let(nil, ::T.untyped)
  STATE_EQ = ::T.let(nil, ::T.untyped)
  STATE_GT = ::T.let(nil, ::T.untyped)
  STATE_IDENTIFIER = ::T.let(nil, ::T.untyped)
  STATE_JSON_LITERAL = ::T.let(nil, ::T.untyped)
  STATE_LBRACKET = ::T.let(nil, ::T.untyped)
  STATE_LT = ::T.let(nil, ::T.untyped)
  STATE_NOT = ::T.let(nil, ::T.untyped)
  STATE_NUMBER = ::T.let(nil, ::T.untyped)
  STATE_PIPE = ::T.let(nil, ::T.untyped)
  STATE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  STATE_SINGLE_CHAR = ::T.let(nil, ::T.untyped)
  STATE_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  STATE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TRANSLATION_TABLE = ::T.let(nil, ::T.untyped)
  T_AND = ::T.let(nil, ::T.untyped)
  T_COLON = ::T.let(nil, ::T.untyped)
  T_COMMA = ::T.let(nil, ::T.untyped)
  T_COMPARATOR = ::T.let(nil, ::T.untyped)
  T_CURRENT = ::T.let(nil, ::T.untyped)
  T_DOT = ::T.let(nil, ::T.untyped)
  T_EOF = ::T.let(nil, ::T.untyped)
  T_EXPREF = ::T.let(nil, ::T.untyped)
  T_FILTER = ::T.let(nil, ::T.untyped)
  T_FLATTEN = ::T.let(nil, ::T.untyped)
  T_IDENTIFIER = ::T.let(nil, ::T.untyped)
  T_LBRACE = ::T.let(nil, ::T.untyped)
  T_LBRACKET = ::T.let(nil, ::T.untyped)
  T_LITERAL = ::T.let(nil, ::T.untyped)
  T_LPAREN = ::T.let(nil, ::T.untyped)
  T_NOT = ::T.let(nil, ::T.untyped)
  T_NUMBER = ::T.let(nil, ::T.untyped)
  T_OR = ::T.let(nil, ::T.untyped)
  T_PIPE = ::T.let(nil, ::T.untyped)
  T_QUOTED_IDENTIFIER = ::T.let(nil, ::T.untyped)
  T_RBRACE = ::T.let(nil, ::T.untyped)
  T_RBRACKET = ::T.let(nil, ::T.untyped)
  T_RPAREN = ::T.let(nil, ::T.untyped)
  T_STAR = ::T.let(nil, ::T.untyped)
  T_UNKNOWN = ::T.let(nil, ::T.untyped)
  VALID_IDENTIFIERS = ::T.let(nil, ::T.untyped)
end

class JMESPath::Lexer::CharacterStream
  def current(); end

  def initialize(chars); end

  def next(); end

  def position(); end
end

class JMESPath::Lexer::CharacterStream
end

class JMESPath::Lexer
  def self.requires_wrapping?(); end
end

module JMESPath::Nodes
end

class JMESPath::Nodes::AbsFunction
end

class JMESPath::Nodes::AbsFunction
end

class JMESPath::Nodes::And
  def initialize(left, right); end
end

class JMESPath::Nodes::And
end

class JMESPath::Nodes::ArrayProjection
  def extract_targets(target); end

  def fast_instance(); end
end

class JMESPath::Nodes::ArrayProjection
end

class JMESPath::Nodes::AvgFunction
end

class JMESPath::Nodes::AvgFunction
end

class JMESPath::Nodes::CeilFunction
end

class JMESPath::Nodes::CeilFunction
end

class JMESPath::Nodes::Chain
  def initialize(children); end

  def optimize(); end

  def visit(value); end
end

class JMESPath::Nodes::Chain
end

class JMESPath::Nodes::ChainedField
  def initialize(keys); end

  def visit(obj); end
end

class JMESPath::Nodes::ChainedField
end

class JMESPath::Nodes::Comparator
  def initialize(left, right); end

  def left(); end

  def right(); end
end

class JMESPath::Nodes::Comparator
  def self.create(relation, left, right); end
end

class JMESPath::Nodes::ComparatorCondition
  def initialize(left, right, child); end
  COMPARATOR_TO_CONDITION = ::T.let(nil, ::T.untyped)
end

class JMESPath::Nodes::ComparatorCondition
end

module JMESPath::Nodes::Comparators
end

class JMESPath::Nodes::Comparators::Eq
end

class JMESPath::Nodes::Comparators::Eq
end

class JMESPath::Nodes::Comparators::Gt
end

class JMESPath::Nodes::Comparators::Gt
end

class JMESPath::Nodes::Comparators::Gte
end

class JMESPath::Nodes::Comparators::Gte
end

class JMESPath::Nodes::Comparators::Lt
end

class JMESPath::Nodes::Comparators::Lt
end

class JMESPath::Nodes::Comparators::Lte
end

class JMESPath::Nodes::Comparators::Lte
end

class JMESPath::Nodes::Comparators::Neq
end

class JMESPath::Nodes::Comparators::Neq
end

module JMESPath::Nodes::Comparators
end

module JMESPath::Nodes::CompareBy
  include ::JMESPath::Nodes::TypeChecker
  def compare_by(mode, *args); end
end

module JMESPath::Nodes::CompareBy
end

class JMESPath::Nodes::Condition
  def initialize(test, child); end
end

class JMESPath::Nodes::Condition
end

class JMESPath::Nodes::ContainsFunction
end

class JMESPath::Nodes::ContainsFunction
end

class JMESPath::Nodes::Current
end

class JMESPath::Nodes::Current
end

class JMESPath::Nodes::EndsWithFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::EndsWithFunction
end

class JMESPath::Nodes::EqCondition
end

class JMESPath::Nodes::EqCondition
end

class JMESPath::Nodes::Expression
  def eval(value); end

  def expression(); end

  def initialize(expression); end
end

class JMESPath::Nodes::Expression
end

class JMESPath::Nodes::FastArrayProjection
  include ::JMESPath::Nodes::FastProjector
end

class JMESPath::Nodes::FastArrayProjection
end

class JMESPath::Nodes::FastObjectProjection
  include ::JMESPath::Nodes::FastProjector
end

class JMESPath::Nodes::FastObjectProjection
end

module JMESPath::Nodes::FastProjector
  def visit(value); end
end

module JMESPath::Nodes::FastProjector
end

class JMESPath::Nodes::Field
  def chain(other); end

  def initialize(key); end

  def keys(); end
end

class JMESPath::Nodes::Field
end

class JMESPath::Nodes::Flatten
  def initialize(child); end
end

class JMESPath::Nodes::Flatten
end

class JMESPath::Nodes::FloorFunction
end

class JMESPath::Nodes::FloorFunction
end

class JMESPath::Nodes::Function
  def initialize(children, options=T.unsafe(nil)); end
  FUNCTIONS = ::T.let(nil, ::T.untyped)
end

class JMESPath::Nodes::Function::FunctionName
  def initialize(name); end

  def name(); end
end

class JMESPath::Nodes::Function::FunctionName
end

class JMESPath::Nodes::Function
  def self.create(name, children, options=T.unsafe(nil)); end
end

class JMESPath::Nodes::GtCondition
end

class JMESPath::Nodes::GtCondition
end

class JMESPath::Nodes::GteCondition
end

class JMESPath::Nodes::GteCondition
end

JMESPath::Nodes::Index = JMESPath::Nodes::Field

class JMESPath::Nodes::JoinFunction
end

class JMESPath::Nodes::JoinFunction
end

class JMESPath::Nodes::KeysFunction
end

class JMESPath::Nodes::KeysFunction
end

class JMESPath::Nodes::LengthFunction
end

class JMESPath::Nodes::LengthFunction
end

class JMESPath::Nodes::Literal
  def initialize(value); end

  def value(); end
end

class JMESPath::Nodes::Literal
end

class JMESPath::Nodes::LiteralRightEqCondition
end

class JMESPath::Nodes::LiteralRightEqCondition
end

class JMESPath::Nodes::LiteralRightNeqCondition
end

class JMESPath::Nodes::LiteralRightNeqCondition
end

class JMESPath::Nodes::LtCondition
end

class JMESPath::Nodes::LtCondition
end

class JMESPath::Nodes::LteCondition
end

class JMESPath::Nodes::LteCondition
end

class JMESPath::Nodes::Map
end

class JMESPath::Nodes::Map
end

class JMESPath::Nodes::MaxByFunction
  include ::JMESPath::Nodes::CompareBy
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::MaxByFunction
end

class JMESPath::Nodes::MaxFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::MaxFunction
end

class JMESPath::Nodes::MergeFunction
end

class JMESPath::Nodes::MergeFunction
end

class JMESPath::Nodes::MinByFunction
  include ::JMESPath::Nodes::CompareBy
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::MinByFunction
end

class JMESPath::Nodes::MinFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::MinFunction
end

class JMESPath::Nodes::MultiSelectHash
  def initialize(kv_pairs); end
end

class JMESPath::Nodes::MultiSelectHash::KeyValuePair
  def initialize(key, value); end

  def key(); end

  def optimize(); end

  def value(); end
end

class JMESPath::Nodes::MultiSelectHash::KeyValuePair
end

class JMESPath::Nodes::MultiSelectHash
end

class JMESPath::Nodes::MultiSelectList
  def initialize(children); end
end

class JMESPath::Nodes::MultiSelectList
end

class JMESPath::Nodes::NeqCondition
end

class JMESPath::Nodes::NeqCondition
end

class JMESPath::Nodes::Node
  def chains_with?(other); end

  def hash_like?(value); end

  def optimize(); end

  def visit(value); end
end

class JMESPath::Nodes::Node
end

class JMESPath::Nodes::Not
  def initialize(expression); end
end

class JMESPath::Nodes::Not
end

class JMESPath::Nodes::NotNullFunction
end

class JMESPath::Nodes::NotNullFunction
end

class JMESPath::Nodes::ObjectProjection
  def extract_targets(target); end

  def fast_instance(); end
end

class JMESPath::Nodes::ObjectProjection
end

class JMESPath::Nodes::Or
  def initialize(left, right); end
end

class JMESPath::Nodes::Or
end

JMESPath::Nodes::Pipe = JMESPath::Nodes::Subexpression

class JMESPath::Nodes::Projection
  def initialize(target, projection); end
end

class JMESPath::Nodes::Projection
end

class JMESPath::Nodes::ReverseFunction
end

class JMESPath::Nodes::ReverseFunction
end

class JMESPath::Nodes::SimpleSlice
  def initialize(start, stop); end
end

class JMESPath::Nodes::SimpleSlice
end

class JMESPath::Nodes::Slice
  def initialize(start, stop, step); end
end

class JMESPath::Nodes::Slice
end

class JMESPath::Nodes::SortByFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::SortByFunction
end

class JMESPath::Nodes::SortFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::SortFunction
end

class JMESPath::Nodes::StartsWithFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::StartsWithFunction
end

class JMESPath::Nodes::Subexpression
  def flatten(); end

  def initialize(left, right); end

  def left(); end

  def right(); end
end

class JMESPath::Nodes::Subexpression
end

class JMESPath::Nodes::SumFunction
end

class JMESPath::Nodes::SumFunction
end

class JMESPath::Nodes::ToArrayFunction
end

class JMESPath::Nodes::ToArrayFunction
end

class JMESPath::Nodes::ToNumberFunction
end

class JMESPath::Nodes::ToNumberFunction
end

class JMESPath::Nodes::ToStringFunction
end

class JMESPath::Nodes::ToStringFunction
end

module JMESPath::Nodes::TypeChecker
  def get_type(value); end
  ARRAY_TYPE = ::T.let(nil, ::T.untyped)
  BOOLEAN_TYPE = ::T.let(nil, ::T.untyped)
  EXPRESSION_TYPE = ::T.let(nil, ::T.untyped)
  NULL_TYPE = ::T.let(nil, ::T.untyped)
  NUMBER_TYPE = ::T.let(nil, ::T.untyped)
  OBJECT_TYPE = ::T.let(nil, ::T.untyped)
  STRING_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::TypeFunction
  include ::JMESPath::Nodes::TypeChecker
end

class JMESPath::Nodes::TypeFunction
end

class JMESPath::Nodes::ValuesFunction
end

class JMESPath::Nodes::ValuesFunction
end

module JMESPath::Nodes
end

class JMESPath::Parser
  def initialize(options=T.unsafe(nil)); end

  def method_missing(method_name, *args); end

  def parse(expression); end
  AFTER_DOT = ::T.let(nil, ::T.untyped)
  COLON_RBRACKET = ::T.let(nil, ::T.untyped)
  CURRENT_NODE = ::T.let(nil, ::T.untyped)
  NUM_COLON_RBRACKET = ::T.let(nil, ::T.untyped)
end

class JMESPath::Parser
end

class JMESPath::Runtime
  def initialize(options=T.unsafe(nil)); end

  def parser(); end

  def search(expression, data); end
end

JMESPath::Runtime::DEFAULT_PARSER = JMESPath::CachingParser

class JMESPath::Runtime
end

class JMESPath::Token
  def initialize(type, value, position); end
  BINDING_POWER = ::T.let(nil, ::T.untyped)
  NULL_TOKEN = ::T.let(nil, ::T.untyped)
end

class JMESPath::Token
end

class JMESPath::TokenStream
  def expression(); end

  def initialize(expression, tokens); end

  def lookahead(count); end

  def next(options=T.unsafe(nil)); end

  def position(); end

  def token(); end
end

class JMESPath::TokenStream
end

module JMESPath::Util
end

module JMESPath::Util
  def self.falsey?(value); end
end

module JMESPath
  def self.load_json(path); end

  def self.search(expression, data, runtime_options=T.unsafe(nil)); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JaroWinkler
  VERSION = ::T.let(nil, ::T.untyped)
end

class JaroWinkler::Error
end

class JaroWinkler::Error
end

class JaroWinkler::InvalidWeightError
end

class JaroWinkler::InvalidWeightError
end

module JaroWinkler
  def self.distance(*_); end

  def self.jaro_distance(*_); end
end

module Kaminari
end

module Kaminari::ActionViewExtension
end

module Kaminari::ActionViewExtension::LogSubscriberSilencer
  def render_partial(*_); end
end

module Kaminari::ActionViewExtension::LogSubscriberSilencer
end

module Kaminari::ActionViewExtension
end

module Kaminari::Actionview
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kaminari::Actionview
end

module Kaminari::ActiveRecordExtension
end

module Kaminari::ActiveRecordExtension
  extend ::ActiveSupport::Concern
end

module Kaminari::ActiveRecordModelExtension
end

module Kaminari::ActiveRecordModelExtension
  extend ::ActiveSupport::Concern
end

module Kaminari::ActiveRecordRelationMethods
  def entry_name(options=T.unsafe(nil)); end

  def reset(); end

  def total_count(column_name=T.unsafe(nil), _options=T.unsafe(nil)); end

  def without_count(); end
end

module Kaminari::ActiveRecordRelationMethods
end

module Kaminari::Activerecord
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kaminari::Activerecord
end

class Kaminari::Config
  def default_per_page(); end

  def default_per_page=(default_per_page); end

  def left(); end

  def left=(left); end

  def max_pages(); end

  def max_pages=(max_pages); end

  def max_per_page(); end

  def max_per_page=(max_per_page); end

  def outer_window(); end

  def outer_window=(outer_window); end

  def page_method_name(); end

  def page_method_name=(page_method_name); end

  def param_name(); end

  def param_name=(param_name); end

  def params_on_first_page(); end

  def params_on_first_page=(params_on_first_page); end

  def right(); end

  def right=(right); end

  def window(); end

  def window=(window); end
end

class Kaminari::Config
end

module Kaminari::ConfigurationMethods
end

module Kaminari::ConfigurationMethods::ClassMethods
  def default_per_page(); end

  def max_pages(val=T.unsafe(nil)); end

  def max_pages_per(val); end

  def max_paginates_per(val); end

  def max_per_page(); end

  def paginates_per(val); end
end

module Kaminari::ConfigurationMethods::ClassMethods
end

module Kaminari::ConfigurationMethods
  extend ::ActiveSupport::Concern
end

class Kaminari::Engine
end

class Kaminari::Engine
end

module Kaminari::Helpers
  PARAM_KEY_EXCEPT_LIST = ::T.let(nil, ::T.untyped)
end

class Kaminari::Helpers::FirstPage
  include ::Kaminari::Helpers::Link
end

class Kaminari::Helpers::FirstPage
end

class Kaminari::Helpers::Gap
end

class Kaminari::Helpers::Gap
end

module Kaminari::Helpers::HelperMethods
  include ::Kaminari::Helpers::UrlHelper
  def link_to_next_page(scope, name, **options); end

  def link_to_prev_page(scope, name, **options); end

  def link_to_previous_page(scope, name, **options); end

  def page_entries_info(collection, entry_name: T.unsafe(nil)); end

  def paginate(scope, paginator_class: T.unsafe(nil), template: T.unsafe(nil), **options); end

  def rel_next_prev_link_tags(scope, options=T.unsafe(nil)); end
end

module Kaminari::Helpers::HelperMethods
end

class Kaminari::Helpers::LastPage
  include ::Kaminari::Helpers::Link
end

class Kaminari::Helpers::LastPage
end

module Kaminari::Helpers::Link
  def page(); end

  def to_s(locals=T.unsafe(nil)); end

  def url(); end
end

module Kaminari::Helpers::Link
end

class Kaminari::Helpers::NextPage
  include ::Kaminari::Helpers::Link
end

class Kaminari::Helpers::NextPage
end

class Kaminari::Helpers::Page
  include ::Kaminari::Helpers::Link
end

class Kaminari::Helpers::Page
end

class Kaminari::Helpers::Paginator
  include ::ActionView::Context
  def each_page(); end

  def each_relevant_page(); end

  def first_page_tag(); end

  def gap_tag(); end

  def initialize(template, window: T.unsafe(nil), outer_window: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), inner_window: T.unsafe(nil), **options); end

  def last_page_tag(); end

  def next_page_tag(); end

  def page_tag(page); end

  def prev_page_tag(); end

  def render(&block); end

  def to_s(); end
end

class Kaminari::Helpers::Paginator::PageProxy
  include ::Comparable
  def +(other); end

  def -(other); end

  def current?(); end

  def display_tag?(); end

  def first?(); end

  def initialize(options, page, last); end

  def inside_window?(); end

  def last?(); end

  def left_outer?(); end

  def next?(); end

  def number(); end

  def out_of_range?(); end

  def prev?(); end

  def rel(); end

  def right_outer?(); end

  def single_gap?(); end

  def to_i(); end

  def was_truncated?(); end
end

class Kaminari::Helpers::Paginator::PageProxy
end

class Kaminari::Helpers::Paginator
end

class Kaminari::Helpers::PrevPage
  include ::Kaminari::Helpers::Link
end

class Kaminari::Helpers::PrevPage
end

class Kaminari::Helpers::Tag
  def initialize(template, params: T.unsafe(nil), param_name: T.unsafe(nil), theme: T.unsafe(nil), views_prefix: T.unsafe(nil), **options); end

  def page_url_for(page); end

  def to_s(locals=T.unsafe(nil)); end
end

class Kaminari::Helpers::Tag
end

module Kaminari::Helpers::UrlHelper
  def next_page_path(scope, options=T.unsafe(nil)); end

  def next_page_url(scope, options=T.unsafe(nil)); end

  def path_to_next_page(scope, options=T.unsafe(nil)); end

  def path_to_next_url(scope, options=T.unsafe(nil)); end

  def path_to_prev_page(scope, options=T.unsafe(nil)); end

  def path_to_previous_page(scope, options=T.unsafe(nil)); end

  def prev_page_path(scope, options=T.unsafe(nil)); end

  def prev_page_url(scope, options=T.unsafe(nil)); end

  def previous_page_path(scope, options=T.unsafe(nil)); end

  def previous_page_url(scope, options=T.unsafe(nil)); end

  def url_to_prev_page(scope, options=T.unsafe(nil)); end

  def url_to_previous_page(scope, options=T.unsafe(nil)); end
end

module Kaminari::Helpers::UrlHelper
end

module Kaminari::Helpers
end

module Kaminari::PageScopeMethods
  def current_page(); end

  def current_per_page(); end

  def first_page?(); end

  def last_page?(); end

  def max_paginates_per(new_max_per_page); end

  def next_page(); end

  def out_of_range?(); end

  def padding(num); end

  def per(num, max_per_page: T.unsafe(nil)); end

  def prev_page(); end

  def total_pages(); end
end

module Kaminari::PageScopeMethods
end

class Kaminari::PaginatableArray
  include ::Kaminari::ConfigurationMethods::ClassMethods
  def entry_name(options=T.unsafe(nil)); end

  def initialize(original_array=T.unsafe(nil), limit: T.unsafe(nil), offset: T.unsafe(nil), total_count: T.unsafe(nil), padding: T.unsafe(nil)); end

  def limit(num); end

  def limit_value(); end

  def limit_value=(limit_value); end

  def offset(num); end

  def offset_value(); end

  def offset_value=(offset_value); end

  def page(num=T.unsafe(nil)); end

  def total_count(); end
  ENTRY = ::T.let(nil, ::T.untyped)
end

class Kaminari::PaginatableArray
end

module Kaminari::PaginatableWithoutCount
  def last_page?(); end

  def load(); end

  def out_of_range?(); end

  def total_count(); end
end

module Kaminari::PaginatableWithoutCount::LimitValueSetter
end

module Kaminari::PaginatableWithoutCount::LimitValueSetter
end

module Kaminari::PaginatableWithoutCount
end

class Kaminari::Railtie
end

class Kaminari::Railtie
end

class Kaminari::ZeroPerPageOperation
end

class Kaminari::ZeroPerPageOperation
end

module Kaminari
  def self.config(); end

  def self.configure(); end

  def self.paginate_array(array, limit: T.unsafe(nil), offset: T.unsafe(nil), total_count: T.unsafe(nil), padding: T.unsafe(nil)); end
end

module Kernel
  def class_eval(*args, &block); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end

  def self.autoload(_, _1); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module Listen
  VERSION = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
end

class Listen::Adapter::Base
  def config(); end

  def configure(); end

  def initialize(config); end

  def options(); end

  def start(); end

  def started?(); end

  def stop(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  def self.usable?(); end
end

class Listen::Adapter::Config
  def adapter_options(); end

  def directories(); end

  def initialize(directories, queue, silencer, adapter_options); end

  def queue(); end

  def silencer(); end
end

class Listen::Adapter::Config
end

class Listen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Darwin
end

class Listen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INOTIFY_LIMIT_MESSAGE = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  WIKI_URL = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Linux
end

class Listen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Polling
end

class Listen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Windows
end

module Listen::Adapter
  def self.select(options=T.unsafe(nil)); end
end

class Listen::Backend
  def initialize(directories, queue, silencer, config); end

  def min_delay_between_events(); end

  def start(*args, &block); end

  def stop(*args, &block); end
end

class Listen::Backend
  extend ::Forwardable
end

class Listen::Change
  def initialize(config, record); end

  def invalidate(type, rel_path, options); end

  def record(); end
end

class Listen::Change::Config
  def initialize(queue, silencer); end

  def queue(*args); end

  def silenced?(path, type); end
end

class Listen::Change::Config
end

class Listen::Change
end

class Listen::Directory
end

class Listen::Directory
  def self._async_changes(snapshot, path, previous, options); end

  def self._change(snapshot, type, path, options); end

  def self._children(path); end

  def self.ascendant_of?(base, other); end

  def self.scan(snapshot, rel_path, options); end
end

module Listen::Event
end

class Listen::Event::Config
  def call(*args); end

  def callable?(); end

  def event_queue(); end

  def initialize(listener, event_queue, queue_optimizer, wait_for_delay, &block); end

  def min_delay_between_events(); end

  def optimize_changes(changes); end

  def paused?(); end

  def sleep(*args); end

  def stopped?(); end

  def timestamp(); end
end

class Listen::Event::Config
end

class Listen::Event::Loop
  def initialize(config); end

  def pause(); end

  def paused?(); end

  def processing?(); end

  def resume(); end

  def setup(); end

  def stopped?(); end

  def teardown(); end

  def wakeup_on_event(); end
end

class Listen::Event::Loop::Error
end

class Listen::Event::Loop::Error::NotStarted
end

class Listen::Event::Loop::Error::NotStarted
end

class Listen::Event::Loop::Error
end

class Listen::Event::Loop
end

class Listen::Event::Processor
  def initialize(config, reasons); end

  def loop_for(latency); end
end

class Listen::Event::Processor::Stopped
end

class Listen::Event::Processor::Stopped
end

class Listen::Event::Processor
end

class Listen::Event::Queue
  def <<(args); end

  def empty?(*args, &block); end

  def initialize(config, &block); end

  def pop(*args, &block); end
end

class Listen::Event::Queue::Config
  def initialize(relative); end

  def relative?(); end
end

class Listen::Event::Queue::Config
end

class Listen::Event::Queue
  extend ::Forwardable
end

module Listen::Event
end

module Listen::FSM
  def current_state(); end

  def current_state_name(); end

  def default_state(); end

  def initialize(); end

  def state(); end

  def states(); end

  def transition(state_name); end

  def transition!(state_name); end

  def transition_with_callbacks!(state_name); end

  def validate_and_sanitize_new_state(state_name); end
  DEFAULT_STATE = ::T.let(nil, ::T.untyped)
end

module Listen::FSM::ClassMethods
  def default_state(new_default=T.unsafe(nil)); end

  def state(*args, &block); end

  def states(); end
end

module Listen::FSM::ClassMethods
end

class Listen::FSM::State
  def call(obj); end

  def initialize(name, transitions=T.unsafe(nil), &block); end

  def name(); end

  def transitions(); end

  def valid_transition?(new_state); end
end

class Listen::FSM::State
end

module Listen::FSM
  def self.included(klass); end
end

class Listen::File
end

class Listen::File
  def self.change(record, rel_path); end

  def self.inaccurate_mac_time?(stat); end
end

module Listen::Internals
end

module Listen::Internals::ThreadPool
end

module Listen::Internals::ThreadPool
  def self.add(&block); end

  def self.stop(); end
end

module Listen::Internals
end

class Listen::Listener
  include ::Listen::FSM
  def ignore(regexps); end

  def ignore!(regexps); end

  def initialize(*dirs, &block); end

  def only(regexps); end

  def pause(); end

  def paused?(); end

  def processing?(); end

  def start(); end

  def stop(); end
end

class Listen::Listener::Config
  def adapter_instance_options(klass); end

  def adapter_select_options(); end

  def initialize(opts); end

  def min_delay_between_events(); end

  def relative?(); end

  def silencer_rules(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Listener::Config
end

class Listen::Listener
  extend ::Listen::FSM::ClassMethods
end

class Listen::Logger
end

class Listen::Logger
  def self.debug(*args, &block); end

  def self.error(*args, &block); end

  def self.fatal(*args, &block); end

  def self.info(*args, &block); end

  def self.warn(*args, &block); end
end

class Listen::Options
  def initialize(opts, defaults); end

  def method_missing(name, *_); end
end

class Listen::Options
end

class Listen::QueueOptimizer
  def initialize(config); end

  def smoosh_changes(changes); end
end

class Listen::QueueOptimizer::Config
  def debug(*args, &block); end

  def exist?(path); end

  def initialize(adapter_class, silencer); end

  def silenced?(path, type); end
end

class Listen::QueueOptimizer::Config
end

class Listen::QueueOptimizer
end

class Listen::Record
  def add_dir(rel_path); end

  def build(); end

  def dir_entries(rel_path); end

  def file_data(rel_path); end

  def initialize(directory); end

  def root(); end

  def unset_path(rel_path); end

  def update_file(rel_path, data); end
end

class Listen::Record::Entry
  def children(); end

  def initialize(root, relative, name=T.unsafe(nil)); end

  def meta(); end

  def name(); end

  def real_path(); end

  def record_dir_key(); end

  def relative(); end

  def root(); end

  def sys_path(); end
end

class Listen::Record::Entry
end

class Listen::Record::SymlinkDetector
  def verify_unwatched!(entry); end
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
  WIKI = ::T.let(nil, ::T.untyped)
end

class Listen::Record::SymlinkDetector::Error
end

class Listen::Record::SymlinkDetector::Error
end

class Listen::Record::SymlinkDetector
end

class Listen::Record
end

class Listen::Silencer
  def configure(options); end

  def ignore_patterns(); end

  def ignore_patterns=(ignore_patterns); end

  def only_patterns(); end

  def only_patterns=(only_patterns); end

  def silenced?(relative_path, type); end
  DEFAULT_IGNORED_DIRECTORIES = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Listen::Silencer::Controller
  def append_ignores(*regexps); end

  def initialize(silencer, default_options); end

  def replace_with_bang_ignores(regexps); end

  def replace_with_only(regexps); end
end

class Listen::Silencer::Controller
end

class Listen::Silencer
end

module Listen
  def self.logger(); end

  def self.logger=(logger); end

  def self.setup_default_logger_if_unset(); end

  def self.stop(); end

  def self.to(*args, &block); end
end

class LoadError
  def is_missing?(location); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module LoggerSilence
end

module LoggerSilence
  extend ::ActiveSupport::Concern
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::DocumentDecorator
  def initialize(*args, &block); end
end

module Loofah::DocumentDecorator
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
end

module Loofah::HTML
end

class Loofah::HTML::Document
  include ::Loofah::ScrubBehavior::Node
  include ::Loofah::DocumentDecorator
  include ::Loofah::TextBehavior
  def serialize_root(); end
end

class Loofah::HTML::Document
end

class Loofah::HTML::DocumentFragment
  include ::Loofah::TextBehavior
  def serialize_root(); end
end

class Loofah::HTML::DocumentFragment
end

module Loofah::HTML
end

module Loofah::HTML5
end

module Loofah::HTML5::SafeList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::SafeList
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  def self.allowed_element?(element_name); end

  def self.force_correct_attribute_escaping!(node); end

  def self.scrub_attributes(node); end

  def self.scrub_css(style); end

  def self.scrub_css_attribute(node); end
end

Loofah::HTML5::WhiteList = Loofah::HTML5::SafeList

module Loofah::HTML5
end

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

module Loofah::LibxmlWorkarounds
end

module Loofah::MetaHelpers
end

module Loofah::MetaHelpers
  def self.add_downcased_set_members_to_all_set_constants(mojule); end
end

module Loofah::ScrubBehavior
end

module Loofah::ScrubBehavior::Node
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::Node
end

module Loofah::ScrubBehavior::NodeSet
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::NodeSet
end

module Loofah::ScrubBehavior
  def self.resolve_scrubber(scrubber); end
end

class Loofah::Scrubber
  def append_attribute(node, attribute, value); end

  def block(); end

  def direction(); end

  def initialize(options=T.unsafe(nil), &block); end

  def scrub(node); end

  def traverse(node); end
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
end

class Loofah::ScrubberNotFound
end

class Loofah::ScrubberNotFound
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubbers::Escape
  def initialize(); end
end

class Loofah::Scrubbers::Escape
end

class Loofah::Scrubbers::NewlineBlockElements
  def initialize(); end
end

class Loofah::Scrubbers::NewlineBlockElements
end

class Loofah::Scrubbers::NoFollow
  def initialize(); end
end

class Loofah::Scrubbers::NoFollow
end

class Loofah::Scrubbers::NoOpener
  def initialize(); end
end

class Loofah::Scrubbers::NoOpener
end

class Loofah::Scrubbers::Prune
  def initialize(); end
end

class Loofah::Scrubbers::Prune
end

class Loofah::Scrubbers::Strip
  def initialize(); end
end

class Loofah::Scrubbers::Strip
end

class Loofah::Scrubbers::Unprintable
  def initialize(); end
end

class Loofah::Scrubbers::Unprintable
end

class Loofah::Scrubbers::Whitewash
  def initialize(); end
end

class Loofah::Scrubbers::Whitewash
end

module Loofah::Scrubbers
  def self.scrubber_symbols(); end
end

module Loofah::TextBehavior
  def inner_text(options=T.unsafe(nil)); end

  def text(options=T.unsafe(nil)); end

  def to_str(options=T.unsafe(nil)); end

  def to_text(options=T.unsafe(nil)); end
end

module Loofah::TextBehavior
end

module Loofah::XML
end

class Loofah::XML::Document
  include ::Loofah::ScrubBehavior::Node
  include ::Loofah::DocumentDecorator
end

class Loofah::XML::Document
end

class Loofah::XML::DocumentFragment
end

class Loofah::XML::DocumentFragment
end

module Loofah::XML
end

module Loofah
  def self.document(*args, &block); end

  def self.fragment(*args, &block); end

  def self.remove_extraneous_whitespace(string); end

  def self.scrub_document(string_or_io, method); end

  def self.scrub_fragment(string_or_io, method); end

  def self.scrub_xml_document(string_or_io, method); end

  def self.scrub_xml_fragment(string_or_io, method); end

  def self.xml_document(*args, &block); end

  def self.xml_fragment(*args, &block); end
end

module Lumberjack
  LINE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Context
  def [](key); end

  def []=(key, value); end

  def initialize(parent_context=T.unsafe(nil)); end

  def reset(); end

  def tag(tags); end

  def tags(); end
end

class Lumberjack::Context
end

class Lumberjack::Device
  def cleanup_files!(); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(format); end

  def do_once(file); end

  def flush(); end

  def reopen(logdev=T.unsafe(nil)); end

  def write(entry); end
end

class Lumberjack::Device::DateRollingLogFile
end

class Lumberjack::Device::DateRollingLogFile
end

class Lumberjack::Device::LogFile
  def initialize(path, options=T.unsafe(nil)); end

  def path(); end
  EXTERNAL_ENCODING = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Device::LogFile
end

class Lumberjack::Device::Multi
  def initialize(*devices); end
end

class Lumberjack::Device::Multi
end

class Lumberjack::Device::Null
  def initialize(*args); end
end

class Lumberjack::Device::Null
end

class Lumberjack::Device::RollingLogFile
  def after_roll(); end

  def archive_file_suffix(); end

  def before_flush(); end

  def keep(); end

  def keep=(keep); end

  def roll_file!(); end

  def roll_file?(); end
end

class Lumberjack::Device::RollingLogFile
end

class Lumberjack::Device::SizeRollingLogFile
  def max_size(); end

  def next_archive_number(); end
end

class Lumberjack::Device::SizeRollingLogFile
end

class Lumberjack::Device::Writer
  def buffer_size(); end

  def buffer_size=(value); end

  def initialize(stream, options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end
  DEFAULT_ADDITIONAL_LINES_TEMPLATE = ::T.let(nil, ::T.untyped)
  DEFAULT_FIRST_LINE_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Device::Writer::Buffer
  def <<(string); end

  def clear(); end

  def empty?(); end

  def pop!(); end

  def size(); end
end

class Lumberjack::Device::Writer::Buffer
end

class Lumberjack::Device::Writer
end

class Lumberjack::Device
end

class Lumberjack::Formatter
  def add(klass, formatter=T.unsafe(nil), &block); end

  def call(severity, timestamp, progname, msg); end

  def clear(); end

  def format(message); end

  def remove(klass); end
end

class Lumberjack::Formatter::DateTimeFormatter
  def call(obj); end

  def format(); end

  def initialize(format=T.unsafe(nil)); end
end

class Lumberjack::Formatter::DateTimeFormatter
end

class Lumberjack::Formatter::ExceptionFormatter
  def backtrace_cleaner(); end

  def backtrace_cleaner=(backtrace_cleaner); end

  def call(exception); end

  def initialize(backtrace_cleaner=T.unsafe(nil)); end
end

class Lumberjack::Formatter::ExceptionFormatter
end

class Lumberjack::Formatter::IdFormatter
  def call(obj); end

  def initialize(id_attribute=T.unsafe(nil)); end
end

class Lumberjack::Formatter::IdFormatter
end

class Lumberjack::Formatter::InspectFormatter
  def call(obj); end
end

class Lumberjack::Formatter::InspectFormatter
end

class Lumberjack::Formatter::ObjectFormatter
  def call(obj); end
end

class Lumberjack::Formatter::ObjectFormatter
end

class Lumberjack::Formatter::PrettyPrintFormatter
  def call(obj); end

  def initialize(width=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class Lumberjack::Formatter::PrettyPrintFormatter
end

class Lumberjack::Formatter::StringFormatter
  def call(obj); end
end

class Lumberjack::Formatter::StringFormatter
end

class Lumberjack::Formatter::StripFormatter
  def call(obj); end
end

class Lumberjack::Formatter::StripFormatter
end

class Lumberjack::Formatter::StructuredFormatter
  def call(obj); end

  def initialize(formatter=T.unsafe(nil)); end
end

class Lumberjack::Formatter::StructuredFormatter::RecusiveReferenceError
end

class Lumberjack::Formatter::StructuredFormatter::RecusiveReferenceError
end

class Lumberjack::Formatter::StructuredFormatter
end

class Lumberjack::Formatter
  def self.empty(); end
end

class Lumberjack::LogEntry
  def initialize(time, severity, message, progname, pid, tags); end

  def message(); end

  def message=(message); end

  def pid(); end

  def pid=(pid); end

  def progname(); end

  def progname=(progname); end

  def severity(); end

  def severity=(severity); end

  def severity_label(); end

  def tag(name); end

  def tags(); end

  def tags=(tags); end

  def time(); end

  def time=(time); end

  def unit_of_work_id(); end

  def unit_of_work_id=(value); end
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
  UNIT_OF_WORK_ID = ::T.let(nil, ::T.untyped)
end

class Lumberjack::LogEntry
end

class Lumberjack::Logger
  include ::Lumberjack::Severity
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def add_entry(severity, message, progname=T.unsafe(nil), tags=T.unsafe(nil)); end

  def close(); end

  def closed?(); end

  def datetime_format(); end

  def datetime_format=(format); end

  def debug(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def debug!(); end

  def debug?(); end

  def device(); end

  def device=(device); end

  def error(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def error!(); end

  def error?(); end

  def fatal(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def fatal!(); end

  def fatal?(); end

  def flush(); end

  def formatter(); end

  def formatter=(value); end

  def info(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def info!(); end

  def info?(); end

  def initialize(device=T.unsafe(nil), options=T.unsafe(nil)); end

  def last_flushed_at(); end

  def level(); end

  def level=(value); end

  def log(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def progname(); end

  def progname=(progname); end

  def remove_tag(*tag_names); end

  def reopen(logdev=T.unsafe(nil)); end

  def set_progname(value, &block); end

  def sev_threshold(); end

  def sev_threshold=(value); end

  def silence(temporary_level=T.unsafe(nil), &block); end

  def silencer(); end

  def silencer=(silencer); end

  def tag(tags, &block); end

  def tag_formatter(); end

  def tag_formatter=(tag_formatter); end

  def tagged_logger!(); end

  def tags(); end

  def unknown(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def warn(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def warn!(); end

  def warn?(); end
end

class Lumberjack::Logger
end

module Lumberjack::Rack
end

class Lumberjack::Rack::Context
  def call(env); end

  def initialize(app); end
end

class Lumberjack::Rack::Context
end

class Lumberjack::Rack::RequestId
  def call(env); end

  def initialize(app, abbreviated=T.unsafe(nil)); end
  REQUEST_ID = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Rack::RequestId
end

class Lumberjack::Rack::UnitOfWork
  def call(env); end

  def initialize(app); end
end

class Lumberjack::Rack::UnitOfWork
end

module Lumberjack::Rack
end

module Lumberjack::Severity
  DEBUG = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FATAL = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  SEVERITY_LABELS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  WARN = ::T.let(nil, ::T.untyped)
end

module Lumberjack::Severity
  def self.label_to_level(label); end

  def self.level_to_label(severity); end
end

class Lumberjack::TagFormatter
  def add(names, formatter=T.unsafe(nil), &block); end

  def clear(); end

  def default(formatter=T.unsafe(nil), &block); end

  def format(tags); end

  def remove(names); end

  def remove_default(); end
end

class Lumberjack::TagFormatter
end

module Lumberjack::TaggedLoggerSupport
  def clear_tags!(); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tagged(*tags, &block); end
end

class Lumberjack::TaggedLoggerSupport::Formatter
  def __formatter(); end

  def clear_tags!(*args, &block); end

  def current_tags(); end

  def initialize(formatter:, logger:); end

  def pop_tags(*args, &block); end

  def push_tags(*args, &block); end

  def tagged(*args, &block); end

  def tags_text(); end
end

class Lumberjack::TaggedLoggerSupport::Formatter
  extend ::Forwardable
end

module Lumberjack::TaggedLoggerSupport
end

module Lumberjack::TaggedLogging
end

module Lumberjack::TaggedLogging
  def self.included(base); end
end

class Lumberjack::Tags
end

class Lumberjack::Tags
  def self.expand_runtime_values(hash); end

  def self.stringify_keys(hash); end
end

class Lumberjack::Template
  def call(entry); end

  def datetime_format(); end

  def datetime_format=(format); end

  def initialize(first_line, options=T.unsafe(nil)); end
  MICROSECOND_TIME_FORMAT = ::T.let(nil, ::T.untyped)
  MILLISECOND_TIME_FORMAT = ::T.let(nil, ::T.untyped)
  PLACEHOLDER_PATTERN = ::T.let(nil, ::T.untyped)
  TEMPLATE_ARGUMENT_ORDER = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Template
end

module Lumberjack
  def self.context(); end

  def self.context?(); end

  def self.context_tags(); end

  def self.tag(tags); end

  def self.unit_of_work(id=T.unsafe(nil)); end

  def self.unit_of_work_id(); end
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::Address
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other_address); end

  def address(output_type=T.unsafe(nil)); end

  def address=(value); end

  def comments(); end

  def decoded(); end

  def display_name(output_type=T.unsafe(nil)); end

  def display_name=(str); end

  def domain(output_type=T.unsafe(nil)); end

  def encoded(); end

  def format(output_type=T.unsafe(nil)); end

  def group(); end

  def initialize(value=T.unsafe(nil)); end

  def local(output_type=T.unsafe(nil)); end

  def name(); end

  def raw(); end
end

class Mail::Address
  def self.wrap(address); end
end

class Mail::AddressContainer
  def <<(address); end

  def initialize(field, list=T.unsafe(nil)); end
end

class Mail::AddressContainer
end

class Mail::AddressList
  def addresses(); end

  def addresses_grouped_by_group(); end

  def group_names(); end

  def initialize(string); end
end

class Mail::AddressList
end

class Mail::AttachmentsList
  def [](index_value); end

  def []=(name, value); end

  def guess_encoding(); end

  def initialize(parts_list); end

  def inline(); end

  def set_mime_type(filename); end
end

class Mail::AttachmentsList
end

class Mail::BccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def include_in_headers(); end

  def include_in_headers=(include_in_headers); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::BccField
end

class Mail::Body
  def <<(val); end

  def ==(other); end

  def =~(regexp); end

  def ascii_only?(); end

  def boundary(); end

  def boundary=(val); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def default_encoding(); end

  def empty?(); end

  def encoded(transfer_encoding=T.unsafe(nil)); end

  def encoding(val=T.unsafe(nil)); end

  def encoding=(val); end

  def epilogue(); end

  def epilogue=(val); end

  def include?(other); end

  def initialize(string=T.unsafe(nil)); end

  def match(regexp); end

  def multipart?(); end

  def negotiate_best_encoding(message_encoding, allowed_encodings=T.unsafe(nil)); end

  def parts(); end

  def preamble(); end

  def preamble=(val); end

  def raw_source(); end

  def set_sort_order(order); end

  def sort_parts!(); end

  def split!(boundary); end
end

class Mail::Body
end

class Mail::CcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
end

module Mail::CheckDeliveryParams
end

module Mail::CheckDeliveryParams
  def self.check(mail); end

  def self.check_addr(addr_name, addr); end

  def self.check_from(addr); end

  def self.check_message(message); end

  def self.check_to(addrs); end

  def self.validate_smtp_addr(addr); end
end

class Mail::CommentsField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
end

module Mail::CommonAddress
  def <<(val); end

  def addresses(); end

  def addrs(); end

  def charset(); end

  def decoded_group_addresses(); end

  def default(); end

  def display_names(); end

  def each(&blk); end

  def encode_if_needed(val); end

  def encoded_group_addresses(); end

  def formatted(); end

  def group_addresses(); end

  def group_names(); end

  def groups(); end

  def parse(val=T.unsafe(nil)); end

  def value=(val); end
end

module Mail::CommonAddress
end

module Mail::CommonDate
  def date_time(); end

  def default(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonDate
end

module Mail::CommonField
  include ::Mail::Constants
  def default(); end

  def field_length(); end

  def name(); end

  def name=(value); end

  def responsible_for?(val); end

  def to_s(); end

  def value(); end

  def value=(value); end
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::CommonField
end

module Mail::CommonMessageId
  def default(); end

  def element(); end

  def message_id(); end

  def message_ids(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonMessageId
end

class Mail::Configuration
  include ::Singleton
  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def lookup_delivery_method(method); end

  def lookup_retriever_method(method); end

  def param_encode_language(value=T.unsafe(nil)); end

  def retriever_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end
end

class Mail::Configuration
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
end

class Mail::ContentDescriptionField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
end

class Mail::ContentDispositionElement
  def disposition_type(); end

  def initialize(string); end

  def parameters(); end
end

class Mail::ContentDispositionElement
end

class Mail::ContentDispositionField
  def decoded(); end

  def disposition_type(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionField
end

class Mail::ContentIdField
  def content_id(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
end

class Mail::ContentLocationElement
  def initialize(string); end

  def location(); end

  def to_s(*args); end
end

class Mail::ContentLocationElement
end

class Mail::ContentLocationField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def location(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationField
end

class Mail::ContentTransferEncodingElement
  def encoding(); end

  def initialize(string); end
end

class Mail::ContentTransferEncodingElement
end

class Mail::ContentTransferEncodingField
  def decoded(); end

  def element(); end

  def encoded(); end

  def encoding(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingField
end

class Mail::ContentTypeElement
  def initialize(string); end

  def main_type(); end

  def parameters(); end

  def sub_type(); end
end

class Mail::ContentTypeElement
end

class Mail::ContentTypeField
  def attempt_to_clean(); end

  def content_type(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def main_type(); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end

  def string(); end

  def stringify(params); end

  def sub_type(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeField
  def self.generate_boundary(); end

  def self.with_boundary(type); end
end

class Mail::DateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
end

class Mail::DateTimeElement
  def date_string(); end

  def initialize(string); end

  def time_string(); end
end

class Mail::DateTimeElement
end

module Mail::Encodings
  include ::Mail::Constants
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Base64
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
end

class Mail::Encodings::Identity
end

class Mail::Encodings::Identity
  def self.decode(str); end

  def self.encode(str); end
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  def self.can_encode?(enc); end

  def self.can_transport?(enc); end

  def self.compatible_input?(str); end

  def self.cost(str); end

  def self.lowest_cost(str, encodings); end

  def self.negotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end

  def self.renegotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  def self.decode(str); end

  def self.encode(str); end
end

module Mail::Encodings
  extend ::Mail::Utilities
  extend ::Mail::Constants
  def self.address_encode(address, charset=T.unsafe(nil)); end

  def self.b_value_decode(str); end

  def self.b_value_encode(string, encoding=T.unsafe(nil)); end

  def self.collapse_adjacent_encodings(str); end

  def self.decode_encode(str, output_type); end

  def self.defined?(name); end

  def self.each_base64_chunk_byterange(str, max_bytesize_per_base64_chunk, &block); end

  def self.each_chunk_byterange(str, max_bytesize_per_chunk); end

  def self.encode_non_usascii(address, charset); end

  def self.find_encoding(str); end

  def self.get_all(); end

  def self.get_encoding(name); end

  def self.get_name(name); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.q_value_decode(str); end

  def self.q_value_encode(encoded_str, encoding=T.unsafe(nil)); end

  def self.register(name, cls); end

  def self.transcode_charset(str, from_charset, to_charset=T.unsafe(nil)); end

  def self.unquote_and_convert_to(str, to_encoding); end

  def self.value_decode(str); end

  def self.value_encoding_from_string(str); end

  def self.with_ascii_kcode(); end
end

class Mail::Envelope
  def date(); end

  def element(); end

  def from(); end

  def initialize(*args); end
end

class Mail::Envelope
end

class Mail::EnvelopeFromElement
  def address(); end

  def date_time(); end

  def formatted_date_time(); end

  def initialize(string); end
end

class Mail::EnvelopeFromElement
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
end

class Mail::Field
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Comparable
  def ==(other); end

  def field(); end

  def field=(value); end

  def field_order_id(); end

  def initialize(name, value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def name(); end

  def responsible_for?(val); end

  def same(other); end

  def unparsed_value(); end

  def update(name, value); end

  def value(); end

  def value=(val); end
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Field::FieldError
end

class Mail::Field::FieldError
end

class Mail::Field::IncompleteParseError
  def initialize(element, original_text, unparsed_index); end
end

class Mail::Field::IncompleteParseError
end

class Mail::Field::NilParseError
  def initialize(element); end
end

class Mail::Field::NilParseError
end

class Mail::Field::ParseError
  def element(); end

  def element=(element); end

  def initialize(element, value, reason); end

  def reason(); end

  def reason=(reason); end

  def value(); end

  def value=(value); end
end

class Mail::Field::ParseError
end

class Mail::Field::SyntaxError
end

class Mail::Field::SyntaxError
end

class Mail::Field
  def self.parse(field, charset=T.unsafe(nil)); end

  def self.split(raw_field); end
end

class Mail::FieldList
  def <<(new_field); end
end

class Mail::FieldList
end

class Mail::FileDelivery
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::FileDelivery
end

class Mail::FromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::FromField
end

class Mail::Header
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Enumerable
  def [](name); end

  def []=(name, value); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def field_summary(); end

  def fields(); end

  def fields=(unfolded_fields); end

  def has_content_id?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def initialize(header_text=T.unsafe(nil), charset=T.unsafe(nil)); end

  def raw_source(); end
  LIMITED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Header
  def self.maximum_amount(); end

  def self.maximum_amount=(value); end
end

class Mail::IMAP
  def connection(&block); end

  def delete_all(mailbox=T.unsafe(nil)); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::IMAP
end

class Mail::InReplyToField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::InReplyToField
end

class Mail::IndifferentHash
  def []=(key, value); end

  def convert_key(key); end

  def convert_value(value); end

  def default(key=T.unsafe(nil)); end

  def delete(key); end

  def fetch(key, *extras); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash); end

  def merge!(other_hash); end

  def regular_update(*_); end

  def regular_writer(_, _1); end

  def store(key, value); end

  def update(other_hash); end

  def values_at(*indices); end
end

class Mail::IndifferentHash
  def self.new_from_hash_copying_default(hash); end
end

class Mail::KeywordsField
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def keywords(); end

  def parse(val=T.unsafe(nil)); end

  def phrase_list(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
end

class Mail::LoggerDelivery
  include ::Mail::CheckDeliveryParams
  def deliver!(mail); end

  def initialize(settings); end

  def logger(); end

  def settings(); end

  def severity(); end
end

class Mail::LoggerDelivery
end

module Mail::Matchers
  def an_attachment_with_filename(filename); end

  def any_attachment(); end

  def have_sent_email(); end
end

class Mail::Matchers::AnyAttachmentMatcher
  def ===(other); end
end

class Mail::Matchers::AnyAttachmentMatcher
end

class Mail::Matchers::AttachmentFilenameMatcher
  def ===(other); end

  def filename(); end

  def initialize(filename); end
end

class Mail::Matchers::AttachmentFilenameMatcher
end

class Mail::Matchers::HasSentEmailMatcher
  def bcc(recipient_or_list); end

  def cc(recipient_or_list); end

  def description(); end

  def dump_deliveries(); end

  def explain_expectations(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def filter_matched_deliveries(deliveries); end

  def from(sender); end

  def initialize(_context); end

  def matches?(subject); end

  def matches_on_attachments?(delivery); end

  def matches_on_blind_copy_recipients?(delivery); end

  def matches_on_body?(delivery); end

  def matches_on_body_matcher?(delivery); end

  def matches_on_copy_recipients?(delivery); end

  def matches_on_having_attachments?(delivery); end

  def matches_on_html_part_body?(delivery); end

  def matches_on_recipients?(delivery); end

  def matches_on_sender?(delivery); end

  def matches_on_subject?(delivery); end

  def matches_on_subject_matcher?(delivery); end

  def matches_on_text_part_body?(delivery); end

  def matching_body(body_matcher); end

  def matching_subject(subject_matcher); end

  def to(recipient_or_list); end

  def with_any_attachments(); end

  def with_attachments(attachments); end

  def with_body(body); end

  def with_html(body); end

  def with_no_attachments(); end

  def with_subject(subject); end

  def with_text(body); end
end

class Mail::Matchers::HasSentEmailMatcher
end

module Mail::Matchers
end

class Mail::Message
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def action(); end

  def add_charset(); end

  def add_content_transfer_encoding(); end

  def add_content_type(); end

  def add_date(date_val=T.unsafe(nil)); end

  def add_file(values); end

  def add_message_id(msg_id_val=T.unsafe(nil)); end

  def add_mime_version(ver_val=T.unsafe(nil)); end

  def add_part(part); end

  def add_transfer_encoding(); end

  def all_parts(); end

  def attachment(); end

  def attachment?(); end

  def attachments(); end

  def bcc(val=T.unsafe(nil)); end

  def bcc=(val); end

  def bcc_addresses(); end

  def bcc_addrs(); end

  def body(value=T.unsafe(nil)); end

  def body=(value); end

  def body_encoding(value=T.unsafe(nil)); end

  def body_encoding=(value); end

  def bounced?(); end

  def boundary(); end

  def cc(val=T.unsafe(nil)); end

  def cc=(val); end

  def cc_addresses(); end

  def cc_addrs(); end

  def charset(); end

  def charset=(value); end

  def comments(val=T.unsafe(nil)); end

  def comments=(val); end

  def content_description(val=T.unsafe(nil)); end

  def content_description=(val); end

  def content_disposition(val=T.unsafe(nil)); end

  def content_disposition=(val); end

  def content_id(val=T.unsafe(nil)); end

  def content_id=(val); end

  def content_location(val=T.unsafe(nil)); end

  def content_location=(val); end

  def content_transfer_encoding(val=T.unsafe(nil)); end

  def content_transfer_encoding=(val); end

  def content_type(val=T.unsafe(nil)); end

  def content_type=(val); end

  def content_type_parameters(); end

  def convert_to_multipart(); end

  def date(val=T.unsafe(nil)); end

  def date=(val); end

  def decode_body(); end

  def decoded(); end

  def default(sym, val=T.unsafe(nil)); end

  def deliver(); end

  def deliver!(); end

  def delivery_handler(); end

  def delivery_handler=(delivery_handler); end

  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def delivery_status_part(); end

  def delivery_status_report?(); end

  def destinations(); end

  def diagnostic_code(); end

  def encode!(); end

  def encoded(); end

  def envelope_date(); end

  def envelope_from(); end

  def error_status(); end

  def errors(); end

  def filename(); end

  def final_recipient(); end

  def find_first_mime_type(mt); end

  def from(val=T.unsafe(nil)); end

  def from=(val); end

  def from_address(); end

  def from_addrs(); end

  def has_attachments?(); end

  def has_charset?(); end

  def has_content_transfer_encoding?(); end

  def has_content_type?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def has_transfer_encoding?(); end

  def header(value=T.unsafe(nil)); end

  def header=(value); end

  def header_fields(); end

  def headers(hash=T.unsafe(nil)); end

  def html_part(&block); end

  def html_part=(msg); end

  def in_reply_to(val=T.unsafe(nil)); end

  def in_reply_to=(val); end

  def inform_interceptors(); end

  def inform_observers(); end

  def initialize(*args, &block); end

  def is_marked_for_delete?(); end

  def keywords(val=T.unsafe(nil)); end

  def keywords=(val); end

  def main_type(); end

  def mark_for_delete=(value=T.unsafe(nil)); end

  def message_content_type(); end

  def message_id(val=T.unsafe(nil)); end

  def message_id=(val); end

  def method_missing(name, *args, &block); end

  def mime_parameters(); end

  def mime_type(); end

  def mime_version(val=T.unsafe(nil)); end

  def mime_version=(val); end

  def multipart?(); end

  def multipart_report?(); end

  def part(params=T.unsafe(nil)); end

  def parts(); end

  def perform_deliveries(); end

  def perform_deliveries=(perform_deliveries); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(raise_delivery_errors); end

  def raw_envelope(); end

  def raw_source(); end

  def read(); end

  def ready_to_send!(); end

  def received(val=T.unsafe(nil)); end

  def received=(val); end

  def recipients(); end

  def recipients_addresses(); end

  def references(val=T.unsafe(nil)); end

  def references=(val); end

  def register_for_delivery_notification(observer); end

  def remote_mta(); end

  def reply(*args, &block); end

  def reply_to(val=T.unsafe(nil)); end

  def reply_to=(val); end

  def resent_bcc(val=T.unsafe(nil)); end

  def resent_bcc=(val); end

  def resent_cc(val=T.unsafe(nil)); end

  def resent_cc=(val); end

  def resent_date(val=T.unsafe(nil)); end

  def resent_date=(val); end

  def resent_from(val=T.unsafe(nil)); end

  def resent_from=(val); end

  def resent_message_id(val=T.unsafe(nil)); end

  def resent_message_id=(val); end

  def resent_sender(val=T.unsafe(nil)); end

  def resent_sender=(val); end

  def resent_to(val=T.unsafe(nil)); end

  def resent_to=(val); end

  def retryable?(); end

  def return_path(val=T.unsafe(nil)); end

  def return_path=(val); end

  def sender(val=T.unsafe(nil)); end

  def sender=(val); end

  def set_envelope(val); end

  def skip_deletion(); end

  def smtp_envelope_from(val=T.unsafe(nil)); end

  def smtp_envelope_from=(val); end

  def smtp_envelope_to(val=T.unsafe(nil)); end

  def smtp_envelope_to=(val); end

  def sub_type(); end

  def subject(val=T.unsafe(nil)); end

  def subject=(val); end

  def text?(); end

  def text_part(&block); end

  def text_part=(msg); end

  def to(val=T.unsafe(nil)); end

  def to=(val); end

  def to_addresses(); end

  def to_addrs(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def transfer_encoding(); end

  def transport_encoding(val=T.unsafe(nil)); end

  def transport_encoding=(val); end

  def without_attachments!(); end

  def x_original_to_addresses(); end
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::Message
  def self.default_charset(); end

  def self.default_charset=(charset); end

  def self.from_hash(hash); end

  def self.from_yaml(str); end
end

class Mail::MessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
end

class Mail::MessageIdsElement
  def initialize(string); end

  def message_id(); end

  def message_ids(); end
end

class Mail::MessageIdsElement
end

class Mail::MimeVersionElement
  def initialize(string); end

  def major(); end

  def minor(); end
end

class Mail::MimeVersionElement
end

class Mail::MimeVersionField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def major(); end

  def minor(); end

  def parse(val=T.unsafe(nil)); end

  def version(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MimeVersionField
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Chars
  include ::Comparable
  def =~(other); end

  def [](*args); end

  def []=(*args); end

  def acts_like_string?(); end

  def capitalize(); end

  def capitalize!(*args); end

  def chars(string); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def g_length(); end

  def initialize(string); end

  def justify(integer, way, padstr=T.unsafe(nil)); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def padding(padsize, padstr=T.unsafe(nil)); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def translate_offset(byte_offset); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class Mail::Multibyte::Chars
  def self.consumes?(string); end
end

class Mail::Multibyte::EncodingError
end

class Mail::Multibyte::EncodingError
end

module Mail::Multibyte::Unicode
  def apply_mapping(string, mapping); end

  def compose_codepoints(codepoints); end

  def decompose_codepoints(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def g_pack(unpacked); end

  def g_unpack(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def reorder_characters(codepoints); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def u_unpack(string); end
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def swapcase_mapping(); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class Mail::Multibyte::Unicode::Codepoint
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module Mail::Multibyte::Unicode
  extend ::Mail::Multibyte::Unicode
  def self.codepoints_to_pattern(array_of_codepoints); end
end

module Mail::Multibyte
  def self.clean(string); end

  def self.mb_chars(str); end

  def self.proxy_class(); end

  def self.proxy_class=(proxy_class); end

  def self.valid_character(); end

  def self.verify(string); end

  def self.verify!(string); end
end

class Mail::OptionalField
end

class Mail::OptionalField
end

class Mail::POP3
  def connection(&block); end

  def delete_all(); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::POP3
end

class Mail::ParameterHash
  include ::Mail::Utilities
  include ::Mail::Constants
  def [](key_name); end

  def decoded(); end

  def encoded(); end
end

class Mail::ParameterHash
end

module Mail::ParserTools
  def chars(data, from_bytes, to_bytes); end
end

module Mail::ParserTools
end

module Mail::Parsers
end

module Mail::Parsers::AddressListsParser
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def addresses(); end

  def addresses=(_); end

  def error(); end

  def error=(_); end

  def group_names(); end

  def group_names=(_); end
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def comments(); end

  def comments=(_); end

  def display_name(); end

  def display_name=(_); end

  def domain(); end

  def domain=(_); end

  def error(); end

  def error=(_); end

  def group(); end

  def group=(_); end

  def local(); end

  def local=(_); end

  def obs_domain_list(); end

  def obs_domain_list=(_); end

  def raw(); end

  def raw=(_); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::AddressListsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentDispositionParser
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def disposition_type(); end

  def disposition_type=(_); end

  def error(); end

  def error=(_); end

  def parameters(); end

  def parameters=(_); end
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentDispositionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentLocationParser
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def error(); end

  def error=(_); end

  def location(); end

  def location=(_); end
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentLocationParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTransferEncodingParser
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def encoding(); end

  def encoding=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentTransferEncodingParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTypeParser
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def error(); end

  def error=(_); end

  def main_type(); end

  def main_type=(_); end

  def parameters(); end

  def parameters=(_); end

  def sub_type(); end

  def sub_type=(_); end
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentTypeParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::DateTimeParser
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def date_string(); end

  def date_string=(_); end

  def error(); end

  def error=(_); end

  def time_string(); end

  def time_string=(_); end
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::DateTimeParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::EnvelopeFromParser
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def address(); end

  def address=(_); end

  def ctime_date(); end

  def ctime_date=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::EnvelopeFromParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MessageIdsParser
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def error(); end

  def error=(_); end

  def message_ids(); end

  def message_ids=(_); end
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::MessageIdsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MimeVersionParser
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def error(); end

  def error=(_); end

  def major(); end

  def major=(_); end

  def minor(); end

  def minor=(_); end
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::MimeVersionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

class Mail::Parsers::PhraseListsParser
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def error(); end

  def error=(_); end

  def phrases(); end

  def phrases=(_); end
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::PhraseListsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ReceivedParser
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def date(); end

  def date=(_); end

  def error(); end

  def error=(_); end

  def info(); end

  def info=(_); end

  def time(); end

  def time=(_); end
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ReceivedParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers
end

class Mail::Part
  def add_content_id(content_id_val=T.unsafe(nil)); end

  def cid(); end

  def delivery_status_data(); end

  def delivery_status_report_part?(); end

  def has_content_id?(); end

  def inline?(); end

  def inline_content_id(); end

  def url(); end
end

class Mail::Part
end

class Mail::PartsList
  def attachments(); end

  def collect(); end

  def collect!(); end

  def encode_with(coder); end

  def initialize(*args); end

  def map(); end

  def map!(); end

  def parts(); end

  def sort(); end

  def sort!(order); end

  def to_yaml(options=T.unsafe(nil)); end
end

class Mail::PartsList
end

class Mail::PhraseList
  def initialize(string); end

  def phrases(); end
end

class Mail::PhraseList
end

class Mail::ReceivedElement
  include ::Mail::Utilities
  include ::Mail::Constants
  def date_time(); end

  def info(); end

  def initialize(string); end

  def to_s(*args); end
end

class Mail::ReceivedElement
end

class Mail::ReceivedField
  def date_time(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def formatted_date(); end

  def info(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReceivedField
end

class Mail::ReferencesField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
end

class Mail::ReplyToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
end

class Mail::ResentBccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
end

class Mail::ResentCcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
end

class Mail::ResentDateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
end

class Mail::ResentFromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
end

class Mail::ResentMessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
end

class Mail::ResentSenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
end

class Mail::ResentToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
end

class Mail::Retriever
  def all(options=T.unsafe(nil), &block); end

  def find_and_delete(options=T.unsafe(nil), &block); end

  def first(options=T.unsafe(nil), &block); end

  def last(options=T.unsafe(nil), &block); end
end

class Mail::Retriever
end

class Mail::ReturnPathField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
end

class Mail::Ruby19
end

class Mail::Ruby19::BestEffortCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::BestEffortCharsetEncoder
end

class Mail::Ruby19::StrictCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::StrictCharsetEncoder
end

class Mail::Ruby19
  def self.b_value_decode(str); end

  def self.b_value_encode(str, encoding=T.unsafe(nil)); end

  def self.bracket(str); end

  def self.charset_encoder(); end

  def self.charset_encoder=(charset_encoder); end

  def self.decode_base64(str); end

  def self.decode_utf7(utf7); end

  def self.encode_base64(str); end

  def self.encode_utf7(string); end

  def self.escape_bracket(str); end

  def self.escape_paren(str); end

  def self.get_constant(klass, string); end

  def self.has_constant?(klass, string); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.paren(str); end

  def self.pick_encoding(charset); end

  def self.q_value_decode(str); end

  def self.q_value_encode(str, encoding=T.unsafe(nil)); end

  def self.string_byteslice(str, *args); end

  def self.transcode_charset(str, from_encoding, to_encoding=T.unsafe(nil)); end

  def self.uri_parser(); end
end

Mail::RubyVer = Mail::Ruby19

class Mail::SMTP
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SMTP
end

class Mail::SMTPConnection
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end

  def smtp(); end

  def smtp=(smtp); end
end

class Mail::SMTPConnection
end

class Mail::SenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SenderField
end

class Mail::Sendmail
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  def self.call(path, arguments, destinations, encoded_message); end

  def self.popen(command, &block); end

  def self.shellquote(address); end
end

class Mail::StructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(val); end

  def errors(); end

  def initialize(name=T.unsafe(nil), value=T.unsafe(nil), charset=T.unsafe(nil)); end
end

class Mail::StructuredField
end

class Mail::SubjectField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
end

class Mail::TestMailer
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::TestMailer
  def self.deliveries(); end

  def self.deliveries=(val); end
end

class Mail::TestRetriever
  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end
end

class Mail::TestRetriever
  def self.emails(); end

  def self.emails=(val); end
end

class Mail::ToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ToField
end

class Mail::UnknownEncodingType
end

class Mail::UnknownEncodingType
end

class Mail::UnstructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(charset); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def initialize(name, value, charset=T.unsafe(nil)); end

  def parse(); end
end

class Mail::UnstructuredField
end

module Mail::Utilities
  include ::Mail::Constants
  def atom_safe?(str); end

  def bracket(str); end

  def capitalize_field(str); end

  def constantize(str); end

  def dasherize(str); end

  def dquote(str); end

  def escape_paren(str); end

  def map_lines(str, &block); end

  def map_with_index(enum, &block); end

  def match_to_s(obj1, obj2); end

  def paren(str); end

  def quote_atom(str); end

  def quote_phrase(str); end

  def quote_token(str); end

  def token_safe?(str); end

  def unbracket(str); end

  def underscoreize(str); end

  def unparen(str); end

  def uri_escape(str); end

  def uri_parser(); end

  def uri_unescape(str); end
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  def self.binary_unsafe_to_crlf(string); end

  def self.binary_unsafe_to_lf(string); end

  def self.blank?(value); end

  def self.safe_for_line_ending_conversion?(string); end

  def self.to_crlf(string); end

  def self.to_lf(string); end

  def self.unescape(str); end

  def self.unquote(str); end
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  def self.version(); end
end

module Mail
  def self.all(*args, &block); end

  def self.connection(&block); end

  def self.defaults(&block); end

  def self.delete_all(*args, &block); end

  def self.deliver(*args, &block); end

  def self.delivery_method(); end

  def self.eager_autoload!(); end

  def self.find(*args, &block); end

  def self.find_and_delete(*args, &block); end

  def self.first(*args, &block); end

  def self.from_source(source); end

  def self.inform_interceptors(mail); end

  def self.inform_observers(mail); end

  def self.last(*args, &block); end

  def self.new(*args, &block); end

  def self.random_tag(); end

  def self.read(filename); end

  def self.read_from_string(mail_as_string); end

  def self.register_autoload(name, path); end

  def self.register_interceptor(interceptor); end

  def self.register_observer(observer); end

  def self.retriever_method(); end

  def self.something_random(); end

  def self.uniq(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_observer(observer); end
end

module Marcel
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  def self.extend(type, extensions: T.unsafe(nil), parents: T.unsafe(nil), magic: T.unsafe(nil)); end

  def self.for(pathname_or_io=T.unsafe(nil), name: T.unsafe(nil), extension: T.unsafe(nil), declared_type: T.unsafe(nil)); end
end

module Marcel
end

module Marshal
  extend ::ActiveSupport::MarshalWithAutoloading
end

class Matrix
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  def *(m); end

  def **(other); end

  def +(m); end

  def +@(); end

  def -(m); end

  def -@(); end

  def /(other); end

  def ==(other); end

  def [](i, j); end

  def []=(i, j, v); end

  def adjugate(); end

  def antisymmetric?(); end

  def coerce(other); end

  def cofactor(row, column); end

  def cofactor_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def collect(which=T.unsafe(nil), &block); end

  def collect!(which=T.unsafe(nil)); end

  def column(j); end

  def column_count(); end

  def column_size(); end

  def column_vectors(); end

  def combine(*matrices, &block); end

  def component(i, j); end

  def conj(); end

  def conjugate(); end

  def det(); end

  def det_e(); end

  def determinant(); end

  def determinant_e(); end

  def diagonal?(); end

  def each_with_index(which=T.unsafe(nil)); end

  def eigen(); end

  def eigensystem(); end

  def element(i, j); end

  def elements_to_f(); end

  def elements_to_i(); end

  def elements_to_r(); end

  def empty?(); end

  def entrywise_product(m); end

  def eql?(other); end

  def find_index(*args); end

  def first_minor(row, column); end

  def hadamard_product(m); end

  def hermitian?(); end

  def hstack(*matrices); end

  def imag(); end

  def imaginary(); end

  def index(*args); end

  def initialize(rows, column_count=T.unsafe(nil)); end

  def inv(); end

  def inverse(); end

  def laplace_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def lower_triangular?(); end

  def lup(); end

  def lup_decomposition(); end

  def map(which=T.unsafe(nil), &block); end

  def map!(which=T.unsafe(nil)); end

  def minor(*param); end

  def normal?(); end

  def orthogonal?(); end

  def permutation?(); end

  def rank(); end

  def rank_e(); end

  def real(); end

  def real?(); end

  def rect(); end

  def rectangular(); end

  def regular?(); end

  def round(ndigits=T.unsafe(nil)); end

  def row(i, &block); end

  def row_count(); end

  def row_size(); end

  def row_vectors(); end

  def rows(); end

  def singular?(); end

  def skew_symmetric?(); end

  def square?(); end

  def symmetric?(); end

  def t(); end

  def to_a(); end

  def to_matrix(); end

  def tr(); end

  def trace(); end

  def transpose(); end

  def unitary?(); end

  def upper_triangular?(); end

  def vstack(*matrices); end

  def zero?(); end
  SELECTORS = ::T.let(nil, ::T.untyped)
end

module Matrix::CoercionHelper
end

module Matrix::CoercionHelper
  def self.check_int(val, count, kind); end

  def self.check_range(val, count, kind); end

  def self.coerce_to(obj, cls, meth); end

  def self.coerce_to_int(obj); end

  def self.coerce_to_matrix(obj); end
end

module Matrix::ConversionHelper
end

module Matrix::ConversionHelper
end

class Matrix::EigenvalueDecomposition
  def initialize(a); end
end

class Matrix::LUPDecomposition
  include ::Matrix::ConversionHelper
  def det(); end

  def determinant(); end

  def initialize(a); end

  def l(); end

  def p(); end

  def pivots(); end

  def singular?(); end

  def solve(b); end

  def to_a(); end

  def to_ary(); end

  def u(); end
end

class Matrix::LUPDecomposition
end

class Matrix::Scalar
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  def *(other); end

  def **(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def initialize(value); end
end

class Matrix::Scalar
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class Matrix
  extend ::Exception2MessageMapper
  extend ::Matrix::ConversionHelper
  def self.included(mod); end
end

module MessagePack
  DEFAULT_EMPTY_PARAMS = ::T.let(nil, ::T.untyped)
end

class MessagePack::Packer
  def write_bin(_); end

  def write_bin_header(_); end
end

module MessagePack::Time
  Packer = ::T.let(nil, ::T.untyped)
  TIME_AT_3_AVAILABLE = ::T.let(nil, ::T.untyped)
  Unpacker = ::T.let(nil, ::T.untyped)
end

module MessagePack::Time
end

class MessagePack::Timestamp
  def ==(other); end

  def initialize(sec, nsec); end

  def nsec(); end

  def sec(); end

  def to_msgpack_ext(); end
  TIMESTAMP32_MAX_SEC = ::T.let(nil, ::T.untyped)
  TIMESTAMP64_MAX_SEC = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

class MessagePack::Timestamp
  def self.from_msgpack_ext(data); end

  def self.to_msgpack_ext(sec, nsec); end
end

class MessagePack::Unpacker
  def feed_reference(_); end
end

class Method
  include ::MethodSource::SourceLocation::MethodExtensions
  include ::MethodSource::MethodExtensions
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers
  def comment_describing(file, line_number); end

  def complete_expression?(str); end

  def expression_at(file, line_number, options=T.unsafe(nil)); end
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  def self.===(ex); end

  def self.rbx?(); end
end

module MethodSource::CodeHelpers
end

module MethodSource::MethodExtensions
  def comment(); end

  def source(); end
end

module MethodSource::MethodExtensions
  def self.included(klass); end
end

module MethodSource::ReeSourceLocation
  def source_location(); end
end

module MethodSource::ReeSourceLocation
end

module MethodSource::SourceLocation
end

module MethodSource::SourceLocation::MethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::MethodExtensions
end

module MethodSource::SourceLocation::ProcExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::ProcExtensions
end

module MethodSource::SourceLocation::UnboundMethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::UnboundMethodExtensions
end

module MethodSource::SourceLocation
end

class MethodSource::SourceNotFoundError
end

class MethodSource::SourceNotFoundError
end

module MethodSource
  extend ::MethodSource::CodeHelpers
  def self.comment_helper(source_location, name=T.unsafe(nil)); end

  def self.extract_code(source_location); end

  def self.lines_for(file_name, name=T.unsafe(nil)); end

  def self.source_helper(source_location, name=T.unsafe(nil)); end

  def self.valid_expression?(str); end
end

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
end

class Mime::AllType
  include ::Singleton
  def initialize(); end
end

class Mime::AllType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Mimes
  include ::Enumerable
  def <<(type); end

  def delete_if(); end

  def each(&blk); end

  def symbols(); end
end

class Mime::Mimes
end

class Mime::NullType
  include ::Singleton
  def ref(); end
end

class Mime::NullType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Type
  def ==(mime_type); end

  def ===(list); end

  def =~(mime_type); end

  def all?(); end

  def eql?(other); end

  def html?(); end

  def initialize(string, symbol=T.unsafe(nil), synonyms=T.unsafe(nil)); end

  def ref(); end

  def string(); end

  def symbol(); end

  def synonyms(); end

  def to_str(); end

  def to_sym(); end
  MIME_NAME = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_KEY = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_VALUE = ::T.let(nil, ::T.untyped)
  MIME_REGEXP = ::T.let(nil, ::T.untyped)
end

class Mime::Type::AcceptItem
  def index(); end

  def index=(index); end

  def initialize(index, name, q=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def q(); end

  def q=(q); end
end

class Mime::Type::AcceptItem
end

class Mime::Type::AcceptList
end

class Mime::Type::AcceptList
  def self.find_item_by_name(array, name); end

  def self.sort!(list); end
end

class Mime::Type::InvalidMimeType
end

class Mime::Type::InvalidMimeType
end

class Mime::Type
  def self.lookup(string); end

  def self.lookup_by_extension(extension); end

  def self.parse(accept_header); end

  def self.parse_data_with_trailing_star(type); end

  def self.parse_trailing_star(accept_header); end

  def self.register(string, symbol, mime_type_synonyms=T.unsafe(nil), extension_synonyms=T.unsafe(nil), skip_lookup=T.unsafe(nil)); end

  def self.register_alias(string, symbol, extension_synonyms=T.unsafe(nil)); end

  def self.register_callback(&block); end

  def self.unregister(symbol); end
end

module Mime
  def self.[](type); end

  def self.fetch(type); end
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

module MiniMime::Configuration
end

module MiniMime::Configuration
  def self.content_type_db_path(); end

  def self.content_type_db_path=(content_type_db_path); end

  def self.ext_db_path(); end

  def self.ext_db_path=(ext_db_path); end
end

class MiniMime::Db
  def lookup_by_content_type(content_type); end

  def lookup_by_extension(extension); end
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::Cache
  def []=(key, val); end

  def fetch(key, &blk); end

  def initialize(size); end
end

class MiniMime::Db::Cache
end

class MiniMime::Db::RandomAccessDb
  def initialize(path, sort_order); end

  def lookup(val); end

  def lookup_uncached(val); end

  def resolve(row); end
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
end

class MiniMime::Db
  def self.lookup_by_content_type(content_type); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

class MiniMime::Info
  def [](idx); end

  def binary?(); end

  def content_type(); end

  def content_type=(content_type); end

  def encoding(); end

  def encoding=(encoding); end

  def extension(); end

  def extension=(extension); end

  def initialize(buffer); end
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
end

module MiniMime
  def self.lookup_by_content_type(mime); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

MiniTest = Minitest

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::AbstractReporter
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def passed?(); end

  def prerecord(klass, name); end

  def record(result); end

  def report(); end

  def start(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class Minitest::AbstractReporter
end

class Minitest::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
end

class Minitest::Assertion
end

module Minitest::Assertions
  def _synchronize(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), bt=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

class Minitest::BacktraceFilter
  def filter(bt); end
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
end

class Minitest::CompositeReporter
  def <<(reporter); end

  def initialize(*reporters); end

  def io(); end

  def reporters(); end

  def reporters=(reporters); end
end

class Minitest::CompositeReporter
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

module Minitest::Guard
end

module Minitest::Parallel
end

class Minitest::Parallel::Executor
  def <<(work); end

  def initialize(size); end

  def shutdown(); end

  def size(); end

  def start(); end
end

class Minitest::Parallel::Executor
end

module Minitest::Parallel::Test
  def _synchronize(); end
end

module Minitest::Parallel::Test::ClassMethods
  def run_one_method(klass, method_name, reporter); end

  def test_order(); end
end

module Minitest::Parallel::Test::ClassMethods
end

module Minitest::Parallel::Test
end

module Minitest::Parallel
end

class Minitest::ProgressReporter
end

class Minitest::ProgressReporter
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
end

module Minitest::Reportable
end

class Minitest::Reporter
  def initialize(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def options(); end

  def options=(options); end
end

class Minitest::Reporter
end

class Minitest::Result
  include ::Minitest::Reportable
  def klass(); end

  def klass=(klass); end

  def source_location(); end

  def source_location=(source_location); end
end

class Minitest::Result
  def self.from(runnable); end
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::Skip
end

class Minitest::Skip
end

class Minitest::StatisticsReporter
  def assertions(); end

  def assertions=(assertions); end

  def count(); end

  def count=(count); end

  def errors(); end

  def errors=(errors); end

  def failures(); end

  def failures=(failures); end

  def results(); end

  def results=(results); end

  def skips(); end

  def skips=(skips); end

  def start_time(); end

  def start_time=(start_time); end

  def total_time(); end

  def total_time=(total_time); end
end

class Minitest::StatisticsReporter
end

class Minitest::SummaryReporter
  def aggregated_results(io); end

  def old_sync(); end

  def old_sync=(old_sync); end

  def statistics(); end

  def summary(); end

  def sync(); end

  def sync=(sync); end
end

class Minitest::SummaryReporter
end

class Minitest::Test
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  def capture_exceptions(); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

module Minitest::Test::LifecycleHooks
end

class Minitest::Test
  extend ::Minitest::Guard
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end

  def self.test_order(); end
end

class Minitest::UnexpectedError
  def error=(error); end

  def initialize(error); end
end

class Minitest::UnexpectedError
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit::TestCase
end

class Minitest::Unit::TestCase
end

class Minitest::Unit
  def self.after_tests(&b); end

  def self.autorun(); end
end

module Minitest
  def self.__run(reporter, options); end

  def self.after_run(&block); end

  def self.backtrace_filter(); end

  def self.backtrace_filter=(backtrace_filter); end

  def self.clock_time(); end

  def self.extensions(); end

  def self.extensions=(extensions); end

  def self.filter_backtrace(bt); end

  def self.info_signal(); end

  def self.info_signal=(info_signal); end

  def self.init_plugins(options); end

  def self.load_plugins(); end

  def self.parallel_executor(); end

  def self.parallel_executor=(parallel_executor); end

  def self.process_args(args=T.unsafe(nil)); end

  def self.reporter(); end

  def self.reporter=(reporter); end

  def self.run_one_method(klass, method_name); end
end

class Module
  include ::ActiveSupport::Dependencies::ModuleConstMissing
  include ::Module::Concerning
  def alias_attribute(new_name, old_name); end

  def anonymous?(); end

  def attr_internal(*attrs); end

  def attr_internal_accessor(*attrs); end

  def attr_internal_reader(*attrs); end

  def attr_internal_writer(*attrs); end

  def autoload_without_bootsnap(_, _1); end

  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def context(*a, &b); end

  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  def delegate_missing_to(target); end

  def deprecate(*method_names); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def method_visibility(method); end

  def module_parent(); end

  def module_parent_name(); end

  def module_parents(); end

  def parent(); end

  def parent_name(); end

  def parents(); end

  def rake_extension(method); end

  def redefine_method(method, &block); end

  def redefine_singleton_method(method, &block); end

  def remove_possible_method(method); end

  def remove_possible_singleton_method(method); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def silence_redefinition_of_method(method); end

  def thread_cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module Module::Concerning
  def concern(topic, &module_definition); end

  def concerning(topic, &block); end
end

module Module::Concerning
end

class Module::DelegationError
end

class Module::DelegationError
end

class Module
  def self.attr_internal_naming_format(); end

  def self.attr_internal_naming_format=(attr_internal_naming_format); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module MultiJson
  include ::MultiJson::Options
  def adapter(); end

  def adapter=(new_adapter); end

  def cached_options(*_); end

  def current_adapter(options=T.unsafe(nil)); end

  def decode(string, options=T.unsafe(nil)); end

  def default_adapter(); end

  def default_engine(); end

  def default_options(); end

  def default_options=(value); end

  def dump(object, options=T.unsafe(nil)); end

  def encode(object, options=T.unsafe(nil)); end

  def engine(); end

  def engine=(new_adapter); end

  def load(string, options=T.unsafe(nil)); end

  def load_adapter(new_adapter); end

  def reset_cached_options!(*_); end

  def use(new_adapter); end

  def with_adapter(new_adapter); end

  def with_engine(new_adapter); end
  ALIASES = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class MultiJson::AdapterError
end

class MultiJson::AdapterError
  def self.build(original_exception); end
end

MultiJson::DecodeError = MultiJson::ParseError

MultiJson::LoadError = MultiJson::ParseError

module MultiJson::Options
  def default_dump_options(); end

  def default_load_options(); end

  def dump_options(*args); end

  def dump_options=(options); end

  def load_options(*args); end

  def load_options=(options); end
end

module MultiJson::Options
end

module MultiJson::OptionsCache
  def fetch(type, key, &block); end

  def reset(); end
  MAX_CACHE_SIZE = ::T.let(nil, ::T.untyped)
end

module MultiJson::OptionsCache
  extend ::MultiJson::OptionsCache
end

class MultiJson::ParseError
  def data(); end
end

class MultiJson::ParseError
  def self.build(original_exception, data); end
end

class MultiJson::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
end

class MultiJson::Version
end

module MultiJson
  extend ::MultiJson
  extend ::MultiJson::Options
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

module NIO
  ENGINE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class NIO::ByteBuffer
  include ::Enumerable
  def <<(_); end

  def [](_); end

  def capacity(); end

  def clear(); end

  def compact(); end

  def each(&blk); end

  def flip(); end

  def full?(); end

  def get(*_); end

  def initialize(_); end

  def limit(); end

  def limit=(limit); end

  def mark(); end

  def position(); end

  def position=(position); end

  def read_from(_); end

  def remaining(); end

  def reset(); end

  def rewind(); end

  def size(); end

  def write_to(_); end
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer
end

class NIO::Monitor
  def add_interest(_); end

  def close(*_); end

  def closed?(); end

  def initialize(_, _1, _2); end

  def interests(); end

  def interests=(interests); end

  def io(); end

  def readable?(); end

  def readiness(); end

  def remove_interest(_); end

  def selector(); end

  def value(); end

  def value=(value); end

  def writable?(); end

  def writeable?(); end
end

class NIO::Monitor
end

class NIO::Selector
  def backend(); end

  def close(); end

  def closed?(); end

  def deregister(_); end

  def empty?(); end

  def initialize(*_); end

  def register(_, _1); end

  def registered?(_); end

  def wakeup(); end
end

class NIO::Selector
  def self.backends(); end
end

module NIO
  def self.engine(); end
end

class NameError
  include ::DidYouMean::Correctable
  def missing_name(); end

  def missing_name?(name); end
end

module Nenv
  VERSION = ::T.let(nil, ::T.untyped)
end

class Nenv::AutoEnvironment
  def method_missing(meth, *args); end
end

class Nenv::AutoEnvironment
end

module Nenv::Builder
end

module Nenv::Builder
  def self.build(&block); end
end

class Nenv::Environment
  def create_method(meth, &block); end

  def initialize(namespace=T.unsafe(nil)); end
end

class Nenv::Environment
  def self._create_env_accessor(klass, meth, &block); end

  def self.create_method(meth, &block); end
end

module Nenv
  def self.instance(); end

  def self.method_missing(meth, *args); end

  def self.reset(); end

  def self.respond_to?(meth); end
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  def open_timeout(); end

  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  Revision = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

Net::SMTPSession = Net::SMTP

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  include ::MessagePack::CoreExt
  def to_d(); end
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS
end

class Nokogiri::CSS::Node
  def accept(visitor); end

  def find_by_type(types); end

  def initialize(type, value); end

  def to_a(); end

  def to_type(); end

  def to_xpath(prefix=T.unsafe(nil), visitor=T.unsafe(nil)); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
end

class Nokogiri::CSS::Parser
  def _reduce_1(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_7(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(namespaces=T.unsafe(nil)); end

  def on_error(error_token_id, error_value, value_stack); end

  def parse(string); end

  def unescape_css_identifier(identifier); end

  def unescape_css_string(str); end

  def xpath_for(string, options=T.unsafe(nil)); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  def self.[](string); end

  def self.[]=(string, value); end

  def self.cache_on(); end

  def self.cache_on=(cache_on); end

  def self.cache_on?(); end

  def self.clear_cache(); end

  def self.parse(selector); end

  def self.set_cache(_); end

  def self.without_cache(&block); end
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::Tokenizer
  def _next_token(); end

  def action(); end

  def filename(); end

  def lineno(); end

  def load_file(filename); end

  def next_token(); end

  def scan(str); end

  def scan_file(filename); end

  def scan_setup(str); end

  def scan_str(str); end

  def state(); end

  def state=(state); end
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer
end

class Nokogiri::CSS::XPathVisitor
  def accept(node); end

  def visit_attribute_condition(node); end

  def visit_child_selector(node); end

  def visit_class_condition(node); end

  def visit_combinator(node); end

  def visit_conditional_selector(node); end

  def visit_descendant_selector(node); end

  def visit_direct_adjacent_selector(node); end

  def visit_element_name(node); end

  def visit_following_selector(node); end

  def visit_function(node); end

  def visit_id(node); end

  def visit_not(node); end

  def visit_pseudo_class(node); end
end

class Nokogiri::CSS::XPathVisitor
end

module Nokogiri::CSS
  def self.parse(selector); end

  def self.xpath_for(selector, options=T.unsafe(nil)); end
end

module Nokogiri::Decorators
end

module Nokogiri::Decorators::Slop
  def method_missing(name, *args, &block); end
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
end

module Nokogiri::Decorators
end

class Nokogiri::EncodingHandler
  def name(); end
end

class Nokogiri::EncodingHandler
  def self.[](_); end

  def self.alias(_, _1); end

  def self.clear_aliases!(); end

  def self.delete(_); end
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::Builder
  def to_html(); end
end

class Nokogiri::HTML::Builder
end

class Nokogiri::HTML::Document
  def meta_encoding(); end

  def meta_encoding=(encoding); end

  def serialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(text); end
end

class Nokogiri::HTML::Document
end

class Nokogiri::HTML::DocumentFragment
end

class Nokogiri::HTML::DocumentFragment
  def self.parse(tags, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::ElementDescription
  def block?(); end

  def default_sub_element(); end

  def deprecated?(); end

  def deprecated_attributes(); end

  def description(); end

  def empty?(); end

  def implied_end_tag?(); end

  def implied_start_tag?(); end

  def inline?(); end

  def name(); end

  def optional_attributes(); end

  def required_attributes(); end

  def save_end_tag?(); end

  def sub_elements(); end
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

class Nokogiri::HTML::ElementDescription
  def self.[](_); end
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityLookup
  def [](name); end

  def get(_); end
end

class Nokogiri::HTML::EntityLookup
end

module Nokogiri::HTML::SAX
end

class Nokogiri::HTML::SAX::Parser
  def parse_file(filename, encoding=T.unsafe(nil)); end

  def parse_memory(data, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::SAX::Parser
end

class Nokogiri::HTML::SAX::ParserContext
end

class Nokogiri::HTML::SAX::ParserContext
  def self.file(_, _1); end

  def self.memory(_, _1); end
end

class Nokogiri::HTML::SAX::PushParser
end

class Nokogiri::HTML::SAX::PushParser
end

module Nokogiri::HTML::SAX
end

module Nokogiri::HTML
  def self.fragment(string, encoding=T.unsafe(nil)); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

class Nokogiri::SyntaxError
end

class Nokogiri::SyntaxError
end

class Nokogiri::VersionInfo
  def compiled_parser_version(); end

  def engine(); end

  def jruby?(); end

  def libxml2?(); end

  def libxml2_using_packaged?(); end

  def libxml2_using_system?(); end

  def loaded_parser_version(); end

  def to_hash(); end

  def to_markdown(); end

  def warnings(); end
end

class Nokogiri::VersionInfo
  def self.instance(); end
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Attr
  def content=(content); end

  def value(); end

  def value=(value); end
end

class Nokogiri::XML::Attr
end

class Nokogiri::XML::AttributeDecl
  def attribute_type(); end

  def default(); end

  def enumeration(); end
end

class Nokogiri::XML::AttributeDecl
end

class Nokogiri::XML::Builder
  def <<(string); end

  def [](ns); end

  def arity(); end

  def arity=(arity); end

  def cdata(string); end

  def comment(string); end

  def context(); end

  def context=(context); end

  def doc(); end

  def doc=(doc); end

  def initialize(options=T.unsafe(nil), root=T.unsafe(nil), &block); end

  def method_missing(method, *args, &block); end

  def parent(); end

  def parent=(parent); end

  def text(string); end

  def to_xml(*args); end
end

class Nokogiri::XML::Builder
  def self.with(root, &block); end
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CharacterData
  include ::Nokogiri::XML::PP::CharacterData
end

class Nokogiri::XML::CharacterData
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::DTD
  def entities(); end

  def external_id(); end

  def html5_dtd?(); end

  def html_dtd?(); end

  def notations(); end

  def system_id(); end

  def validate(_); end
end

class Nokogiri::XML::DTD
end

class Nokogiri::XML::Document
  def canonicalize(*_); end

  def collect_namespaces(); end

  def create_cdata(string, &block); end

  def create_comment(string, &block); end

  def create_element(name, *args, &block); end

  def create_entity(*_); end

  def create_text_node(string, &block); end

  def decorate(node); end

  def decorators(key); end

  def encoding(); end

  def encoding=(encoding); end

  def errors(); end

  def errors=(errors); end

  def fragment(tags=T.unsafe(nil)); end

  def initialize(*args); end

  def remove_namespaces!(); end

  def root(); end

  def root=(root); end

  def slop!(); end

  def to_java(); end

  def to_xml(*args, &block); end

  def url(); end

  def validate(); end

  def version(); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  def self.empty_doc?(string_or_io); end

  def self.parse(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.read_io(_, _1, _2, _3); end

  def self.read_memory(_, _1, _2, _3); end

  def self.wrap(document); end
end

class Nokogiri::XML::DocumentFragment
  def dup(); end

  def errors(); end

  def errors=(things); end

  def initialize(document, tags=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def search(*rules); end

  def serialize(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end
end

class Nokogiri::XML::DocumentFragment
  def self.parse(tags); end
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  def children(); end

  def document(); end

  def name(); end

  def occur(); end

  def prefix(); end

  def type(); end
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ElementContent
end

class Nokogiri::XML::ElementDecl
  def element_type(); end

  def prefix(); end
end

class Nokogiri::XML::ElementDecl
end

class Nokogiri::XML::EntityDecl
  def entity_type(); end

  def external_id(); end

  def original_content(); end

  def system_id(); end
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  def self.new(name, doc, *args); end
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::Namespace
  include ::Nokogiri::XML::PP::Node
  def document(); end

  def href(); end

  def prefix(); end
end

class Nokogiri::XML::Namespace
end

class Nokogiri::XML::Node
  include ::Nokogiri::XML::PP::Node
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def <<(node_or_tags); end

  def ==(other); end

  def >(selector); end

  def [](name); end

  def []=(name, value); end

  def accept(visitor); end

  def add_child(node_or_tags); end

  def add_class(name); end

  def add_namespace(_, _1); end

  def add_namespace_definition(_, _1); end

  def add_next_sibling(node_or_tags); end

  def add_previous_sibling(node_or_tags); end

  def after(node_or_tags); end

  def ancestors(selector=T.unsafe(nil)); end

  def append_class(name); end

  def attr(name); end

  def attribute(_); end

  def attribute_nodes(); end

  def attribute_with_ns(_, _1); end

  def attributes(); end

  def before(node_or_tags); end

  def canonicalize(mode=T.unsafe(nil), inclusive_namespaces=T.unsafe(nil), with_comments=T.unsafe(nil)); end

  def cdata?(); end

  def child(); end

  def children(); end

  def children=(node_or_tags); end

  def classes(); end

  def comment?(); end

  def content(); end

  def content=(string); end

  def create_external_subset(_, _1, _2); end

  def create_internal_subset(_, _1, _2); end

  def css_path(); end

  def decorate!(); end

  def default_namespace=(url); end

  def delete(name); end

  def description(); end

  def do_xinclude(options=T.unsafe(nil)); end

  def document(); end

  def document?(); end

  def dup(*_); end

  def each(&blk); end

  def elem?(); end

  def element?(); end

  def element_children(); end

  def elements(); end

  def encode_special_chars(_); end

  def external_subset(); end

  def first_element_child(); end

  def fragment(tags); end

  def fragment?(); end

  def get_attribute(name); end

  def has_attribute?(_); end

  def html?(); end

  def initialize(name, document); end

  def inner_html(*args); end

  def inner_html=(node_or_tags); end

  def inner_text(); end

  def internal_subset(); end

  def key?(_); end

  def keys(); end

  def lang(); end

  def lang=(lang); end

  def last_element_child(); end

  def line(); end

  def matches?(selector); end

  def name(); end

  def name=(name); end

  def namespace(); end

  def namespace=(ns); end

  def namespace_definitions(); end

  def namespace_scopes(); end

  def namespaced_key?(_, _1); end

  def namespaces(); end

  def native_content=(native_content); end

  def next(); end

  def next=(node_or_tags); end

  def next_element(); end

  def next_sibling(); end

  def node_name(); end

  def node_name=(node_name); end

  def node_type(); end

  def parent(); end

  def parent=(parent_node); end

  def parse(string_or_io, options=T.unsafe(nil)); end

  def path(); end

  def pointer_id(); end

  def prepend_child(node_or_tags); end

  def previous(); end

  def previous=(node_or_tags); end

  def previous_element(); end

  def previous_sibling(); end

  def processing_instruction?(); end

  def read_only?(); end

  def remove(); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def replace(node_or_tags); end

  def serialize(*args, &block); end

  def set_attribute(name, value); end

  def swap(node_or_tags); end

  def text(); end

  def text?(); end

  def to_html(options=T.unsafe(nil)); end

  def to_str(); end

  def to_xhtml(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def traverse(&block); end

  def type(); end

  def unlink(); end

  def values(); end

  def wrap(html); end

  def write_html_to(io, options=T.unsafe(nil)); end

  def write_to(io, *options); end

  def write_xhtml_to(io, options=T.unsafe(nil)); end

  def write_xml_to(io, options=T.unsafe(nil)); end

  def xml?(); end
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
end

class Nokogiri::XML::NodeSet
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def &(_); end

  def +(_); end

  def -(_); end

  def <<(_); end

  def ==(other); end

  def >(selector); end

  def [](*_); end

  def add_class(name); end

  def after(datum); end

  def append_class(name); end

  def attr(key, value=T.unsafe(nil), &block); end

  def attribute(key, value=T.unsafe(nil), &block); end

  def before(datum); end

  def children(); end

  def clone(); end

  def delete(_); end

  def document(); end

  def document=(document); end

  def each(&blk); end

  def empty?(); end

  def filter(expr); end

  def first(n=T.unsafe(nil)); end

  def index(node=T.unsafe(nil)); end

  def initialize(document, list=T.unsafe(nil)); end

  def inner_html(*args); end

  def inner_text(); end

  def last(); end

  def length(); end

  def pop(); end

  def push(_); end

  def remove(); end

  def remove_attr(name); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def reverse(); end

  def set(key, value=T.unsafe(nil), &block); end

  def shift(); end

  def size(); end

  def slice(*_); end

  def text(); end

  def to_a(); end

  def to_ary(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end

  def unlink(); end

  def wrap(html); end

  def |(_); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
end

class Nokogiri::XML::Notation
end

class Nokogiri::XML::Notation
end

module Nokogiri::XML::PP
end

module Nokogiri::XML::PP::CharacterData
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::CharacterData
end

module Nokogiri::XML::PP::Node
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::Node
end

module Nokogiri::XML::PP
end

class Nokogiri::XML::ParseOptions
  def compact(); end

  def compact?(); end

  def default_html(); end

  def default_html?(); end

  def default_xml(); end

  def default_xml?(); end

  def dtdattr(); end

  def dtdattr?(); end

  def dtdload(); end

  def dtdload?(); end

  def dtdvalid(); end

  def dtdvalid?(); end

  def huge(); end

  def huge?(); end

  def initialize(options=T.unsafe(nil)); end

  def nobasefix(); end

  def nobasefix?(); end

  def noblanks(); end

  def noblanks?(); end

  def nocdata(); end

  def nocdata?(); end

  def nocompact(); end

  def nodefault_html(); end

  def nodefault_xml(); end

  def nodict(); end

  def nodict?(); end

  def nodtdattr(); end

  def nodtdload(); end

  def nodtdvalid(); end

  def noent(); end

  def noent?(); end

  def noerror(); end

  def noerror?(); end

  def nohuge(); end

  def nonet(); end

  def nonet?(); end

  def nonobasefix(); end

  def nonoblanks(); end

  def nonocdata(); end

  def nonodict(); end

  def nonoent(); end

  def nonoerror(); end

  def nononet(); end

  def nonowarning(); end

  def nonoxincnode(); end

  def nonsclean(); end

  def noold10(); end

  def nopedantic(); end

  def norecover(); end

  def nosax1(); end

  def nowarning(); end

  def nowarning?(); end

  def noxinclude(); end

  def noxincnode(); end

  def noxincnode?(); end

  def nsclean(); end

  def nsclean?(); end

  def old10(); end

  def old10?(); end

  def options(); end

  def options=(options); end

  def pedantic(); end

  def pedantic?(); end

  def recover(); end

  def recover?(); end

  def sax1(); end

  def sax1?(); end

  def strict(); end

  def strict?(); end

  def to_i(); end

  def xinclude(); end

  def xinclude?(); end
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
end

class Nokogiri::XML::ProcessingInstruction
  def initialize(document, name, content); end
end

class Nokogiri::XML::ProcessingInstruction
end

class Nokogiri::XML::Reader
  include ::Enumerable
  def attribute(_); end

  def attribute_at(_); end

  def attribute_count(); end

  def attribute_nodes(); end

  def attributes(); end

  def attributes?(); end

  def base_uri(); end

  def default?(); end

  def depth(); end

  def each(&blk); end

  def empty_element?(); end

  def encoding(); end

  def errors(); end

  def errors=(errors); end

  def initialize(source, url=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def inner_xml(); end

  def lang(); end

  def local_name(); end

  def name(); end

  def namespace_uri(); end

  def namespaces(); end

  def node_type(); end

  def outer_xml(); end

  def prefix(); end

  def read(); end

  def self_closing?(); end

  def source(); end

  def state(); end

  def value(); end

  def value?(); end

  def xml_version(); end
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  def self.from_io(*_); end

  def self.from_memory(*_); end
end

class Nokogiri::XML::RelaxNG
end

class Nokogiri::XML::RelaxNG
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::SAX::Document
  def cdata_block(string); end

  def characters(string); end

  def comment(string); end

  def end_document(); end

  def end_element(name); end

  def end_element_namespace(name, prefix=T.unsafe(nil), uri=T.unsafe(nil)); end

  def error(string); end

  def processing_instruction(name, content); end

  def start_document(); end

  def start_element(name, attrs=T.unsafe(nil)); end

  def start_element_namespace(name, attrs=T.unsafe(nil), prefix=T.unsafe(nil), uri=T.unsafe(nil), ns=T.unsafe(nil)); end

  def warning(string); end

  def xmldecl(version, encoding, standalone); end
end

class Nokogiri::XML::SAX::Document
end

class Nokogiri::XML::SAX::Parser
  def document(); end

  def document=(document); end

  def encoding(); end

  def encoding=(encoding); end

  def initialize(doc=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def parse(thing, &block); end

  def parse_file(filename); end

  def parse_io(io, encoding=T.unsafe(nil)); end

  def parse_memory(data); end
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
end

class Nokogiri::XML::SAX::ParserContext
  def column(); end

  def line(); end

  def parse_with(_); end

  def recovery(); end

  def recovery=(recovery); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end
end

class Nokogiri::XML::SAX::ParserContext
  def self.file(_); end

  def self.io(_, _1); end

  def self.memory(_); end

  def self.new(thing, encoding=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
  def <<(chunk, last_chunk=T.unsafe(nil)); end

  def document(); end

  def document=(document); end

  def finish(); end

  def initialize(doc=T.unsafe(nil), file_name=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end

  def write(chunk, last_chunk=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::Schema
  def errors(); end

  def errors=(errors); end

  def valid?(thing); end

  def validate(thing); end
end

class Nokogiri::XML::Schema
  def self.from_document(_); end

  def self.new(string_or_io); end

  def self.read_memory(_); end
end

module Nokogiri::XML::Searchable
  def %(*args); end

  def /(*args); end

  def at(*args); end

  def at_css(*args); end

  def at_xpath(*args); end

  def css(*args); end

  def search(*args); end

  def xpath(*args); end
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
end

class Nokogiri::XML::SyntaxError
  def code(); end

  def column(); end

  def domain(); end

  def error?(); end

  def fatal?(); end

  def file(); end

  def int1(); end

  def level(); end

  def line(); end

  def none?(); end

  def str1(); end

  def str2(); end

  def str3(); end

  def warning?(); end
end

class Nokogiri::XML::SyntaxError
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::XPath
  def document(); end

  def document=(document); end
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath
end

class Nokogiri::XML::XPathContext
  def evaluate(*_); end

  def register_namespaces(namespaces); end

  def register_ns(_, _1); end

  def register_variable(_, _1); end
end

class Nokogiri::XML::XPathContext
  def self.new(_); end
end

module Nokogiri::XML
  def self.Reader(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.RelaxNG(string_or_io); end

  def self.Schema(string_or_io); end

  def self.fragment(string); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module Nokogiri::XSLT
end

class Nokogiri::XSLT::Stylesheet
  def apply_to(document, params=T.unsafe(nil)); end

  def serialize(_); end

  def transform(*_); end
end

class Nokogiri::XSLT::Stylesheet
  def self.parse_stylesheet_doc(_); end
end

module Nokogiri::XSLT
  def self.parse(string, modules=T.unsafe(nil)); end

  def self.quote_params(params); end

  def self.register(_, _1); end
end

module Nokogiri
  def self.HTML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.Slop(*args, &block); end

  def self.XML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.XSLT(stylesheet, modules=T.unsafe(nil)); end

  def self.install_default_aliases(); end

  def self.jruby?(); end

  def self.make(input=T.unsafe(nil), opts=T.unsafe(nil), &blk); end

  def self.parse(string, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.uses_libxml?(); end
end

module Notiffany
end

class Notiffany::Notifier
  def active?(); end

  def available(); end

  def config(); end

  def disconnect(); end

  def enabled?(); end

  def initialize(opts); end

  def notify(message, message_opts=T.unsafe(nil)); end

  def turn_off(); end

  def turn_on(options=T.unsafe(nil)); end
  NOTIFICATIONS_DISABLED = ::T.let(nil, ::T.untyped)
  ONLY_NOTIFY = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
  USING_NOTIFIER = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Base
  def _image_path(image); end

  def initialize(opts=T.unsafe(nil)); end

  def name(); end

  def notify(message, opts=T.unsafe(nil)); end

  def options(); end

  def title(); end
  ERROR_ADD_GEM_AND_RUN_BUNDLE = ::T.let(nil, ::T.untyped)
  HOSTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Base::RequireFailed
  def initialize(gem_name); end
end

class Notiffany::Notifier::Base::RequireFailed
end

class Notiffany::Notifier::Base::UnavailableError
  def initialize(reason); end
end

class Notiffany::Notifier::Base::UnavailableError
end

class Notiffany::Notifier::Base::UnsupportedPlatform
  def initialize(); end
end

class Notiffany::Notifier::Base::UnsupportedPlatform
end

class Notiffany::Notifier::Base
end

class Notiffany::Notifier::Config
  def env_namespace(); end

  def initialize(opts); end

  def logger(); end

  def notifiers(); end

  def notify?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Config
end

class Notiffany::Notifier::Detected
  def add(name, opts); end

  def available(); end

  def detect(); end

  def initialize(supported, env_namespace, logger); end

  def reset(); end
  NO_SUPPORTED_NOTIFIERS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Detected::NoneAvailableError
end

class Notiffany::Notifier::Detected::NoneAvailableError
end

class Notiffany::Notifier::Detected::UnknownNotifier
  def initialize(name); end

  def name(); end
end

class Notiffany::Notifier::Detected::UnknownNotifier
end

class Notiffany::Notifier::Detected
end

class Notiffany::Notifier::Emacs
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULT_ELISP_ERB = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Emacs::Client
  def available?(); end

  def elisp_erb(); end

  def initialize(options); end

  def notify(color, bgcolor, message=T.unsafe(nil)); end
end

class Notiffany::Notifier::Emacs::Client::Elisp
  def bgcolor(); end

  def color(); end

  def initialize(code, color, bgcolor, message); end

  def message(); end

  def result(); end
end

class Notiffany::Notifier::Emacs::Client::Elisp
end

class Notiffany::Notifier::Emacs::Client
end

class Notiffany::Notifier::Emacs
end

class Notiffany::Notifier::Env
  def notify?(); end

  def notify_active=(raw_value); end

  def notify_active?(); end

  def notify_pid(); end

  def notify_pid=(raw_value); end
end

class Notiffany::Notifier::Env
end

class Notiffany::Notifier::File
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::File
end

class Notiffany::Notifier::GNTP
  def _check_available(_opts); end

  def _perform_notify(message, opts=T.unsafe(nil)); end
  CLIENT_DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::GNTP
end

class Notiffany::Notifier::Growl
  def _check_available(_opts=T.unsafe(nil)); end

  def _perform_notify(message, opts=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INSTALL_GROWLNOTIFY = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Growl
end

class Notiffany::Notifier::Libnotify
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Libnotify
end

class Notiffany::Notifier::NotServer
end

class Notiffany::Notifier::NotServer
end

class Notiffany::Notifier::Notifu
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Notifu
end

class Notiffany::Notifier::NotifySend
  DEFAULTS = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::NotifySend
end

class Notiffany::Notifier::TerminalNotifier
  def _check_available(_opts=T.unsafe(nil)); end

  def _perform_notify(message, opts=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  ERROR_ONLY_OSX10 = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::TerminalNotifier
end

class Notiffany::Notifier::TerminalTitle
  def turn_off(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::TerminalTitle
end

class Notiffany::Notifier::Tmux
  def turn_off(); end

  def turn_on(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  ERROR_ANCIENT_TMUX = ::T.let(nil, ::T.untyped)
  ERROR_NOT_INSIDE_TMUX = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Tmux::Client
  def clients(); end

  def display_message(message); end

  def display_time=(time); end

  def initialize(client); end

  def message_bg=(color); end

  def message_fg=(color); end

  def parse_options(); end

  def set(key, value); end

  def title=(string); end

  def unset(key, value); end
  CLIENT = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Tmux::Client
  def self._capture(*args); end

  def self._run(*args); end

  def self.version(); end
end

class Notiffany::Notifier::Tmux::Error
end

class Notiffany::Notifier::Tmux::Error
end

class Notiffany::Notifier::Tmux::Notification
  def colorize(locations); end

  def display_message(title, message); end

  def display_title(title, message); end

  def initialize(type, options); end
end

class Notiffany::Notifier::Tmux::Notification
end

class Notiffany::Notifier::Tmux::Session
  def close(); end
end

class Notiffany::Notifier::Tmux::Session
end

class Notiffany::Notifier::Tmux
  def self._end_session(); end

  def self._session(); end

  def self._start_session(); end
end

class Notiffany::Notifier::YamlEnvStorage
  def notifiers(); end

  def notifiers=(raw_value); end
end

class Notiffany::Notifier::YamlEnvStorage
end

class Notiffany::Notifier
end

module Notiffany
  def self.connect(options=T.unsafe(nil)); end
end

module OTNetstring
end

class OTNetstring::Error
end

class OTNetstring::Error
end

module OTNetstring
  def self.encode(obj, string_sep=T.unsafe(nil)); end

  def self.parse(io, encoding=T.unsafe(nil), fallback_encoding=T.unsafe(nil)); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Dependencies::Loadable
  include ::ActiveSupport::Tryable
  include ::PP::ObjectMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
  def as_json(options=T.unsafe(nil)); end

  def dclone(); end

  def html_safe?(); end

  def presence_in(another_object); end

  def pry(object=T.unsafe(nil), hash=T.unsafe(nil)); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::InternalObjectWrapper
  def internal_object_id(); end

  def type(); end
end

class ObjectSpace::InternalObjectWrapper
end

module ObjectSpace
  def self.allocation_class_path(_); end

  def self.allocation_generation(_); end

  def self.allocation_method_id(_); end

  def self.allocation_sourcefile(_); end

  def self.allocation_sourceline(_); end

  def self.count_imemo_objects(*_); end

  def self.count_nodes(*_); end

  def self.count_objects_size(*_); end

  def self.count_symbols(*_); end

  def self.count_tdata_objects(*_); end

  def self.dump(*_); end

  def self.dump_all(*_); end

  def self.internal_class_of(_); end

  def self.internal_super_of(_); end

  def self.memsize_of(_); end

  def self.memsize_of_all(*_); end

  def self.reachable_objects_from(_); end

  def self.reachable_objects_from_root(); end

  def self.trace_object_allocations(); end

  def self.trace_object_allocations_debug_start(); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

module OrmAdapter
  VERSION = ::T.let(nil, ::T.untyped)
end

class OrmAdapter::ActiveRecord
  def conditions_to_fields(conditions); end

  def construct_relation(relation, options); end

  def order_clause(order); end
end

class OrmAdapter::ActiveRecord
end

class OrmAdapter::Base
  def column_names(); end

  def create!(attributes=T.unsafe(nil)); end

  def destroy(object); end

  def extract_conditions!(options=T.unsafe(nil)); end

  def find_all(options=T.unsafe(nil)); end

  def find_first(options=T.unsafe(nil)); end

  def get(id); end

  def get!(id); end

  def initialize(klass); end

  def klass(); end

  def normalize_order(order); end

  def valid_object?(object); end

  def wrap_key(key); end
end

class OrmAdapter::Base
  def self.inherited(adapter); end
end

class OrmAdapter::NotSupportedError
end

class OrmAdapter::NotSupportedError
end

module OrmAdapter::ToAdapter
  def to_adapter(); end
end

module OrmAdapter::ToAdapter
end

module OrmAdapter
  def self.adapters(); end
end

class Osemosys::Config
  extend ::Dry::Configurable
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable::ClassMethods
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::TestInterface
end

module PG
  include ::PG::Constants
  ERROR_CLASSES = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PG::ActiveSqlTransaction
end

class PG::ActiveSqlTransaction
end

class PG::AdminShutdown
end

class PG::AdminShutdown
end

class PG::AmbiguousAlias
end

class PG::AmbiguousAlias
end

class PG::AmbiguousColumn
end

class PG::AmbiguousColumn
end

class PG::AmbiguousFunction
end

class PG::AmbiguousFunction
end

class PG::AmbiguousParameter
end

class PG::AmbiguousParameter
end

class PG::ArraySubscriptError
end

class PG::ArraySubscriptError
end

class PG::AssertFailure
end

class PG::AssertFailure
end

class PG::BadCopyFileFormat
end

class PG::BadCopyFileFormat
end

class PG::BasicTypeMapBasedOnResult
  include ::PG::BasicTypeRegistry
  def initialize(connection); end
end

class PG::BasicTypeMapBasedOnResult
end

class PG::BasicTypeMapForQueries
  include ::PG::BasicTypeRegistry
  def encode_array_as(); end

  def encode_array_as=(pg_type); end

  def initialize(connection); end
  DEFAULT_ARRAY_TYPE_MAP = ::T.let(nil, ::T.untyped)
  DEFAULT_TYPE_MAP = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeMapForQueries
end

class PG::BasicTypeMapForResults
  include ::PG::BasicTypeRegistry
  def initialize(connection); end
end

class PG::BasicTypeMapForResults::WarningTypeMap
  def initialize(typenames); end

  def typecast_result_value(result, _tuple, field); end
end

class PG::BasicTypeMapForResults::WarningTypeMap
end

class PG::BasicTypeMapForResults
end

module PG::BasicTypeRegistry
  def check_format_and_direction(format, direction); end
  CODERS_BY_NAME = ::T.let(nil, ::T.untyped)
  ValidDirections = ::T.let(nil, ::T.untyped)
  ValidFormats = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeRegistry::CoderMap
  def coder_by_name(name); end

  def coder_by_oid(oid); end

  def coders(); end

  def coders_by_name(); end

  def coders_by_oid(); end

  def initialize(result, coders_by_name, format, arraycoder); end

  def typenames_by_oid(); end
  DONT_QUOTE_TYPES = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeRegistry::CoderMap
end

module PG::BasicTypeRegistry
  def self.alias_type(format, new, old); end

  def self.register_coder(coder); end

  def self.register_type(format, name, encoder_class, decoder_class); end
end

module PG::BinaryDecoder
end

class PG::BinaryDecoder::Boolean
  include ::PG::Coder::BinaryFormatting
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Boolean
end

class PG::BinaryDecoder::Bytea
  include ::PG::Coder::BinaryFormatting
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Bytea
end

class PG::BinaryDecoder::Float
  include ::PG::Coder::BinaryFormatting
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Float
end

class PG::BinaryDecoder::Integer
  include ::PG::Coder::BinaryFormatting
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Integer
end

class PG::BinaryDecoder::String
  include ::PG::Coder::BinaryFormatting
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::String
end

class PG::BinaryDecoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Timestamp
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::ToBase64
  include ::PG::Coder::BinaryFormatting
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::ToBase64
end

module PG::BinaryDecoder
end

module PG::BinaryEncoder
end

class PG::BinaryEncoder::Boolean
  include ::PG::Coder::BinaryFormatting
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Boolean
end

class PG::BinaryEncoder::Bytea
  include ::PG::Coder::BinaryFormatting
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Bytea
end

class PG::BinaryEncoder::FromBase64
  include ::PG::Coder::BinaryFormatting
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::FromBase64
end

class PG::BinaryEncoder::Int2
  include ::PG::Coder::BinaryFormatting
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int2
end

class PG::BinaryEncoder::Int4
  include ::PG::Coder::BinaryFormatting
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int4
end

class PG::BinaryEncoder::Int8
  include ::PG::Coder::BinaryFormatting
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int8
end

class PG::BinaryEncoder::String
  include ::PG::Coder::BinaryFormatting
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::String
end

module PG::BinaryEncoder
end

class PG::BranchTransactionAlreadyActive
end

class PG::BranchTransactionAlreadyActive
end

class PG::CannotCoerce
end

class PG::CannotCoerce
end

class PG::CannotConnectNow
end

class PG::CannotConnectNow
end

class PG::CantChangeRuntimeParam
end

class PG::CantChangeRuntimeParam
end

class PG::CardinalityViolation
end

class PG::CardinalityViolation
end

class PG::CaseNotFound
end

class PG::CaseNotFound
end

class PG::CharacterNotInRepertoire
end

class PG::CharacterNotInRepertoire
end

class PG::CheckViolation
end

class PG::CheckViolation
end

class PG::Coder
  def ==(v); end

  def flags(); end

  def flags=(flags); end

  def format(); end

  def format=(format); end

  def initialize(params=T.unsafe(nil)); end

  def inspect_short(); end

  def marshal_dump(); end

  def marshal_load(str); end

  def name(); end

  def name=(name); end

  def oid(); end

  def oid=(oid); end

  def to_h(); end
  FORMAT_ERROR_MASK = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_PARTIAL = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_RAISE = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_STRING = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_UTC = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_UTC = ::T.let(nil, ::T.untyped)
end

module PG::Coder::BinaryFormatting
  def initialize(params=T.unsafe(nil)); end
  Params = ::T.let(nil, ::T.untyped)
end

module PG::Coder::BinaryFormatting
end

class PG::Coder
end

class PG::CollationMismatch
end

class PG::CollationMismatch
end

class PG::CompositeCoder
  def delimiter(); end

  def delimiter=(delimiter); end

  def elements_type(); end

  def elements_type=(elements_type); end

  def needs_quotation=(needs_quotation); end

  def needs_quotation?(); end
end

class PG::CompositeCoder
end

class PG::CompositeDecoder
end

class PG::CompositeDecoder
end

class PG::CompositeEncoder
end

class PG::CompositeEncoder
end

class PG::ConfigFileError
end

class PG::ConfigFileError
end

class PG::ConfigurationLimitExceeded
end

class PG::ConfigurationLimitExceeded
end

class PG::Connection
  include ::PG::Constants
  def async_describe_portal(_); end

  def async_describe_prepared(_); end

  def async_exec(*_); end

  def async_exec_params(*_); end

  def async_exec_prepared(*_); end

  def async_prepare(*_); end

  def async_query(*_); end

  def backend_pid(); end

  def block(*_); end

  def cancel(); end

  def client_encoding=(client_encoding); end

  def close(); end

  def conndefaults(); end

  def conndefaults_hash(); end

  def connect_poll(); end

  def connection_needs_password(); end

  def connection_used_password(); end

  def conninfo(); end

  def conninfo_hash(); end

  def consume_input(); end

  def copy_data(sql, coder=T.unsafe(nil)); end

  def db(); end

  def decoder_for_get_copy_data(); end

  def decoder_for_get_copy_data=(decoder_for_get_copy_data); end

  def describe_portal(_); end

  def describe_prepared(_); end

  def discard_results(); end

  def encoder_for_put_copy_data(); end

  def encoder_for_put_copy_data=(encoder_for_put_copy_data); end

  def encrypt_password(*_); end

  def error_message(); end

  def escape(_); end

  def escape_bytea(_); end

  def escape_identifier(_); end

  def escape_literal(_); end

  def escape_string(_); end

  def exec_params(*_); end

  def exec_prepared(*_); end

  def external_encoding(); end

  def field_name_type(); end

  def field_name_type=(field_name_type); end

  def finish(); end

  def finished?(); end

  def flush(); end

  def get_client_encoding(); end

  def get_copy_data(*_); end

  def get_last_result(); end

  def get_result(); end

  def host(); end

  def initialize(*_); end

  def internal_encoding(); end

  def internal_encoding=(internal_encoding); end

  def is_busy(); end

  def isnonblocking(); end

  def lo_close(_); end

  def lo_creat(*_); end

  def lo_create(_); end

  def lo_export(_, _1); end

  def lo_import(_); end

  def lo_lseek(_, _1, _2); end

  def lo_open(*_); end

  def lo_read(_, _1); end

  def lo_seek(_, _1, _2); end

  def lo_tell(_); end

  def lo_truncate(_, _1); end

  def lo_unlink(_); end

  def lo_write(_, _1); end

  def loclose(_); end

  def locreat(*_); end

  def locreate(_); end

  def loexport(_, _1); end

  def loimport(_); end

  def lolseek(_, _1, _2); end

  def loopen(*_); end

  def loread(_, _1); end

  def loseek(_, _1, _2); end

  def lotell(_); end

  def lotruncate(_, _1); end

  def lounlink(_); end

  def lowrite(_, _1); end

  def make_empty_pgresult(_); end

  def nonblocking?(); end

  def notifies(); end

  def notifies_wait(*_); end

  def options(); end

  def parameter_status(_); end

  def pass(); end

  def port(); end

  def prepare(*_); end

  def protocol_version(); end

  def put_copy_data(*_); end

  def put_copy_end(*_); end

  def query(*_); end

  def quote_ident(_); end

  def reset(); end

  def reset_poll(); end

  def reset_start(); end

  def send_describe_portal(_); end

  def send_describe_prepared(_); end

  def send_prepare(*_); end

  def send_query(*_); end

  def send_query_params(*_); end

  def send_query_prepared(*_); end

  def server_version(); end

  def set_client_encoding(_); end

  def set_default_encoding(); end

  def set_error_context_visibility(_); end

  def set_error_verbosity(_); end

  def set_notice_processor(); end

  def set_notice_receiver(); end

  def set_single_row_mode(); end

  def setnonblocking(_); end

  def socket(); end

  def socket_io(); end

  def ssl_attribute(_); end

  def ssl_attribute_names(); end

  def ssl_attributes(); end

  def ssl_in_use?(); end

  def status(); end

  def sync_describe_portal(_); end

  def sync_describe_prepared(_); end

  def sync_exec(*_); end

  def sync_exec_params(*_); end

  def sync_exec_prepared(*_); end

  def sync_prepare(*_); end

  def trace(_); end

  def transaction(); end

  def transaction_status(); end

  def tty(); end

  def type_map_for_queries(); end

  def type_map_for_queries=(type_map_for_queries); end

  def type_map_for_results(); end

  def type_map_for_results=(type_map_for_results); end

  def unescape_bytea(_); end

  def untrace(); end

  def user(); end

  def wait_for_notify(*_); end
  CONNECT_ARGUMENT_ORDER = ::T.let(nil, ::T.untyped)
  REDIRECT_METHODS = ::T.let(nil, ::T.untyped)
end

class PG::Connection
  def self.async_api=(enable); end

  def self.conndefaults(); end

  def self.conndefaults_hash(); end

  def self.connect(*_); end

  def self.connect_start(*_); end

  def self.encrypt_password(_, _1); end

  def self.escape(_); end

  def self.escape_bytea(_); end

  def self.escape_string(_); end

  def self.isthreadsafe(); end

  def self.parse_connect_args(*args); end

  def self.ping(*_); end

  def self.quote_connstr(value); end

  def self.quote_ident(_); end

  def self.setdb(*_); end

  def self.setdblogin(*_); end

  def self.unescape_bytea(_); end
end

class PG::ConnectionBad
end

class PG::ConnectionBad
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionException
end

class PG::ConnectionException
end

class PG::ConnectionFailure
end

class PG::ConnectionFailure
end

module PG::Constants
  CONNECTION_AUTH_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_AWAITING_RESPONSE = ::T.let(nil, ::T.untyped)
  CONNECTION_BAD = ::T.let(nil, ::T.untyped)
  CONNECTION_MADE = ::T.let(nil, ::T.untyped)
  CONNECTION_NEEDED = ::T.let(nil, ::T.untyped)
  CONNECTION_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_SETENV = ::T.let(nil, ::T.untyped)
  CONNECTION_SSL_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_STARTED = ::T.let(nil, ::T.untyped)
  INVALID_OID = ::T.let(nil, ::T.untyped)
  INV_READ = ::T.let(nil, ::T.untyped)
  INV_WRITE = ::T.let(nil, ::T.untyped)
  InvalidOid = ::T.let(nil, ::T.untyped)
  PGRES_BAD_RESPONSE = ::T.let(nil, ::T.untyped)
  PGRES_COMMAND_OK = ::T.let(nil, ::T.untyped)
  PGRES_COPY_BOTH = ::T.let(nil, ::T.untyped)
  PGRES_COPY_IN = ::T.let(nil, ::T.untyped)
  PGRES_COPY_OUT = ::T.let(nil, ::T.untyped)
  PGRES_EMPTY_QUERY = ::T.let(nil, ::T.untyped)
  PGRES_FATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_NONFATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_FAILED = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_OK = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_READING = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_WRITING = ::T.let(nil, ::T.untyped)
  PGRES_SINGLE_TUPLE = ::T.let(nil, ::T.untyped)
  PGRES_TUPLES_OK = ::T.let(nil, ::T.untyped)
  PG_DIAG_COLUMN_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONSTRAINT_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONTEXT = ::T.let(nil, ::T.untyped)
  PG_DIAG_DATATYPE_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_QUERY = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_DETAIL = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_HINT = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_PRIMARY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SCHEMA_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY_NONLOCALIZED = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FILE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FUNCTION = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_LINE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SQLSTATE = ::T.let(nil, ::T.untyped)
  PG_DIAG_STATEMENT_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_TABLE_NAME = ::T.let(nil, ::T.untyped)
  PQERRORS_DEFAULT = ::T.let(nil, ::T.untyped)
  PQERRORS_TERSE = ::T.let(nil, ::T.untyped)
  PQERRORS_VERBOSE = ::T.let(nil, ::T.untyped)
  PQPING_NO_ATTEMPT = ::T.let(nil, ::T.untyped)
  PQPING_NO_RESPONSE = ::T.let(nil, ::T.untyped)
  PQPING_OK = ::T.let(nil, ::T.untyped)
  PQPING_REJECT = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ALWAYS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ERRORS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_NEVER = ::T.let(nil, ::T.untyped)
  PQTRANS_ACTIVE = ::T.let(nil, ::T.untyped)
  PQTRANS_IDLE = ::T.let(nil, ::T.untyped)
  PQTRANS_INERROR = ::T.let(nil, ::T.untyped)
  PQTRANS_INTRANS = ::T.let(nil, ::T.untyped)
  PQTRANS_UNKNOWN = ::T.let(nil, ::T.untyped)
  SEEK_CUR = ::T.let(nil, ::T.untyped)
  SEEK_END = ::T.let(nil, ::T.untyped)
  SEEK_SET = ::T.let(nil, ::T.untyped)
end

module PG::Constants
end

class PG::CopyCoder
  def delimiter(); end

  def delimiter=(delimiter); end

  def null_string(); end

  def null_string=(null_string); end

  def type_map(); end

  def type_map=(type_map); end
end

class PG::CopyCoder
end

class PG::CopyDecoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyDecoder
end

class PG::CopyEncoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyEncoder
end

class PG::CrashShutdown
end

class PG::CrashShutdown
end

class PG::DataCorrupted
end

class PG::DataCorrupted
end

class PG::DataException
end

class PG::DataException
end

class PG::DatabaseDropped
end

class PG::DatabaseDropped
end

class PG::DatatypeMismatch
end

class PG::DatatypeMismatch
end

class PG::DatetimeFieldOverflow
end

class PG::DatetimeFieldOverflow
end

class PG::DependentObjectsStillExist
end

class PG::DependentObjectsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DiagnosticsException
end

class PG::DiagnosticsException
end

class PG::DiskFull
end

class PG::DiskFull
end

class PG::DivisionByZero
end

class PG::DivisionByZero
end

class PG::DuplicateAlias
end

class PG::DuplicateAlias
end

class PG::DuplicateColumn
end

class PG::DuplicateColumn
end

class PG::DuplicateCursor
end

class PG::DuplicateCursor
end

class PG::DuplicateDatabase
end

class PG::DuplicateDatabase
end

class PG::DuplicateFile
end

class PG::DuplicateFile
end

class PG::DuplicateFunction
end

class PG::DuplicateFunction
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateObject
end

class PG::DuplicateObject
end

class PG::DuplicatePstatement
end

class PG::DuplicatePstatement
end

class PG::DuplicateSchema
end

class PG::DuplicateSchema
end

class PG::DuplicateTable
end

class PG::DuplicateTable
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::Error
  def connection(); end

  def error(); end

  def result(); end
end

class PG::Error
end

class PG::ErrorInAssignment
end

class PG::ErrorInAssignment
end

class PG::EscapeCharacterConflict
end

class PG::EscapeCharacterConflict
end

class PG::ExclusionViolation
end

class PG::ExclusionViolation
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineInvocationException
end

class PG::ExternalRoutineInvocationException
end

class PG::FdwColumnNameNotFound
end

class PG::FdwColumnNameNotFound
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwError
end

class PG::FdwError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwNoSchemas
end

class PG::FdwNoSchemas
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOutOfMemory
end

class PG::FdwOutOfMemory
end

class PG::FdwReplyHandle
end

class PG::FdwReplyHandle
end

class PG::FdwSchemaNotFound
end

class PG::FdwSchemaNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTooManyHandles
end

class PG::FdwTooManyHandles
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToEstablishConnection
end

class PG::FdwUnableToEstablishConnection
end

class PG::FeatureNotSupported
end

class PG::FeatureNotSupported
end

class PG::FloatingPointException
end

class PG::FloatingPointException
end

class PG::ForeignKeyViolation
end

class PG::ForeignKeyViolation
end

class PG::GeneratedAlways
end

class PG::GeneratedAlways
end

class PG::GroupingError
end

class PG::GroupingError
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleInTransactionSessionTimeout
end

class PG::InFailedSqlTransaction
end

class PG::InFailedSqlTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::IndeterminateCollation
end

class PG::IndeterminateCollation
end

class PG::IndeterminateDatatype
end

class PG::IndeterminateDatatype
end

class PG::IndexCorrupted
end

class PG::IndexCorrupted
end

class PG::IndicatorOverflow
end

class PG::IndicatorOverflow
end

class PG::InsufficientPrivilege
end

class PG::InsufficientPrivilege
end

class PG::InsufficientResources
end

class PG::InsufficientResources
end

class PG::IntegrityConstraintViolation
end

class PG::IntegrityConstraintViolation
end

class PG::InternalError
end

class PG::InternalError
end

class PG::IntervalFieldOverflow
end

class PG::IntervalFieldOverflow
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidCatalogName
end

class PG::InvalidCatalogName
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnReference
end

class PG::InvalidColumnReference
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorName
end

class PG::InvalidCursorName
end

class PG::InvalidCursorState
end

class PG::InvalidCursorState
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeSequence
end

class PG::InvalidEscapeSequence
end

class PG::InvalidForeignKey
end

class PG::InvalidForeignKey
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantor
end

class PG::InvalidGrantor
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidJsonText
end

class PG::InvalidJsonText
end

class PG::InvalidName
end

class PG::InvalidName
end

class PG::InvalidObjectDefinition
end

class PG::InvalidObjectDefinition
end

class PG::InvalidParameterValue
end

class PG::InvalidParameterValue
end

class PG::InvalidPassword
end

class PG::InvalidPassword
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidRecursion
end

class PG::InvalidRecursion
end

class PG::InvalidRegularExpression
end

class PG::InvalidRegularExpression
end

class PG::InvalidResultStatus
end

class PG::InvalidResultStatus
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaName
end

class PG::InvalidSchemaName
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlStatementName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidTableDefinition
end

class PG::InvalidTableDefinition
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionTermination
end

class PG::InvalidTransactionTermination
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlProcessingInstruction
end

class PG::InvalidXmlProcessingInstruction
end

class PG::IoError
end

class PG::IoError
end

class PG::LEInvalidSpecification
end

class PG::LEInvalidSpecification
end

class PG::LocatorException
end

class PG::LocatorException
end

class PG::LockFileExists
end

class PG::LockFileExists
end

class PG::LockNotAvailable
end

class PG::LockNotAvailable
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MostSpecificTypeMismatch
end

class PG::MostSpecificTypeMismatch
end

class PG::NameTooLong
end

class PG::NameTooLong
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoDataFound
end

class PG::NoDataFound
end

class PG::NoResultError
end

class PG::NoResultError
end

class PG::NoSqlJsonItem
end

class PG::NoSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NotAllCopyDataRetrieved
end

class PG::NotAllCopyDataRetrieved
end

class PG::NotAnXmlDocument
end

class PG::NotAnXmlDocument
end

class PG::NotNullViolation
end

class PG::NotNullViolation
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNotAllowed
end

class PG::NullValueNotAllowed
end

class PG::NumericValueOutOfRange
end

class PG::NumericValueOutOfRange
end

class PG::ObjectInUse
end

class PG::ObjectInUse
end

class PG::ObjectNotInPrerequisiteState
end

class PG::ObjectNotInPrerequisiteState
end

class PG::OperatorIntervention
end

class PG::OperatorIntervention
end

class PG::OutOfMemory
end

class PG::OutOfMemory
end

class PG::PlpgsqlError
end

class PG::PlpgsqlError
end

class PG::ProgramLimitExceeded
end

class PG::ProgramLimitExceeded
end

class PG::ProtocolViolation
end

class PG::ProtocolViolation
end

class PG::QueryCanceled
end

class PG::QueryCanceled
end

class PG::RaiseException
end

class PG::RaiseException
end

class PG::ReadOnlySqlTransaction
end

class PG::ReadOnlySqlTransaction
end

class PG::RecordCoder
  def type_map(); end

  def type_map=(type_map); end
end

class PG::RecordCoder
end

class PG::RecordDecoder
end

class PG::RecordDecoder
end

class PG::RecordEncoder
end

class PG::RecordEncoder
end

class PG::ReservedName
end

class PG::ReservedName
end

class PG::RestrictViolation
end

class PG::RestrictViolation
end

class PG::Result
  include ::Enumerable
  include ::PG::Constants
  def [](_); end

  def autoclear?(); end

  def check(); end

  def check_result(); end

  def clear(); end

  def cleared?(); end

  def cmd_status(); end

  def cmd_tuples(); end

  def cmdtuples(); end

  def column_values(_); end

  def each(&blk); end

  def each_row(); end

  def error_field(_); end

  def error_message(); end

  def fformat(_); end

  def field_name_type(); end

  def field_name_type=(field_name_type); end

  def field_names_as(type); end

  def field_values(_); end

  def fields(); end

  def fmod(_); end

  def fname(_); end

  def fnumber(_); end

  def fsize(_); end

  def ftable(_); end

  def ftablecol(_); end

  def ftype(_); end

  def getisnull(_, _1); end

  def getlength(_, _1); end

  def getvalue(_, _1); end

  def map_types!(type_map); end

  def nfields(); end

  def nparams(); end

  def ntuples(); end

  def num_fields(); end

  def num_tuples(); end

  def oid_value(); end

  def paramtype(_); end

  def res_status(_); end

  def result_error_field(_); end

  def result_error_message(); end

  def result_status(); end

  def result_verbose_error_message(_, _1); end

  def stream_each(); end

  def stream_each_row(); end

  def stream_each_tuple(); end

  def tuple(_); end

  def tuple_values(_); end

  def type_map(); end

  def type_map=(type_map); end

  def values(); end

  def verbose_error_message(_, _1); end
end

class PG::Result
end

class PG::SEInvalidSpecification
end

class PG::SEInvalidSpecification
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SavepointException
end

class PG::SavepointException
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::ServerError
end

class PG::ServerError
end

class PG::SimpleCoder
end

class PG::SimpleCoder
end

class PG::SimpleDecoder
end

class PG::SimpleDecoder
end

class PG::SimpleEncoder
end

class PG::SimpleEncoder
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SnapshotTooOld
end

class PG::SnapshotTooOld
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonScalarRequired
end

class PG::SqlJsonScalarRequired
end

class PG::SqlRoutineException
end

class PG::SqlRoutineException
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StatementTooComplex
end

class PG::StatementTooComplex
end

class PG::StringDataLengthMismatch
end

class PG::StringDataLengthMismatch
end

class PG::StringDataRightTruncation
end

class PG::StringDataRightTruncation
end

class PG::SubstringError
end

class PG::SubstringError
end

class PG::SyntaxError
end

class PG::SyntaxError
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SystemError
end

class PG::SystemError
end

class PG::TRDeadlockDetected
end

class PG::TRDeadlockDetected
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRSerializationFailure
end

class PG::TRSerializationFailure
end

class PG::TRStatementCompletionUnknown
end

class PG::TRStatementCompletionUnknown
end

module PG::TextDecoder
end

class PG::TextDecoder::Array
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Array
end

class PG::TextDecoder::Boolean
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Boolean
end

class PG::TextDecoder::Bytea
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Bytea
end

class PG::TextDecoder::CopyRow
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::CopyRow
end

class PG::TextDecoder::Date
  def decode(string, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
end

class PG::TextDecoder::Date
end

class PG::TextDecoder::Float
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Float
end

class PG::TextDecoder::FromBase64
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::FromBase64
end

class PG::TextDecoder::Identifier
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Identifier
end

class PG::TextDecoder::Inet
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
end

class PG::TextDecoder::Integer
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Integer
end

class PG::TextDecoder::JSON
  def decode(string, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
end

class PG::TextDecoder::JSON
end

class PG::TextDecoder::Numeric
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Numeric
end

class PG::TextDecoder::Record
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Record
end

class PG::TextDecoder::String
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::String
end

class PG::TextDecoder::Timestamp
  def decode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Timestamp
end

class PG::TextDecoder::TimestampLocal
end

class PG::TextDecoder::TimestampLocal
end

class PG::TextDecoder::TimestampUtc
end

class PG::TextDecoder::TimestampUtc
end

class PG::TextDecoder::TimestampUtcToLocal
end

class PG::TextDecoder::TimestampUtcToLocal
end

PG::TextDecoder::TimestampWithTimeZone = PG::TextDecoder::Timestamp

PG::TextDecoder::TimestampWithoutTimeZone = PG::TextDecoder::TimestampLocal

module PG::TextDecoder
end

module PG::TextEncoder
end

class PG::TextEncoder::Array
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Array
end

class PG::TextEncoder::Boolean
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Boolean
end

class PG::TextEncoder::Bytea
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Bytea
end

class PG::TextEncoder::CopyRow
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::CopyRow
end

class PG::TextEncoder::Date
  def encode(value); end
end

class PG::TextEncoder::Date
end

class PG::TextEncoder::Float
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Float
end

class PG::TextEncoder::Identifier
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Identifier
end

class PG::TextEncoder::Inet
  def encode(value); end
end

class PG::TextEncoder::Inet
end

class PG::TextEncoder::Integer
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Integer
end

class PG::TextEncoder::JSON
  def encode(value); end
end

class PG::TextEncoder::JSON
end

class PG::TextEncoder::Numeric
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Numeric
end

class PG::TextEncoder::QuotedLiteral
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::QuotedLiteral
end

class PG::TextEncoder::Record
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Record
end

class PG::TextEncoder::String
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::String
end

class PG::TextEncoder::TimestampUtc
  def encode(value); end
end

class PG::TextEncoder::TimestampUtc
end

class PG::TextEncoder::TimestampWithTimeZone
  def encode(value); end
end

class PG::TextEncoder::TimestampWithTimeZone
end

class PG::TextEncoder::TimestampWithoutTimeZone
  def encode(value); end
end

class PG::TextEncoder::TimestampWithoutTimeZone
end

class PG::TextEncoder::ToBase64
  def encode(*_); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::ToBase64
end

module PG::TextEncoder
end

class PG::TooManyArguments
end

class PG::TooManyArguments
end

class PG::TooManyColumns
end

class PG::TooManyColumns
end

class PG::TooManyConnections
end

class PG::TooManyConnections
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyRows
end

class PG::TooManyRows
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionRollback
end

class PG::TransactionRollback
end

class PG::TriggeredActionException
end

class PG::TriggeredActionException
end

class PG::TriggeredDataChangeViolation
end

class PG::TriggeredDataChangeViolation
end

class PG::TrimError
end

class PG::TrimError
end

class PG::Tuple
  include ::Enumerable
  def [](_); end

  def each(&blk); end

  def each_key(&block); end

  def each_value(); end

  def fetch(*_); end

  def has_key?(key); end

  def index(_); end

  def key?(key); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

class PG::Tuple
end

class PG::TypeMap
end

module PG::TypeMap::DefaultTypeMappable
  def default_type_map(); end

  def default_type_map=(default_type_map); end

  def with_default_type_map(_); end
end

module PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMap
end

class PG::TypeMapAllStrings
end

class PG::TypeMapAllStrings
end

class PG::TypeMapByClass
  include ::PG::TypeMap::DefaultTypeMappable
  def [](_); end

  def []=(_, _1); end

  def coders(); end
end

class PG::TypeMapByClass
end

class PG::TypeMapByColumn
  include ::PG::TypeMap::DefaultTypeMappable
  def coders(); end

  def initialize(_); end

  def oids(); end
end

class PG::TypeMapByColumn
end

class PG::TypeMapByMriType
  include ::PG::TypeMap::DefaultTypeMappable
  def [](_); end

  def []=(_, _1); end

  def coders(); end
end

class PG::TypeMapByMriType
end

class PG::TypeMapByOid
  include ::PG::TypeMap::DefaultTypeMappable
  def add_coder(_); end

  def build_column_map(_); end

  def coders(); end

  def max_rows_for_online_lookup(); end

  def max_rows_for_online_lookup=(max_rows_for_online_lookup); end

  def rm_coder(_, _1); end
end

class PG::TypeMapByOid
end

class PG::TypeMapInRuby
  include ::PG::TypeMap::DefaultTypeMappable
  def typecast_copy_get(_, _1, _2, _3); end

  def typecast_query_param(_, _1); end

  def typecast_result_value(_, _1, _2); end
end

class PG::TypeMapInRuby
end

class PG::UnableToSend
end

class PG::UnableToSend
end

class PG::UndefinedColumn
end

class PG::UndefinedColumn
end

class PG::UndefinedFile
end

class PG::UndefinedFile
end

class PG::UndefinedFunction
end

class PG::UndefinedFunction
end

class PG::UndefinedObject
end

class PG::UndefinedObject
end

class PG::UndefinedParameter
end

class PG::UndefinedParameter
end

class PG::UndefinedTable
end

class PG::UndefinedTable
end

class PG::UniqueViolation
end

class PG::UniqueViolation
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnterminatedCString
end

class PG::UnterminatedCString
end

class PG::UntranslatableCharacter
end

class PG::UntranslatableCharacter
end

class PG::WindowingError
end

class PG::WindowingError
end

class PG::WithCheckOptionViolation
end

class PG::WithCheckOptionViolation
end

class PG::WrongObjectType
end

class PG::WrongObjectType
end

class PG::ZeroLengthCharacterString
end

class PG::ZeroLengthCharacterString
end

module PG
  def self.connect(*args); end

  def self.init_openssl(_, _1); end

  def self.init_ssl(_); end

  def self.is_threadsafe?(); end

  def self.isthreadsafe(); end

  def self.library_version(); end

  def self.threadsafe?(); end

  def self.version_string(include_buildnum=T.unsafe(nil)); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
end

class Parallel::Break
end

class Parallel::DeadWorker
end

class Parallel::DeadWorker
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::ExceptionWrapper
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::JobFactory
end

class Parallel::Kill
end

class Parallel::Kill
end

module Parallel::ProcessorCount
  def physical_processor_count(); end

  def processor_count(); end
end

module Parallel::ProcessorCount
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UndumpableException
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

class Parallel::Worker
end

module Parallel
  extend ::Parallel::ProcessorCount
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.flat_map(*args, &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

ParseError = Racc::ParseError

module ParseMethods
  def arr_with_fa(array); end

  def icon_type(type); end

  def prepend_fa(string); end
end

module ParseMethods
end

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_def_e(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_defs_e(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_find_pattern(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_mrasgn(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_rasgn(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def find_pattern(lbrack_t, elements, rbrack_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_arg(dots_t); end

  def forward_only_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match, comma_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def multi_rassign(lhs, assoc_t, rhs); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rassign(lhs, assoc_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_forward_arg(); end

  def self.emit_forward_arg=(emit_forward_arg); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def class_definition_allowed?(); end

  def dynamic_const_definition_allowed?(); end

  def in_block?(); end

  def in_class?(); end

  def in_dynamic_block?(); end

  def in_lambda?(); end

  def indirectly_in_def?(); end

  def module_definition_allowed?(); end

  def pop(); end

  def push(state); end

  def reset(); end

  def stack(); end
end

class Parser::Context
end

class Parser::CurrentArgStack
  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

class Parser::CurrentArgStack
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encode_escape(ord); end

  def encoding(); end

  def eof_codepoint?(point); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def initialize(version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def pop_literal(); end

  def push_cmdarg(); end

  def push_cond(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(); end

  def register(numparam); end

  def stack(); end

  def top(); end
end

class Parser::MaxNumparamStack
end

module Parser::Messages
end

module Parser::Messages
  def self.compile(reason, arguments); end
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*_); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil), source: T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(range); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::EndlessDefinition
  def assignment(); end

  def initialize(keyword_l, operator_l, name_l, assignment_l, body_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::EndlessDefinition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def to_range(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def action_root(); end

  def as_nested_actions(); end

  def as_replacements(); end

  def diagnostics(); end

  def empty?(); end

  def import!(foreign_rewriter, offset: T.unsafe(nil)); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def merge(with); end

  def merge!(with); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def analyse_hierarchy(action); end

  def bsearch_child_index(from=T.unsafe(nil)); end

  def call_enforcer_for_merge(action); end

  def check_fusible(action, *fusible); end

  def children(); end

  def combine(action); end

  def combine_children(more_children); end

  def contract(); end

  def do_combine(action); end

  def empty?(); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def moved(source_buffer, offset); end

  def nested_actions(); end

  def ordered_replacements(); end

  def place_in_hierarchy(action); end

  def range(); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_forward_args?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def reset(); end

  def unextend(); end
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Parser::VariablesStack
end

module Parser
end

module Pastel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Pastel::ANSI
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

module Pastel::ANSI
  def self.background?(code); end

  def self.foreground?(code); end

  def self.style?(code); end
end

class Pastel::AliasImporter
  def color(); end

  def env(); end

  def import(); end

  def initialize(color, env, output=T.unsafe(nil)); end

  def output(); end
end

class Pastel::AliasImporter
end

class Pastel::Color
  include ::Equatable
  include ::Equatable::Methods
  include ::Pastel::ANSI
  def alias_color(alias_name, *colors); end

  def apply_codes(string, ansi_colors); end

  def clear(); end

  def code(*colors); end

  def colored?(string); end

  def compare?(comparator, other); end

  def decorate(string, *colors); end

  def disable!(); end

  def eachline(); end

  def enabled(); end

  def enabled?(); end

  def initialize(options=T.unsafe(nil)); end

  def lookup(*colors); end

  def strip(*strings); end

  def style_names(); end

  def styles(); end

  def valid?(*colors); end
  ALIASES = ::T.let(nil, ::T.untyped)
  ANSI_COLOR_REGEXP = ::T.let(nil, ::T.untyped)
end

class Pastel::Color
  extend ::Equatable
end

class Pastel::ColorParser
  include ::Pastel::ANSI
  CSI = ::T.let(nil, ::T.untyped)
  ESC = ::T.let(nil, ::T.untyped)
end

class Pastel::ColorParser
  def self.ansi_for(ansi); end

  def self.attribute_for(ansi); end

  def self.parse(text); end

  def self.unpack_ansi(ansi_stack); end
end

class Pastel::ColorResolver
  def color(); end

  def initialize(color); end

  def resolve(base, unprocessed_string); end
end

class Pastel::ColorResolver
end

class Pastel::DecoratorChain
  include ::Enumerable
  include ::Equatable
  include ::Equatable::Methods
  def add(decorator); end

  def compare?(comparator, other); end

  def decorators(); end

  def each(&block); end

  def initialize(decorators=T.unsafe(nil)); end
end

class Pastel::DecoratorChain
  extend ::Equatable
  def self.empty(); end
end

class Pastel::Delegator
  include ::Equatable
  include ::Equatable::Methods
  def alias_color(*args, &block); end

  def base(); end

  def colored?(*args, &block); end

  def compare?(comparator, other); end

  def decorate(*args, &block); end

  def enabled?(*args, &block); end

  def evaluate_block(&block); end

  def initialize(resolver, base); end

  def lookup(*args, &block); end

  def method_missing(method_name, *args, &block); end

  def parse(*args, &block); end

  def resolver(); end

  def strip(*args, &block); end

  def styles(*args, &block); end

  def undecorate(*args, &block); end

  def valid?(*args, &block); end

  def wrap(base); end
end

class Pastel::Delegator
  extend ::Forwardable
  extend ::Equatable
  def self.for(resolver, base); end
end

class Pastel::Detached
  include ::Equatable
  include ::Equatable::Methods
  def [](*args); end

  def call(*args); end

  def compare?(comparator, other); end

  def initialize(color, *styles); end

  def styles(); end

  def to_proc(); end
end

class Pastel::Detached
  extend ::Equatable
end

class Pastel::InvalidAliasNameError
end

class Pastel::InvalidAliasNameError
end

class Pastel::InvalidAttributeNameError
end

class Pastel::InvalidAttributeNameError
end

module Pastel
  def self.new(options=T.unsafe(nil)); end
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  include ::MethodSource::SourceLocation::ProcExtensions
  include ::MethodSource::MethodExtensions
  def <<(_); end

  def >>(_); end

  def clone(); end
end

class ProgressBar
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar(); end

  def bar=(bar); end

  def clear(*args, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage(); end

  def percentage=(percentage); end

  def progress(*args, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def rate(); end

  def rate=(rate); end

  def refresh(*args, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time(); end

  def time=(time); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_comp(); end

  def title_comp=(title_comp); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, &block); end

  def total=(new_total); end

  def update_progress(*args); end
end

class ProgressBar::Base
  extend ::Forwardable
end

module ProgressBar::Calculators
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::Length
end

class ProgressBar::Calculators::RunningAverage
end

class ProgressBar::Calculators::RunningAverage
  def self.calculate(current_average, new_value_to_average, smoothing_factor); end
end

module ProgressBar::Calculators
end

module ProgressBar::Components
end

class ProgressBar::Components::Bar
  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Percentage
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Rate
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def out_of_bounds_time_format(); end

  def out_of_bounds_time_format=(format); end

  def progress(); end

  def progress=(progress); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
end

module ProgressBar::Components
end

module ProgressBar::Format
end

class ProgressBar::Format::Formatter
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
end

module ProgressBar::Format
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

module ProgressBar::Outputs
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*_); end

  def resolve_format(*_); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
end

module ProgressBar::Outputs
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def running_average(); end

  def running_average=(running_average); end

  def smoothing(); end

  def smoothing=(smoothing); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
end

module ProgressBar::Refinements
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Throttle
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar::Timer
end

class ProgressBar
  def self.create(*args); end
end

class Pry
  def add_sticky_local(name, &block); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def binding_stack(); end

  def binding_stack=(binding_stack); end

  def color(*args, &block); end

  def color=(*args, &block); end

  def commands(*args, &block); end

  def commands=(*args, &block); end

  def complete(str); end

  def config(); end

  def current_binding(); end

  def current_context(); end

  def custom_completions(); end

  def custom_completions=(custom_completions); end

  def editor(*args, &block); end

  def editor=(*args, &block); end

  def eval(line, options=T.unsafe(nil)); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def evaluate_ruby(code); end

  def exception_handler(*args, &block); end

  def exception_handler=(*args, &block); end

  def exec_hook(name, *args, &block); end

  def exit_value(); end

  def extra_sticky_locals(*args, &block); end

  def extra_sticky_locals=(*args, &block); end

  def hooks(*args, &block); end

  def hooks=(*args, &block); end

  def initialize(options=T.unsafe(nil)); end

  def inject_local(name, value, binding); end

  def inject_sticky_locals!(); end

  def input(*args, &block); end

  def input=(*args, &block); end

  def input_ring(); end

  def last_dir(); end

  def last_dir=(last_dir); end

  def last_exception(); end

  def last_exception=(exception); end

  def last_file(); end

  def last_file=(last_file); end

  def last_result(); end

  def last_result=(last_result); end

  def last_result_is_exception?(); end

  def memory_size(); end

  def memory_size=(size); end

  def output(); end

  def output=(*args, &block); end

  def output_ring(); end

  def pager(); end

  def pager=(*args, &block); end

  def pop_prompt(); end

  def print(*args, &block); end

  def print=(*args, &block); end

  def process_command(val); end

  def process_command_safely(val); end

  def prompt(); end

  def prompt=(new_prompt); end

  def push_binding(object); end

  def push_initial_binding(target=T.unsafe(nil)); end

  def push_prompt(new_prompt); end

  def quiet?(); end

  def raise_up(*args); end

  def raise_up!(*args); end

  def raise_up_common(force, *args); end

  def repl(target=T.unsafe(nil)); end

  def reset_eval_string(); end

  def run_command(val); end

  def select_prompt(); end

  def set_last_result(result, code=T.unsafe(nil)); end

  def should_print?(); end

  def show_result(result); end

  def sticky_locals(); end

  def suppress_output(); end

  def suppress_output=(suppress_output); end

  def update_input_history(code); end
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  include ::Kernel
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::BasicObject
end

class Pry::BlockCommand
  def call(*args); end

  def help(); end
end

class Pry::BlockCommand
end

class Pry::CLI
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI
  def self.add_option_processor(&block); end

  def self.add_options(&block); end

  def self.add_plugin_options(); end

  def self.input_args(); end

  def self.input_args=(input_args); end

  def self.option_processors(); end

  def self.option_processors=(option_processors); end

  def self.options(); end

  def self.options=(options); end

  def self.parse_options(args=T.unsafe(nil)); end

  def self.reset(); end

  def self.start(opts); end
end

class Pry::ClassCommand
  def args(); end

  def args=(args); end

  def call(*args); end

  def complete(search); end

  def help(); end

  def options(opt); end

  def opts(); end

  def opts=(opts); end

  def process(); end

  def setup(); end

  def slop(); end

  def subcommands(cmd); end
end

class Pry::ClassCommand
  def self.inherited(klass); end

  def self.source_location(); end
end

class Pry::Code
  def <<(line); end

  def ==(other); end

  def after(lineno, lines=T.unsafe(nil)); end

  def alter(&block); end

  def around(lineno, lines=T.unsafe(nil)); end

  def before(lineno, lines=T.unsafe(nil)); end

  def between(start_line, end_line=T.unsafe(nil)); end

  def code_type(); end

  def code_type=(code_type); end

  def comment_describing(line_number); end

  def expression_at(line_number, consume=T.unsafe(nil)); end

  def grep(pattern); end

  def highlighted(); end

  def initialize(lines=T.unsafe(nil), start_line=T.unsafe(nil), code_type=T.unsafe(nil)); end

  def length(); end

  def max_lineno_width(); end

  def method_missing(method_name, *args, &block); end

  def nesting_at(line_number); end

  def print_to_output(output, color=T.unsafe(nil)); end

  def push(line); end

  def raw(); end

  def reject(&block); end

  def select(&block); end

  def take_lines(start_line, num_lines); end

  def with_indentation(spaces=T.unsafe(nil)); end

  def with_line_numbers(y_n=T.unsafe(nil)); end

  def with_marker(lineno=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
  def indices_range(lines); end

  def initialize(start_line, end_line=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
end

class Pry::Code::LOC
  def ==(other); end

  def add_line_number(max_width=T.unsafe(nil), color=T.unsafe(nil)); end

  def add_marker(marker_lineno); end

  def colorize(code_type); end

  def handle_multiline_entries_from_edit_command(line, max_width); end

  def indent(distance); end

  def initialize(line, lineno); end

  def line(); end

  def lineno(); end

  def tuple(); end
end

class Pry::Code::LOC
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
  def self.from_file(filename, code_type=T.unsafe(nil)); end

  def self.from_method(meth, start_line=T.unsafe(nil)); end

  def self.from_module(mod, candidate_rank=T.unsafe(nil), start_line=T.unsafe(nil)); end
end

class Pry::CodeFile
  def code(); end

  def code_type(); end

  def initialize(filename, code_type=T.unsafe(nil)); end
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::CodeFile
end

class Pry::CodeObject
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def command_lookup(); end

  def default_lookup(); end

  def empty_lookup(); end

  def initialize(str, pry_instance, options=T.unsafe(nil)); end

  def method_or_class_lookup(); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def str(); end

  def str=(str); end

  def super_level(); end

  def super_level=(super_level); end

  def target(); end

  def target=(target); end
end

module Pry::CodeObject::Helpers
  def c_method?(); end

  def c_module?(); end

  def command?(); end

  def module_with_yard_docs?(); end

  def real_method_object?(); end
end

module Pry::CodeObject::Helpers
end

class Pry::CodeObject
  def self.lookup(str, pry_instance, options=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def pp(object); end

  def text(str, max_width=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def self.default(_output, value, pry_instance); end

  def self.pp(obj, output=T.unsafe(nil), max_width=T.unsafe(nil)); end
end

class Pry::Command
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::Text
  def _pry_(); end

  def _pry_=(_pry_); end

  def arg_string(); end

  def arg_string=(arg_string); end

  def block(); end

  def captures(); end

  def captures=(captures); end

  def check_for_command_collision(command_match, arg_string); end

  def command_block(); end

  def command_block=(command_block); end

  def command_name(); end

  def command_options(); end

  def command_set(); end

  def command_set=(command_set); end

  def commands(); end

  def complete(_search); end

  def context(); end

  def context=(context); end

  def description(); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def hooks(); end

  def hooks=(hooks); end

  def initialize(context=T.unsafe(nil)); end

  def interpolate_string(str); end

  def match(); end

  def name(); end

  def output(); end

  def output=(output); end

  def process_line(line); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def run(command_string, *args); end

  def source(); end

  def state(); end

  def target(); end

  def target=(target); end

  def target_self(); end

  def tokenize(val); end

  def void(); end
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::AmendLine
end

class Pry::Command::AmendLine
end

class Pry::Command::Bang
end

class Pry::Command::Bang
end

class Pry::Command::BangPry
end

class Pry::Command::BangPry
end

class Pry::Command::Cat
  def load_path_completions(); end
end

class Pry::Command::Cat::AbstractFormatter
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::BaseHelpers
end

class Pry::Command::Cat::AbstractFormatter
end

class Pry::Command::Cat::ExceptionFormatter
  include ::Pry::Helpers::Text
  def ex(); end

  def format(); end

  def initialize(exception, pry_instance, opts); end

  def opts(); end

  def pry_instance(); end
end

class Pry::Command::Cat::ExceptionFormatter
end

class Pry::Command::Cat::FileFormatter
  def file_and_line(); end

  def file_with_embedded_line(); end

  def format(); end

  def initialize(file_with_embedded_line, pry_instance, opts); end

  def opts(); end

  def pry_instance(); end
end

class Pry::Command::Cat::FileFormatter
end

class Pry::Command::Cat::InputExpressionFormatter
  def format(); end

  def initialize(input_expressions, opts); end

  def input_expressions(); end

  def input_expressions=(input_expressions); end

  def opts(); end

  def opts=(opts); end
end

class Pry::Command::Cat::InputExpressionFormatter
end

class Pry::Command::Cat
end

class Pry::Command::Cd
end

class Pry::Command::Cd
end

class Pry::Command::ChangeInspector
  def process(inspector); end
end

class Pry::Command::ChangeInspector
end

class Pry::Command::ChangePrompt
  def process(prompt); end
end

class Pry::Command::ChangePrompt
end

class Pry::Command::ClearScreen
end

class Pry::Command::ClearScreen
end

class Pry::Command::CodeCollector
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def args(); end

  def code_object(); end

  def content(); end

  def file(); end

  def file=(file); end

  def initialize(args, opts, pry_instance); end

  def line_range(); end

  def obj_name(); end

  def opts(); end

  def pry_input_content(); end

  def pry_instance(); end

  def pry_output_content(); end

  def restrict_to_lines(content, range); end
end

class Pry::Command::CodeCollector
  def self.inject_options(opt); end

  def self.input_expression_ranges(); end

  def self.input_expression_ranges=(input_expression_ranges); end

  def self.output_result_ranges(); end

  def self.output_result_ranges=(output_result_ranges); end
end

class Pry::Command::DisablePry
end

class Pry::Command::DisablePry
end

class Pry::Command::Edit
  def apply_runtime_patch(); end

  def bad_option_combination?(); end

  def code_object(); end

  def ensure_file_name_is_valid(file_name); end

  def file_and_line(); end

  def file_and_line_for_current_exception(); end

  def file_based_exception?(); end

  def file_edit(); end

  def filename_argument(); end

  def initial_temp_file_content(); end

  def input_expression(); end

  def never_reload?(); end

  def patch_exception?(); end

  def previously_patched?(code_object); end

  def probably_a_file?(str); end

  def pry_method?(code_object); end

  def reload?(file_name=T.unsafe(nil)); end

  def reloadable?(); end

  def repl_edit(); end

  def repl_edit?(); end

  def runtime_patch?(); end
end

class Pry::Command::Edit::ExceptionPatcher
  def file_and_line(); end

  def file_and_line=(file_and_line); end

  def initialize(pry_instance, state, exception_file_and_line); end

  def perform_patch(); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def state(); end

  def state=(state); end
end

class Pry::Command::Edit::ExceptionPatcher
end

module Pry::Command::Edit::FileAndLineLocator
end

module Pry::Command::Edit::FileAndLineLocator
  def self.from_binding(target); end

  def self.from_code_object(code_object, filename_argument); end

  def self.from_exception(exception, backtrace_level); end

  def self.from_filename_argument(filename_argument); end
end

class Pry::Command::Edit
end

class Pry::Command::Exit
  def process_pop_and_return(); end
end

class Pry::Command::Exit
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitProgram
end

class Pry::Command::ExitProgram
end

class Pry::Command::FindMethod
end

class Pry::Command::FindMethod
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::FixIndent
end

class Pry::Command::FixIndent
end

class Pry::Command::Help
  def command_groups(); end

  def display_command(command); end

  def display_filtered_commands(search); end

  def display_filtered_search_results(search); end

  def display_index(groups); end

  def display_search(search); end

  def group_sort_key(group_name); end

  def help_text_for_commands(name, commands); end

  def normalize(key); end

  def search_hash(search, hash); end

  def sorted_commands(commands); end

  def sorted_group_names(groups); end

  def visible_commands(); end
end

class Pry::Command::Help
end

class Pry::Command::Hist
end

class Pry::Command::Hist
end

class Pry::Command::ImportSet
  def process(_command_set_name); end
end

class Pry::Command::ImportSet
end

class Pry::Command::JumpTo
  def process(break_level); end
end

class Pry::Command::JumpTo
end

class Pry::Command::ListInspectors
end

class Pry::Command::ListInspectors
end

class Pry::Command::Ls
  def no_user_opts?(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
end

class Pry::Command::Ls::Formatter
  def grep=(grep); end

  def initialize(pry_instance); end

  def pry_instance(); end

  def write_out(); end
end

class Pry::Command::Ls::Formatter
end

class Pry::Command::Ls::Globals
  def initialize(opts, pry_instance); end
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
end

class Pry::Command::Ls::Grep
  def initialize(grep_regexp); end

  def regexp(); end
end

class Pry::Command::Ls::Grep
end

class Pry::Command::Ls::InstanceVars
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::InstanceVars
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::JRubyHacks
end

class Pry::Command::Ls::LocalNames
  def initialize(no_user_opts, args, pry_instance); end
end

class Pry::Command::Ls::LocalNames
end

class Pry::Command::Ls::LocalVars
  def initialize(opts, pry_instance); end
end

class Pry::Command::Ls::LocalVars
end

class Pry::Command::Ls::LsEntity
  def entities_table(); end

  def initialize(opts); end

  def pry_instance(); end
end

class Pry::Command::Ls::LsEntity
end

class Pry::Command::Ls::Methods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::Methods
end

module Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::MethodsHelper
end

class Pry::Command::Ls::SelfMethods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::SelfMethods
end

class Pry::Command::Ls
end

class Pry::Command::Nesting
end

class Pry::Command::Nesting
end

class Pry::Command::Play
  def code_object(); end

  def content(); end

  def content_after_options(); end

  def content_at_expression(); end

  def default_file(); end

  def file_content(); end

  def perform_play(); end

  def should_use_default_file?(); end

  def show_input(); end
end

class Pry::Command::Play
end

class Pry::Command::PryBacktrace
end

class Pry::Command::PryBacktrace
end

class Pry::Command::RaiseUp
end

class Pry::Command::RaiseUp
end

class Pry::Command::ReloadCode
end

class Pry::Command::ReloadCode
end

class Pry::Command::Reset
end

class Pry::Command::Reset
end

class Pry::Command::Ri
  def process(spec); end
end

class Pry::Command::Ri
end

class Pry::Command::SaveFile
  def display_content(); end

  def file_name(); end

  def mode(); end

  def save_file(); end
end

class Pry::Command::SaveFile
end

class Pry::Command::ShellCommand
  def process(cmd); end
end

class Pry::Command::ShellCommand
end

class Pry::Command::ShellMode
end

class Pry::Command::ShellMode
end

class Pry::Command::ShowDoc
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowDoc
end

class Pry::Command::ShowInfo
  def code_object_header(code_object, line_num); end

  def code_object_with_accessible_source(code_object); end

  def complete(input); end

  def content_and_header_for_code_object(code_object); end

  def content_and_headers_for_all_module_candidates(mod); end

  def file_and_line_for(code_object); end

  def header(code_object); end

  def header_options(); end

  def initialize(*_); end

  def method_header(code_object, line_num); end

  def method_sections(code_object); end

  def module_header(code_object, line_num); end

  def no_definition_message(); end

  def obj_name(); end

  def show_all_modules?(code_object); end

  def start_line_for(code_object); end

  def use_line_numbers?(); end

  def valid_superclass?(code_object); end
end

class Pry::Command::ShowInfo
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowSource
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowSource
end

class Pry::Command::Stat
end

class Pry::Command::Stat
end

class Pry::Command::SwitchTo
  def process(selection); end
end

class Pry::Command::SwitchTo
end

class Pry::Command::ToggleColor
  def color_toggle(); end
end

class Pry::Command::ToggleColor
end

class Pry::Command::Version
end

class Pry::Command::Version
end

class Pry::Command::WatchExpression
end

class Pry::Command::WatchExpression::Expression
  def changed?(); end

  def eval!(); end

  def initialize(pry_instance, target, source); end

  def previous_value(); end

  def pry_instance(); end

  def source(); end

  def target(); end

  def value(); end
end

class Pry::Command::WatchExpression::Expression
end

class Pry::Command::WatchExpression
end

class Pry::Command::Whereami
  def bad_option_combination?(); end

  def code(); end

  def code?(); end

  def initialize(*_); end

  def location(); end
end

class Pry::Command::Whereami
  def self.method_size_cutoff(); end

  def self.method_size_cutoff=(method_size_cutoff); end
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Wtf
end

class Pry::Command
  extend ::Pry::Helpers::DocumentationHelpers
  extend ::Pry::CodeObject::Helpers
  def self.banner(arg=T.unsafe(nil)); end

  def self.block(); end

  def self.block=(block); end

  def self.command_name(); end

  def self.command_options(arg=T.unsafe(nil)); end

  def self.command_options=(command_options); end

  def self.command_regex(); end

  def self.convert_to_regex(obj); end

  def self.default_options(match); end

  def self.description(arg=T.unsafe(nil)); end

  def self.description=(description); end

  def self.doc(); end

  def self.file(); end

  def self.group(name=T.unsafe(nil)); end

  def self.line(); end

  def self.match(arg=T.unsafe(nil)); end

  def self.match=(match); end

  def self.match_score(val); end

  def self.matches?(val); end

  def self.options(arg=T.unsafe(nil)); end

  def self.options=(options); end

  def self.source(); end

  def self.source_file(); end

  def self.source_line(); end

  def self.state(); end

  def self.subclass(match, description, options, helpers, &block); end
end

class Pry::CommandError
end

class Pry::CommandError
end

class Pry::CommandSet
  include ::Enumerable
  include ::Pry::Helpers::BaseHelpers
  def [](pattern); end

  def []=(pattern, command); end

  def add_command(command); end

  def alias_command(match, action, options=T.unsafe(nil)); end

  def block_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def complete(search, context=T.unsafe(nil)); end

  def create_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def delete(*searches); end

  def desc(search, description=T.unsafe(nil)); end

  def each(&block); end

  def find_command(pattern); end

  def find_command_by_match_or_listing(match_or_listing); end

  def find_command_for_help(search); end

  def helper_module(); end

  def import(*sets); end

  def import_from(set, *matches); end

  def initialize(*imported_sets, &block); end

  def keys(); end

  def list_commands(); end

  def process_line(val, context=T.unsafe(nil)); end

  def rename_command(new_match, search, options=T.unsafe(nil)); end

  def to_h(); end

  def to_hash(); end

  def valid_command?(val); end
end

class Pry::CommandSet
end

class Pry::CommandState
  def reset(command_name); end

  def state_for(command_name); end
end

class Pry::CommandState
  def self.default(); end
end

class Pry::Config
  def [](attr); end

  def []=(attr, value); end

  def auto_indent(); end

  def auto_indent=(auto_indent); end

  def collision_warning(); end

  def collision_warning=(collision_warning); end

  def color(); end

  def color=(color); end

  def command_completions(); end

  def command_completions=(command_completions); end

  def command_prefix(); end

  def command_prefix=(command_prefix); end

  def commands(); end

  def commands=(commands); end

  def completer(); end

  def completer=(completer); end

  def control_d_handler(); end

  def control_d_handler=(value); end

  def correct_indent(); end

  def correct_indent=(correct_indent); end

  def default_window_size(); end

  def default_window_size=(default_window_size); end

  def disable_auto_reload(); end

  def disable_auto_reload=(disable_auto_reload); end

  def editor(); end

  def editor=(editor); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def exception_whitelist(); end

  def exception_whitelist=(exception_whitelist); end

  def exec_string(); end

  def exec_string=(exec_string); end

  def extra_sticky_locals(); end

  def extra_sticky_locals=(extra_sticky_locals); end

  def file_completions(); end

  def file_completions=(file_completions); end

  def history(); end

  def history=(history); end

  def history_file(); end

  def history_file=(history_file); end

  def history_ignorelist(); end

  def history_ignorelist=(history_ignorelist); end

  def history_load(); end

  def history_load=(history_load); end

  def history_save(); end

  def history_save=(history_save); end

  def hooks(); end

  def hooks=(hooks); end

  def input(); end

  def input=(input); end

  def ls(); end

  def ls=(ls); end

  def memory_size(); end

  def memory_size=(memory_size); end

  def merge(config_hash); end

  def merge!(config_hash); end

  def method_missing(method_name, *args, &_block); end

  def output(); end

  def output=(output); end

  def output_prefix(); end

  def output_prefix=(output_prefix); end

  def pager(); end

  def pager=(pager); end

  def print(); end

  def print=(print); end

  def prompt(); end

  def prompt=(prompt); end

  def prompt_name(); end

  def prompt_name=(prompt_name); end

  def prompt_safe_contexts(); end

  def prompt_safe_contexts=(prompt_safe_contexts); end

  def quiet(); end

  def quiet=(quiet); end

  def rc_file(); end

  def rc_file=(rc_file); end

  def requires(); end

  def requires=(requires); end

  def should_load_local_rc(); end

  def should_load_local_rc=(should_load_local_rc); end

  def should_load_plugins(); end

  def should_load_plugins=(should_load_plugins); end

  def should_load_rc(); end

  def should_load_rc=(should_load_rc); end

  def should_load_requires(); end

  def should_load_requires=(should_load_requires); end

  def should_trap_interrupts(); end

  def should_trap_interrupts=(should_trap_interrupts); end

  def system(); end

  def system=(system); end

  def unrescued_exceptions(); end

  def unrescued_exceptions=(unrescued_exceptions); end

  def windows_console_warning(); end

  def windows_console_warning=(windows_console_warning); end
end

module Pry::Config::Attributable
  def attribute(attr_name); end
end

module Pry::Config::Attributable
end

class Pry::Config::LazyValue
  def call(); end

  def initialize(&block); end
end

class Pry::Config::LazyValue
end

class Pry::Config::MemoizedValue
  def call(); end

  def initialize(&block); end
end

class Pry::Config::MemoizedValue
end

class Pry::Config::Value
  def call(); end

  def initialize(value); end
end

class Pry::Config::Value
end

class Pry::Config
  extend ::Pry::Config::Attributable
end

module Pry::ControlDHandler
end

module Pry::ControlDHandler
  def self.default(pry_instance); end
end

class Pry::Editor
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def build_editor_invocation_string(file, line, blocking); end

  def edit_tempfile_with_content(initial_content, line=T.unsafe(nil)); end

  def initialize(pry_instance); end

  def invoke_editor(file, line, blocking=T.unsafe(nil)); end

  def pry_instance(); end
end

class Pry::Editor
  def self.default(); end
end

module Pry::Env
end

module Pry::Env
  def self.[](key); end
end

module Pry::ExceptionHandler
end

module Pry::ExceptionHandler
  def self.handle_exception(output, exception, _pry_instance); end
end

module Pry::Forwardable
  include ::Forwardable
  def def_private_delegators(target, *private_delegates); end
end

module Pry::Forwardable
end

module Pry::FrozenObjectException
end

module Pry::FrozenObjectException
  def self.===(exception); end
end

module Pry::Helpers
end

module Pry::Helpers::BaseHelpers
  def colorize_code(code); end

  def find_command(name, set=T.unsafe(nil)); end

  def heading(text); end

  def highlight(string, regexp, highlight_color=T.unsafe(nil)); end

  def not_a_real_file?(file); end

  def safe_send(obj, method, *args, &block); end

  def silence_warnings(); end

  def stagger_output(text, _out=T.unsafe(nil)); end

  def use_ansi_codes?(); end
end

module Pry::Helpers::BaseHelpers
  extend ::Pry::Helpers::BaseHelpers
end

module Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def absolute_index_number(line_number, array_length); end

  def absolute_index_range(range_or_number, array_length); end

  def get_method_or_raise(method_name, context, opts=T.unsafe(nil)); end

  def internal_binding?(context); end

  def one_index_number(line_number); end

  def one_index_range(range); end

  def one_index_range_or_number(range_or_number); end

  def restrict_to_lines(content, lines); end

  def set_file_and_dir_locals(file_name, pry=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def temp_file(ext=T.unsafe(nil)); end

  def unindent(dirty_text, left_padding=T.unsafe(nil)); end
end

module Pry::Helpers::CommandHelpers
  extend ::Pry::Helpers::CommandHelpers
  extend ::Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  def self.get_comment_content(comment); end

  def self.process_comment_markup(comment); end

  def self.process_rdoc(comment); end

  def self.process_yardoc(comment); end

  def self.process_yardoc_tag(comment, tag); end

  def self.strip_comments_from_c_code(code); end

  def self.strip_leading_whitespace(text); end
end

module Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::OptionsHelpers
  def self.method_object(); end

  def self.method_options(opt); end
end

module Pry::Helpers::Platform
end

module Pry::Helpers::Platform
  def self.jruby?(); end

  def self.jruby_19?(); end

  def self.linux?(); end

  def self.mac_osx?(); end

  def self.mri?(); end

  def self.mri_19?(); end

  def self.mri_2?(); end

  def self.windows?(); end

  def self.windows_ansi?(); end
end

class Pry::Helpers::Table
  def ==(other); end

  def column_count(); end

  def column_count=(count); end

  def columns(); end

  def fits_on_line?(line_length); end

  def initialize(items, args, pry_instance=T.unsafe(nil)); end

  def items(); end

  def items=(items); end

  def rows_to_s(style=T.unsafe(nil)); end

  def to_a(); end
end

class Pry::Helpers::Table
end

module Pry::Helpers::Text
  def black(text); end

  def black_on_black(text); end

  def black_on_blue(text); end

  def black_on_cyan(text); end

  def black_on_green(text); end

  def black_on_magenta(text); end

  def black_on_purple(text); end

  def black_on_red(text); end

  def black_on_white(text); end

  def black_on_yellow(text); end

  def blue(text); end

  def blue_on_black(text); end

  def blue_on_blue(text); end

  def blue_on_cyan(text); end

  def blue_on_green(text); end

  def blue_on_magenta(text); end

  def blue_on_purple(text); end

  def blue_on_red(text); end

  def blue_on_white(text); end

  def blue_on_yellow(text); end

  def bold(text); end

  def bright_black(text); end

  def bright_black_on_black(text); end

  def bright_black_on_blue(text); end

  def bright_black_on_cyan(text); end

  def bright_black_on_green(text); end

  def bright_black_on_magenta(text); end

  def bright_black_on_purple(text); end

  def bright_black_on_red(text); end

  def bright_black_on_white(text); end

  def bright_black_on_yellow(text); end

  def bright_blue(text); end

  def bright_blue_on_black(text); end

  def bright_blue_on_blue(text); end

  def bright_blue_on_cyan(text); end

  def bright_blue_on_green(text); end

  def bright_blue_on_magenta(text); end

  def bright_blue_on_purple(text); end

  def bright_blue_on_red(text); end

  def bright_blue_on_white(text); end

  def bright_blue_on_yellow(text); end

  def bright_cyan(text); end

  def bright_cyan_on_black(text); end

  def bright_cyan_on_blue(text); end

  def bright_cyan_on_cyan(text); end

  def bright_cyan_on_green(text); end

  def bright_cyan_on_magenta(text); end

  def bright_cyan_on_purple(text); end

  def bright_cyan_on_red(text); end

  def bright_cyan_on_white(text); end

  def bright_cyan_on_yellow(text); end

  def bright_green(text); end

  def bright_green_on_black(text); end

  def bright_green_on_blue(text); end

  def bright_green_on_cyan(text); end

  def bright_green_on_green(text); end

  def bright_green_on_magenta(text); end

  def bright_green_on_purple(text); end

  def bright_green_on_red(text); end

  def bright_green_on_white(text); end

  def bright_green_on_yellow(text); end

  def bright_magenta(text); end

  def bright_magenta_on_black(text); end

  def bright_magenta_on_blue(text); end

  def bright_magenta_on_cyan(text); end

  def bright_magenta_on_green(text); end

  def bright_magenta_on_magenta(text); end

  def bright_magenta_on_purple(text); end

  def bright_magenta_on_red(text); end

  def bright_magenta_on_white(text); end

  def bright_magenta_on_yellow(text); end

  def bright_purple(text); end

  def bright_purple_on_black(text); end

  def bright_purple_on_blue(text); end

  def bright_purple_on_cyan(text); end

  def bright_purple_on_green(text); end

  def bright_purple_on_magenta(text); end

  def bright_purple_on_purple(text); end

  def bright_purple_on_red(text); end

  def bright_purple_on_white(text); end

  def bright_purple_on_yellow(text); end

  def bright_red(text); end

  def bright_red_on_black(text); end

  def bright_red_on_blue(text); end

  def bright_red_on_cyan(text); end

  def bright_red_on_green(text); end

  def bright_red_on_magenta(text); end

  def bright_red_on_purple(text); end

  def bright_red_on_red(text); end

  def bright_red_on_white(text); end

  def bright_red_on_yellow(text); end

  def bright_white(text); end

  def bright_white_on_black(text); end

  def bright_white_on_blue(text); end

  def bright_white_on_cyan(text); end

  def bright_white_on_green(text); end

  def bright_white_on_magenta(text); end

  def bright_white_on_purple(text); end

  def bright_white_on_red(text); end

  def bright_white_on_white(text); end

  def bright_white_on_yellow(text); end

  def bright_yellow(text); end

  def bright_yellow_on_black(text); end

  def bright_yellow_on_blue(text); end

  def bright_yellow_on_cyan(text); end

  def bright_yellow_on_green(text); end

  def bright_yellow_on_magenta(text); end

  def bright_yellow_on_purple(text); end

  def bright_yellow_on_red(text); end

  def bright_yellow_on_white(text); end

  def bright_yellow_on_yellow(text); end

  def cyan(text); end

  def cyan_on_black(text); end

  def cyan_on_blue(text); end

  def cyan_on_cyan(text); end

  def cyan_on_green(text); end

  def cyan_on_magenta(text); end

  def cyan_on_purple(text); end

  def cyan_on_red(text); end

  def cyan_on_white(text); end

  def cyan_on_yellow(text); end

  def default(text); end

  def green(text); end

  def green_on_black(text); end

  def green_on_blue(text); end

  def green_on_cyan(text); end

  def green_on_green(text); end

  def green_on_magenta(text); end

  def green_on_purple(text); end

  def green_on_red(text); end

  def green_on_white(text); end

  def green_on_yellow(text); end

  def indent(text, chars); end

  def magenta(text); end

  def magenta_on_black(text); end

  def magenta_on_blue(text); end

  def magenta_on_cyan(text); end

  def magenta_on_green(text); end

  def magenta_on_magenta(text); end

  def magenta_on_purple(text); end

  def magenta_on_red(text); end

  def magenta_on_white(text); end

  def magenta_on_yellow(text); end

  def no_color(); end

  def no_pager(); end

  def purple(text); end

  def purple_on_black(text); end

  def purple_on_blue(text); end

  def purple_on_cyan(text); end

  def purple_on_green(text); end

  def purple_on_magenta(text); end

  def purple_on_purple(text); end

  def purple_on_red(text); end

  def purple_on_white(text); end

  def purple_on_yellow(text); end

  def red(text); end

  def red_on_black(text); end

  def red_on_blue(text); end

  def red_on_cyan(text); end

  def red_on_green(text); end

  def red_on_magenta(text); end

  def red_on_purple(text); end

  def red_on_red(text); end

  def red_on_white(text); end

  def red_on_yellow(text); end

  def strip_color(text); end

  def white(text); end

  def white_on_black(text); end

  def white_on_blue(text); end

  def white_on_cyan(text); end

  def white_on_green(text); end

  def white_on_magenta(text); end

  def white_on_purple(text); end

  def white_on_red(text); end

  def white_on_white(text); end

  def white_on_yellow(text); end

  def with_line_numbers(text, offset, color=T.unsafe(nil)); end

  def yellow(text); end

  def yellow_on_black(text); end

  def yellow_on_blue(text); end

  def yellow_on_cyan(text); end

  def yellow_on_green(text); end

  def yellow_on_magenta(text); end

  def yellow_on_purple(text); end

  def yellow_on_red(text); end

  def yellow_on_white(text); end

  def yellow_on_yellow(text); end
  COLORS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  extend ::Pry::Helpers::Text
end

module Pry::Helpers
  def self.tablify(things, line_length, pry_instance=T.unsafe(nil)); end

  def self.tablify_or_one_line(heading, things, pry_instance=T.unsafe(nil)); end

  def self.tablify_to_screen_width(things, options, pry_instance=T.unsafe(nil)); end
end

class Pry::History
  def <<(line); end

  def clear(); end

  def filter(history); end

  def history_line_count(); end

  def initialize(options=T.unsafe(nil)); end

  def load(); end

  def loader(); end

  def loader=(loader); end

  def original_lines(); end

  def push(line); end

  def saver(); end

  def saver=(saver); end

  def session_line_count(); end

  def to_a(); end
end

class Pry::History
  def self.default_file(); end
end

class Pry::Hooks
  def add_hook(event_name, hook_name, callable=T.unsafe(nil), &block); end

  def clear_event_hooks(event_name); end

  def delete_hook(event_name, hook_name); end

  def errors(); end

  def exec_hook(event_name, *args, &block); end

  def get_hook(event_name, hook_name); end

  def get_hooks(event_name); end

  def hook_count(event_name); end

  def hook_exists?(event_name, hook_name); end

  def hooks(); end

  def merge(other); end

  def merge!(other); end
end

class Pry::Hooks
  def self.default(); end
end

class Pry::Indent
  include ::Pry::Helpers::BaseHelpers
  def correct_indentation(prompt, code, overhang=T.unsafe(nil)); end

  def current_prefix(); end

  def end_of_statement?(last_token, last_kind); end

  def in_string?(); end

  def indent(input); end

  def indent_level(); end

  def indentation_delta(tokens); end

  def initialize(pry_instance=T.unsafe(nil)); end

  def module_nesting(); end

  def open_delimiters(); end

  def open_delimiters_line(); end

  def reset(); end

  def stack(); end

  def tokenize(string); end

  def track_delimiter(token); end

  def track_module_nesting(token, kind); end

  def track_module_nesting_end(token, kind=T.unsafe(nil)); end
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent
  def self.indent(str); end

  def self.nesting_at(str, line_number); end
end

class Pry::InputCompleter
  def build_path(input); end

  def call(str, options=T.unsafe(nil)); end

  def ignored_modules(); end

  def initialize(input, pry=T.unsafe(nil)); end

  def select_message(path, receiver, message, candidates); end
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::InputCompleter
end

class Pry::InputLock
  def __with_ownership(); end

  def enter_interruptible_region(); end

  def interruptible_region(); end

  def leave_interruptible_region(); end

  def with_ownership(&block); end
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock
  def self.for(input); end

  def self.global_lock(); end

  def self.global_lock=(global_lock); end

  def self.input_locks(); end

  def self.input_locks=(input_locks); end
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
end

class Pry::LastException
  def bt_index(); end

  def bt_index=(bt_index); end

  def bt_source_location_for(index); end

  def file(); end

  def inc_bt_index(); end

  def initialize(exception); end

  def line(); end

  def method_missing(name, *args, &block); end

  def wrapped_exception(); end
end

class Pry::LastException
end

class Pry::Method
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def ==(other); end

  def alias?(); end

  def aliases(); end

  def bound_method?(); end

  def comment(); end

  def doc(); end

  def dynamically_defined?(); end

  def initialize(method, known_info=T.unsafe(nil)); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(method_name, *args, &block); end

  def name(); end

  def name_with_owner(); end

  def original_name(); end

  def owner(*args, &block); end

  def parameters(*args, &block); end

  def pry_method?(); end

  def receiver(*args, &block); end

  def redefine(source); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def signature(); end

  def singleton_method?(); end

  def source(); end

  def source?(); end

  def source_file(); end

  def source_line(); end

  def source_range(); end

  def source_type(); end

  def super(times=T.unsafe(nil)); end

  def unbound_method?(); end

  def undefined?(); end

  def visibility(); end

  def wrapped(); end

  def wrapped_owner(); end
end

class Pry::Method::Disowned
  def initialize(receiver, method_name); end

  def owner(); end

  def receiver(); end
end

class Pry::Method::Disowned
end

class Pry::Method::Patcher
  def initialize(method); end

  def method(); end

  def method=(method); end

  def patch_in_ram(source); end
end

class Pry::Method::Patcher
  def self.code_for(filename); end
end

class Pry::Method::WeirdMethodLocator
  def find_method(); end

  def initialize(method, target); end

  def lost_method?(); end

  def method(); end

  def method=(method); end

  def target(); end

  def target=(target); end
end

class Pry::Method::WeirdMethodLocator
  def self.normal_method?(method, binding); end

  def self.weird_method?(method, binding); end
end

class Pry::Method
  extend ::Pry::Helpers::BaseHelpers
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.all_from_class(klass, include_super=T.unsafe(nil)); end

  def self.all_from_obj(obj, include_super=T.unsafe(nil)); end

  def self.from_binding(binding); end

  def self.from_class(klass, name, target=T.unsafe(nil)); end

  def self.from_module(klass, name, target=T.unsafe(nil)); end

  def self.from_obj(obj, name, target=T.unsafe(nil)); end

  def self.from_str(name, target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.instance_method_definition?(name, definition_line); end

  def self.instance_resolution_order(klass); end

  def self.lookup_method_via_binding(obj, method_name, method_type, target=T.unsafe(nil)); end

  def self.method_definition?(name, definition_line); end

  def self.resolution_order(obj); end

  def self.singleton_class_of(obj); end

  def self.singleton_class_resolution_order(klass); end

  def self.singleton_method_definition?(name, definition_line); end
end

class Pry::MethodNotFound
end

class Pry::MethodNotFound
end

class Pry::NoCommandError
  def initialize(match, owner); end
end

class Pry::NoCommandError
end

class Pry::ObjectPath
  def initialize(path_string, current_stack); end

  def resolve(); end
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
end

class Pry::ObsoleteError
end

class Pry::ObsoleteError
end

class Pry::Output
  def <<(*objs); end

  def decolorize_maybe(str); end

  def height(); end

  def initialize(pry_instance); end

  def method_missing(method_name, *args, &block); end

  def print(*objs); end

  def pry_instance(); end

  def puts(*objs); end

  def size(); end

  def tty?(); end

  def width(); end

  def write(*objs); end
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::Output
end

class Pry::Pager
  def initialize(pry_instance); end

  def open(); end

  def page(text); end

  def pry_instance(); end
end

class Pry::Pager::NullPager
  def <<(str); end

  def close(); end

  def initialize(out); end

  def print(str); end

  def puts(str); end

  def write(str); end
end

class Pry::Pager::NullPager
end

class Pry::Pager::PageTracker
  def initialize(rows, cols); end

  def page?(); end

  def record(str); end

  def reset(); end
end

class Pry::Pager::PageTracker
end

class Pry::Pager::SimplePager
  def initialize(*_); end
end

class Pry::Pager::SimplePager
end

class Pry::Pager::StopPaging
end

class Pry::Pager::StopPaging
end

class Pry::Pager::SystemPager
  def initialize(*_); end
end

class Pry::Pager::SystemPager
  def self.available?(); end

  def self.default_pager(); end
end

class Pry::Pager
end

class Pry::PluginManager
  def load_plugins(); end

  def locate_plugins(); end

  def plugins(); end
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager::NoPlugin
  def initialize(name); end
end

class Pry::PluginManager::NoPlugin
end

class Pry::PluginManager::Plugin
  def activate!(); end

  def active(); end

  def active=(active); end

  def active?(); end

  def disable!(); end

  def enable!(); end

  def enabled(); end

  def enabled=(enabled); end

  def enabled?(); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def initialize(name, gem_name, spec, enabled); end

  def load_cli_options(); end

  def name(); end

  def name=(name); end

  def spec(); end

  def spec=(spec); end

  def supported?(); end
end

class Pry::PluginManager::Plugin
end

class Pry::PluginManager
end

class Pry::Prompt
  def [](key); end

  def description(); end

  def incomplete_proc(); end

  def initialize(name, description, prompt_procs); end

  def name(); end

  def prompt_procs(); end

  def wait_proc(); end
end

class Pry::Prompt
  def self.[](name); end

  def self.add(name, description=T.unsafe(nil), separators=T.unsafe(nil)); end

  def self.all(); end
end

class Pry::REPL
  def initialize(pry, options=T.unsafe(nil)); end

  def input(*args, &block); end

  def output(*args, &block); end

  def pry(); end

  def pry=(pry); end

  def start(); end
end

class Pry::REPL
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.start(options); end
end

class Pry::REPLFileLoader
  def define_additional_commands(); end

  def initialize(file_name); end

  def interactive_mode(pry_instance); end

  def load(); end

  def non_interactive_mode(pry_instance, content); end
end

class Pry::REPLFileLoader
end

module Pry::RescuableException
end

module Pry::RescuableException
  def self.===(exception); end
end

class Pry::Result
  def command?(); end

  def initialize(is_command, retval=T.unsafe(nil)); end

  def retval(); end

  def void_command?(); end
end

class Pry::Result
end

class Pry::Ring
  def <<(value); end

  def [](index); end

  def clear(); end

  def count(); end

  def initialize(max_size); end

  def max_size(); end

  def size(); end

  def to_a(); end
end

class Pry::Ring
end

class Pry::Slop
  include ::Enumerable
  def [](key); end

  def add_callback(label, &block); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def command(command, options=T.unsafe(nil), &block); end

  def config(); end

  def description(desc=T.unsafe(nil)); end

  def description=(desc); end

  def each(&block); end

  def fetch_command(command); end

  def fetch_option(key); end

  def get(key); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def missing(); end

  def on(*objects, &block); end

  def opt(*objects, &block); end

  def option(*objects, &block); end

  def options(); end

  def parse(items=T.unsafe(nil), &block); end

  def parse!(items=T.unsafe(nil), &block); end

  def present?(*keys); end

  def run(callable=T.unsafe(nil), &block); end

  def separator(text); end

  def strict?(); end

  def to_h(include_commands=T.unsafe(nil)); end

  def to_hash(include_commands=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Commands
  include ::Enumerable
  def [](key); end

  def arguments(); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def commands(); end

  def config(); end

  def default(config=T.unsafe(nil), &block); end

  def each(&block); end

  def get(key); end

  def global(config=T.unsafe(nil), &block); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def on(command, config=T.unsafe(nil), &block); end

  def parse(items=T.unsafe(nil)); end

  def parse!(items=T.unsafe(nil)); end

  def present?(key); end

  def to_hash(); end
end

class Pry::Slop::Commands
end

class Pry::Slop::Error
end

class Pry::Slop::Error
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::Option
  def accepts_optional_argument?(); end

  def argument?(); end

  def argument_in_value(); end

  def argument_in_value=(argument_in_value); end

  def as?(); end

  def autocreated?(); end

  def call(*objects); end

  def callback?(); end

  def config(); end

  def count(); end

  def count=(count); end

  def default?(); end

  def delimiter?(); end

  def description(); end

  def expects_argument?(); end

  def help(); end

  def initialize(slop, short, long, description, config=T.unsafe(nil), &block); end

  def key(); end

  def limit?(); end

  def long(); end

  def match?(); end

  def optional?(); end

  def optional_argument?(); end

  def required?(); end

  def short(); end

  def tail?(); end

  def types(); end

  def value(); end

  def value=(new_value); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
end

class Pry::Slop
  def self.optspec(string, config=T.unsafe(nil)); end

  def self.parse(items=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.parse!(items=T.unsafe(nil), config=T.unsafe(nil), &block); end
end

class Pry::SyntaxHighlighter
end

class Pry::SyntaxHighlighter
  def self.highlight(code, language=T.unsafe(nil)); end

  def self.keyword_token_color(); end

  def self.overwrite_coderay_comment_token!(); end

  def self.tokenize(code, language=T.unsafe(nil)); end
end

module Pry::SystemCommandHandler
end

module Pry::SystemCommandHandler
  def self.default(output, command, _pry_instance); end
end

module Pry::TooSafeException
end

module Pry::TooSafeException
  def self.===(exception); end
end

module Pry::UserError
end

module Pry::UserError
end

module Pry::Warning
end

module Pry::Warning
  def self.warn(message); end
end

class Pry::WrappedModule
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::CodeObject::Helpers
  def candidate(rank); end

  def candidates(); end

  def class?(); end

  def constants(inherit=T.unsafe(nil)); end

  def doc(); end

  def file(); end

  def initialize(mod); end

  def line(); end

  def method_missing(method_name, *args, &block); end

  def method_prefix(); end

  def module?(); end

  def nonblank_name(); end

  def number_of_candidates(); end

  def singleton_class?(); end

  def singleton_instance(); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def super(times=T.unsafe(nil)); end

  def wrapped(); end

  def yard_doc(); end

  def yard_docs?(); end

  def yard_file(); end

  def yard_line(); end
end

class Pry::WrappedModule::Candidate
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def class?(*args, &block); end

  def doc(); end

  def file(); end

  def initialize(wrapper, rank); end

  def line(); end

  def module?(*args, &block); end

  def nonblank_name(*args, &block); end

  def number_of_candidates(*args, &block); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def wrapped(*args, &block); end
end

class Pry::WrappedModule::Candidate
  extend ::Pry::Forwardable
  extend ::Forwardable
end

class Pry::WrappedModule
  def self.from_str(mod_name, target=T.unsafe(nil)); end
end

class Pry
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.Code(obj); end

  def self.Method(obj); end

  def self.WrappedModule(obj); end

  def self.auto_resize!(); end

  def self.binding_for(target); end

  def self.cli(); end

  def self.cli=(cli); end

  def self.color(*args, &block); end

  def self.color=(*args, &block); end

  def self.commands(*args, &block); end

  def self.commands=(*args, &block); end

  def self.config(); end

  def self.config=(config); end

  def self.configure(); end

  def self.critical_section(); end

  def self.current(); end

  def self.current_line(); end

  def self.current_line=(current_line); end

  def self.custom_completions(); end

  def self.custom_completions=(custom_completions); end

  def self.editor(*args, &block); end

  def self.editor=(*args, &block); end

  def self.eval_path(); end

  def self.eval_path=(eval_path); end

  def self.exception_handler(*args, &block); end

  def self.exception_handler=(*args, &block); end

  def self.extra_sticky_locals(*args, &block); end

  def self.extra_sticky_locals=(*args, &block); end

  def self.final_session_setup(); end

  def self.history(*args, &block); end

  def self.history=(*args, &block); end

  def self.hooks(*args, &block); end

  def self.hooks=(*args, &block); end

  def self.in_critical_section?(); end

  def self.init(); end

  def self.initial_session?(); end

  def self.initial_session_setup(); end

  def self.input(*args, &block); end

  def self.input=(*args, &block); end

  def self.last_internal_error(); end

  def self.last_internal_error=(last_internal_error); end

  def self.line_buffer(); end

  def self.line_buffer=(line_buffer); end

  def self.load_file_at_toplevel(file); end

  def self.load_file_through_repl(file_name); end

  def self.load_history(); end

  def self.load_plugins(*args, &block); end

  def self.load_rc_files(); end

  def self.load_requires(); end

  def self.load_traps(); end

  def self.load_win32console(); end

  def self.locate_plugins(*args, &block); end

  def self.main(); end

  def self.memory_size(*args, &block); end

  def self.memory_size=(*args, &block); end

  def self.output(*args, &block); end

  def self.output=(*args, &block); end

  def self.pager(*args, &block); end

  def self.pager=(*args, &block); end

  def self.plugins(*args, &block); end

  def self.print(*args, &block); end

  def self.print=(*args, &block); end

  def self.prompt(*args, &block); end

  def self.prompt=(*args, &block); end

  def self.quiet(); end

  def self.quiet=(quiet); end

  def self.rc_files_to_load(); end

  def self.real_path_to(file); end

  def self.reset_defaults(); end

  def self.run_command(command_string, options=T.unsafe(nil)); end

  def self.start(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.toplevel_binding(); end

  def self.toplevel_binding=(toplevel_binding); end

  def self.view_clip(obj, options=T.unsafe(nil)); end
end

module PryRails
  Commands = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PryRails::FindRoute
  def process(controller); end
end

class PryRails::FindRoute
end

class PryRails::ModelFormatter
  def format_active_record(model); end

  def format_association(type, other, options=T.unsafe(nil)); end

  def format_column(name, type); end

  def format_error(message); end

  def format_model_name(model); end

  def format_mongoid(model); end

  def kind_of_relation(relation); end
end

class PryRails::ModelFormatter
end

class PryRails::Prompt
end

class PryRails::Prompt
  def self.formatted_env(); end

  def self.project_name(); end
end

class PryRails::Railtie
end

class PryRails::Railtie
end

class PryRails::RecognizePath
  def process(path); end
end

class PryRails::RecognizePath
end

class PryRails::ShowMiddleware
  def print_middleware(middlewares); end
end

class PryRails::ShowMiddleware
end

class PryRails::ShowModel
end

class PryRails::ShowModel
end

class PryRails::ShowModels
  def colorize_matches(string); end

  def display_activerecord_models(); end

  def display_mongoid_models(); end

  def grep_regex(); end

  def print_unless_filtered(str); end
end

class PryRails::ShowModels
end

class PryRails::ShowRoutes
  def grep_routes(formatted); end

  def process_rails_3_0_and_3_1(all_routes); end

  def process_rails_3_2(all_routes); end

  def process_rails_4_and_5(all_routes); end

  def process_rails_6_and_higher(all_routes); end
end

class PryRails::ShowRoutes
end

module PryRails
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::Domain
  def domain(); end

  def domain?(); end

  def initialize(*args); end

  def name(); end

  def sld(); end

  def subdomain(); end

  def subdomain?(); end

  def tld(); end

  def to_a(); end

  def trd(); end
end

class PublicSuffix::Domain
  def self.name_to_labels(name); end
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::Error
end

class PublicSuffix::Error
end

class PublicSuffix::List
  def <<(rule); end

  def ==(other); end

  def add(rule); end

  def clear(); end

  def default_rule(); end

  def each(&block); end

  def empty?(); end

  def eql?(other); end

  def find(name, default: T.unsafe(nil), **options); end

  def rules(); end

  def size(); end
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  def self.default(**options); end

  def self.default=(value); end

  def self.parse(input, private_domains: T.unsafe(nil)); end
end

module PublicSuffix::Rule
end

class PublicSuffix::Rule::Base
  def ==(other); end

  def decompose(*_); end

  def eql?(other); end

  def initialize(value:, length: T.unsafe(nil), private: T.unsafe(nil)); end

  def length(); end

  def match?(name); end

  def parts(); end

  def private(); end

  def value(); end
end

class PublicSuffix::Rule::Base
  def self.build(content, private: T.unsafe(nil)); end
end

class PublicSuffix::Rule::Entry
  def length=(_); end

  def private(); end

  def private=(_); end

  def type(); end

  def type=(_); end
end

class PublicSuffix::Rule::Entry
  def self.[](*_); end

  def self.members(); end
end

class PublicSuffix::Rule::Exception
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Exception
end

class PublicSuffix::Rule::Normal
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Normal
end

class PublicSuffix::Rule::Wildcard
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Wildcard
end

module PublicSuffix::Rule
  def self.default(); end

  def self.factory(content, private: T.unsafe(nil)); end
end

module PublicSuffix
  def self.decompose(name, rule); end

  def self.domain(name, **options); end

  def self.normalize(name); end

  def self.parse(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end

  def self.valid?(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end
end

module Puma
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  IS_JRUBY = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  Plugins = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
  include ::Puma::Const
  def add_ssl_listener(host, port, ctx, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_tcp_listener(host, port, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_unix_listener(path, umask=T.unsafe(nil), mode=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def close(); end

  def close_listeners(); end

  def close_unix_paths(); end

  def connected_port(); end

  def env(sock); end

  def import_from_env(); end

  def inherit_ssl_listener(fd, ctx); end

  def inherit_tcp_listener(host, port, fd); end

  def inherit_unix_listener(path, fd); end

  def initialize(events); end

  def ios(); end

  def loopback_addresses(); end

  def parse(binds, logger); end

  def redirects_for_restart(); end
  RACK_VERSION = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
end

class Puma::Client
  include ::Puma::Const
  def body(); end

  def call(); end

  def close(); end

  def closed?(*args, &block); end

  def eagerly_finish(); end

  def env(); end

  def finish(); end

  def hijacked(); end

  def in_data_phase(); end

  def initialize(io, env=T.unsafe(nil)); end

  def io(); end

  def peerip(); end

  def peerip=(peerip); end

  def ready(); end

  def remote_addr_header(); end

  def remote_addr_header=(remote_addr_header); end

  def reset(fast_check=T.unsafe(nil)); end

  def set_timeout(val); end

  def tempfile(); end

  def timeout_at(); end

  def to_io(); end

  def try_to_finish(); end

  def write_error(status_code); end
  EmptyBody = ::T.let(nil, ::T.untyped)
end

class Puma::Client
  extend ::Forwardable
end

class Puma::Cluster
  def all_workers_booted?(); end

  def check_workers(force=T.unsafe(nil)); end

  def cull_workers(); end

  def halt(); end

  def next_worker_index(); end

  def phased_restart(); end

  def preload?(); end

  def reload_worker_directory(); end

  def restart(); end

  def run(); end

  def setup_signals(); end

  def spawn_workers(); end

  def start_phased_restart(); end

  def stats(); end

  def stop(); end

  def stop_blocked(); end

  def stop_workers(); end

  def wakeup!(); end

  def worker(index, master); end
end

class Puma::Cluster::Worker
  def boot!(); end

  def booted?(); end

  def hup(); end

  def index(); end

  def initialize(idx, pid, phase, options); end

  def kill(); end

  def last_checkin(); end

  def last_status(); end

  def phase(); end

  def pid(); end

  def ping!(status); end

  def ping_timeout?(which); end

  def signal(); end

  def started_at(); end

  def term(); end

  def term?(); end
end

class Puma::Cluster::Worker
end

class Puma::Cluster
end

module Puma::ConfigDefault
  DefaultRackup = ::T.let(nil, ::T.untyped)
  DefaultTCPHost = ::T.let(nil, ::T.untyped)
  DefaultTCPPort = ::T.let(nil, ::T.untyped)
  DefaultWorkerShutdownTimeout = ::T.let(nil, ::T.untyped)
  DefaultWorkerTimeout = ::T.let(nil, ::T.untyped)
end

module Puma::ConfigDefault
end

class Puma::Configuration
  include ::Puma::ConfigDefault
  def app(); end

  def app_configured?(); end

  def clamp(); end

  def config_files(); end

  def configure(); end

  def environment(); end

  def environment_str(); end

  def flatten(); end

  def flatten!(); end

  def initialize(user_options=T.unsafe(nil), default_options=T.unsafe(nil), &block); end

  def load(); end

  def load_plugin(name); end

  def options(); end

  def plugins(); end

  def puma_default_options(); end

  def rackup(); end

  def run_hooks(key, arg); end
end

class Puma::Configuration::ConfigMiddleware
  def call(env); end

  def initialize(config, app); end
end

class Puma::Configuration::ConfigMiddleware
end

class Puma::Configuration
  def self.random_token(); end

  def self.temp_path(); end
end

class Puma::ConnectionError
end

class Puma::ConnectionError
end

module Puma::Const
  CGI_VER = ::T.let(nil, ::T.untyped)
  CHUNKED = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  CLOSE_CHUNKED = ::T.let(nil, ::T.untyped)
  CODE_NAME = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONNECTION_CLOSE = ::T.let(nil, ::T.untyped)
  CONNECTION_KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH2 = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_S = ::T.let(nil, ::T.untyped)
  CONTINUE = ::T.let(nil, ::T.untyped)
  EARLY_HINTS = ::T.let(nil, ::T.untyped)
  ERROR_RESPONSE = ::T.let(nil, ::T.untyped)
  FAST_TRACK_KA_TIMEOUT = ::T.let(nil, ::T.untyped)
  FIRST_DATA_TIMEOUT = ::T.let(nil, ::T.untyped)
  GATEWAY_INTERFACE = ::T.let(nil, ::T.untyped)
  HALT_COMMAND = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HIJACK = ::T.let(nil, ::T.untyped)
  HIJACK_IO = ::T.let(nil, ::T.untyped)
  HIJACK_P = ::T.let(nil, ::T.untyped)
  HTTP = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTPS_KEY = ::T.let(nil, ::T.untyped)
  HTTP_10_200 = ::T.let(nil, ::T.untyped)
  HTTP_11 = ::T.let(nil, ::T.untyped)
  HTTP_11_100 = ::T.let(nil, ::T.untyped)
  HTTP_11_200 = ::T.let(nil, ::T.untyped)
  HTTP_CONNECTION = ::T.let(nil, ::T.untyped)
  HTTP_EXPECT = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_INJECTION_REGEX = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  LINE_END = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  LOCALHOST_ADDR = ::T.let(nil, ::T.untyped)
  LOCALHOST_IP = ::T.let(nil, ::T.untyped)
  MAX_BODY = ::T.let(nil, ::T.untyped)
  MAX_FAST_INLINE = ::T.let(nil, ::T.untyped)
  MAX_HEADER = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  PERSISTENT_TIMEOUT = ::T.let(nil, ::T.untyped)
  PORT_443 = ::T.let(nil, ::T.untyped)
  PORT_80 = ::T.let(nil, ::T.untyped)
  PUMA_CONFIG = ::T.let(nil, ::T.untyped)
  PUMA_PEERCERT = ::T.let(nil, ::T.untyped)
  PUMA_SERVER_STRING = ::T.let(nil, ::T.untyped)
  PUMA_SOCKET = ::T.let(nil, ::T.untyped)
  PUMA_TMP_BASE = ::T.let(nil, ::T.untyped)
  PUMA_VERSION = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_AFTER_REPLY = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  REMOTE_ADDR = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  REQUEST_URI = ::T.let(nil, ::T.untyped)
  RESTART_COMMAND = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SERVER_SOFTWARE = ::T.let(nil, ::T.untyped)
  STOP_COMMAND = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING2 = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING_CHUNKED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WORKER_CHECK_INTERVAL = ::T.let(nil, ::T.untyped)
  WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

module Puma::Const
end

class Puma::DSL
  include ::Puma::ConfigDefault
  def _load_from(path); end

  def _offer_plugins(); end

  def activate_control_app(url=T.unsafe(nil), opts=T.unsafe(nil)); end

  def after_worker_boot(&block); end

  def after_worker_fork(&block); end

  def app(obj=T.unsafe(nil), &block); end

  def before_fork(&block); end

  def bind(url); end

  def clean_thread_locals(which=T.unsafe(nil)); end

  def clear_binds!(); end

  def daemonize(which=T.unsafe(nil)); end

  def debug(); end

  def default_host(); end

  def directory(dir); end

  def drain_on_shutdown(which=T.unsafe(nil)); end

  def early_hints(answer=T.unsafe(nil)); end

  def environment(environment); end

  def extra_runtime_dependencies(answer=T.unsafe(nil)); end

  def first_data_timeout(seconds); end

  def force_shutdown_after(val=T.unsafe(nil)); end

  def get(key, default=T.unsafe(nil)); end

  def initialize(options, config); end

  def inject(&blk); end

  def load(file); end

  def log_formatter(&block); end

  def log_requests(which=T.unsafe(nil)); end

  def lowlevel_error_handler(obj=T.unsafe(nil), &block); end

  def on_restart(&block); end

  def on_worker_boot(&block); end

  def on_worker_fork(&block); end

  def on_worker_shutdown(&block); end

  def out_of_band(&block); end

  def persistent_timeout(seconds); end

  def pidfile(path); end

  def plugin(name); end

  def port(port, host=T.unsafe(nil)); end

  def preload_app!(answer=T.unsafe(nil)); end

  def prune_bundler(answer=T.unsafe(nil)); end

  def queue_requests(answer=T.unsafe(nil)); end

  def quiet(which=T.unsafe(nil)); end

  def rackup(path); end

  def raise_exception_on_sigterm(answer=T.unsafe(nil)); end

  def restart_command(cmd); end

  def set_default_host(host); end

  def set_remote_address(val=T.unsafe(nil)); end

  def shutdown_debug(val=T.unsafe(nil)); end

  def ssl_bind(host, port, opts); end

  def state_path(path); end

  def stdout_redirect(stdout=T.unsafe(nil), stderr=T.unsafe(nil), append=T.unsafe(nil)); end

  def tag(string); end

  def tcp_mode(); end

  def tcp_mode!(); end

  def threads(min, max); end

  def worker_boot_timeout(timeout); end

  def worker_directory(dir); end

  def worker_shutdown_timeout(timeout); end

  def worker_timeout(timeout); end

  def workers(count); end
end

class Puma::DSL
end

class Puma::Events
  include ::Puma::Const
  def debug(str); end

  def error(str); end

  def fire(hook, *args); end

  def fire_on_booted!(); end

  def format(str); end

  def formatter(); end

  def formatter=(formatter); end

  def initialize(stdout, stderr); end

  def log(str); end

  def on_booted(&block); end

  def parse_error(server, env, error); end

  def register(hook, obj=T.unsafe(nil), &blk); end

  def ssl_error(server, peeraddr, peercert, error); end

  def stderr(); end

  def stdout(); end

  def unknown_error(server, error, kind=T.unsafe(nil), env=T.unsafe(nil)); end

  def write(str); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puma::Events::DefaultFormatter
  def call(str); end
end

class Puma::Events::DefaultFormatter
end

class Puma::Events::PidFormatter
  def call(str); end
end

class Puma::Events::PidFormatter
end

class Puma::Events
  def self.null(); end

  def self.stdio(); end

  def self.strings(); end
end

class Puma::HttpParser
  def body(); end

  def error?(); end

  def execute(_, _1, _2); end

  def finish(); end

  def finished?(); end

  def nread(); end

  def reset(); end
end

class Puma::HttpParser
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

class Puma::IOBuffer
  def <<(_); end

  def append(*_); end

  def capacity(); end

  def reset(); end

  def to_str(); end

  def used(); end
end

class Puma::IOBuffer
end

class Puma::Launcher
  def binder(); end

  def close_binder_listeners(); end

  def config(); end

  def connected_port(); end

  def delete_pidfile(); end

  def events(); end

  def halt(); end

  def initialize(conf, launcher_args=T.unsafe(nil)); end

  def options(); end

  def phased_restart(); end

  def restart(); end

  def restart_args(); end

  def restart_dir(); end

  def run(); end

  def stats(); end

  def stop(); end

  def write_state(); end
  KEYS_NOT_TO_PERSIST_IN_STATE = ::T.let(nil, ::T.untyped)
end

class Puma::Launcher
end

module Puma::MiniSSL
  OPENSSL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_SSL3 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1_1 = ::T.let(nil, ::T.untyped)
  OPENSSL_VERSION = ::T.let(nil, ::T.untyped)
  VERIFY_FAIL_IF_NO_PEER_CERT = ::T.let(nil, ::T.untyped)
  VERIFY_NONE = ::T.let(nil, ::T.untyped)
  VERIFY_PEER = ::T.let(nil, ::T.untyped)
end

class Puma::MiniSSL::Context
  def ca(); end

  def ca=(ca); end

  def cert(); end

  def cert=(cert); end

  def check(); end

  def key(); end

  def key=(key); end

  def no_tlsv1(); end

  def no_tlsv1=(tlsv1); end

  def no_tlsv1_1(); end

  def no_tlsv1_1=(tlsv1_1); end

  def ssl_cipher_filter(); end

  def ssl_cipher_filter=(ssl_cipher_filter); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end
end

class Puma::MiniSSL::Context
end

class Puma::MiniSSL::ContextBuilder
  def context(); end

  def initialize(params, events); end
end

class Puma::MiniSSL::ContextBuilder
end

class Puma::MiniSSL::Engine
  def extract(); end

  def init?(); end

  def inject(_); end

  def peercert(); end

  def read(); end

  def shutdown(); end

  def write(_); end
end

class Puma::MiniSSL::Engine
  def self.client(); end

  def self.server(_); end
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::Server
  def accept(); end

  def accept_nonblock(); end

  def close(); end

  def initialize(socket, ctx); end

  def to_io(); end
end

class Puma::MiniSSL::Server
end

class Puma::MiniSSL::Socket
  def <<(data); end

  def close(); end

  def closed?(); end

  def engine_read_all(); end

  def flush(); end

  def initialize(socket, engine); end

  def peeraddr(); end

  def peercert(); end

  def read_and_drop(timeout=T.unsafe(nil)); end

  def read_nonblock(size, *_); end

  def readpartial(size); end

  def should_drop_bytes?(); end

  def syswrite(data); end

  def to_io(); end

  def write(data); end

  def write_nonblock(data, *_); end
end

class Puma::MiniSSL::Socket
end

module Puma::MiniSSL
  def self.check(); end
end

class Puma::NullIO
  def close(); end

  def each(&blk); end

  def eof?(); end

  def gets(); end

  def puts(*ary); end

  def read(count=T.unsafe(nil), _buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def sync=(v); end

  def write(*ary); end
end

class Puma::NullIO
end

class Puma::Plugin
  def in_background(&blk); end

  def initialize(loader); end

  def workers_supported?(); end
  CALLER_FILE = ::T.let(nil, ::T.untyped)
end

class Puma::Plugin
  def self.create(&blk); end

  def self.extract_name(ary); end
end

class Puma::PluginLoader
  def create(name); end

  def fire_starts(launcher); end
end

class Puma::PluginLoader
end

class Puma::PluginRegistry
  def add_background(blk); end

  def find(name); end

  def fire_background(); end

  def register(name, cls); end
end

class Puma::PluginRegistry
end

module Puma::Rack
end

class Puma::Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Puma::Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Puma::Rack::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Puma::Rack::Options
end

module Puma::Rack
end

class Puma::Reactor
  def add(c); end

  def calculate_sleep(); end

  def clear!(); end

  def initialize(server, app_pool); end

  def run(); end

  def run_in_thread(); end

  def shutdown(); end
  DefaultSleepFor = ::T.let(nil, ::T.untyped)
end

class Puma::Reactor
end

class Puma::Runner
  def app(); end

  def before_restart(); end

  def daemon?(); end

  def debug(str); end

  def development?(); end

  def error(str); end

  def initialize(cli, events); end

  def load_and_bind(); end

  def log(str); end

  def output_header(mode); end

  def redirect_io(); end

  def redirected_io?(); end

  def ruby_engine(); end

  def start_control(); end

  def start_server(); end

  def test?(); end
end

class Puma::Runner
end

class Puma::Server
  include ::Puma::Const
  def add_ssl_listener(*args, &block); end

  def add_tcp_listener(*args, &block); end

  def add_unix_listener(*args, &block); end

  def app(); end

  def app=(app); end

  def auto_trim_time(); end

  def auto_trim_time=(auto_trim_time); end

  def backlog(); end

  def begin_restart(); end

  def binder(); end

  def binder=(binder); end

  def closed_socket?(socket); end

  def connected_port(*args, &block); end

  def cork_socket(socket); end

  def default_server_port(env); end

  def early_hints(); end

  def early_hints=(early_hints); end

  def events(); end

  def first_data_timeout(); end

  def first_data_timeout=(first_data_timeout); end

  def graceful_shutdown(); end

  def halt(sync=T.unsafe(nil)); end

  def handle_check(); end

  def handle_request(req, lines); end

  def handle_servers(); end

  def handle_servers_lopez_mode(); end

  def inherit_binder(bind); end

  def initialize(app, events=T.unsafe(nil), options=T.unsafe(nil)); end

  def leak_stack_on_error(); end

  def leak_stack_on_error=(leak_stack_on_error); end

  def lowlevel_error(e, env); end

  def max_threads(); end

  def max_threads=(max_threads); end

  def min_threads(); end

  def min_threads=(min_threads); end

  def normalize_env(env, client); end

  def persistent_timeout(); end

  def persistent_timeout=(persistent_timeout); end

  def pool_capacity(); end

  def process_client(client, buffer); end

  def read_body(env, client, body, cl); end

  def reaping_time(); end

  def reaping_time=(reaping_time); end

  def run(background=T.unsafe(nil)); end

  def run_lopez_mode(background=T.unsafe(nil)); end

  def running(); end

  def shutting_down?(); end

  def stop(sync=T.unsafe(nil)); end

  def tcp_mode!(); end

  def thread(); end

  def uncork_socket(socket); end
  ThreadLocalKey = ::T.let(nil, ::T.untyped)
end

class Puma::Server
  extend ::Forwardable
  def self.current(); end
end

class Puma::Single
  def halt(); end

  def jruby_daemon?(); end

  def jruby_daemon_start(); end

  def restart(); end

  def run(); end

  def stats(); end

  def stop(); end

  def stop_blocked(); end
end

class Puma::Single
end

class Puma::ThreadPool
  def <<(work); end

  def auto_reap!(timeout=T.unsafe(nil)); end

  def auto_trim!(timeout=T.unsafe(nil)); end

  def backlog(); end

  def clean_thread_locals(); end

  def clean_thread_locals=(clean_thread_locals); end

  def initialize(min, max, *extra, &block); end

  def pool_capacity(); end

  def reap(); end

  def shutdown(timeout=T.unsafe(nil)); end

  def spawned(); end

  def trim(force=T.unsafe(nil)); end

  def trim_requested(); end

  def wait_until_not_full(); end

  def waiting(); end
  SHUTDOWN_GRACE_TIME = ::T.let(nil, ::T.untyped)
end

class Puma::ThreadPool::Automaton
  def initialize(pool, timeout, thread_name, message); end

  def start!(); end

  def stop(); end
end

class Puma::ThreadPool::Automaton
end

class Puma::ThreadPool::ForceShutdown
end

class Puma::ThreadPool::ForceShutdown
end

class Puma::ThreadPool
  def self.clean_thread_locals(); end
end

class Puma::UnknownPlugin
end

class Puma::UnknownPlugin
end

class Puma::UnsupportedOption
end

class Puma::UnsupportedOption
end

class Puma::UserFileDefaultOptions
  def [](key); end

  def []=(key, value); end

  def all_of(key); end

  def default_options(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def file_options(); end

  def finalize_values(); end

  def initialize(user_options, default_options); end

  def user_options(); end
end

class Puma::UserFileDefaultOptions
end

module Puma::Util
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Puma::Util::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def replace(other); end
end

class Puma::Util::HeaderHash
  def self.new(hash=T.unsafe(nil)); end
end

module Puma::Util
  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.pipe(); end

  def self.unescape(s, encoding=T.unsafe(nil)); end
end

module Puma
  def self.jruby?(); end

  def self.set_thread_name(name); end

  def self.stats(); end

  def self.stats_object=(val); end

  def self.windows?(); end
end

class REXML::AttlistDecl
  def initialize(source); end
end

class REXML::Attribute
  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Attributes
  def initialize(element); end
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Child
  def initialize(parent=T.unsafe(nil)); end
end

class REXML::Comment
  def initialize(first, second=T.unsafe(nil)); end
end

class REXML::Declaration
  def initialize(src); end
end

class REXML::DocType
  def initialize(first, parent=T.unsafe(nil)); end
end

class REXML::Document
  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Element
  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Elements
  def initialize(parent); end
end

class REXML::Entity
  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end
end

class REXML::ExternalEntity
  def initialize(src); end
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end
end

class REXML::Formatters::Pretty
  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::Instruction
  def initialize(target, content=T.unsafe(nil)); end
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end
end

class REXML::Output
  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::ParseException
  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end
end

class REXML::Parsers::BaseParser
  def initialize(source); end
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::StreamParser
  def initialize(source, listener); end
end

class REXML::Parsers::TreeParser
  def initialize(source, build_context=T.unsafe(nil)); end
end

class REXML::Parsers::XPathParser
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::Source
  def initialize(arg, encoding=T.unsafe(nil)); end
end

class REXML::SyncEnumerator
  def initialize(*enums); end
end

class REXML::Text
  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::XMLDecl
  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end
end

class REXML::XPath
  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  def initialize(strict: T.unsafe(nil)); end
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  def self.first_non_rspec_line(skip_frames=T.unsafe(nil), increment=T.unsafe(nil)); end
end

module RSpec::Core
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::BacktraceFormatter
  def backtrace_line(line); end

  def exclude?(line); end

  def exclusion_patterns(); end

  def exclusion_patterns=(exclusion_patterns); end

  def filter_gem(gem_name); end

  def format_backtrace(backtrace, options=T.unsafe(nil)); end

  def full_backtrace=(full_backtrace); end

  def full_backtrace?(); end

  def inclusion_patterns(); end

  def inclusion_patterns=(inclusion_patterns); end
end

class RSpec::Core::BacktraceFormatter
end

module RSpec::Core::Bisect
end

class RSpec::Core::Bisect::BisectFailedError
end

class RSpec::Core::Bisect::BisectFailedError
  def self.for_failed_spec_run(spec_output); end
end

class RSpec::Core::Bisect::Channel
  def close(); end

  def receive(); end

  def send(message); end
end

class RSpec::Core::Bisect::Channel
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def all_example_ids(); end

  def all_example_ids=(_); end

  def failed_example_ids(); end

  def failed_example_ids=(_); end
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Bisect::Notifier
  def initialize(formatter); end

  def publish(event, *args); end
end

class RSpec::Core::Bisect::Notifier
end

module RSpec::Core::Bisect
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Hooks
  include ::RSpec::Core::Configuration::Readers
  def add_formatter(formatter, output=T.unsafe(nil)); end

  def add_setting(name, opts=T.unsafe(nil)); end

  def after(scope=T.unsafe(nil), *meta, &block); end

  def alias_example_group_to(new_name, *args); end

  def alias_example_to(name, *args); end

  def alias_it_behaves_like_to(new_name, report_label=T.unsafe(nil)); end

  def alias_it_should_behave_like_to(new_name, report_label=T.unsafe(nil)); end

  def append_after(scope=T.unsafe(nil), *meta, &block); end

  def append_before(scope=T.unsafe(nil), *meta, &block); end

  def apply_derived_metadata_to(metadata); end

  def around(scope=T.unsafe(nil), *meta, &block); end

  def backtrace_exclusion_patterns(); end

  def backtrace_exclusion_patterns=(patterns); end

  def backtrace_formatter(); end

  def backtrace_inclusion_patterns(); end

  def backtrace_inclusion_patterns=(patterns); end

  def before(scope=T.unsafe(nil), *meta, &block); end

  def bisect_runner(); end

  def bisect_runner=(value); end

  def bisect_runner_class(); end

  def color(); end

  def color=(color); end

  def color_enabled?(output=T.unsafe(nil)); end

  def color_mode(); end

  def color_mode=(color_mode); end

  def configure_example(example, example_hooks); end

  def configure_expectation_framework(); end

  def configure_group(group); end

  def configure_mock_framework(); end

  def default_color=(default_color); end

  def default_color?(); end

  def default_formatter(); end

  def default_formatter=(value); end

  def default_path=(path); end

  def default_path?(); end

  def define_derived_metadata(*filters, &block); end

  def deprecation_stream=(value); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def disable_monkey_patching(); end

  def disable_monkey_patching!(); end

  def disable_monkey_patching=(disable_monkey_patching); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def example_status_persistence_file_path=(value); end

  def exclude_pattern=(value); end

  def exclusion_filter(); end

  def exclusion_filter=(filter); end

  def expect_with(*frameworks); end

  def expectation_framework=(framework); end

  def expectation_frameworks(); end

  def expose_current_running_example_as(method_name); end

  def expose_dsl_globally=(value); end

  def expose_dsl_globally?(); end

  def extend(mod, *filters); end

  def fail_fast=(value); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def files_or_directories_to_run=(*files); end

  def files_to_run(); end

  def files_to_run=(files_to_run); end

  def filter(); end

  def filter=(filter); end

  def filter_gems_from_backtrace(*gem_names); end

  def filter_manager(); end

  def filter_manager=(filter_manager); end

  def filter_run(*args); end

  def filter_run_excluding(*args); end

  def filter_run_including(*args); end

  def filter_run_when_matching(*args); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def force(hash); end

  def format_docstrings(&block); end

  def format_docstrings_block(); end

  def formatter=(formatter, output=T.unsafe(nil)); end

  def formatter_loader(); end

  def formatters(); end

  def full_backtrace=(true_or_false); end

  def full_backtrace?(); end

  def full_description(); end

  def full_description=(description); end

  def in_project_source_dir_regex(); end

  def include(mod, *filters); end

  def include_context(shared_group_name, *filters); end

  def inclusion_filter(); end

  def inclusion_filter=(filter); end

  def last_run_statuses(); end

  def libs=(libs); end

  def load_spec_files(); end

  def loaded_spec_files(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def mock_framework(); end

  def mock_framework=(framework); end

  def mock_with(framework); end

  def on_example_group_definition(&block); end

  def on_example_group_definition_callbacks(); end

  def only_failures?(); end

  def only_failures_but_not_configured?(); end

  def order=(*args, &block); end

  def ordering_manager(); end

  def ordering_registry(*args, &block); end

  def output_stream=(value); end

  def pattern=(value); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def prepend(mod, *filters); end

  def prepend_after(scope=T.unsafe(nil), *meta, &block); end

  def prepend_before(scope=T.unsafe(nil), *meta, &block); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def raise_errors_for_deprecations!(); end

  def raise_on_warning=(value); end

  def register_ordering(*args, &block); end

  def reporter(); end

  def requires=(paths); end

  def reset(); end

  def reset_filters(); end

  def reset_reporter(); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def shared_context_metadata_behavior=(value); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def spec_files_with_failures(); end

  def start_time=(start_time); end

  def start_time?(); end

  def static_config_filter_manager(); end

  def static_config_filter_manager=(static_config_filter_manager); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def treat_symbols_as_metadata_keys_with_true_values=(_value); end

  def tty=(tty); end

  def tty?(); end

  def warnings=(value); end

  def warnings?(); end

  def when_first_matching_example_defined(*filters); end

  def with_suite_hooks(); end

  def world(); end

  def world=(world); end
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def deprecation(*args); end

  def play_onto(reporter); end
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

module RSpec::Core::Configuration::Readers
  def default_color(); end

  def default_path(); end

  def deprecation_stream(); end

  def detail_color(); end

  def drb(); end

  def drb_port(); end

  def dry_run(); end

  def error_stream(); end

  def example_status_persistence_file_path(); end

  def exclude_pattern(); end

  def fail_fast(); end

  def fail_if_no_examples(); end

  def failure_color(); end

  def failure_exit_code(); end

  def fixed_color(); end

  def libs(); end

  def max_displayed_failure_line_count(); end

  def only_failures(); end

  def output_stream(); end

  def pattern(); end

  def pending_color(); end

  def profile_examples(); end

  def project_source_dirs(); end

  def requires(); end

  def run_all_when_everything_filtered(); end

  def shared_context_metadata_behavior(); end

  def silence_filter_announcements(); end

  def start_time(); end

  def success_color(); end

  def threadsafe(); end

  def tty(); end
end

module RSpec::Core::Configuration::Readers
end

class RSpec::Core::Configuration
  def self.add_read_only_setting(name, opts=T.unsafe(nil)); end

  def self.add_setting(name, opts=T.unsafe(nil)); end

  def self.define_aliases(name, alias_name); end

  def self.define_predicate_for(*names); end

  def self.define_reader(name); end

  def self.delegate_to_ordering_manager(*methods); end
end

class RSpec::Core::ConfigurationOptions
  def args(); end

  def configure(config); end

  def configure_filter_manager(filter_manager); end

  def initialize(args); end

  def options(); end
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
end

module RSpec::Core::DSL
end

module RSpec::Core::DSL
  def self.change_global_dsl(&changes); end

  def self.example_group_aliases(); end

  def self.expose_example_group_alias(name); end

  def self.expose_example_group_alias_globally(method_name); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end

  def self.top_level(); end

  def self.top_level=(top_level); end
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DidYouMean
  def call(); end

  def initialize(relative_file_name); end

  def relative_file_name(); end
end

class RSpec::Core::DidYouMean
end

class RSpec::Core::Example
  def clock(); end

  def clock=(clock); end

  def description(); end

  def display_exception(); end

  def display_exception=(ex); end

  def duplicate_with(metadata_overrides=T.unsafe(nil)); end

  def example_group(); end

  def example_group_instance(); end

  def exception(); end

  def execution_result(); end

  def fail_with_exception(reporter, exception); end

  def file_path(); end

  def full_description(); end

  def id(); end

  def initialize(example_group_class, description, user_metadata, example_block=T.unsafe(nil)); end

  def inspect_output(); end

  def instance_exec(*args, &block); end

  def location(); end

  def location_rerun_argument(); end

  def metadata(); end

  def pending(); end

  def pending?(); end

  def reporter(); end

  def rerun_argument(); end

  def run(example_group_instance, reporter); end

  def set_aggregate_failures_exception(exception); end

  def set_exception(exception); end

  def skip(); end

  def skip_with_exception(reporter, exception); end

  def skipped?(); end

  def update_inherited_metadata(updates); end
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::Example::ExecutionResult
  include ::RSpec::Core::HashImitatable
  def ensure_timing_set(clock); end

  def example_skipped?(); end

  def exception(); end

  def exception=(exception); end

  def finished_at(); end

  def finished_at=(finished_at); end

  def pending_exception(); end

  def pending_exception=(pending_exception); end

  def pending_fixed(); end

  def pending_fixed=(pending_fixed); end

  def pending_fixed?(); end

  def pending_message(); end

  def pending_message=(pending_message); end

  def record_finished(status, finished_at); end

  def run_time(); end

  def run_time=(run_time); end

  def started_at(); end

  def started_at=(started_at); end

  def status(); end

  def status=(status); end
end

class RSpec::Core::Example::ExecutionResult
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

class RSpec::Core::Example::Procsy
  def <<(*a, &b); end

  def ===(*a, &b); end

  def >>(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def call(*args, &block); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def example(); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def executed?(); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def initialize(example, &block); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def run(*args, &block); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def to_proc(); end

  def update_inherited_metadata(*a, &b); end

  def wrap(&block); end

  def yield(*a, &b); end
end

class RSpec::Core::Example::Procsy
end

class RSpec::Core::Example
  def self.delegate_to_metadata(key); end

  def self.parse_id(id); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MemoizedHelpers
  include ::RSpec::Core::Pending
  def described_class(); end

  def initialize(inspect_output=T.unsafe(nil)); end
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup
  extend ::RSpec::Core::Hooks
  extend ::RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::RSpec::Core::SharedExampleGroup
  def self.add_example(example); end

  def self.before_context_ivars(); end

  def self.children(); end

  def self.context(*args, &example_group_block); end

  def self.currently_executing_a_context_hook?(); end

  def self.declaration_locations(); end

  def self.define_example_group_method(name, metadata=T.unsafe(nil)); end

  def self.define_example_method(name, extra_options=T.unsafe(nil)); end

  def self.define_nested_shared_group_method(new_name, report_label=T.unsafe(nil)); end

  def self.delegate_to_metadata(*names); end

  def self.descendant_filtered_examples(); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.description(); end

  def self.each_instance_variable_for_example(group); end

  def self.ensure_example_groups_are_configured(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.examples(); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.filtered_examples(); end

  def self.find_and_eval_shared(label, name, inclusion_location, *args, &customization_block); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.for_filtered_examples(reporter, &block); end

  def self.fspecify(*all_args, &block); end

  def self.id(); end

  def self.idempotently_define_singleton_method(name, &definition); end

  def self.include_context(name, *args, &block); end

  def self.include_examples(name, *args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.metadata(); end

  def self.next_runnable_index_for(file); end

  def self.ordering_strategy(); end

  def self.parent_groups(); end

  def self.pending(*all_args, &block); end

  def self.remove_example(example); end

  def self.reset_memoized(); end

  def self.run(reporter=T.unsafe(nil)); end

  def self.run_after_context_hooks(example_group_instance); end

  def self.run_before_context_hooks(example_group_instance); end

  def self.run_examples(reporter); end

  def self.set_it_up(description, args, registration_collection, &example_group_block); end

  def self.set_ivars(instance, ivars); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.store_before_context_ivars(example_group_instance); end

  def self.subclass(parent, description, args, registration_collection, &example_group_block); end

  def self.superclass_before_context_ivars(); end

  def self.superclass_metadata(); end

  def self.top_level?(); end

  def self.top_level_description(); end

  def self.traverse_tree_until(&block); end

  def self.update_inherited_metadata(updates); end

  def self.with_replaced_metadata(meta); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::ExampleStatusDumper
  def dump(); end

  def initialize(examples); end
end

class RSpec::Core::ExampleStatusDumper
  def self.dump(examples); end
end

class RSpec::Core::ExampleStatusMerger
  def initialize(this_run, from_previous_runs); end

  def merge(); end
end

class RSpec::Core::ExampleStatusMerger
  def self.merge(this_run, from_previous_runs); end
end

class RSpec::Core::ExampleStatusParser
  def initialize(string); end

  def parse(); end
end

class RSpec::Core::ExampleStatusParser
  def self.parse(string); end
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterManager
  def add_ids(rerun_path, scoped_ids); end

  def add_location(file_path, line_numbers); end

  def empty?(); end

  def exclude(*args); end

  def exclude_only(*args); end

  def exclude_with_low_priority(*args); end

  def exclusions(); end

  def include(*args); end

  def include_only(*args); end

  def include_with_low_priority(*args); end

  def inclusions(); end

  def prune(examples); end
end

class RSpec::Core::FilterManager
end

class RSpec::Core::FilterRules
  def [](key); end

  def add(updated); end

  def add_with_low_priority(updated); end

  def clear(); end

  def delete(key); end

  def description(); end

  def each_pair(&block); end

  def empty?(); end

  def fetch(*args, &block); end

  def include_example?(example); end

  def initialize(rules=T.unsafe(nil)); end

  def opposite(); end

  def opposite=(opposite); end

  def rules(); end

  def use_only(updated); end
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::FilterRules
  def self.build(); end
end

module RSpec::Core::FilterableItemRepository
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
  def items_for(metadata); end
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
  def append(item, metadata); end

  def delete(item, metadata); end

  def initialize(applies_predicate); end

  def items_and_filters(); end

  def items_for(request_meta); end

  def prepend(item, metadata); end
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
end

module RSpec::Core::FilterableItemRepository
end

module RSpec::Core::FlatMap
end

module RSpec::Core::FlatMap
  def self.flat_map(array, &block); end
end

module RSpec::Core::Formatters
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseFormatter
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  def self.config_colors_to_methods(); end

  def self.console_code_for(code_or_symbol); end

  def self.wrap(text, code_or_symbol); end
end

class RSpec::Core::Formatters::DeprecationFormatter
  def count(); end

  def deprecation(notification); end

  def deprecation_message_for(data); end

  def deprecation_stream(); end

  def deprecation_summary(_notification); end

  def initialize(deprecation_stream, summary_stream); end

  def output(); end

  def printer(); end

  def summary_stream(); end
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deferred_deprecation_warnings(); end

  def print_deprecation_message(data); end

  def stash_deprecation_message(deprecation_message); end

  def summary_stream(); end
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
  def initialize(file); end

  def puts(*args); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deprecation_message(data); end

  def summary_stream(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
  def puts(message); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end
end

class RSpec::Core::Formatters::DocumentationFormatter
end

class RSpec::Core::Formatters::ExceptionPresenter
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def example(); end

  def exception(); end

  def formatted_backtrace(exception=T.unsafe(nil)); end

  def formatted_cause(exception); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer); end

  def initialize(exception, example, options=T.unsafe(nil)); end

  def message_lines(); end
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
  def build(); end

  def initialize(example); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
  def initialize(parent); end

  def with_truncated_backtrace(child); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  def self.format_backtrace(*_); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
end

class RSpec::Core::Formatters::ExceptionPresenter
end

class RSpec::Core::Formatters::FailureListFormatter
  def dump_profile(_profile); end

  def example_failed(failure); end

  def message(_message); end
end

class RSpec::Core::Formatters::FailureListFormatter
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  def self.format_duration(duration); end

  def self.format_seconds(float, precision=T.unsafe(nil)); end

  def self.organize_ids(ids); end

  def self.pluralize(count, string); end
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlFormatter
end

class RSpec::Core::Formatters::HtmlPrinter
  include ::ERB::Util
  def flush(); end

  def initialize(output); end

  def make_example_group_header_red(group_id); end

  def make_example_group_header_yellow(group_id); end

  def make_header_red(); end

  def make_header_yellow(); end

  def move_progress(percent_done); end

  def print_example_failed(pending_fixed, description, run_time, failure_id, exception, extra_content); end

  def print_example_group_end(); end

  def print_example_group_start(group_id, description, number_of_parents); end

  def print_example_passed(description, run_time); end

  def print_example_pending(description, pending_message); end

  def print_html_start(); end

  def print_summary(duration, example_count, failure_count, pending_count); end
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlPrinter
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(notification); end
end

class RSpec::Core::Formatters::JsonFormatter
end

class RSpec::Core::Formatters::Loader
  def add(formatter_to_use, *paths); end

  def default_formatter(); end

  def default_formatter=(default_formatter); end

  def formatters(); end

  def initialize(reporter); end

  def prepare_default(output_stream, deprecation_stream); end

  def reporter(); end

  def setup_default(output_stream, deprecation_stream); end
end

class RSpec::Core::Formatters::Loader
  def self.formatters(); end
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProfileFormatter
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::ProgressFormatter
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def expression_lines(); end

  def initialize(source, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def max_line_count(); end

  def source(); end
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor
  def self.extract_expression_lines_at(file_path, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def self.extract_line_at(file_path, line_number); end

  def self.least_indentation_from(lines); end

  def self.source_from_file(path); end
end

class RSpec::Core::Formatters::SyntaxHighlighter
  def highlight(lines); end

  def initialize(configuration); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  def self.highlight_syntax(lines); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  def self.highlight_syntax(lines); end
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Formatters::SyntaxHighlighter
  def self.attempt_to_add_rspec_terms_to_coderay_keywords(); end
end

module RSpec::Core::Formatters
  def self.register(formatter_class, *notifications); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assert_valid_keys(*args, &block); end

  def assoc(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def deep_merge(*args, &block); end

  def deep_merge!(*args, &block); end

  def deep_stringify_keys(*args, &block); end

  def deep_stringify_keys!(*args, &block); end

  def deep_symbolize_keys(*args, &block); end

  def deep_symbolize_keys!(*args, &block); end

  def deep_transform_keys(*args, &block); end

  def deep_transform_keys!(*args, &block); end

  def deep_transform_values(*args, &block); end

  def deep_transform_values!(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def except(*args, &block); end

  def except!(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extractable_options?(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def nested_under_indifferent_access(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def pluck(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def reverse_merge(*args, &block); end

  def reverse_merge!(*args, &block); end

  def reverse_update(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def stringify_keys(*args, &block); end

  def stringify_keys!(*args, &block); end

  def sum(*args, &block); end

  def symbolize_keys(*args, &block); end

  def symbolize_keys!(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(*args, &block); end

  def to_h(); end

  def to_hash(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_options(*args, &block); end

  def to_options!(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def with_defaults(*args, &block); end

  def with_defaults!(*args, &block); end

  def with_indifferent_access(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::HashImitatable::ClassMethods
  def attr_accessor(*names); end

  def hash_attribute_names(); end
end

module RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::HashImitatable
  def self.included(klass); end
end

module RSpec::Core::Hooks
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def hooks(); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterContextHook
end

class RSpec::Core::Hooks::AfterHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook
end

class RSpec::Core::Hooks::AroundHook
  def execute_with(example, procsy); end

  def hook_description(); end
end

class RSpec::Core::Hooks::AroundHook
end

class RSpec::Core::Hooks::BeforeHook
  def run(example); end
end

class RSpec::Core::Hooks::BeforeHook
end

class RSpec::Core::Hooks::Hook
  def block(); end

  def block=(_); end

  def options(); end

  def options=(_); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Hooks::HookCollections
  def all_hooks_for(position, scope); end

  def initialize(owner, filterable_item_repo_class); end

  def matching_hooks_for(position, scope, example_or_group); end

  def processable_hooks_for(position, scope, host); end

  def register(prepend_or_append, position, *args, &block); end

  def register_global_singleton_context_hooks(example, globals); end

  def register_globals(host, globals); end

  def run(position, scope, example_or_group); end

  def run_owned_hooks_for(position, scope, example_or_group); end
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Hooks::HookCollections
end

module RSpec::Core::Hooks
end

class RSpec::Core::InclusionRules
  def add(*args); end

  def add_with_low_priority(*args); end

  def split_file_scoped_rules(); end

  def standalone?(); end
end

class RSpec::Core::InclusionRules
end

module RSpec::Core::Invocations
end

class RSpec::Core::Invocations::Bisect
  def call(options, err, out); end
end

class RSpec::Core::Invocations::Bisect
end

class RSpec::Core::Invocations::DRbWithFallback
  def call(options, err, out); end
end

class RSpec::Core::Invocations::DRbWithFallback
end

class RSpec::Core::Invocations::InitializeProject
  def call(*_args); end
end

class RSpec::Core::Invocations::InitializeProject
end

class RSpec::Core::Invocations::PrintHelp
  def call(_options, _err, out); end

  def hidden_options(); end

  def hidden_options=(_); end

  def parser(); end

  def parser=(_); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintVersion
  def call(_options, _err, out); end
end

class RSpec::Core::Invocations::PrintVersion
end

module RSpec::Core::Invocations
end

class RSpec::Core::LegacyExampleGroupHash
  include ::RSpec::Core::HashImitatable
  def initialize(metadata); end
end

class RSpec::Core::LegacyExampleGroupHash
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::MemoizedHelpers
  def initialize(*_); end

  def is_expected(); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def subject(); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  def let(name, &block); end

  def let!(name, &block); end

  def subject(name=T.unsafe(nil), &block); end

  def subject!(name=T.unsafe(nil), &block); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
  def self.fetch_or_store(key, &_block); end

  def self.isolate_for_context_hook(example_group_instance); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
end

module RSpec::Core::MemoizedHelpers
  def self.define_helpers_on(example_group); end

  def self.get_constant_or_yield(example_group, name); end

  def self.module_for(example_group); end
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Metadata::ExampleGroupHash
end

class RSpec::Core::Metadata::ExampleGroupHash
  def self.backwards_compatibility_default_proc(&example_group_selector); end

  def self.create(parent_group_metadata, user_metadata, example_group_index, *args, &block); end

  def self.hash_with_backwards_compatibility_default_proc(); end
end

class RSpec::Core::Metadata::ExampleHash
end

class RSpec::Core::Metadata::ExampleHash
  def self.create(group_metadata, user_metadata, index_provider, description, block); end
end

class RSpec::Core::Metadata::HashPopulator
  def block(); end

  def description_args(); end

  def initialize(metadata, user_metadata, index_provider, description_args, block); end

  def metadata(); end

  def populate(); end

  def user_metadata(); end
end

class RSpec::Core::Metadata::HashPopulator
end

module RSpec::Core::Metadata
  def self.ascend(metadata); end

  def self.ascending(metadata); end

  def self.build_hash_from(args, warn_about_example_group_filtering=T.unsafe(nil)); end

  def self.deep_hash_dup(object); end

  def self.id_from(metadata); end

  def self.location_tuple_from(metadata); end

  def self.relative_path(line); end

  def self.relative_path_regex(); end
end

module RSpec::Core::MetadataFilter
end

module RSpec::Core::MetadataFilter
  def self.apply?(predicate, filters, metadata); end

  def self.filter_applies?(key, filter_value, metadata); end

  def self.silence_metadata_example_group_deprecations(); end
end

module RSpec::Core::MockingAdapters
end

module RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  def setup_mocks_for_rspec(); end

  def teardown_mocks_for_rspec(); end

  def verify_mocks_for_rspec(); end
end

module RSpec::Core::MockingAdapters::RSpec
  def self.configuration(); end

  def self.framework_name(); end
end

module RSpec::Core::MockingAdapters
end

class RSpec::Core::MultipleExceptionError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(*exceptions); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def add(exception); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def self.for(ex); end
end

class RSpec::Core::MultipleExceptionError
end

module RSpec::Core::Notifications
end

class RSpec::Core::Notifications::CustomNotification
end

class RSpec::Core::Notifications::CustomNotification
  def self.for(options=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def call_site(); end

  def call_site=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def message(); end

  def message=(_); end

  def replacement(); end

  def replacement=(_); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*_); end

  def self.from_hash(data); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def example(); end

  def example=(_); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*_); end

  def self.for(example); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExamplesNotification
  def examples(); end

  def failed_examples(); end

  def failure_notifications(); end

  def fully_formatted_failed_examples(colorizer=T.unsafe(nil)); end

  def fully_formatted_pending_examples(colorizer=T.unsafe(nil)); end

  def initialize(reporter); end

  def notifications(); end

  def pending_examples(); end

  def pending_notifications(); end
end

class RSpec::Core::Notifications::ExamplesNotification
end

class RSpec::Core::Notifications::FailedExampleNotification
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def exception(); end

  def formatted_backtrace(); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer=T.unsafe(nil)); end

  def initialize(example, exception_presenter=T.unsafe(nil)); end

  def message_lines(); end
end

class RSpec::Core::Notifications::FailedExampleNotification
end

class RSpec::Core::Notifications::GroupNotification
  def group(); end

  def group=(_); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def message(); end

  def message=(_); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications::NullColorizer
end

module RSpec::Core::Notifications::NullColorizer
  def self.wrap(line, _code_or_symbol); end
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::ProfileNotification
  def duration(); end

  def examples(); end

  def initialize(duration, examples, number_of_examples, example_groups); end

  def number_of_examples(); end

  def percentage(); end

  def slow_duration(); end

  def slowest_examples(); end

  def slowest_groups(); end
end

class RSpec::Core::Notifications::ProfileNotification
end

class RSpec::Core::Notifications::SeedNotification
  def fully_formatted(); end

  def seed(); end

  def seed=(_); end

  def seed_used?(); end

  def used=(_); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
  def fully_formatted(pending_number, colorizer=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
end

class RSpec::Core::Notifications::StartNotification
  def count(); end

  def count=(_); end

  def load_time(); end

  def load_time=(_); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  include ::RSpec::Core::ShellEscape
  def colorized_rerun_commands(colorizer=T.unsafe(nil)); end

  def colorized_totals_line(colorizer=T.unsafe(nil)); end

  def duration(); end

  def duration=(_); end

  def errors_outside_of_examples_count(); end

  def errors_outside_of_examples_count=(_); end

  def example_count(); end

  def examples(); end

  def examples=(_); end

  def failed_examples(); end

  def failed_examples=(_); end

  def failure_count(); end

  def formatted_duration(); end

  def formatted_load_time(); end

  def fully_formatted(colorizer=T.unsafe(nil)); end

  def load_time(); end

  def load_time=(_); end

  def pending_count(); end

  def pending_examples(); end

  def pending_examples=(_); end

  def totals_line(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications
end

class RSpec::Core::NullReporter
end

class RSpec::Core::NullReporter
end

module RSpec::Core::Ordering
end

class RSpec::Core::Ordering::ConfigurationManager
  def force(hash); end

  def order=(type); end

  def ordering_registry(); end

  def register_ordering(name, strategy=T.unsafe(nil)); end

  def seed(); end

  def seed=(seed); end

  def seed_used?(); end
end

class RSpec::Core::Ordering::ConfigurationManager
end

class RSpec::Core::Ordering::Custom
  def initialize(callable); end

  def order(list); end
end

class RSpec::Core::Ordering::Custom
end

class RSpec::Core::Ordering::Identity
  def order(items); end
end

class RSpec::Core::Ordering::Identity
end

class RSpec::Core::Ordering::Random
  def initialize(configuration); end

  def order(items); end

  def used?(); end
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
end

class RSpec::Core::Ordering::Registry
  def fetch(name, &fallback); end

  def initialize(configuration); end

  def register(sym, strategy); end

  def used_random_seed?(); end
end

class RSpec::Core::Ordering::Registry
end

module RSpec::Core::Ordering
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def as_json(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def beep(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def bytes(*args, &block); end

  def chars(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def codepoints(*args, &block); end

  def cooked(*args, &block); end

  def cooked!(*args, &block); end

  def cursor(*args, &block); end

  def cursor=(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def echo=(*args, &block); end

  def echo?(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def getch(*args, &block); end

  def getpass(*args, &block); end

  def gets(*args, &block); end

  def goto(*args, &block); end

  def iflush(*args, &block); end

  def initialize(output); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def ioflush(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def lines(*args, &block); end

  def method_missing(name, *args, &block); end

  def noecho(*args, &block); end

  def nonblock(*args, &block); end

  def nonblock=(*args, &block); end

  def nonblock?(*args, &block); end

  def nread(*args, &block); end

  def oflush(*args, &block); end

  def output(); end

  def output=(output); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def pressed?(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def raw(*args, &block); end

  def raw!(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def respond_to?(name, priv=T.unsafe(nil)); end

  def rewind(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def winsize(*args, &block); end

  def winsize=(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

class RSpec::Core::OutputWrapper
end

class RSpec::Core::Parser
  def initialize(original_args); end

  def original_args(); end

  def parse(source=T.unsafe(nil)); end
end

class RSpec::Core::Parser
  def self.parse(args, source=T.unsafe(nil)); end
end

module RSpec::Core::Pending
  def pending(message=T.unsafe(nil)); end

  def skip(message=T.unsafe(nil)); end
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::SkipDeclaredInExample
  def argument(); end

  def initialize(argument); end
end

class RSpec::Core::Pending::SkipDeclaredInExample
end

module RSpec::Core::Pending
  def self.mark_fixed!(example); end

  def self.mark_pending!(example, message_or_bool); end

  def self.mark_skipped!(example, message_or_bool); end
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
end

class RSpec::Core::Reporter
  def abort_with(msg, exit_status); end

  def close_after(); end

  def deprecation(hash); end

  def example_failed(example); end

  def example_finished(example); end

  def example_group_finished(group); end

  def example_group_started(group); end

  def example_passed(example); end

  def example_pending(example); end

  def example_started(example); end

  def examples(); end

  def exit_early(exit_code); end

  def fail_fast_limit_met?(); end

  def failed_examples(); end

  def finish(); end

  def initialize(configuration); end

  def message(message); end

  def notify(event, notification); end

  def notify_non_example_exception(exception, context_description); end

  def pending_examples(); end

  def prepare_default(loader, output_stream, deprecation_stream); end

  def publish(event, options=T.unsafe(nil)); end

  def register_listener(listener, *notifications); end

  def registered_listeners(notification); end

  def report(expected_example_count); end

  def start(expected_example_count, time=T.unsafe(nil)); end

  def stop(); end
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
end

module RSpec::Core::RubyProject
end

module RSpec::Core::RubyProject
  def self.add_dir_to_load_path(dir); end

  def self.add_to_load_path(*dirs); end

  def self.ascend_until(); end

  def self.determine_root(); end

  def self.find_first_parent_containing(dir); end

  def self.root(); end
end

class RSpec::Core::Runner
  def configuration(); end

  def configure(err, out); end

  def initialize(options, configuration=T.unsafe(nil), world=T.unsafe(nil)); end

  def options(); end

  def run(err, out); end

  def run_specs(example_groups); end

  def setup(err, out); end

  def world(); end
end

class RSpec::Core::Runner
  def self.autorun(); end

  def self.autorun_disabled?(); end

  def self.disable_autorun!(); end

  def self.handle_interrupt(); end

  def self.installed_at_exit?(); end

  def self.invoke(); end

  def self.perform_at_exit(); end

  def self.run(args, err=T.unsafe(nil), out=T.unsafe(nil)); end

  def self.running_in_drb?(); end

  def self.trap_interrupt(); end
end

class RSpec::Core::Set
  include ::Enumerable
  def <<(key); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def include?(key); end

  def initialize(array=T.unsafe(nil)); end

  def merge(values); end
end

class RSpec::Core::Set
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::SharedExampleGroup
  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end
end

class RSpec::Core::SharedExampleGroup::Registry
  def add(context, name, *metadata_args, &block); end

  def find(lookup_contexts, name); end
end

class RSpec::Core::SharedExampleGroup::Registry
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  def self.definitions(); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end
end

module RSpec::Core::SharedExampleGroup
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def description(); end

  def formatted_inclusion_location(); end

  def inclusion_location(); end

  def initialize(shared_group_name, inclusion_location); end

  def shared_group_name(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def self.current_backtrace(); end

  def self.shared_example_group_inclusions(); end

  def self.with_frame(name, location); end
end

class RSpec::Core::SharedExampleGroupModule
  def definition(); end

  def include_in(klass, inclusion_line, args, customization_block); end

  def included(klass); end

  def initialize(description, definition, metadata); end
end

class RSpec::Core::SharedExampleGroupModule
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  def self.conditionally_quote(id); end

  def self.escape(shell_command); end

  def self.quote(argument); end

  def self.shell_allows_unquoted_ids?(); end
end

class RSpec::Core::SuiteHookContext
  def initialize(hook_description, reporter); end
end

class RSpec::Core::SuiteHookContext
end

class RSpec::Core::Time
end

class RSpec::Core::Time
  def self.now(); end
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
end

module RSpec::Core::Warnings
  def deprecate(deprecated, data=T.unsafe(nil)); end

  def warn_deprecation(message, opts=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end
end

module RSpec::Core::Warnings
end

class RSpec::Core::World
  def all_example_groups(); end

  def all_examples(); end

  def announce_exclusion_filter(announcements); end

  def announce_filters(); end

  def announce_inclusion_filter(announcements); end

  def everything_filtered_message(); end

  def example_count(groups=T.unsafe(nil)); end

  def example_group_counts_by_spec_file(); end

  def example_groups(); end

  def exclusion_filter(); end

  def filter_manager(); end

  def filtered_examples(); end

  def inclusion_filter(); end

  def initialize(configuration=T.unsafe(nil)); end

  def non_example_failure(); end

  def non_example_failure=(non_example_failure); end

  def num_example_groups_defined_in(file); end

  def ordered_example_groups(); end

  def preceding_declaration_line(absolute_file_name, filter_line); end

  def prepare_example_filtering(); end

  def record(example_group); end

  def registered_example_group_files(); end

  def report_filter_message(message); end

  def reporter(); end

  def reset(); end

  def shared_example_group_registry(); end

  def source_from_file(path); end

  def syntax_highlighter(); end

  def traverse_example_group_trees_until(&block); end

  def wants_to_quit(); end

  def wants_to_quit=(wants_to_quit); end
end

module RSpec::Core::World::Null
end

module RSpec::Core::World::Null
  def self.all_example_groups(); end

  def self.example_groups(); end

  def self.non_example_failure(); end

  def self.non_example_failure=(_); end

  def self.registered_example_group_files(); end

  def self.traverse_example_group_trees_until(); end
end

class RSpec::Core::World
end

module RSpec::Core
  def self.path_to_executable(); end
end

module RSpec::ExampleGroups
end

module RSpec::ExampleGroups
  extend ::RSpec::Support::RecursiveConstMethods
  def self.assign_const(group); end

  def self.base_name_for(group); end

  def self.constant_scope_for(group); end

  def self.disambiguate(name, const_scope); end

  def self.remove_all_constants(); end
end

module RSpec::Expectations
end

class RSpec::Expectations::BlockExpectationTarget
  def not_to(matcher, message=T.unsafe(nil), &block); end

  def to(matcher, message=T.unsafe(nil), &block); end

  def to_not(matcher, message=T.unsafe(nil), &block); end
end

class RSpec::Expectations::BlockExpectationTarget
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end

  def backtrace_formatter(); end

  def backtrace_formatter=(backtrace_formatter); end

  def color?(); end

  def false_positives_handler(); end

  def include_chain_clauses_in_custom_matcher_descriptions=(include_chain_clauses_in_custom_matcher_descriptions); end

  def include_chain_clauses_in_custom_matcher_descriptions?(); end

  def max_formatted_output_length=(length); end

  def on_potential_false_positives(); end

  def on_potential_false_positives=(behavior); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(values); end

  def warn_about_potential_false_positives=(boolean); end

  def warn_about_potential_false_positives?(); end
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  def self.format_backtrace(backtrace); end
end

class RSpec::Expectations::Configuration
end

module RSpec::Expectations::ExpectationHelper
end

module RSpec::Expectations::ExpectationHelper
  def self.check_message(msg); end

  def self.handle_failure(matcher, message, failure_message_method); end

  def self.modern_matcher_from(matcher); end

  def self.with_matcher(handler, matcher, message); end
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationTarget
  include ::RSpec::Expectations::ExpectationTarget::InstanceMethods
  def initialize(value); end

  def target(); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  def not_to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

class RSpec::Expectations::ExpectationTarget
  def self.for(value, block); end
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
end

class RSpec::Expectations::FailureAggregator
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::LegacyMatcherAdapter
  def initialize(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter
  def self.wrap(matcher); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
end

class RSpec::Expectations::NegativeExpectationHandler
end

class RSpec::Expectations::NegativeExpectationHandler
  def self.does_not_match?(matcher, actual, &block); end

  def self.handle_matcher(actual, initial_matcher, message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

class RSpec::Expectations::PositiveExpectationHandler
end

class RSpec::Expectations::PositiveExpectationHandler
  def self.handle_matcher(actual, initial_matcher, message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

module RSpec::Expectations::Syntax
end

module RSpec::Expectations::Syntax
  def self.default_should_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_about_should_unless_configured(method_name); end
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Version
end

module RSpec::Expectations
  def self.configuration(); end

  def self.differ(); end

  def self.fail_with(message, expected=T.unsafe(nil), actual=T.unsafe(nil)); end
end

module RSpec::Matchers
  def a_block_changing(*args, &block); end

  def a_block_outputting(*args, &block); end

  def a_block_raising(*args, &block); end

  def a_block_throwing(*args, &block); end

  def a_block_yielding_control(*args, &block); end

  def a_block_yielding_successive_args(*args, &block); end

  def a_block_yielding_with_args(*args, &block); end

  def a_block_yielding_with_no_args(*args, &block); end

  def a_collection_containing_exactly(*args, &block); end

  def a_collection_ending_with(*args, &block); end

  def a_collection_including(*args, &block); end

  def a_collection_starting_with(*args, &block); end

  def a_falsey_value(*args, &block); end

  def a_falsy_value(*args, &block); end

  def a_hash_including(*args, &block); end

  def a_kind_of(*args, &block); end

  def a_nil_value(*args, &block); end

  def a_range_covering(*args, &block); end

  def a_string_ending_with(*args, &block); end

  def a_string_including(*args, &block); end

  def a_string_matching(*args, &block); end

  def a_string_starting_with(*args, &block); end

  def a_truthy_value(*args, &block); end

  def a_value(*args, &block); end

  def a_value_between(*args, &block); end

  def a_value_within(*args, &block); end

  def aggregate_failures(label=T.unsafe(nil), metadata=T.unsafe(nil), &block); end

  def all(expected); end

  def an_instance_of(*args, &block); end

  def an_object_eq_to(*args, &block); end

  def an_object_eql_to(*args, &block); end

  def an_object_equal_to(*args, &block); end

  def an_object_existing(*args, &block); end

  def an_object_having_attributes(*args, &block); end

  def an_object_matching(*args, &block); end

  def an_object_responding_to(*args, &block); end

  def an_object_satisfying(*args, &block); end

  def be(*args); end

  def be_a(klass); end

  def be_a_kind_of(expected); end

  def be_an(klass); end

  def be_an_instance_of(expected); end

  def be_between(min, max); end

  def be_falsey(); end

  def be_falsy(*args, &block); end

  def be_instance_of(expected); end

  def be_kind_of(expected); end

  def be_nil(); end

  def be_truthy(); end

  def be_within(delta); end

  def change(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def changing(*args, &block); end

  def contain_exactly(*items); end

  def containing_exactly(*args, &block); end

  def cover(*values); end

  def covering(*args, &block); end

  def end_with(*expected); end

  def ending_with(*args, &block); end

  def eq(expected); end

  def eq_to(*args, &block); end

  def eql(expected); end

  def eql_to(*args, &block); end

  def equal(expected); end

  def equal_to(*args, &block); end

  def exist(*args); end

  def existing(*args, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def have_attributes(expected); end

  def having_attributes(*args, &block); end

  def include(*expected); end

  def including(*args, &block); end

  def match(expected); end

  def match_array(items); end

  def match_regex(*args, &block); end

  def matching(*args, &block); end

  def output(expected=T.unsafe(nil)); end

  def raise_error(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raise_exception(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raising(*args, &block); end

  def respond_to(*names); end

  def responding_to(*args, &block); end

  def satisfy(description=T.unsafe(nil), &block); end

  def satisfying(*args, &block); end

  def start_with(*expected); end

  def starting_with(*args, &block); end

  def throw_symbol(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def throwing(*args, &block); end

  def within(*args, &block); end

  def yield_control(); end

  def yield_successive_args(*args); end

  def yield_with_args(*args); end

  def yield_with_no_args(); end

  def yielding_control(*args, &block); end

  def yielding_successive_args(*args, &block); end

  def yielding_with_args(*args, &block); end

  def yielding_with_no_args(*args, &block); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::AliasedMatcher
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(base_matcher, description_block); end

  def method_missing(*_); end
end

class RSpec::Matchers::AliasedMatcher
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedNegatedMatcher
  def does_not_match?(*args, &block); end

  def matches?(*args, &block); end
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::AliasedNegatedMatcher
end

module RSpec::Matchers::BuiltIn
end

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::All
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def actual(); end

  def actual_formatted(); end

  def description(); end

  def diffable?(); end

  def expected(); end

  def expected_formatted(); end

  def expects_call_stack_jump?(); end

  def initialize(expected=T.unsafe(nil)); end

  def match_unless_raises(*exceptions); end

  def matcher_name(); end

  def matcher_name=(matcher_name); end

  def matches?(actual); end

  def present_ivars(); end

  def rescued_exception(); end

  def supports_block_expectations?(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def failure_message(); end

  def failure_message_when_negated(); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def self.has_default_failure_messages?(matcher); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  def self.improve_hash_formatting(inspect_string); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  def self.matcher_name(); end
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeBetween
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual, &block); end

  def initialize(*args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

module RSpec::Matchers::BuiltIn::CaptureStderr
end

module RSpec::Matchers::BuiltIn::CaptureStderr
  def self.capture(block); end
end

module RSpec::Matchers::BuiltIn::CaptureStdout
end

module RSpec::Matchers::BuiltIn::CaptureStdout
  def self.capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
  def capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::ChangeDetails
  def actual_after(); end

  def actual_delta(); end

  def changed?(); end

  def initialize(matcher_name, receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def perform_change(event_proc); end

  def value_representation(); end
end

class RSpec::Matchers::BuiltIn::ChangeDetails
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
  def does_not_match?(event_proc); end

  def initialize(change_details, expected_before); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
  def does_not_match?(_event_proc); end

  def initialize(change_details, expected_delta, relativity, &comparer); end

  def matches?(event_proc); end
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
end

class RSpec::Matchers::BuiltIn::ChangeToValue
  def does_not_match?(_event_proc); end

  def from(value); end

  def initialize(change_details, expected_after); end
end

class RSpec::Matchers::BuiltIn::ChangeToValue
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def self.matcher_expects_call_stack_jump?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *_); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
end

class RSpec::Matchers::BuiltIn::Compound
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::HaveAttributes
end

class RSpec::Matchers::BuiltIn::Include
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
end

module RSpec::Matchers::BuiltIn::NullCapture
end

module RSpec::Matchers::BuiltIn::NullCapture
  def self.capture(_block); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message=T.unsafe(nil), expected_message=T.unsafe(nil), &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def with_message(expected_message); end
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
  def captures(); end

  def initialize(match_data); end

  def match_data(); end

  def names(); end
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def ignoring_method_signature_failure!(); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::SpecificValuesChange
  def initialize(change_details, from, to); end

  def matches?(event_proc); end
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

class RSpec::Matchers::BuiltIn::SpecificValuesChange
end

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  def at_least(number); end

  def at_most(number); end

  def does_not_match?(block); end

  def exactly(number); end

  def initialize(); end

  def matches?(block); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def assert_used!(); end

  def assert_valid_expect_block!(); end

  def has_block?(); end

  def initialize(block, &callback); end

  def num_yields(); end

  def num_yields=(num_yields); end

  def probe(); end

  def single_yield_args(); end

  def to_proc(); end

  def yielded_args(); end

  def yielded_args=(yielded_args); end

  def yielded_once?(matcher_name); end
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def self.probe(block, &callback); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

module RSpec::Matchers::BuiltIn
end

module RSpec::Matchers::Composable
  def &(matcher); end

  def ===(value); end

  def and(matcher); end

  def or(matcher); end

  def |(matcher); end
end

module RSpec::Matchers::Composable
  def self.should_enumerate?(item); end

  def self.surface_descriptions_in(item); end

  def self.unreadable_io?(object); end
end

module RSpec::Matchers::DSL
  def alias_matcher(new_name, old_name, options=T.unsafe(nil), &description_override); end

  def define(name, &declarations); end

  def define_negated_matcher(negated_name, base_name, &description_override); end

  def matcher(name, &declarations); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def description(); end

  def diffable?(); end

  def expects_call_stack_jump?(); end

  def supports_block_expectations?(); end
end

module RSpec::Matchers::DSL::DefaultImplementations
end

module RSpec::Matchers::DSL::Macros
  def chain(method_name, *attr_names, &definition); end

  def description(&definition); end

  def diffable(); end

  def failure_message(&definition); end

  def failure_message_when_negated(&definition); end

  def match(options=T.unsafe(nil), &match_block); end

  def match_unless_raises(expected_exception=T.unsafe(nil), &match_block); end

  def match_when_negated(options=T.unsafe(nil), &match_block); end

  def supports_block_expectations(); end
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::DSL::Macros::Deprecated
  def failure_message_for_should(&definition); end

  def failure_message_for_should_not(&definition); end

  def match_for_should(&definition); end

  def match_for_should_not(&definition); end
end

module RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL::Macros
end

class RSpec::Matchers::DSL::Matcher
  include ::RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  include ::RSpec::Matchers
  include ::RSpec::Matchers::Composable
  def actual(); end

  def block_arg(); end

  def expected(); end

  def expected_as_array(); end

  def initialize(name, declarations, matcher_execution_context, *expected, &block_arg); end

  def name(); end

  def rescued_exception(); end
end

class RSpec::Matchers::DSL::Matcher
  extend ::RSpec::Matchers::DSL::Macros
  extend ::RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL
end

module RSpec::Matchers::EnglishPhrasing
end

module RSpec::Matchers::EnglishPhrasing
  def self.list(obj); end

  def self.split_words(sym); end
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def initialize(expected_list); end

  def message_with_diff(message, differ, actual); end
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def self.for_many_matchers(matchers); end

  def self.from(expected); end
end

class RSpec::Matchers::MatcherDelegator
  include ::RSpec::Matchers::Composable
  def base_matcher(); end

  def initialize(base_matcher); end

  def method_missing(*args, &block); end
end

class RSpec::Matchers::MatcherDelegator
end

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL
  def self.alias_matcher(*args, &block); end

  def self.clear_generated_description(); end

  def self.configuration(); end

  def self.generated_description(); end

  def self.is_a_describable_matcher?(obj); end

  def self.is_a_matcher?(obj); end

  def self.last_description(); end

  def self.last_expectation_handler(); end

  def self.last_expectation_handler=(last_expectation_handler); end

  def self.last_matcher(); end

  def self.last_matcher=(last_matcher); end
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AllowanceTarget
end

class RSpec::Mocks::AndReturnImplementation
  def call(*_args_to_ignore, &_block); end

  def initialize(values_to_return); end
end

class RSpec::Mocks::AndReturnImplementation
end

class RSpec::Mocks::AndWrapOriginalImplementation
  def call(*args, &block); end

  def initial_action=(_value); end

  def initialize(method, block); end

  def inner_action(); end

  def inner_action=(_value); end

  def terminal_action=(_value); end
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation
end

class RSpec::Mocks::AndYieldImplementation
  def call(*_args_to_ignore, &block); end

  def initialize(args_to_yield, eval_context, error_generator); end
end

class RSpec::Mocks::AndYieldImplementation
end

module RSpec::Mocks::AnyInstance
end

class RSpec::Mocks::AnyInstance::Chain
  include ::RSpec::Mocks::AnyInstance::Chain::Customizations
  def constrained_to_any_of?(*constraints); end

  def expectation_fulfilled!(); end

  def initialize(recorder, *args, &block); end

  def matches_args?(*args); end

  def never(); end

  def playback!(instance); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def self.record(method_name); end
end

class RSpec::Mocks::AnyInstance::Chain
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
end

class RSpec::Mocks::AnyInstance::ExpectationChain
  def expectation_fulfilled?(); end

  def initialize(*args, &block); end
end

class RSpec::Mocks::AnyInstance::ExpectationChain
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
end

class RSpec::Mocks::AnyInstance::MessageChains
  def [](method_name); end

  def add(method_name, chain); end

  def all_expectations_fulfilled?(); end

  def each_unfulfilled_expectation_matching(method_name, *args); end

  def has_expectation?(method_name); end

  def playback!(instance, method_name); end

  def received_expected_message!(method_name); end

  def remove_stub_chains_for!(method_name); end

  def unfulfilled_expectations(); end
end

class RSpec::Mocks::AnyInstance::MessageChains
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
end

class RSpec::Mocks::AnyInstance::Proxy
  def expect_chain(*chain, &block); end

  def initialize(recorder, target_proxies); end

  def klass(); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stub(method_name_or_method_map, &block); end

  def stub_chain(*chain, &block); end

  def unstub(method_name); end
end

class RSpec::Mocks::AnyInstance::Proxy
end

class RSpec::Mocks::AnyInstance::Recorder
  def already_observing?(method_name); end

  def build_alias_method_name(method_name); end

  def expect_chain(*method_names_and_optional_return_values, &block); end

  def initialize(klass); end

  def instance_that_received(method_name); end

  def klass(); end

  def message_chains(); end

  def notify_received_message(_object, message, args, _blk); end

  def playback!(instance, method_name); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stop_all_observation!(); end

  def stop_observing!(method_name); end

  def stub(method_name, &block); end

  def stub_chain(*method_names_and_optional_return_values, &block); end

  def stubs(); end

  def unstub(method_name); end

  def verify(); end
end

class RSpec::Mocks::AnyInstance::Recorder
end

class RSpec::Mocks::AnyInstance::StubChain
  def expectation_fulfilled?(); end
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
end

class RSpec::Mocks::AnyInstance::StubChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::StubChainChain
end

module RSpec::Mocks::AnyInstance
  def self.error_generator(); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::AnyInstanceExpectationTarget
end

class RSpec::Mocks::ArgumentListMatcher
  def args_match?(*args); end

  def expected_args(); end

  def initialize(*expected_args); end

  def resolve_expected_args_based_on(actual_args); end
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
end

module RSpec::Mocks::ArgumentMatchers
  def a_kind_of(klass); end

  def an_instance_of(klass); end

  def any_args(); end

  def anything(); end

  def array_including(*args); end

  def boolean(); end

  def duck_type(*args); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def hash_not_including(*args); end

  def instance_of(klass); end

  def kind_of(klass); end

  def no_args(); end
end

module RSpec::Mocks::ArgumentMatchers
  def self.anythingize_lonely_keys(*args); end
end

class RSpec::Mocks::CallbackInvocationStrategy
  def call(doubled_module); end
end

class RSpec::Mocks::CallbackInvocationStrategy
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::ClassNewMethodReference
end

class RSpec::Mocks::ClassNewMethodReference
  def self.applies_to?(method_name); end
end

class RSpec::Mocks::ClassVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ClassVerifyingDouble
end

class RSpec::Mocks::Configuration
  def add_stub_and_should_receive_to(*modules); end

  def allow_message_expectations_on_nil(); end

  def allow_message_expectations_on_nil=(allow_message_expectations_on_nil); end

  def before_verifying_doubles(&block); end

  def color?(); end

  def patch_marshal_to_support_partial_doubles=(val); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(*values); end

  def temporarily_suppress_partial_double_verification(); end

  def temporarily_suppress_partial_double_verification=(temporarily_suppress_partial_double_verification); end

  def transfer_nested_constants=(transfer_nested_constants); end

  def transfer_nested_constants?(); end

  def verify_doubled_constant_names=(verify_doubled_constant_names); end

  def verify_doubled_constant_names?(); end

  def verify_partial_doubles=(val); end

  def verify_partial_doubles?(); end

  def verifying_double_callbacks(); end

  def when_declaring_verifying_double(&block); end

  def yield_receiver_to_any_instance_implementation_blocks=(yield_receiver_to_any_instance_implementation_blocks); end

  def yield_receiver_to_any_instance_implementation_blocks?(); end
end

class RSpec::Mocks::Configuration
end

class RSpec::Mocks::Constant
  def hidden=(hidden); end

  def hidden?(); end

  def initialize(name); end

  def mutated?(); end

  def name(); end

  def original_value(); end

  def original_value=(original_value); end

  def previously_defined=(previously_defined); end

  def previously_defined?(); end

  def stubbed=(stubbed); end

  def stubbed?(); end

  def valid_name=(valid_name); end

  def valid_name?(); end
end

class RSpec::Mocks::Constant
  extend ::RSpec::Support::RecursiveConstMethods
  def self.original(name); end

  def self.unmutated(name); end
end

class RSpec::Mocks::ConstantMutator
end

class RSpec::Mocks::ConstantMutator::BaseMutator
  include ::RSpec::Support::RecursiveConstMethods
  def full_constant_name(); end

  def idempotently_reset(); end

  def initialize(full_constant_name, mutated_value, transfer_nested_constants); end

  def original_value(); end

  def to_constant(); end
end

class RSpec::Mocks::ConstantMutator::BaseMutator
end

class RSpec::Mocks::ConstantMutator::ConstantHider
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::ConstantHider
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
  def initialize(*args); end

  def mutate(); end

  def reset(); end

  def should_transfer_nested_constants?(); end

  def transfer_nested_constants(); end

  def verify_constants_to_transfer!(); end
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
end

class RSpec::Mocks::ConstantMutator
  extend ::RSpec::Support::RecursiveConstMethods
  def self.hide(constant_name); end

  def self.mutate(mutator); end

  def self.raise_on_invalid_const(); end

  def self.stub(constant_name, value, options=T.unsafe(nil)); end
end

class RSpec::Mocks::DirectObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(object); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::DirectObjectReference
end

class RSpec::Mocks::Double
  include ::RSpec::Mocks::TestDouble
end

class RSpec::Mocks::Double
end

class RSpec::Mocks::ErrorGenerator
  def default_error_message(expectation, expected_args, actual_args); end

  def describe_expectation(verb, message, expected_received_count, _actual_received_count, args); end

  def expectation_on_nil_message(method_name); end

  def initialize(target=T.unsafe(nil)); end

  def intro(unwrapped=T.unsafe(nil)); end

  def method_call_args_description(args, generic_prefix=T.unsafe(nil), matcher_prefix=T.unsafe(nil)); end

  def opts(); end

  def opts=(opts); end

  def raise_already_invoked_error(message, calling_customization); end

  def raise_cant_constrain_count_for_negated_have_received_error(count_constraint); end

  def raise_double_negation_error(wrapped_expression); end

  def raise_expectation_error(message, expected_received_count, argument_list_matcher, actual_received_count, expectation_count_type, args, backtrace_line=T.unsafe(nil), source_id=T.unsafe(nil)); end

  def raise_expectation_on_mocked_method(method); end

  def raise_expectation_on_nil_error(method_name); end

  def raise_expectation_on_unstubbed_method(method); end

  def raise_expired_test_double_error(); end

  def raise_have_received_disallowed(type, reason); end

  def raise_invalid_arguments_error(verifier); end

  def raise_method_not_stubbed_error(method_name); end

  def raise_missing_block_error(args_to_yield); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_non_public_error(method_name, visibility); end

  def raise_only_valid_on_a_partial_double(method); end

  def raise_out_of_order_error(message); end

  def raise_similar_message_args_error(expectation, args_for_multiple_calls, backtrace_line=T.unsafe(nil)); end

  def raise_unexpected_message_args_error(expectation, args_for_multiple_calls, source_id=T.unsafe(nil)); end

  def raise_unexpected_message_error(message, args); end

  def raise_unimplemented_error(doubled_module, method_name, object); end

  def raise_verifying_double_not_defined_error(ref); end

  def raise_wrong_arity_error(args_to_yield, signature); end
end

class RSpec::Mocks::ErrorGenerator
end

module RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  def allow(target); end

  def allow_any_instance_of(klass); end

  def allow_message_expectations_on_nil(); end

  def class_double(doubled_class, *args); end

  def class_spy(*args); end

  def double(*args); end

  def expect_any_instance_of(klass); end

  def have_received(method_name, &block); end

  def hide_const(constant_name); end

  def instance_double(doubled_class, *args); end

  def instance_spy(*args); end

  def object_double(object_or_name, *args); end

  def object_spy(*args); end

  def receive(method_name, &block); end

  def receive_message_chain(*messages, &block); end

  def receive_messages(message_return_value_hash); end

  def spy(*args); end

  def stub_const(constant_name, value, options=T.unsafe(nil)); end

  def without_partial_double_verification(); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
end

module RSpec::Mocks::ExampleMethods
  def self.declare_double(type, *args); end

  def self.declare_verifying_double(type, ref, *args); end

  def self.extended(object); end

  def self.included(klass); end
end

class RSpec::Mocks::ExpectChain
end

class RSpec::Mocks::ExpectChain
  def self.expect_chain_on(object, *chain, &blk); end
end

class RSpec::Mocks::ExpectationTarget
  include ::RSpec::Mocks::ExpectationTargetMethods
end

class RSpec::Mocks::ExpectationTarget
end

module RSpec::Mocks::ExpectationTargetMethods
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

module RSpec::Mocks::ExpectationTargetMethods
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::Implementation
  def call(*args, &block); end

  def initial_action(); end

  def initial_action=(initial_action); end

  def inner_action(); end

  def inner_action=(inner_action); end

  def terminal_action(); end

  def terminal_action=(terminal_action); end
end

class RSpec::Mocks::Implementation
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodStasher
  def handle_restoration_failures(); end

  def initialize(object, method); end

  def method_is_stashed?(); end

  def original_method(); end

  def restore(); end

  def stash(); end
end

class RSpec::Mocks::InstanceMethodStasher
end

class RSpec::Mocks::InstanceVerifyingDouble
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::InstanceVerifyingDouble
end

class RSpec::Mocks::MarshalExtension
end

class RSpec::Mocks::MarshalExtension
  def self.patch!(); end

  def self.unpatch!(); end
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::Matchers::ExpectationCustomization
  def block(); end

  def block=(block); end

  def initialize(method_name, args, block); end

  def playback_onto(expectation); end
end

class RSpec::Mocks::Matchers::ExpectationCustomization
end

class RSpec::Mocks::Matchers::HaveReceived
  include ::RSpec::Mocks::Matchers::Matcher
  def at_least(*args); end

  def at_most(*args); end

  def description(); end

  def does_not_match?(subject); end

  def exactly(*args); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method_name, &block); end

  def matches?(subject, &block); end

  def name(); end

  def once(*args); end

  def ordered(*args); end

  def setup_allowance(_subject, &_block); end

  def setup_any_instance_allowance(_subject, &_block); end

  def setup_any_instance_expectation(_subject, &_block); end

  def setup_any_instance_negative_expectation(_subject, &_block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args); end

  def time(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
end

module RSpec::Mocks::Matchers::Matcher
end

module RSpec::Mocks::Matchers::Matcher
end

class RSpec::Mocks::Matchers::Receive
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def description(); end

  def does_not_match?(subject, &block); end

  def exactly(*args, &block); end

  def initialize(message, block); end

  def matches?(subject, &block); end

  def name(); end

  def never(*args, &block); end

  def once(*args, &block); end

  def ordered(*args, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_any_instance_negative_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
  def description_for(verb); end

  def initialize(message); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
end

class RSpec::Mocks::Matchers::Receive
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def description(); end

  def does_not_match?(*_args); end

  def initialize(chain, &block); end

  def matches?(subject, &block); end

  def name(); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(*_args); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
end

class RSpec::Mocks::Matchers::ReceiveMessages
  include ::RSpec::Mocks::Matchers::Matcher
  def description(); end

  def does_not_match?(_subject); end

  def initialize(message_return_value_hash); end

  def matches?(subject); end

  def name(); end

  def setup_allowance(subject); end

  def setup_any_instance_allowance(subject); end

  def setup_any_instance_expectation(subject); end

  def setup_expectation(subject); end

  def setup_negative_expectation(_subject); end

  def warn_about_block(); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::MessageChain
  def block(); end

  def chain(); end

  def initialize(object, *chain, &blk); end

  def object(); end

  def setup_chain(); end
end

class RSpec::Mocks::MessageChain
end

class RSpec::Mocks::MessageExpectation
  include ::RSpec::Mocks::MessageExpectation::ImplementationDetails
  def and_call_original(); end

  def and_raise(*args); end

  def and_return(first_value, *values); end

  def and_throw(*args); end

  def and_wrap_original(&block); end

  def and_yield(*args, &block); end

  def at_least(n, &block); end

  def at_most(n, &block); end

  def exactly(n, &block); end

  def never(); end

  def once(&block); end

  def ordered(&block); end

  def thrice(&block); end

  def time(&block); end

  def times(&block); end

  def twice(&block); end

  def with(*args, &block); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
  def actual_received_count_matters?(); end

  def additional_expected_calls(); end

  def advise(*args); end

  def and_yield_receiver_to_implementation(); end

  def argument_list_matcher=(argument_list_matcher); end

  def called_max_times?(); end

  def description_for(verb); end

  def ensure_expected_ordering_received!(); end

  def error_generator(); end

  def error_generator=(error_generator); end

  def expectation_count_type(); end

  def expected_args(); end

  def expected_from=(expected_from); end

  def expected_messages_received?(); end

  def expected_received_count=(expected_received_count); end

  def generate_error(); end

  def ignoring_args?(); end

  def implementation(); end

  def implementation=(implementation); end

  def increase_actual_received_count!(); end

  def initialize(error_generator, expectation_ordering, expected_from, method_double, type=T.unsafe(nil), opts=T.unsafe(nil), &implementation_block); end

  def invoke(parent_stub, *args, &block); end

  def invoke_without_incrementing_received_count(parent_stub, *args, &block); end

  def matches?(message, *args); end

  def matches_at_least_count?(); end

  def matches_at_most_count?(); end

  def matches_exact_count?(); end

  def matches_name_but_not_args(message, *args); end

  def message(); end

  def negative?(); end

  def negative_expectation_for?(message); end

  def ordered?(); end

  def orig_object(); end

  def raise_out_of_order_error(); end

  def raise_unexpected_message_args_error(args_for_multiple_calls); end

  def safe_invoke(parent_stub, *args, &block); end

  def similar_messages(); end

  def type(); end

  def unadvise(args); end

  def verify_messages_received(); end

  def yield_receiver_to_implementation_block?(); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
end

class RSpec::Mocks::MessageExpectation
end

class RSpec::Mocks::MethodDouble
  def add_default_stub(*args, &implementation); end

  def add_expectation(error_generator, expectation_ordering, expected_from, opts, &implementation); end

  def add_simple_expectation(method_name, response, error_generator, backtrace_line); end

  def add_simple_stub(method_name, response); end

  def add_stub(error_generator, expectation_ordering, expected_from, opts=T.unsafe(nil), &implementation); end

  def build_expectation(error_generator, expectation_ordering); end

  def clear(); end

  def configure_method(); end

  def define_proxy_method(); end

  def expectations(); end

  def initialize(object, method_name, proxy); end

  def message_expectation_class(); end

  def method_name(); end

  def method_stasher(); end

  def object(); end

  def object_singleton_class(); end

  def original_implementation_callable(); end

  def original_method(); end

  def proxy_method_invoked(_obj, *args, &block); end

  def raise_method_not_stubbed_error(); end

  def remove_stub(); end

  def remove_stub_if_present(); end

  def reset(); end

  def restore_original_method(); end

  def restore_original_visibility(); end

  def save_original_implementation_callable!(); end

  def setup_simple_method_double(method_name, response, collection, error_generator=T.unsafe(nil), backtrace_line=T.unsafe(nil)); end

  def show_frozen_warning(); end

  def stubs(); end

  def verify(); end

  def visibility(); end
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble
end

class RSpec::Mocks::MethodReference
  def defined?(); end

  def implemented?(); end

  def initialize(object_reference, method_name); end

  def unimplemented?(); end

  def visibility(); end

  def with_signature(); end
end

class RSpec::Mocks::MethodReference
  def self.for(object_reference, method_name); end

  def self.instance_method_visibility_for(klass, method_name); end

  def self.method_defined_at_any_visibility?(klass, method_name); end

  def self.method_visibility_for(object, method_name); end
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::NamedObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(const_name); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::NamedObjectReference
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NestedSpace
  def initialize(parent); end
end

class RSpec::Mocks::NestedSpace
end

class RSpec::Mocks::NoCallbackInvocationStrategy
  def call(_doubled_module); end
end

class RSpec::Mocks::NoCallbackInvocationStrategy
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  def self.for(object_module_or_name, allow_direct_object_refs=T.unsafe(nil)); end
end

class RSpec::Mocks::ObjectVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ObjectVerifyingDouble
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
  def as_stubbed_const(options=T.unsafe(nil)); end
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
end

class RSpec::Mocks::OrderGroup
  def clear(); end

  def consume(); end

  def empty?(); end

  def handle_order_constraint(expectation); end

  def invoked(message); end

  def ready_for?(expectation); end

  def register(expectation); end

  def verify_invocation_order(expectation); end
end

class RSpec::Mocks::OrderGroup
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::PartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialClassDoubleProxy
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
  def initialize(source_space, *args); end

  def method_double_from_ancestor_for(message); end

  def original_method_handle_for(message); end

  def original_unbound_method_handle_from_ancestor_for(message); end

  def superclass_proxy(); end
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialDoubleProxy
  def original_method_handle_for(message); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::PartialDoubleProxy
end

class RSpec::Mocks::Proxy
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_expectation(method_name, response, location); end

  def add_simple_stub(method_name, response); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def build_expectation(method_name); end

  def check_for_unexpected_arguments(expectation); end

  def ensure_implemented(*_args); end

  def has_negative_expectation?(message); end

  def initialize(object, order_group, options=T.unsafe(nil)); end

  def message_received(message, *args, &block); end

  def messages_arg_list(); end

  def method_double_if_exists_for_message(message); end

  def object(); end

  def original_method_handle_for(_message); end

  def prepended_modules_of_singleton_class(); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_unexpected_message_error(method_name, args); end

  def received_message?(method_name, *args, &block); end

  def record_message_received(message, *args, &block); end

  def remove_stub(method_name); end

  def remove_stub_if_present(method_name); end

  def replay_received_message_on(expectation, &block); end

  def reset(); end

  def verify(); end

  def visibility_for(_method_name); end
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy::SpecificMessage
  def ==(expectation); end

  def args(); end

  def args=(_); end

  def message(); end

  def message=(_); end

  def object(); end

  def object=(_); end
end

class RSpec::Mocks::Proxy::SpecificMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Mocks::Proxy
  def self.prepended_modules_of(klass); end
end

class RSpec::Mocks::ProxyForNil
  def disallow_expectations(); end

  def disallow_expectations=(disallow_expectations); end

  def initialize(order_group); end

  def warn_about_expectations(); end

  def warn_about_expectations=(warn_about_expectations); end
end

class RSpec::Mocks::ProxyForNil
end

class RSpec::Mocks::RootSpace
  def any_instance_proxy_for(*_args); end

  def any_instance_recorder_for(*_args); end

  def any_instance_recorders_from_ancestry_of(_object); end

  def new_scope(); end

  def proxy_for(*_args); end

  def register_constant_mutator(_mutator); end

  def registered?(_object); end

  def reset_all(); end

  def superclass_proxy_for(*_args); end

  def verify_all(); end
end

class RSpec::Mocks::RootSpace
end

class RSpec::Mocks::SimpleMessageExpectation
  def called_max_times?(); end

  def initialize(message, response, error_generator, backtrace_line=T.unsafe(nil)); end

  def invoke(*_); end

  def matches?(message, *_); end

  def unadvise(_); end

  def verify_messages_received(); end
end

class RSpec::Mocks::SimpleMessageExpectation
end

class RSpec::Mocks::Space
  def any_instance_mutex(); end

  def any_instance_proxy_for(klass); end

  def any_instance_recorder_for(klass, only_return_existing=T.unsafe(nil)); end

  def any_instance_recorders(); end

  def any_instance_recorders_from_ancestry_of(object); end

  def constant_mutator_for(name); end

  def ensure_registered(object); end

  def new_scope(); end

  def proxies(); end

  def proxies_of(klass); end

  def proxy_for(object); end

  def proxy_mutex(); end

  def register_constant_mutator(mutator); end

  def registered?(object); end

  def reset_all(); end

  def superclass_proxy_for(klass); end

  def verify_all(); end
end

class RSpec::Mocks::Space
end

class RSpec::Mocks::StubChain
end

class RSpec::Mocks::StubChain
  def self.stub_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::Syntax
end

module RSpec::Mocks::Syntax
  def self.default_should_syntax_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_unless_should_configured(method_name, replacement=T.unsafe(nil)); end
end

class RSpec::Mocks::TargetBase
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def initialize(target); end
end

class RSpec::Mocks::TargetBase
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationClassMethods
  def delegate_not_to(matcher_method, options=T.unsafe(nil)); end

  def delegate_to(matcher_method); end

  def disallow_negation(method_name); end
end

module RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationInstanceMethods
  def target(); end
end

module RSpec::Mocks::TargetDelegationInstanceMethods
end

module RSpec::Mocks::TestDouble
  def ==(other); end

  def __build_mock_proxy_unless_expired(order_group); end

  def __disallow_further_usage!(); end

  def as_null_object(); end

  def freeze(); end

  def initialize(name=T.unsafe(nil), stubs=T.unsafe(nil)); end

  def inspect(); end

  def null_object?(); end

  def respond_to?(message, incl_private=T.unsafe(nil)); end

  def to_s(); end
end

module RSpec::Mocks::TestDouble
end

module RSpec::Mocks::TestDoubleFormatter
end

module RSpec::Mocks::TestDoubleFormatter
  def self.format(dbl, unwrap=T.unsafe(nil)); end
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::UnsupportedMatcherError
end

class RSpec::Mocks::UnsupportedMatcherError
end

module RSpec::Mocks::VerifyingDouble
  def __send__(name, *args, &block); end

  def initialize(doubled_module, *args); end

  def method_missing(message, *args, &block); end

  def respond_to?(message, include_private=T.unsafe(nil)); end

  def send(name, *args, &block); end
end

module RSpec::Mocks::VerifyingDouble::SilentIO
end

module RSpec::Mocks::VerifyingDouble::SilentIO
end

module RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def initialize(object, method_name, proxy); end

  def unimplemented?(); end

  def with_signature(); end
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def self.for(object, method_name, proxy); end
end

class RSpec::Mocks::VerifyingMessageExpectation
  def initialize(*args); end

  def method_reference(); end

  def method_reference=(method_reference); end
end

class RSpec::Mocks::VerifyingMessageExpectation
end

class RSpec::Mocks::VerifyingMethodDouble
  def add_expectation(*args, &block); end

  def add_stub(*args, &block); end

  def initialize(object, method_name, proxy, method_reference); end

  def proxy_method_invoked(obj, *args, &block); end

  def validate_arguments!(actual_args); end
end

class RSpec::Mocks::VerifyingMethodDouble
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def ensure_implemented(_method_name); end

  def initialize(object, expectation_ordering, optional_callback_invocation_strategy=T.unsafe(nil)); end

  def method_reference(); end
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
end

class RSpec::Mocks::VerifyingProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def initialize(object, order_group, doubled_module, method_reference_class); end

  def method_reference(); end

  def validate_arguments!(method_name, args); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::VerifyingProxy
end

module RSpec::Mocks::VerifyingProxyMethods
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_stub(method_name, *args); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def ensure_implemented(method_name); end

  def ensure_publicly_implemented(method_name, _object); end
end

module RSpec::Mocks::VerifyingProxyMethods
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
end

module RSpec::Mocks
  def self.allow_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.configuration(); end

  def self.error_generator(); end

  def self.expect_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.setup(); end

  def self.space(); end

  def self.teardown(); end

  def self.verify(); end

  def self.with_temporary_scope(); end
end

module RSpec::Rails
end

module RSpec::Rails::FeatureCheck
end

module RSpec::Rails::FeatureCheck
  def self.has_action_cable_testing?(); end

  def self.has_action_mailbox?(); end

  def self.has_action_mailer?(); end

  def self.has_action_mailer_parameterized?(); end

  def self.has_action_mailer_preview?(); end

  def self.has_action_mailer_unified_delivery?(); end

  def self.has_active_job?(); end

  def self.has_active_record?(); end

  def self.has_active_record_migration?(); end

  def self.type_metatag(type); end
end

class RSpec::Rails::Railtie
end

class RSpec::Rails::Railtie
end

module RSpec::Rails
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  def self.===(exception); end
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::ComparableVersion
  include ::Comparable
  def initialize(string); end

  def segments(); end

  def string(); end
end

class RSpec::Support::ComparableVersion
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::DirectoryMaker
end

class RSpec::Support::DirectoryMaker
  def self.mkdir_p(path); end
end

class RSpec::Support::EncodedString
  def <<(string); end

  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def initialize(string, encoding=T.unsafe(nil)); end

  def lines(*args, &block); end

  def source_encoding(); end

  def split(regex_or_string); end

  def to_str(); end
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::EncodedString
  def self.pick_encoding(source_a, source_b); end
end

module RSpec::Support::FuzzyMatcher
end

module RSpec::Support::FuzzyMatcher
  def self.values_match?(expected, actual); end
end

class RSpec::Support::HunkGenerator
  def hunks(); end

  def initialize(actual, expected); end
end

class RSpec::Support::HunkGenerator
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def has_kw_args_in?(args); end

  def initialize(signature); end

  def invalid_kw_args_from(_kw_args); end

  def missing_kw_args_from(_kw_args); end

  def non_kw_args_arity_description(); end

  def valid_non_kw_args?(*args); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::MethodSignature
  def arbitrary_kw_args?(); end

  def classify_arity(arity=T.unsafe(nil)); end

  def classify_parameters(); end

  def could_contain_kw_args?(args); end

  def description(); end

  def has_kw_args_in?(args); end

  def initialize(method); end

  def invalid_kw_args_from(given_kw_args); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def missing_kw_args_from(given_kw_args); end

  def non_kw_args_arity_description(); end

  def optional_kw_args(); end

  def required_kw_args(); end

  def unlimited_args?(); end

  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count=T.unsafe(nil)); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
end

class RSpec::Support::MethodSignatureExpectation
  def empty?(); end

  def expect_arbitrary_keywords(); end

  def expect_arbitrary_keywords=(expect_arbitrary_keywords); end

  def expect_unlimited_arguments(); end

  def expect_unlimited_arguments=(expect_unlimited_arguments); end

  def keywords(); end

  def keywords=(values); end

  def max_count(); end

  def max_count=(number); end

  def min_count(); end

  def min_count=(number); end
end

class RSpec::Support::MethodSignatureExpectation
end

class RSpec::Support::MethodSignatureVerifier
  def error_message(); end

  def initialize(signature, args=T.unsafe(nil)); end

  def kw_args(); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def non_kw_args(); end

  def valid?(); end

  def with_expectation(expectation); end
end

class RSpec::Support::MethodSignatureVerifier
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  def self.new(); end
end

module RSpec::Support::OS
end

module RSpec::Support::OS
  def self.windows?(); end

  def self.windows_file_path?(); end
end

class RSpec::Support::ObjectFormatter
  def format(object); end

  def initialize(max_formatted_output_length=T.unsafe(nil)); end

  def max_formatted_output_length(); end

  def max_formatted_output_length=(max_formatted_output_length); end

  def prepare_array(array); end

  def prepare_element(element); end

  def prepare_for_inspection(object); end

  def prepare_hash(input_hash); end

  def recursive_structure?(object); end

  def sort_hash_keys(input_hash); end

  def with_entering_structure(structure); end
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def formatter(); end

  def formatter=(_); end

  def object(); end

  def object=(_); end

  def pretty_print(pp); end
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*_); end

  def self.can_inspect?(_object); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def pretty_print(pp); end

  def text(); end

  def text=(_); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def klass(); end

  def native_object_id(); end
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter
  def self.default_instance(); end

  def self.format(object); end

  def self.prepare_for_inspection(object); end
end

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end

  def constants_defined_on(mod); end

  def get_const_defined_on(mod, const_name); end

  def normalize_const_name(const_name); end

  def recursive_const_defined?(const_name); end

  def recursive_const_get(const_name); end
end

module RSpec::Support::RecursiveConstMethods
end

class RSpec::Support::ReentrantMutex
  def synchronize(); end
end

class RSpec::Support::ReentrantMutex
end

module RSpec::Support::Ruby
end

module RSpec::Support::Ruby
  def self.jruby?(); end

  def self.jruby_9000?(); end

  def self.jruby_version(); end

  def self.mri?(); end

  def self.non_mri?(); end

  def self.rbx?(); end

  def self.truffleruby?(); end
end

module RSpec::Support::RubyFeatures
end

module RSpec::Support::RubyFeatures
  def self.caller_locations_supported?(); end

  def self.fork_supported?(); end

  def self.kw_args_supported?(); end

  def self.module_prepends_supported?(); end

  def self.module_refinement_supported?(); end

  def self.optional_and_splat_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end

  def self.supports_taint?(); end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::Version
end

module RSpec::Support::Warnings
  def deprecate(deprecated, options=T.unsafe(nil)); end

  def warn_deprecation(message, options=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end

  def warning(text, options=T.unsafe(nil)); end
end

module RSpec::Support::Warnings
end

module RSpec::Support::WithKeywordsWhenNeeded
end

module RSpec::Support::WithKeywordsWhenNeeded
  def self.class_exec(klass, *args, &block); end
end

module RSpec::Support
  def self.class_of(object); end

  def self.define_optimized_require_for_rspec(lib, &require_relative); end

  def self.deregister_matcher_definition(&block); end

  def self.failure_notifier(); end

  def self.failure_notifier=(callable); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.method_handle_for(object, method_name); end

  def self.notify_failure(failure, options=T.unsafe(nil)); end

  def self.register_matcher_definition(&block); end

  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_mocks(f); end

  def self.require_rspec_support(f); end

  def self.rspec_description_for_object(object); end

  def self.thread_local_data(); end

  def self.warning_notifier(); end

  def self.warning_notifier=(warning_notifier); end

  def self.with_failure_notifier(callable); end
end

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings
  def self.clear_examples(); end

  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(); end

  def self.const_missing(name); end

  def self.context(*args, &example_group_block); end

  def self.current_example(); end

  def self.current_example=(example); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.reset(); end

  def self.world(); end

  def self.world=(world); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rack::Auth
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

module Rack::Auth::Digest
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

module Rack::Auth::Digest
end

module Rack::Auth
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, &block); end
end

class Rack::BodyProxy
end

class Rack::Builder
  def call(env); end

  def freeze_app(); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.load_file(path, opts=T.unsafe(nil)); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, cascade_for=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  def close(); end

  def each(&block); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime, sync); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def root(); end

  def stat(path); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
end

class Rack::Events
  def call(env); end

  def initialize(app, handlers); end
end

module Rack::Events::Abstract
  def on_commit(req, res); end

  def on_error(req, res, e); end

  def on_finish(req, res); end

  def on_send(req, res); end

  def on_start(req, res); end
end

module Rack::Events::Abstract
end

class Rack::Events::BufferedResponse
  def body(); end

  def initialize(status, headers, body); end

  def to_a(); end
end

class Rack::Events::BufferedResponse
end

class Rack::Events::EventedBodyProxy
  def each(&blk); end

  def initialize(body, request, response, handlers, &block); end

  def request(); end

  def response(); end
end

class Rack::Events::EventedBodyProxy
end

class Rack::Events
end

Rack::File = Rack::Files

class Rack::Files
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Files::BaseIterator
  def bytesize(); end

  def close(); end

  def each(&blk); end

  def initialize(path, ranges, options); end

  def options(); end

  def path(); end

  def ranges(); end
end

class Rack::Files::BaseIterator
end

class Rack::Files::Iterator
  def to_path(); end
end

class Rack::Files::Iterator
end

class Rack::Files
  def self.method_added(name); end
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, **options); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def flush(*args, &block); end

  def initialize(io); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
  extend ::Forwardable
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  def self.params(content_type); end

  def self.type(content_type); end
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def cookie(name); end

  def cookies(); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
  def self.[](*_); end
end

class Rack::MockSession
  def after_request(&block); end

  def clear_cookies(); end

  def cookie_jar(); end

  def cookie_jar=(cookie_jar); end

  def default_host(); end

  def initialize(app, default_host=T.unsafe(nil)); end

  def last_request(); end

  def last_response(); end

  def request(uri, env); end

  def set_cookie(cookie, uri=T.unsafe(nil)); end
end

class Rack::MockSession
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

class Rack::QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end

  def key_space_limit(); end

  def make_params(); end

  def new_depth_limit(param_depth_limit); end

  def new_space_limit(key_space_limit); end

  def normalize_params(params, name, v, depth); end

  def param_depth_limit(); end

  def parse_nested_query(qs, d=T.unsafe(nil)); end

  def parse_query(qs, d=T.unsafe(nil), &unescaper); end
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::Params
  def [](key); end

  def []=(key, value); end

  def initialize(limit); end

  def key?(key); end

  def to_h(); end

  def to_params_hash(); end
end

class Rack::QueryParser::Params
end

class Rack::QueryParser
  def self.make_default(key_space_limit, param_depth_limit); end
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Env
  def add_header(key, v); end

  def delete_header(name); end

  def each_header(&block); end

  def env(); end

  def fetch_header(name, &block); end

  def get_header(name); end

  def has_header?(name); end

  def initialize(env); end

  def set_header(name, v); end
end

module Rack::Request::Env
end

module Rack::Request::Helpers
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def accept_language(); end

  def authority(); end

  def base_url(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def delete_param(k); end

  def form_data?(); end

  def forwarded_authority(); end

  def forwarded_for(); end

  def forwarded_port(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_authority(); end

  def host_with_port(authority=T.unsafe(nil)); end

  def hostname(); end

  def ip(); end

  def link?(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def multithread?(); end

  def options?(); end

  def params(); end

  def parseable_data?(); end

  def patch?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def server_authority(); end

  def server_name(); end

  def server_port(); end

  def session(); end

  def session_options(); end

  def ssl?(); end

  def trace?(); end

  def trusted_proxy?(ip); end

  def unlink?(); end

  def update_param(k, v); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def xhr?(); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
end

class Rack::Request
  def self.ip_filter(); end

  def self.ip_filter=(ip_filter); end
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, v); end

  def body(); end

  def body=(body); end

  def chunked?(); end

  def close(); end

  def delete_header(key); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), headers=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def write(chunk); end
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def add_header(key, v); end

  def append(chunk); end

  def bad_request?(); end

  def buffered_body!(); end

  def cache!(duration=T.unsafe(nil), directive: T.unsafe(nil)); end

  def cache_control(); end

  def cache_control=(v); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def content_type=(content_type); end

  def created?(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def do_not_cache!(); end

  def etag(); end

  def etag=(v); end

  def forbidden?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def location=(location); end

  def media_type(); end

  def media_type_params(); end

  def method_not_allowed?(); end

  def moved_permanently?(); end

  def no_content?(); end

  def not_found?(); end

  def ok?(); end

  def precondition_failed?(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def set_cookie(key, value); end

  def set_cookie_header(); end

  def set_cookie_header=(v); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

module Rack::Response::Helpers
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers
  def delete_header(key); end

  def get_header(key); end

  def has_header?(key); end

  def headers(); end

  def initialize(status, headers); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end
end

class Rack::Response::Raw
end

class Rack::Response
  def self.[](status, headers, body); end
end

class Rack::RewindableInput
  def close(); end

  def each(&block); end

  def gets(); end

  def initialize(io); end

  def read(*args); end

  def rewind(); end
end

class Rack::RewindableInput
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&block); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

module Rack::Session
end

module Rack::Session::Abstract
end

class Rack::Session::Abstract::ID
  def find_session(req, sid); end
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def commit_session(req, res); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end

  def sid_secure(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
end

class Rack::Session::Abstract::PersistedSecure
  def extract_session_id(*_); end

  def generate_sid(*_); end
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash
end

class Rack::Session::Abstract::PersistedSecure
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def dig(key, *keys); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  def self.find(req); end

  def self.set(req, session); end

  def self.set_options(req, options); end
end

module Rack::Session::Abstract
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value); end
end

class Rack::Session::Cookie::SessionId
end

class Rack::Session::Cookie
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::Session::SessionId
  def cookie_value(); end

  def empty?(); end

  def initialize(public_id); end

  def private_id(); end

  def public_id(); end
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Session::SessionId
end

module Rack::Session
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end

  def template(); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::Cookie
  include ::Rack::Utils
  def default_uri(); end

  def domain(); end

  def empty?(); end

  def expired?(); end

  def expires(); end

  def http_only?(); end

  def initialize(raw, uri=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def matches?(uri); end

  def name(); end

  def path(); end

  def raw(); end

  def replaces?(other); end

  def secure?(); end

  def to_h(); end

  def to_hash(); end

  def valid?(uri); end

  def value(); end
end

class Rack::Test::Cookie
end

class Rack::Test::CookieJar
  def <<(new_cookie); end

  def [](name); end

  def []=(name, value); end

  def delete(name); end

  def for(uri); end

  def get_cookie(name); end

  def hash_for(uri=T.unsafe(nil)); end

  def initialize(cookies=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def merge(raw_cookies, uri=T.unsafe(nil)); end

  def to_hash(); end
  DELIMITER = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
end

class Rack::Test::Error
end

class Rack::Test::Error
end

module Rack::Test::Methods
  def _current_session_names(); end

  def authorize(*args, &block); end

  def basic_authorize(*args, &block); end

  def build_rack_mock_session(); end

  def build_rack_test_session(name); end

  def clear_cookies(*args, &block); end

  def current_session(); end

  def custom_request(*args, &block); end

  def delete(*args, &block); end

  def digest_authorize(*args, &block); end

  def env(*args, &block); end

  def follow_redirect!(*args, &block); end

  def get(*args, &block); end

  def head(*args, &block); end

  def header(*args, &block); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(*args, &block); end

  def patch(*args, &block); end

  def post(*args, &block); end

  def put(*args, &block); end

  def rack_mock_session(name=T.unsafe(nil)); end

  def rack_test_session(name=T.unsafe(nil)); end

  def request(*args, &block); end

  def set_cookie(*args, &block); end

  def with_session(name); end
  METHODS = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  extend ::Forwardable
end

class Rack::Test::MockDigestRequest
  def initialize(params); end

  def method(); end

  def method_missing(sym); end

  def response(password); end
end

class Rack::Test::MockDigestRequest
end

class Rack::Test::Session
  include ::Rack::Test::Utils
  include ::Rack::Utils
  def authorize(username, password); end

  def basic_authorize(username, password); end

  def clear_cookies(*args, &block); end

  def custom_request(verb, uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def delete(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def digest_authorize(username, password); end

  def env(name, value); end

  def follow_redirect!(); end

  def get(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def head(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def header(name, value); end

  def initialize(mock_session); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def patch(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def post(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def put(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def request(uri, env=T.unsafe(nil), &block); end

  def set_cookie(*args, &block); end
end

class Rack::Test::Session
  extend ::Forwardable
end

class Rack::Test::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(content, content_type=T.unsafe(nil), binary=T.unsafe(nil), original_filename: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def tempfile(); end
end

class Rack::Test::UploadedFile
  def self.actually_finalize(file); end

  def self.finalize(file); end
end

module Rack::Test::Utils
  include ::Rack::Utils
end

module Rack::Test::Utils
  extend ::Rack::Utils
  def self.build_file_part(parameter_name, uploaded_file); end

  def self.build_multipart(params, first=T.unsafe(nil), multipart=T.unsafe(nil)); end

  def self.build_parts(parameters); end

  def self.build_primitive_part(parameter_name, value); end

  def self.get_parts(parameters); end
end

module Rack::Test
  def self.encoding_aware_strings?(); end
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

class Rack::Utils::Context
  def app(); end

  def call(env); end

  def context(env, app=T.unsafe(nil)); end

  def for(); end

  def initialize(app_f, app_r); end

  def recontext(app); end
end

class Rack::Utils::Context
end

class Rack::Utils::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def replace(other); end
end

class Rack::Utils::HeaderHash
  def self.[](headers); end
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

module Rack::Utils
  def self.add_cookie_to_header(header, key, value); end

  def self.add_remove_cookie_to_header(header, key, value=T.unsafe(nil)); end

  def self.best_q_match(q_value_header, available_mimes); end

  def self.build_nested_query(value, prefix=T.unsafe(nil)); end

  def self.build_query(params); end

  def self.byte_ranges(env, size); end

  def self.clean_path_info(path_info); end

  def self.clock_time(); end

  def self.default_query_parser(); end

  def self.default_query_parser=(default_query_parser); end

  def self.delete_cookie_header!(header, key, value=T.unsafe(nil)); end

  def self.escape(s); end

  def self.escape_html(string); end

  def self.escape_path(s); end

  def self.get_byte_ranges(http_range, size); end

  def self.key_space_limit(); end

  def self.key_space_limit=(v); end

  def self.make_delete_cookie_header(header, key, value); end

  def self.multipart_part_limit(); end

  def self.multipart_part_limit=(multipart_part_limit); end

  def self.param_depth_limit(); end

  def self.param_depth_limit=(v); end

  def self.parse_cookies(env); end

  def self.parse_cookies_header(header); end

  def self.parse_nested_query(qs, d=T.unsafe(nil)); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.q_values(q_value_header); end

  def self.rfc2109(time); end

  def self.rfc2822(time); end

  def self.secure_compare(a, b); end

  def self.select_best_encoding(available_encodings, accept_encoding); end

  def self.set_cookie_header!(header, key, value); end

  def self.status_code(status); end

  def self.unescape(s, encoding=T.unsafe(nil)); end

  def self.unescape_path(s); end

  def self.valid_path?(path); end
end

module Rack
  def self.release(); end

  def self.version(); end
end

class Rails::Application
  def asset_precompiled?(logical_path); end

  def assets(); end

  def assets=(assets); end

  def assets_manifest(); end

  def assets_manifest=(assets_manifest); end

  def build_middleware_stack(); end

  def config=(config); end

  def config_for(name, env: T.unsafe(nil)); end

  def console(&blk); end

  def credentials(); end

  def default_url_options(*args, &block); end

  def default_url_options=(arg); end

  def encrypted(path, key_path: T.unsafe(nil), env_key: T.unsafe(nil)); end

  def executor(); end

  def generators(&blk); end

  def initialize(initial_variable_values=T.unsafe(nil), &block); end

  def initialize!(group=T.unsafe(nil)); end

  def initialized?(); end

  def initializer(name, opts=T.unsafe(nil), &block); end

  def isolate_namespace(mod); end

  def key_generator(); end

  def message_verifier(verifier_name); end

  def migration_railties(); end

  def ordered_railties(); end

  def precompiled_assets(clear_cache=T.unsafe(nil)); end

  def railties_initializers(current); end

  def rake_tasks(&block); end

  def reload_routes!(); end

  def reloader(); end

  def reloaders(); end

  def require_environment!(); end

  def routes_reloader(); end

  def run_load_hooks!(); end

  def run_tasks_blocks(app); end

  def runner(&blk); end

  def sandbox(); end

  def sandbox=(sandbox); end

  def sandbox?(); end

  def secret_key_base(); end

  def secrets(); end

  def secrets=(secrets); end

  def to_app(); end

  def validate_secret_key_base(secret_key_base); end

  def watchable_args(); end
  INITIAL_VARIABLES = ::T.let(nil, ::T.untyped)
end

class Rails::Application
  def self.add_lib_to_load_path!(root); end

  def self.create(initial_variable_values=T.unsafe(nil), &block); end
end

class Rails::ApplicationController
end

class Rails::ApplicationController
end

module Rails::Autoloaders
end

module Rails::Autoloaders
  extend ::Enumerable
  def self.each(&blk); end

  def self.log!(); end

  def self.logger=(logger); end

  def self.main(); end

  def self.once(); end

  def self.zeitwerk_enabled?(); end
end

class Rails::BacktraceCleaner
  APP_DIRS_PATTERN = ::T.let(nil, ::T.untyped)
  DOT_SLASH = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  RENDER_TEMPLATE_PATTERN = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

class Rails::BacktraceCleaner
end

module Rails::Conductor
end

module Rails::Conductor::ActionMailbox
end

class Rails::Conductor::ActionMailbox::InboundEmailsController
  def create(); end

  def index(); end

  def new(); end

  def show(); end
end

class Rails::Conductor::ActionMailbox::InboundEmailsController
end

class Rails::Conductor::ActionMailbox::ReroutesController
  def create(); end
end

class Rails::Conductor::ActionMailbox::ReroutesController
end

module Rails::Conductor::ActionMailbox
end

class Rails::Conductor::BaseController
end

class Rails::Conductor::BaseController
end

module Rails::Conductor
end

module Rails::Configuration
end

class Rails::Configuration::Generators
  def aliases(); end

  def aliases=(aliases); end

  def api_only(); end

  def api_only=(api_only); end

  def colorize_logging(); end

  def colorize_logging=(colorize_logging); end

  def fallbacks(); end

  def fallbacks=(fallbacks); end

  def hidden_namespaces(); end

  def hide_namespace(namespace); end

  def method_missing(method, *args); end

  def options(); end

  def options=(options); end

  def templates(); end

  def templates=(templates); end
end

class Rails::Configuration::Generators
end

class Rails::Configuration::MiddlewareStackProxy
  def +(other); end

  def delete(*args, &block); end

  def delete_operations(); end

  def initialize(operations=T.unsafe(nil), delete_operations=T.unsafe(nil)); end

  def insert(*args, &block); end

  def insert_after(*args, &block); end

  def insert_before(*args, &block); end

  def merge_into(other); end

  def operations(); end

  def swap(*args, &block); end

  def unshift(*args, &block); end

  def use(*args, &block); end
end

class Rails::Configuration::MiddlewareStackProxy
end

module Rails::Configuration
end

module Rails::Dom
end

module Rails::Dom::Testing
end

module Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message=T.unsafe(nil)); end

  def assert_dom_not_equal(expected, actual, message=T.unsafe(nil)); end

  def compare_doms(expected, actual); end

  def equal_attribute?(attr, other_attr); end

  def equal_attribute_nodes?(nodes, other_nodes); end

  def equal_children?(child, other_child); end
end

module Rails::Dom::Testing::Assertions::DomAssertions
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  def assert_select(*args, &block); end

  def assert_select_email(&block); end

  def assert_select_encoded(element=T.unsafe(nil), &block); end

  def css_select(*args); end
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  extend ::ActiveSupport::Concern
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
end

module Rails::Dom::Testing::Assertions
  extend ::ActiveSupport::Concern
end

module Rails::Dom::Testing
end

module Rails::Dom
end

class Rails::Engine
  def app(); end

  def call(env); end

  def eager_load!(); end

  def endpoint(); end

  def engine_name(*args, &block); end

  def env_config(); end

  def helpers(); end

  def helpers_paths(); end

  def isolated?(*args, &block); end

  def load_console(app=T.unsafe(nil)); end

  def load_generators(app=T.unsafe(nil)); end

  def load_runner(app=T.unsafe(nil)); end

  def load_seed(); end

  def load_tasks(app=T.unsafe(nil)); end

  def middleware(*args, &block); end

  def paths(*args, &block); end

  def railties(); end

  def root(*args, &block); end

  def routes(&block); end

  def routes?(); end

  def run_tasks_blocks(*_); end
end

class Rails::Engine
  def self.called_from(); end

  def self.called_from=(called_from); end

  def self.eager_load!(*args, &block); end

  def self.endpoint(endpoint=T.unsafe(nil)); end

  def self.engine_name(name=T.unsafe(nil)); end

  def self.find(path); end

  def self.find_root(from); end

  def self.find_root_with_flag(flag, root_path, default=T.unsafe(nil)); end

  def self.isolate_namespace(mod); end

  def self.isolated(); end

  def self.isolated=(isolated); end

  def self.isolated?(); end
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::FullSanitizer
end

class Rails::Html::FullSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::PermitScrubber
  def allowed_node?(node); end

  def attributes(); end

  def attributes=(attributes); end

  def initialize(); end

  def keep_node?(node); end

  def scrub_attribute(node, attr_node); end

  def scrub_attribute?(name); end

  def scrub_attributes(node); end

  def scrub_css_attribute(node); end

  def scrub_node(node); end

  def skip_node?(node); end

  def tags(); end

  def tags=(tags); end

  def validate!(var, name); end
end

class Rails::Html::PermitScrubber
end

class Rails::Html::SafeListSanitizer
  def sanitize_css(style_string); end
end

class Rails::Html::SafeListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(allowed_attributes); end

  def self.allowed_tags(); end

  def self.allowed_tags=(allowed_tags); end
end

class Rails::Html::Sanitizer
  def sanitize(html, options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  def self.full_sanitizer(); end

  def self.link_sanitizer(); end

  def self.safe_list_sanitizer(); end

  def self.white_list_sanitizer(); end
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TextOnlyScrubber
  def initialize(); end
end

class Rails::Html::TextOnlyScrubber
end

Rails::Html::WhiteListSanitizer = Rails::Html::SafeListSanitizer

module Rails::Html
end

module Rails::Info
  def properties(); end

  def properties=(obj); end
end

module Rails::Info
  def self.properties(); end

  def self.properties=(obj); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def _layout_from_proc(); end

  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

module Rails::Initializable
  def initializers(); end

  def run_initializers(group=T.unsafe(nil), *args); end
end

module Rails::Initializable
  def self.included(base); end
end

module Rails::LineFiltering
  def run(reporter, options=T.unsafe(nil)); end
end

module Rails::LineFiltering
end

class Rails::MailersController
  def index(); end

  def preview(); end
end

class Rails::MailersController
end

module Rails::Paths
end

class Rails::Paths::Path
  include ::Enumerable
  def <<(path); end

  def absolute_current(); end

  def autoload!(); end

  def autoload?(); end

  def autoload_once!(); end

  def autoload_once?(); end

  def children(); end

  def concat(paths); end

  def each(&block); end

  def eager_load!(); end

  def eager_load?(); end

  def existent(); end

  def existent_directories(); end

  def expanded(); end

  def extensions(); end

  def first(); end

  def glob(); end

  def glob=(glob); end

  def initialize(root, current, paths, options=T.unsafe(nil)); end

  def last(); end

  def load_path!(); end

  def load_path?(); end

  def push(path); end

  def skip_autoload!(); end

  def skip_autoload_once!(); end

  def skip_eager_load!(); end

  def skip_load_path!(); end

  def to_a(); end

  def to_ary(); end

  def unshift(*paths); end
end

class Rails::Paths::Path
end

class Rails::Paths::Root
  def [](path); end

  def []=(path, value); end

  def add(path, options=T.unsafe(nil)); end

  def all_paths(); end

  def autoload_once(); end

  def autoload_paths(); end

  def eager_load(); end

  def initialize(path); end

  def keys(); end

  def load_paths(); end

  def path(); end

  def path=(path); end

  def values(); end

  def values_at(*list); end
end

class Rails::Paths::Root
end

module Rails::Paths
end

module Rails::Rack
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

class Rails::Rack::Logger
end

module Rails::Rack
end

class Rails::Railtie
  include ::Rails::Initializable
  def config(); end

  def configure(&block); end

  def railtie_name(*args, &block); end

  def railtie_namespace(); end

  def run_console_blocks(app); end

  def run_generators_blocks(app); end

  def run_runner_blocks(app); end

  def run_tasks_blocks(app); end
  ABSTRACT_RAILTIES = ::T.let(nil, ::T.untyped)
end

class Rails::Railtie
  def self.abstract_railtie?(); end

  def self.config(*args, &block); end

  def self.configure(&block); end

  def self.console(&blk); end

  def self.generators(&blk); end

  def self.inherited(base); end

  def self.instance(); end

  def self.railtie_name(name=T.unsafe(nil)); end

  def self.rake_tasks(&blk); end

  def self.runner(&blk); end
end

class Rails::Secrets
end

class Rails::Secrets::MissingKeyError
  def initialize(); end
end

class Rails::Secrets::MissingKeyError
end

class Rails::Secrets
  def self.decrypt(data); end

  def self.encrypt(data); end

  def self.key(); end

  def self.parse(paths, env:); end

  def self.read(); end

  def self.read_for_editing(&block); end

  def self.root=(root); end

  def self.write(contents); end
end

class Rails::SourceAnnotationExtractor
  def display(results, options=T.unsafe(nil)); end

  def extract_annotations_from(file, pattern); end

  def find(dirs); end

  def find_in(dir); end

  def initialize(tag); end

  def tag(); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def to_s(options=T.unsafe(nil)); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def self.directories(); end

  def self.extensions(); end

  def self.notes_task_deprecation_warning(); end

  def self.register_directories(*dirs); end

  def self.register_extensions(*exts, &block); end

  def self.register_tags(*additional_tags); end

  def self.tags(); end
end

class Rails::SourceAnnotationExtractor
  def self.enumerate(tag=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Rails::TestUnit
end

class Rails::TestUnit::CompositeFilter
  def ===(method); end

  def initialize(runnable, filter, patterns); end

  def named_filter(); end
end

class Rails::TestUnit::CompositeFilter
end

class Rails::TestUnit::Filter
  def ===(method); end

  def initialize(runnable, file, line); end
end

class Rails::TestUnit::Filter
end

class Rails::TestUnit::Runner
  def filters(); end
end

class Rails::TestUnit::Runner
  def self.attach_before_load_options(opts); end

  def self.compose_filter(runnable, filter); end

  def self.filters(); end

  def self.load_tests(argv); end

  def self.parse_options(argv); end

  def self.rake_run(argv=T.unsafe(nil)); end

  def self.run(argv=T.unsafe(nil)); end
end

module Rails::TestUnit
end

class Rails::TestUnitRailtie
end

class Rails::TestUnitRailtie
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Rails::VERSION
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

module Rails
  extend ::ActiveSupport::Autoload
  def self.app_class(); end

  def self.app_class=(app_class); end

  def self.application=(application); end

  def self.autoloaders(); end

  def self.backtrace_cleaner(); end

  def self.cache(); end

  def self.cache=(cache); end

  def self.configuration(); end

  def self.env(); end

  def self.env=(environment); end

  def self.gem_version(); end

  def self.groups(*groups); end

  def self.initialize!(*args, &block); end

  def self.initialized?(*args, &block); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.public_path(); end

  def self.version(); end
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::NullPresenter
  def method_missing(method_name, *args); end
end

class Rainbow::Presenter
  def method_missing(method_name, *args); end
end

class Rainbow::StringUtils
  def self.uncolor(string); end
end

module Rainbow
  def self.new(); end
end

module Rake
end

module Rake::Cloneable
end

module Rake::Cloneable
end

class Rake::FileList
  include ::Rake::Cloneable
  def &(*args, &block); end

  def *(other); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(obj); end

  def ==(array); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def add(*filenames); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def clear_exclude(); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def egrep(pattern, *options); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude(*patterns, &block); end

  def excluded_from_list?(fn); end

  def excluding(*args, &block); end

  def existing(); end

  def existing!(); end

  def ext(newext=T.unsafe(nil)); end

  def extract!(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def gsub(pat, rep); end

  def gsub!(pat, rep); end

  def import(array); end

  def include(*filenames); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def initialize(*patterns); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def is_a?(klass); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def kind_of?(klass); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(&block); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resolve(); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sub(pat, rep); end

  def sub!(pat, rep); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_a(); end

  def to_ary(); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileList
  def self.[](*args); end

  def self.glob(pattern, *args); end
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, **options, &block); end

  def chdir(*args, **options, &block); end

  def chmod(*args, **options, &block); end

  def chmod_R(*args, **options, &block); end

  def chown(*args, **options, &block); end

  def chown_R(*args, **options, &block); end

  def copy(*args, **options, &block); end

  def cp(*args, **options, &block); end

  def cp_lr(*args, **options, &block); end

  def cp_r(*args, **options, &block); end

  def install(*args, **options, &block); end

  def link(*args, **options, &block); end

  def ln(*args, **options, &block); end

  def ln_s(*args, **options, &block); end

  def ln_sf(*args, **options, &block); end

  def makedirs(*args, **options, &block); end

  def mkdir(*args, **options, &block); end

  def mkdir_p(*args, **options, &block); end

  def mkpath(*args, **options, &block); end

  def move(*args, **options, &block); end

  def mv(*args, **options, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_output_message(message); end

  def remove(*args, **options, &block); end

  def rm(*args, **options, &block); end

  def rm_f(*args, **options, &block); end

  def rm_r(*args, **options, &block); end

  def rm_rf(*args, **options, &block); end

  def rmdir(*args, **options, &block); end

  def rmtree(*args, **options, &block); end

  def safe_unlink(*args, **options, &block); end

  def symlink(*args, **options, &block); end

  def touch(*args, **options, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

module Rake
  def self.each_dir_parent(dir); end

  def self.from_pathname(path); end
end

class Random
  def self.bytes(_); end
end

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::IncludeTimeWithZone
  include ::ActiveSupport::EachTimeWithZone
  def %(_); end

  def entries(); end

  def overlaps?(other); end

  def sum(identity=T.unsafe(nil)); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

class Redis
  include ::MonitorMixin
  include ::ActiveSupport::Cache::ConnectionPoolLike
  def _bpop(cmd, args, &blk); end

  def _client(); end

  def _eval(cmd, args); end

  def _exists(*keys); end

  def _scan(command, cursor, args, match: T.unsafe(nil), count: T.unsafe(nil), &block); end

  def append(key, value); end

  def asking(); end

  def auth(password); end

  def bgrewriteaof(); end

  def bgsave(); end

  def bitcount(key, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def bitop(operation, destkey, *keys); end

  def bitpos(key, bit, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def blpop(*args); end

  def brpop(*args); end

  def brpoplpush(source, destination, deprecated_timeout=T.unsafe(nil), timeout: T.unsafe(nil)); end

  def bzpopmax(*args); end

  def bzpopmin(*args); end

  def call(*command); end

  def client(subcommand=T.unsafe(nil), *args); end

  def close(); end

  def cluster(subcommand, *args); end

  def commit(); end

  def config(action, *args); end

  def connected?(); end

  def connection(); end

  def dbsize(); end

  def debug(*args); end

  def decr(key); end

  def decrby(key, decrement); end

  def del(*keys); end

  def discard(); end

  def disconnect!(); end

  def dump(key); end

  def echo(value); end

  def eval(*args); end

  def evalsha(*args); end

  def exec(); end

  def exists(*keys); end

  def exists?(*keys); end

  def expire(key, seconds); end

  def expireat(key, unix_time); end

  def flushall(options=T.unsafe(nil)); end

  def flushdb(options=T.unsafe(nil)); end

  def geoadd(key, *member); end

  def geodist(key, member1, member2, unit=T.unsafe(nil)); end

  def geohash(key, member); end

  def geopos(key, member); end

  def georadius(*args, **geoptions); end

  def georadiusbymember(*args, **geoptions); end

  def get(key); end

  def getbit(key, offset); end

  def getrange(key, start, stop); end

  def getset(key, value); end

  def hdel(key, *fields); end

  def hexists(key, field); end

  def hget(key, field); end

  def hgetall(key); end

  def hincrby(key, field, increment); end

  def hincrbyfloat(key, field, increment); end

  def hkeys(key); end

  def hlen(key); end

  def hmget(key, *fields, &blk); end

  def hmset(key, *attrs); end

  def hscan(key, cursor, **options); end

  def hscan_each(key, **options, &block); end

  def hset(key, *attrs); end

  def hsetnx(key, field, value); end

  def hvals(key); end

  def id(); end

  def incr(key); end

  def incrby(key, increment); end

  def incrbyfloat(key, increment); end

  def info(cmd=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def keys(pattern=T.unsafe(nil)); end

  def lastsave(); end

  def lindex(key, index); end

  def linsert(key, where, pivot, value); end

  def llen(key); end

  def lpop(key); end

  def lpush(key, value); end

  def lpushx(key, value); end

  def lrange(key, start, stop); end

  def lrem(key, count, value); end

  def lset(key, index, value); end

  def ltrim(key, start, stop); end

  def mapped_hmget(key, *fields); end

  def mapped_hmset(key, hash); end

  def mapped_mget(*keys); end

  def mapped_mset(hash); end

  def mapped_msetnx(hash); end

  def method_missing(command, *args); end

  def mget(*keys, &blk); end

  def migrate(key, options); end

  def monitor(&block); end

  def move(key, db); end

  def mset(*args); end

  def msetnx(*args); end

  def multi(); end

  def object(*args); end

  def persist(key); end

  def pexpire(key, milliseconds); end

  def pexpireat(key, ms_unix_time); end

  def pfadd(key, member); end

  def pfcount(*keys); end

  def pfmerge(dest_key, *source_key); end

  def ping(message=T.unsafe(nil)); end

  def pipelined(); end

  def psetex(key, ttl, value); end

  def psubscribe(*channels, &block); end

  def psubscribe_with_timeout(timeout, *channels, &block); end

  def pttl(key); end

  def publish(channel, message); end

  def pubsub(subcommand, *args); end

  def punsubscribe(*channels); end

  def queue(*command); end

  def quit(); end

  def randomkey(); end

  def rename(old_name, new_name); end

  def renamenx(old_name, new_name); end

  def restore(key, ttl, serialized_value, replace: T.unsafe(nil)); end

  def rpop(key); end

  def rpoplpush(source, destination); end

  def rpush(key, value); end

  def rpushx(key, value); end

  def sadd(key, member); end

  def save(); end

  def scan(cursor, **options); end

  def scan_each(**options, &block); end

  def scard(key); end

  def script(subcommand, *args); end

  def sdiff(*keys); end

  def sdiffstore(destination, *keys); end

  def select(db); end

  def sentinel(subcommand, *args); end

  def set(key, value, ex: T.unsafe(nil), px: T.unsafe(nil), nx: T.unsafe(nil), xx: T.unsafe(nil), keepttl: T.unsafe(nil)); end

  def setbit(key, offset, value); end

  def setex(key, ttl, value); end

  def setnx(key, value); end

  def setrange(key, offset, value); end

  def shutdown(); end

  def sinter(*keys); end

  def sinterstore(destination, *keys); end

  def sismember(key, member); end

  def slaveof(host, port); end

  def slowlog(subcommand, length=T.unsafe(nil)); end

  def smembers(key); end

  def smove(source, destination, member); end

  def sort(key, by: T.unsafe(nil), limit: T.unsafe(nil), get: T.unsafe(nil), order: T.unsafe(nil), store: T.unsafe(nil)); end

  def spop(key, count=T.unsafe(nil)); end

  def srandmember(key, count=T.unsafe(nil)); end

  def srem(key, member); end

  def sscan(key, cursor, **options); end

  def sscan_each(key, **options, &block); end

  def strlen(key); end

  def subscribe(*channels, &block); end

  def subscribe_with_timeout(timeout, *channels, &block); end

  def subscribed?(); end

  def sunion(*keys); end

  def sunionstore(destination, *keys); end

  def sync(); end

  def time(); end

  def ttl(key); end

  def type(key); end

  def unlink(*keys); end

  def unsubscribe(*channels); end

  def unwatch(); end

  def watch(*keys); end

  def with_reconnect(val=T.unsafe(nil), &blk); end

  def without_reconnect(&blk); end

  def xack(key, group, *ids); end

  def xadd(key, entry, approximate: T.unsafe(nil), maxlen: T.unsafe(nil), id: T.unsafe(nil)); end

  def xclaim(key, group, consumer, min_idle_time, *ids, **opts); end

  def xdel(key, *ids); end

  def xgroup(subcommand, key, group, id_or_consumer=T.unsafe(nil), mkstream: T.unsafe(nil)); end

  def xinfo(subcommand, key, group=T.unsafe(nil)); end

  def xlen(key); end

  def xpending(key, group, *args); end

  def xrange(key, start=T.unsafe(nil), range_end=T.unsafe(nil), count: T.unsafe(nil)); end

  def xread(keys, ids, count: T.unsafe(nil), block: T.unsafe(nil)); end

  def xreadgroup(group, consumer, keys, ids, count: T.unsafe(nil), block: T.unsafe(nil), noack: T.unsafe(nil)); end

  def xrevrange(key, range_end=T.unsafe(nil), start=T.unsafe(nil), count: T.unsafe(nil)); end

  def xtrim(key, maxlen, approximate: T.unsafe(nil)); end

  def zadd(key, *args, nx: T.unsafe(nil), xx: T.unsafe(nil), ch: T.unsafe(nil), incr: T.unsafe(nil)); end

  def zcard(key); end

  def zcount(key, min, max); end

  def zincrby(key, increment, member); end

  def zinterstore(destination, keys, weights: T.unsafe(nil), aggregate: T.unsafe(nil)); end

  def zlexcount(key, min, max); end

  def zpopmax(key, count=T.unsafe(nil)); end

  def zpopmin(key, count=T.unsafe(nil)); end

  def zrange(key, start, stop, withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  def zrangebylex(key, min, max, limit: T.unsafe(nil)); end

  def zrangebyscore(key, min, max, withscores: T.unsafe(nil), with_scores: T.unsafe(nil), limit: T.unsafe(nil)); end

  def zrank(key, member); end

  def zrem(key, member); end

  def zremrangebyrank(key, start, stop); end

  def zremrangebyscore(key, min, max); end

  def zrevrange(key, start, stop, withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  def zrevrangebylex(key, max, min, limit: T.unsafe(nil)); end

  def zrevrangebyscore(key, max, min, withscores: T.unsafe(nil), with_scores: T.unsafe(nil), limit: T.unsafe(nil)); end

  def zrevrank(key, member); end

  def zscan(key, cursor, **options); end

  def zscan_each(key, **options, &block); end

  def zscore(key, member); end

  def zunionstore(destination, keys, weights: T.unsafe(nil), aggregate: T.unsafe(nil)); end
  Boolify = ::T.let(nil, ::T.untyped)
  BoolifySet = ::T.let(nil, ::T.untyped)
  Floatify = ::T.let(nil, ::T.untyped)
  FloatifyPairs = ::T.let(nil, ::T.untyped)
  Hashify = ::T.let(nil, ::T.untyped)
  HashifyClusterNodeInfo = ::T.let(nil, ::T.untyped)
  HashifyClusterNodes = ::T.let(nil, ::T.untyped)
  HashifyClusterSlaves = ::T.let(nil, ::T.untyped)
  HashifyClusterSlots = ::T.let(nil, ::T.untyped)
  HashifyInfo = ::T.let(nil, ::T.untyped)
  HashifyStreamEntries = ::T.let(nil, ::T.untyped)
  HashifyStreamPendingDetails = ::T.let(nil, ::T.untyped)
  HashifyStreamPendings = ::T.let(nil, ::T.untyped)
  HashifyStreams = ::T.let(nil, ::T.untyped)
  Noop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Redis::BaseConnectionError
end

class Redis::BaseConnectionError
end

class Redis::BaseError
end

class Redis::BaseError
end

class Redis::CannotConnectError
end

class Redis::CannotConnectError
end

class Redis::Client
  def _parse_driver(driver); end

  def _parse_options(options); end

  def call(command); end

  def call_loop(command, timeout=T.unsafe(nil)); end

  def call_pipeline(pipeline); end

  def call_pipelined(pipeline); end

  def call_with_timeout(command, timeout, &blk); end

  def call_without_timeout(command, &blk); end

  def close(); end

  def command_map(); end

  def connect(); end

  def connect_timeout(); end

  def connected?(); end

  def connection(); end

  def db(); end

  def db=(db); end

  def disconnect(); end

  def driver(); end

  def ensure_connected(); end

  def establish_connection(); end

  def host(); end

  def id(); end

  def inherit_socket?(); end

  def initialize(options=T.unsafe(nil)); end

  def io(); end

  def location(); end

  def logger(); end

  def logger=(logger); end

  def logging(commands); end

  def options(); end

  def password(); end

  def path(); end

  def port(); end

  def process(commands); end

  def read(); end

  def read_timeout(); end

  def reconnect(); end

  def scheme(); end

  def timeout(); end

  def with_reconnect(val=T.unsafe(nil)); end

  def with_socket_timeout(timeout); end

  def without_reconnect(&blk); end

  def without_socket_timeout(&blk); end

  def write(command); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Redis::Client::Connector
  def check(client); end

  def initialize(options); end

  def resolve(); end
end

class Redis::Client::Connector::Sentinel
  def resolve_master(); end

  def resolve_slave(); end

  def sentinel_detect(); end
end

class Redis::Client::Connector::Sentinel
end

class Redis::Client::Connector
end

class Redis::Client
end

class Redis::Cluster
  def call(command, &block); end

  def call_loop(command, timeout=T.unsafe(nil), &block); end

  def call_pipeline(pipeline); end

  def call_with_timeout(command, timeout, &block); end

  def call_without_timeout(command, &block); end

  def connected?(); end

  def connection_info(); end

  def db(); end

  def db=(_db); end

  def disconnect(); end

  def id(); end

  def initialize(options=T.unsafe(nil)); end

  def process(commands, &block); end

  def timeout(); end

  def with_reconnect(val=T.unsafe(nil), &block); end
end

class Redis::Cluster::AmbiguousNodeError
  def initialize(command); end
end

class Redis::Cluster::AmbiguousNodeError
end

class Redis::Cluster::Command
  def extract_first_key(command); end

  def initialize(details); end

  def should_send_to_master?(command); end

  def should_send_to_slave?(command); end
end

class Redis::Cluster::Command
end

class Redis::Cluster::CommandErrorCollection
  def errors(); end

  def initialize(errors, error_message=T.unsafe(nil)); end
end

class Redis::Cluster::CommandErrorCollection
end

module Redis::Cluster::CommandLoader
end

module Redis::Cluster::CommandLoader
  def self.load(nodes); end
end

class Redis::Cluster::CrossSlotPipeliningError
  def initialize(keys); end
end

class Redis::Cluster::CrossSlotPipeliningError
end

module Redis::Cluster::KeySlotConverter
  HASH_SLOTS = ::T.let(nil, ::T.untyped)
  XMODEM_CRC16_LOOKUP = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::KeySlotConverter
  def self.convert(key); end
end

class Redis::Cluster::Node
  include ::Enumerable
  def call_all(command, &block); end

  def call_master(command, &block); end

  def call_slave(command, &block); end

  def each(&block); end

  def find_by(node_key); end

  def initialize(options, node_flags=T.unsafe(nil), with_replica=T.unsafe(nil)); end

  def process_all(commands, &block); end

  def sample(); end
  ROLE_SLAVE = ::T.let(nil, ::T.untyped)
end

class Redis::Cluster::Node::ReloadNeeded
end

class Redis::Cluster::Node::ReloadNeeded
end

class Redis::Cluster::Node
end

module Redis::Cluster::NodeKey
  DELIMITER = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::NodeKey
  def self.build_from_host_port(host, port); end

  def self.build_from_uri(uri); end

  def self.optionize(node_key); end

  def self.split(node_key); end
end

module Redis::Cluster::NodeLoader
end

module Redis::Cluster::NodeLoader
  def self.load_flags(nodes); end
end

class Redis::Cluster::Option
  def add_node(host, port); end

  def initialize(options); end

  def per_node_key(); end

  def update_node(addrs); end

  def use_replica?(); end
  DEFAULT_SCHEME = ::T.let(nil, ::T.untyped)
  SECURE_SCHEME = ::T.let(nil, ::T.untyped)
  VALID_SCHEMES = ::T.let(nil, ::T.untyped)
end

class Redis::Cluster::Option
end

class Redis::Cluster::OrchestrationCommandNotSupported
  def initialize(command, subcommand=T.unsafe(nil)); end
end

class Redis::Cluster::OrchestrationCommandNotSupported
end

class Redis::Cluster::Slot
  def exists?(slot); end

  def find_node_key_of_master(slot); end

  def find_node_key_of_slave(slot); end

  def initialize(available_slots, node_flags=T.unsafe(nil), with_replica=T.unsafe(nil)); end

  def put(slot, node_key); end
  ROLE_SLAVE = ::T.let(nil, ::T.untyped)
end

class Redis::Cluster::Slot
end

module Redis::Cluster::SlotLoader
end

module Redis::Cluster::SlotLoader
  def self.load(nodes); end
end

class Redis::Cluster
end

class Redis::CommandError
end

class Redis::CommandError
end

module Redis::Connection
end

module Redis::Connection::CommandHelper
  def build_command(args); end

  def encode(string); end
  COMMAND_DELIMITER = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::CommandHelper
end

class Redis::Connection::Ruby
  include ::Redis::Connection::CommandHelper
  def connected?(); end

  def disconnect(); end

  def format_bulk_reply(line); end

  def format_error_reply(line); end

  def format_integer_reply(line); end

  def format_multi_bulk_reply(line); end

  def format_reply(reply_type, line); end

  def format_status_reply(line); end

  def get_tcp_keepalive(); end

  def initialize(sock); end

  def read(); end

  def set_tcp_keepalive(keepalive); end

  def set_tcp_nodelay(); end

  def timeout=(timeout); end

  def write(command); end

  def write_timeout=(timeout); end
  ASTERISK = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  DOLLAR = ::T.let(nil, ::T.untyped)
  MINUS = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
end

class Redis::Connection::Ruby
  def self.connect(config); end
end

class Redis::Connection::SSLSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::SSLSocket
  def self.connect(host, port, timeout, ssl_params); end
end

module Redis::Connection::SocketMixin
  def _read_from_socket(nbytes); end

  def _write_to_socket(data); end

  def gets(); end

  def initialize(*args); end

  def read(nbytes); end

  def timeout=(timeout); end

  def write(data); end

  def write_timeout=(timeout); end
  CRLF = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::SocketMixin
end

class Redis::Connection::TCPSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::TCPSocket
  def self.connect(host, port, timeout); end

  def self.connect_addrinfo(addrinfo, port, timeout); end
end

class Redis::Connection::UNIXSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::UNIXSocket
  def self.connect(path, timeout); end
end

module Redis::Connection
  def self.drivers(); end
end

class Redis::ConnectionError
end

class Redis::ConnectionError
end

class Redis::Distributed
  include ::ActiveSupport::Cache::ConnectionPoolLike
  def [](key); end

  def []=(key, value); end

  def _bpop(cmd, args); end

  def _eval(cmd, args); end

  def add_node(options); end

  def append(key, value); end

  def bgsave(); end

  def bitcount(key, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def bitop(operation, destkey, *keys); end

  def bitpos(key, bit, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def blpop(*args); end

  def brpop(*args); end

  def brpoplpush(source, destination, deprecated_timeout=T.unsafe(nil), **options); end

  def dbsize(); end

  def decr(key); end

  def decrby(key, decrement); end

  def del(*args); end

  def discard(); end

  def dump(key); end

  def echo(value); end

  def ensure_same_node(command, keys); end

  def eval(*args); end

  def evalsha(*args); end

  def exec(); end

  def exists(*args); end

  def exists?(*args); end

  def expire(key, seconds); end

  def expireat(key, unix_time); end

  def flushall(); end

  def flushdb(); end

  def get(key); end

  def getbit(key, offset); end

  def getrange(key, start, stop); end

  def getset(key, value); end

  def hdel(key, *fields); end

  def hexists(key, field); end

  def hget(key, field); end

  def hgetall(key); end

  def hincrby(key, field, increment); end

  def hincrbyfloat(key, field, increment); end

  def hkeys(key); end

  def hlen(key); end

  def hmget(key, *fields); end

  def hmset(key, *attrs); end

  def hset(key, *attrs); end

  def hsetnx(key, field, value); end

  def hvals(key); end

  def incr(key); end

  def incrby(key, increment); end

  def incrbyfloat(key, increment); end

  def info(cmd=T.unsafe(nil)); end

  def initialize(node_configs, options=T.unsafe(nil)); end

  def key_tag(key); end

  def keys(glob=T.unsafe(nil)); end

  def lastsave(); end

  def lindex(key, index); end

  def linsert(key, where, pivot, value); end

  def llen(key); end

  def lpop(key); end

  def lpush(key, value); end

  def lpushx(key, value); end

  def lrange(key, start, stop); end

  def lrem(key, count, value); end

  def lset(key, index, value); end

  def ltrim(key, start, stop); end

  def mapped_hmget(key, *fields); end

  def mapped_hmset(key, hash); end

  def mapped_mget(*keys); end

  def mapped_mset(_hash); end

  def mapped_msetnx(_hash); end

  def mget(*keys); end

  def migrate(_key, _options); end

  def monitor(); end

  def move(key, db); end

  def mset(*_args); end

  def msetnx(*_args); end

  def multi(); end

  def node_for(key); end

  def node_index_for(key); end

  def nodes(); end

  def on_each_node(command, *args); end

  def persist(key); end

  def pexpire(key, milliseconds); end

  def pexpireat(key, ms_unix_time); end

  def pfadd(key, member); end

  def pfcount(*keys); end

  def pfmerge(dest_key, *source_key); end

  def ping(); end

  def pipelined(); end

  def psetex(key, ttl, value); end

  def psubscribe(*channels, &block); end

  def pttl(key); end

  def publish(channel, message); end

  def punsubscribe(*channels); end

  def quit(); end

  def randomkey(); end

  def rename(old_name, new_name); end

  def renamenx(old_name, new_name); end

  def restore(key, ttl, serialized_value, **options); end

  def ring(); end

  def rpop(key); end

  def rpoplpush(source, destination); end

  def rpush(key, value); end

  def rpushx(key, value); end

  def sadd(key, member); end

  def save(); end

  def scard(key); end

  def script(subcommand, *args); end

  def sdiff(*keys); end

  def sdiffstore(destination, *keys); end

  def select(db); end

  def set(key, value, **options); end

  def setbit(key, offset, value); end

  def setex(key, ttl, value); end

  def setnx(key, value); end

  def setrange(key, offset, value); end

  def sinter(*keys); end

  def sinterstore(destination, *keys); end

  def sismember(key, member); end

  def smembers(key); end

  def smove(source, destination, member); end

  def sort(key, **options); end

  def spop(key, count=T.unsafe(nil)); end

  def srandmember(key, count=T.unsafe(nil)); end

  def srem(key, member); end

  def sscan(key, cursor, **options); end

  def sscan_each(key, **options, &block); end

  def strlen(key); end

  def subscribe(channel, *channels, &block); end

  def subscribed?(); end

  def sunion(*keys); end

  def sunionstore(destination, *keys); end

  def time(); end

  def ttl(key); end

  def type(key); end

  def unlink(*args); end

  def unsubscribe(*channels); end

  def unwatch(); end

  def watch(*_keys); end

  def zadd(key, *args); end

  def zcard(key); end

  def zcount(key, min, max); end

  def zincrby(key, increment, member); end

  def zinterstore(destination, keys, **options); end

  def zrange(key, start, stop, **options); end

  def zrangebyscore(key, min, max, **options); end

  def zrank(key, member); end

  def zrem(key, member); end

  def zremrangebyrank(key, start, stop); end

  def zremrangebyscore(key, min, max); end

  def zrevrange(key, start, stop, **options); end

  def zrevrangebyscore(key, max, min, **options); end

  def zrevrank(key, member); end

  def zscore(key, member); end

  def zunionstore(destination, keys, **options); end
end

class Redis::Distributed::CannotDistribute
  def initialize(command); end
end

class Redis::Distributed::CannotDistribute
end

class Redis::Distributed
end

class Redis::Future
  def ==(_other); end

  def _command(); end

  def _set(object); end

  def class(); end

  def initialize(command, transformation, timeout); end

  def inspect(); end

  def is_a?(other); end

  def timeout(); end

  def value(); end
  FutureNotReady = ::T.let(nil, ::T.untyped)
end

class Redis::Future
end

class Redis::FutureNotReady
  def initialize(); end
end

class Redis::FutureNotReady
end

class Redis::HashRing
  def add_node(node); end

  def get_node(key); end

  def get_node_pos(key); end

  def initialize(nodes=T.unsafe(nil), replicas=T.unsafe(nil)); end

  def iter_nodes(key); end

  def nodes(); end

  def remove_node(node); end

  def replicas(); end

  def ring(); end

  def sorted_keys(); end
  POINTS_PER_SERVER = ::T.let(nil, ::T.untyped)
end

class Redis::HashRing
  def self.binary_search(ary, value); end
end

class Redis::InheritedError
end

class Redis::InheritedError
end

class Redis::InvalidClientOptionError
end

class Redis::InvalidClientOptionError
end

class Redis::Pipeline
  def call(command, timeout: T.unsafe(nil), &block); end

  def call_pipeline(pipeline); end

  def call_with_timeout(command, timeout, &block); end

  def client(); end

  def commands(); end

  def db(); end

  def db=(db); end

  def empty?(); end

  def finish(replies, &blk); end

  def futures(); end

  def initialize(client); end

  def shutdown?(); end

  def timeout(); end

  def timeouts(); end

  def with_reconnect(val=T.unsafe(nil)); end

  def with_reconnect?(); end

  def without_reconnect(&blk); end

  def without_reconnect?(); end
end

class Redis::Pipeline::Multi
  def finish(replies); end
end

class Redis::Pipeline::Multi
end

class Redis::Pipeline
end

class Redis::ProtocolError
  def initialize(reply_type); end
end

class Redis::ProtocolError
end

class Redis::SubscribedClient
  def call(command); end

  def initialize(client); end

  def psubscribe(*channels, &block); end

  def psubscribe_with_timeout(timeout, *channels, &block); end

  def punsubscribe(*channels); end

  def subscribe(*channels, &block); end

  def subscribe_with_timeout(timeout, *channels, &block); end

  def subscription(start, stop, channels, block, timeout=T.unsafe(nil)); end

  def unsubscribe(*channels); end
end

class Redis::SubscribedClient
end

class Redis::Subscription
  def callbacks(); end

  def message(&block); end

  def pmessage(&block); end

  def psubscribe(&block); end

  def punsubscribe(&block); end

  def subscribe(&block); end

  def unsubscribe(&block); end
end

class Redis::Subscription
end

class Redis::TimeoutError
end

class Redis::TimeoutError
end

class Redis
  def self.current(); end

  def self.current=(current); end

  def self.exists_returns_integer(); end

  def self.exists_returns_integer=(value); end
end

class Regexp
  def multiline?(); end
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

module Regexp::Expression
end

class Regexp::Expression::Alternation
  def alternatives(); end
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

class Regexp::Expression::Alternation
end

class Regexp::Expression::Alternative
end

class Regexp::Expression::Alternative
end

module Regexp::Expression::Anchor
end

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base
  def match_length(); end
end

class Regexp::Expression::Anchor::Base
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfString
end

class Regexp::Expression::Anchor::BeginningOfString
end

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

module Regexp::Expression::Anchor
end

module Regexp::Expression::Assertion
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

module Regexp::Expression::Assertion
end

module Regexp::Expression::Backreference
end

class Regexp::Expression::Backreference::Base
  def match_length(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Backreference::Base
end

class Regexp::Expression::Backreference::Name
  def name(); end

  def reference(); end
end

class Regexp::Expression::Backreference::Name
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NameRecursionLevel
end

class Regexp::Expression::Backreference::Number
  def number(); end

  def reference(); end
end

class Regexp::Expression::Backreference::Number
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NumberRecursionLevel
end

class Regexp::Expression::Backreference::NumberRelative
  def effective_number(); end

  def effective_number=(effective_number); end
end

class Regexp::Expression::Backreference::NumberRelative
end

module Regexp::Expression::Backreference
end

class Regexp::Expression::Base
  def =~(string, offset=T.unsafe(nil)); end

  def a?(); end

  def ascii_classes?(); end

  def attributes(); end

  def case_insensitive?(); end

  def coded_offset(); end

  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def d?(); end

  def default_classes?(); end

  def extended?(); end

  def free_spacing?(); end

  def full_length(); end

  def greedy?(); end

  def i?(); end

  def ignore_case?(); end

  def initialize(token, options=T.unsafe(nil)); end

  def is?(test_token, test_type=T.unsafe(nil)); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def m?(); end

  def match(string, offset=T.unsafe(nil)); end

  def match?(string); end

  def matches?(string); end

  def multiline?(); end

  def nesting_level(); end

  def nesting_level=(nesting_level); end

  def offset(); end

  def one_of?(scope, top=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def possessive?(); end

  def quantified?(); end

  def quantifier(); end

  def quantifier=(quantifier); end

  def quantifier_affix(expression_format); end

  def quantify(token, text, min=T.unsafe(nil), max=T.unsafe(nil), mode=T.unsafe(nil)); end

  def quantity(); end

  def reluctant?(); end

  def repetitions(); end

  def set_level(); end

  def set_level=(set_level); end

  def starts_at(); end

  def strfre(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def strfregexp(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def terminal?(); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def to_re(format=T.unsafe(nil)); end

  def to_s(format=T.unsafe(nil)); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end

  def type?(test_type); end

  def u?(); end

  def unicode_classes?(); end

  def unquantified_clone(); end

  def x?(); end
end

class Regexp::Expression::Base
end

class Regexp::Expression::CharacterSet
  def close(); end

  def closed(); end

  def closed=(closed); end

  def closed?(); end

  def negate(); end

  def negated?(); end

  def negative(); end

  def negative=(negative); end

  def negative?(); end
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::Intersection
end

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet::Intersection
end

class Regexp::Expression::CharacterSet::Range
  def complete?(); end

  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::CharacterSet::Range
end

class Regexp::Expression::CharacterSet
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Base
  def match_length(); end
end

class Regexp::Expression::CharacterType::Base
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Word
end

class Regexp::Expression::CharacterType::Word
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::Comment
end

class Regexp::Expression::Comment
end

module Regexp::Expression::Conditional
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Condition
  def match_length(); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Condition
end

class Regexp::Expression::Conditional::Expression
  def add_sequence(active_opts=T.unsafe(nil)); end

  def branch(active_opts=T.unsafe(nil)); end

  def branches(); end

  def condition(); end

  def condition=(exp); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Expression
end

class Regexp::Expression::Conditional::TooManyBranches
  def initialize(); end
end

class Regexp::Expression::Conditional::TooManyBranches
end

module Regexp::Expression::Conditional
end

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Base
  def char(); end

  def codepoint(); end

  def match_length(); end
end

class Regexp::Expression::EscapeSequence::Base
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::CodepointList
  def chars(); end

  def codepoints(); end
end

class Regexp::Expression::EscapeSequence::CodepointList
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::FreeSpace
  def match_length(); end
end

class Regexp::Expression::FreeSpace
end

module Regexp::Expression::Group
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Base
  def capturing?(); end

  def comment?(); end
end

class Regexp::Expression::Group::Base
end

class Regexp::Expression::Group::Capture
  def identifier(); end

  def number(); end

  def number=(number); end

  def number_at_level(); end

  def number_at_level=(number_at_level); end
end

class Regexp::Expression::Group::Capture
end

class Regexp::Expression::Group::Comment
  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::Group::Comment
end

class Regexp::Expression::Group::Named
  def name(); end
end

class Regexp::Expression::Group::Named
end

class Regexp::Expression::Group::Options
  def option_changes(); end

  def option_changes=(option_changes); end
end

class Regexp::Expression::Group::Options
end

class Regexp::Expression::Group::Passive
end

class Regexp::Expression::Group::Passive
end

module Regexp::Expression::Group
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Keep::Mark
  def match_length(); end
end

class Regexp::Expression::Keep::Mark
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Literal
  def match_length(); end
end

class Regexp::Expression::Literal
end

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::PosixClass
  def match_length(); end

  def name(); end

  def negative?(); end
end

class Regexp::Expression::PosixClass
end

class Regexp::Expression::Quantifier
  def greedy?(); end

  def initialize(token, text, min, max, mode); end

  def lazy?(); end

  def max(); end

  def min(); end

  def mode(); end

  def possessive?(); end

  def reluctant?(); end

  def text(); end

  def to_h(); end

  def to_str(); end

  def token(); end
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Quantifier
end

class Regexp::Expression::Root
  def initialize(*args); end
end

class Regexp::Expression::Root
  def self.build(options=T.unsafe(nil)); end

  def self.build_token(); end
end

class Regexp::Expression::Sequence
  def initialize(*args); end
end

class Regexp::Expression::Sequence
  def self.add_to(subexpression, params=T.unsafe(nil), active_opts=T.unsafe(nil)); end

  def self.at_levels(level, set_level, conditional_level); end
end

class Regexp::Expression::SequenceOperation
  def add_sequence(active_opts=T.unsafe(nil)); end

  def operands(); end

  def operator(); end

  def sequences(); end
end

class Regexp::Expression::SequenceOperation
end

class Regexp::Expression::Subexpression
  include ::Enumerable
  def <<(exp); end

  def [](*args, &block); end

  def at(*args, &block); end

  def dig(*indices); end

  def each(*args, &block); end

  def each_expression(include_self=T.unsafe(nil), &block); end

  def empty?(*args, &block); end

  def expressions(); end

  def expressions=(expressions); end

  def fetch(*args, &block); end

  def flat_map(include_self=T.unsafe(nil), &block); end

  def index(*args, &block); end

  def inner_match_length(); end

  def join(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def match_length(); end

  def strfre_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def strfregexp_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def te(); end

  def to_h(); end

  def traverse(include_self=T.unsafe(nil), &block); end

  def values_at(*args, &block); end

  def walk(include_self=T.unsafe(nil), &block); end
end

class Regexp::Expression::Subexpression
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Base
  def match_length(); end

  def name(); end

  def negative?(); end

  def shortcut(); end
end

class Regexp::Expression::UnicodeProperty::Base
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Graph
end

class Regexp::Expression::UnicodeProperty::Graph
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Lower
end

class Regexp::Expression::UnicodeProperty::Lower
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Newline
end

class Regexp::Expression::UnicodeProperty::Newline
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Punct
end

class Regexp::Expression::UnicodeProperty::Punct
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Script
end

class Regexp::Expression::UnicodeProperty::Script
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Space
end

class Regexp::Expression::UnicodeProperty::Space
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::WhiteSpace
  def merge(exp); end
end

class Regexp::Expression::WhiteSpace
end

module Regexp::Expression
  def self.parsed(exp); end
end

class Regexp::Lexer
  def lex(input, syntax=T.unsafe(nil), &block); end
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  def self.lex(input, syntax=T.unsafe(nil), &block); end

  def self.scan(input, syntax=T.unsafe(nil), &block); end
end

class Regexp::MatchLength
  include ::Enumerable
  def each(opts=T.unsafe(nil), &blk); end

  def endless_each(&block); end

  def fixed?(); end

  def include?(length); end

  def initialize(exp, opts=T.unsafe(nil)); end

  def max(); end

  def min(); end

  def to_re(); end
end

class Regexp::MatchLength
  def self.of(obj); end
end

class Regexp::Parser
  include ::Regexp::Expression
  include ::Regexp::Syntax
  include ::Regexp::Expression::UnicodeProperty
  def parse(input, syntax=T.unsafe(nil), &block); end
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::UnknownTokenError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenError
end

class Regexp::Parser::UnknownTokenTypeError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError
end

class Regexp::Parser
  def self.parse(input, syntax=T.unsafe(nil), &block); end
end

class Regexp::Scanner
  def emit(type, token, text, ts, te); end

  def scan(input_object, &block); end
  PROP_MAPS_DIR = ::T.let(nil, ::T.untyped)
end

class Regexp::Scanner::InvalidBackrefError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidBackrefError
end

class Regexp::Scanner::InvalidGroupError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupError
end

class Regexp::Scanner::InvalidGroupOption
  def initialize(option, text); end
end

class Regexp::Scanner::InvalidGroupOption
end

class Regexp::Scanner::InvalidSequenceError
  def initialize(what=T.unsafe(nil), where=T.unsafe(nil)); end
end

class Regexp::Scanner::InvalidSequenceError
end

class Regexp::Scanner::PrematureEndError
  def initialize(where=T.unsafe(nil)); end
end

class Regexp::Scanner::PrematureEndError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::UnknownUnicodePropertyError
  def initialize(name); end
end

class Regexp::Scanner::UnknownUnicodePropertyError
end

class Regexp::Scanner::ValidationError
  def initialize(reason); end
end

class Regexp::Scanner::ValidationError
end

class Regexp::Scanner
  def self.long_prop_map(); end

  def self.scan(input_object, &block); end

  def self.short_prop_map(); end
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Base
  include ::Regexp::Syntax::Token
  def check!(type, token); end

  def check?(type, token); end

  def excludes(type, tokens); end

  def features(); end

  def implementations(type); end

  def implements(type, tokens); end

  def implements!(type, token); end

  def implements?(type, token); end

  def normalize(type, token); end

  def normalize_backref(type, token); end

  def normalize_group(type, token); end
end

class Regexp::Syntax::Base
end

class Regexp::Syntax::InvalidVersionNameError
  def initialize(name); end
end

class Regexp::Syntax::InvalidVersionNameError
end

class Regexp::Syntax::NotImplementedError
  def initialize(syntax, type, token); end
end

class Regexp::Syntax::NotImplementedError
end

class Regexp::Syntax::SyntaxError
end

class Regexp::Syntax::SyntaxError
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
end

module Regexp::Syntax::Token::UnicodeProperty
end

module Regexp::Syntax::Token
end

class Regexp::Syntax::UnknownSyntaxNameError
  def initialize(name); end
end

class Regexp::Syntax::UnknownSyntaxNameError
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_9
end

class Regexp::Syntax::V1_9
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_1
end

class Regexp::Syntax::V2_1
end

class Regexp::Syntax::V2_2
end

class Regexp::Syntax::V2_2
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_3
end

class Regexp::Syntax::V2_3
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_4
end

class Regexp::Syntax::V2_4
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_5
end

class Regexp::Syntax::V2_5
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_6_0
end

class Regexp::Syntax::V2_6_0
end

class Regexp::Syntax::V2_6_2
end

class Regexp::Syntax::V2_6_2
end

class Regexp::Syntax::V2_6_3
end

class Regexp::Syntax::V2_6_3
end

module Regexp::Syntax
  def self.comparable_version(name); end

  def self.const_missing(const_name); end

  def self.fallback_version_class(version); end

  def self.inherit_from_version(parent_version, new_version); end

  def self.new(name); end

  def self.specified_versions(); end

  def self.supported?(name); end

  def self.version_class(version); end

  def self.version_const_name(version_string); end

  def self.warn_if_future_version(const_name); end
end

class Regexp::Token
  def conditional_level(); end

  def conditional_level=(_); end

  def level(); end

  def level=(_); end

  def next(); end

  def next=(_); end

  def offset(); end

  def previous(); end

  def previous=(previous); end

  def set_level(); end

  def set_level=(_); end

  def te(); end

  def te=(_); end

  def text(); end

  def text=(_); end

  def token(); end

  def token=(_); end

  def ts(); end

  def ts=(_); end

  def type(); end

  def type=(_); end
end

class Regexp::Token
  def self.[](*_); end

  def self.members(); end
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def getname(address); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

module Responders
end

module Responders::CollectionResponder
  def navigation_location(); end
end

module Responders::CollectionResponder
end

module Responders::ControllerMethod
  def responders(*responders); end
end

module Responders::ControllerMethod
end

module Responders::FlashResponder
  def controller_interpolation_options(); end

  def flash_defaults_by_namespace(status); end

  def initialize(controller, resources, options=T.unsafe(nil)); end

  def mount_i18n_options(status); end

  def resource_name(); end

  def set_flash(key, value); end

  def set_flash_message!(); end

  def set_flash_message?(); end

  def set_flash_now?(); end

  def to_html(); end

  def to_js(); end
end

module Responders::FlashResponder
  def self.flash_keys(); end

  def self.flash_keys=(flash_keys); end

  def self.helper(); end

  def self.helper=(helper); end

  def self.namespace_lookup(); end

  def self.namespace_lookup=(namespace_lookup); end
end

module Responders::HttpCacheResponder
  def do_http_cache!(); end

  def do_http_cache?(); end

  def initialize(controller, resources, options=T.unsafe(nil)); end

  def persisted?(); end

  def to_format(); end
end

module Responders::HttpCacheResponder
end

module Responders::LocationResponder
end

module Responders::LocationResponder
  def self.included(_base); end
end

class Responders::Railtie
end

class Responders::Railtie
end

module Responders
end

class Ripper
  def column(); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def state(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper
  def self.dedent_string(_, _1); end

  def self.lex_state_name(_); end

  def self.token_match(src, pattern); end
end

module RuboCop
end

module RuboCop::AST
end

class RuboCop::AST::AliasNode
  def new_identifier(); end

  def old_identifier(); end
end

class RuboCop::AST::AliasNode
end

class RuboCop::AST::AndNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::AndNode
end

class RuboCop::AST::ArgsNode
  include ::RuboCop::AST::CollectionNode
  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArgsNode
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ArrayNode
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BasicLiteralNode
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

module RuboCop::AST::BinaryOperatorNode
end

class RuboCop::AST::BlockNode
  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def keywords?(); end

  def lambda?(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
  VOID_CONTEXT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::BlockNode
end

class RuboCop::AST::BreakNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::BreakNode
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Builder
end

class RuboCop::AST::CaseNode
  include ::RuboCop::AST::ConditionalNode
  def each_when(); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CaseNode
end

class RuboCop::AST::ClassNode
  def body(); end

  def identifier(); end

  def parent_class(); end
end

class RuboCop::AST::ClassNode
end

module RuboCop::AST::CollectionNode
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inject(*args, &block); end

  def inquiry(*args, &block); end

  def insert(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(*args, &block); end

  def permutation(*args, &block); end

  def pluck(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def split(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_ary(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::CollectionNode
  extend ::Forwardable
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

module RuboCop::AST::ConditionalNode
end

class RuboCop::AST::DefNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end

  def body(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefNode
end

class RuboCop::AST::DefinedNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::DefinedNode
end

class RuboCop::AST::EnsureNode
  def body(); end
end

class RuboCop::AST::EnsureNode
end

class RuboCop::AST::FloatNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::FloatNode
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

class RuboCop::AST::ForNode
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

module RuboCop::AST::HashElementNode
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::HashNode
end

class RuboCop::AST::IfNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def branches(); end

  def each_branch(); end

  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::IfNode
end

class RuboCop::AST::IntNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::IntNode
end

class RuboCop::AST::KeywordSplatNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
  DOUBLE_SPLAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::KeywordSplatNode
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def access_modifier?(); end

  def adjacent_def_modifier?(node=T.unsafe(nil)); end

  def arguments(); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def binary_operation?(); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier?(); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def macro_scope?(node=T.unsafe(nil)); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def receiver(); end

  def self_receiver?(); end

  def setter_method?(); end

  def special_modifier?(); end

  def unary_operation?(); end

  def wrapped_macro_scope?(node=T.unsafe(nil)); end
  ARITHMETIC_OPERATORS = ::T.let(nil, ::T.untyped)
  SPECIAL_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodDispatchNode
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
  ENUMERATOR_METHODS = ::T.let(nil, ::T.untyped)
  OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodIdentifierPredicates
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

module RuboCop::AST::ModifierNode
end

class RuboCop::AST::ModuleNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::ModuleNode
end

class RuboCop::AST::Node
  include ::RuboCop::AST::Sexp
  include ::RuboCop::RSpec::Node
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def array_pattern_type?(); end

  def array_pattern_with_tail_type?(); end

  def array_type?(); end

  def assignment?(); end

  def assignment_or_similar?(node=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_conditional?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def break_type?(); end

  def call_type?(); end

  def case_match_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def child_nodes(); end

  def class_constructor?(node=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def conditional?(); end

  def const_name(); end

  def const_pattern_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_e_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_e_type?(); end

  def defs_type?(); end

  def descendants(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def eflipflop_type?(); end

  def empty_else_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def find_pattern_type?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def forward_arg_type?(); end

  def forward_args_type?(); end

  def forwarded_args_type?(); end

  def guard_clause?(node=T.unsafe(nil)); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_pattern_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_guard_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def in_match_type?(); end

  def in_pattern_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(node=T.unsafe(nil)); end

  def lambda_or_proc?(node=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def line_count(); end

  def literal?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_alt_type?(); end

  def match_as_type?(); end

  def match_current_line_type?(); end

  def match_nil_pattern_type?(); end

  def match_rest_type?(); end

  def match_var_type?(); end

  def match_with_lvasgn_type?(); end

  def match_with_trailing_comma_type?(); end

  def mlhs_type?(); end

  def module_type?(); end

  def mrasgn_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(node=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def pin_type?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(node=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def range_type?(); end

  def rasgn_type?(); end

  def rational_type?(); end

  def receiver(node=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def root_type?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(node=T.unsafe(nil)); end

  def str_type?(); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def undef_type?(); end

  def unless_guard_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def visit_descendants(types, &block); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::AST::NumericNode
  def sign?(); end
  SIGN_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NumericNode
end

class RuboCop::AST::OrNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::OrNode
end

class RuboCop::AST::PairNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def delimiter(with_spacing=T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(with_spacing=T.unsafe(nil)); end

  def value_on_new_line?(); end
  COLON = ::T.let(nil, ::T.untyped)
  HASH_ROCKET = ::T.let(nil, ::T.untyped)
  SPACED_COLON = ::T.let(nil, ::T.untyped)
  SPACED_HASH_ROCKET = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::PairNode
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
  LOGICAL_AND = ::T.let(nil, ::T.untyped)
  LOGICAL_OR = ::T.let(nil, ::T.untyped)
  SEMANTIC_AND = ::T.let(nil, ::T.untyped)
  SEMANTIC_OR = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::PredicateOperatorNode
end

class RuboCop::AST::RangeNode
  def begin(); end

  def end(); end
end

class RuboCop::AST::RangeNode
end

class RuboCop::AST::RegexpNode
  def content(); end

  def regopt(); end

  def to_regexp(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::RegexpNode
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def exception_variable(); end
end

class RuboCop::AST::ResbodyNode
end

class RuboCop::AST::RetryNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::RetryNode
end

class RuboCop::AST::SelfClassNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::SelfClassNode
end

class RuboCop::AST::SendNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::SendNode
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

module RuboCop::AST::Sexp
end

class RuboCop::AST::StrNode
  include ::RuboCop::AST::BasicLiteralNode
  def heredoc?(); end
end

class RuboCop::AST::StrNode
end

class RuboCop::AST::SuperNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::SuperNode
end

class RuboCop::AST::SymbolNode
  include ::RuboCop::AST::BasicLiteralNode
end

class RuboCop::AST::SymbolNode
end

module RuboCop::AST::Traversal
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_float(node); end

  def on_for(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_if(node); end

  def on_iflipflop(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_current_line(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  MANY_CHILD_NODES = ::T.let(nil, ::T.untyped)
  NO_CHILD_NODES = ::T.let(nil, ::T.untyped)
  ONE_CHILD_NODE = ::T.let(nil, ::T.untyped)
  SECOND_CHILD_ONLY = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
end

class RuboCop::AST::UntilNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::UntilNode
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(); end

  def then?(); end
end

class RuboCop::AST::WhenNode
end

class RuboCop::AST::WhileNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::WhileNode
end

class RuboCop::AST::YieldNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::YieldNode
end

module RuboCop::AST
end

class RuboCop::CLI
  include ::RuboCop::Formatter::TextUtil
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CachedData
end

class RuboCop::CommentConfig
  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end
  COMMENT_DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  UNNEEDED_DISABLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::CommentConfig
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  def [](*args, &block); end

  def []=(*args, &block); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def bundler_lock_file_path(); end

  def check(); end

  def delete(*args, &block); end

  def deprecation_check(); end

  def each(*args, &block); end

  def each_key(*args, &block); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_cop(cop); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(*args, &block); end

  def merge(*args, &block); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def possibly_include_hidden?(); end

  def signature(); end

  def smart_loaded_path(); end

  def target_rails_version(); end

  def target_ruby_version(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end

  def validate(*args, &block); end
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config
  extend ::Forwardable
  def self.create(hash, path); end
end

class RuboCop::ConfigLoader
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_inheritance_from_auto_generated_file(); end

  def self.add_missing_namespaces(path, hash); end

  def self.auto_gen_config(); end

  def self.auto_gen_config=(auto_gen_config); end

  def self.auto_gen_config?(); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.load_file(file); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

  def self.options_config(); end

  def self.options_config=(options_config); end
end

class RuboCop::ConfigLoaderResolver
  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file, unset_nil:); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash, gems); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigLoaderResolver
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigObsoletion
  def initialize(config); end

  def reject_obsolete_cops_and_parameters(); end
  MOVED_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_ENFORCED_STYLES = ::T.let(nil, ::T.untyped)
  OBSOLETE_PARAMETERS = ::T.let(nil, ::T.untyped)
  REMOVED_COPS = ::T.let(nil, ::T.untyped)
  REMOVED_COPS_WITH_REASON = ::T.let(nil, ::T.untyped)
  RENAMED_COPS = ::T.let(nil, ::T.untyped)
  SPLIT_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def force_default_config!(); end

  def options_config=(options_config); end
end

class RuboCop::ConfigStore
end

class RuboCop::ConfigValidator
  def base_dir_for_path_parameters(*args, &block); end

  def bundler_lock_file_path(*args, &block); end

  def find_file_upwards(*args, &block); end

  def for_all_cops(*args, &block); end

  def initialize(config); end

  def smart_loaded_path(*args, &block); end

  def target_ruby_version(); end

  def validate(); end

  def validate_section_presence(name); end
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  DEFAULT_RUBY_VERSION = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  KNOWN_RUBIES = ::T.let(nil, ::T.untyped)
  OBSOLETE_RUBIES = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_FILENAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigValidator
  extend ::Forwardable
end

module RuboCop::Cop
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
end

class RuboCop::Cop::AlignmentCorrector
end

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment
  def self.align_end(processed_source, node, align_to); end

  def self.correct(processed_source, node, column_delta); end

  def self.processed_source(); end
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def correctable?(); end

  def disable_offense(node); end

  def disable_uncorrectable?(); end

  def support_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def eql?(other); end

  def initialize(department, cop_name); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge::InvalidBadge
  def initialize(token); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Badge::InvalidBadge
end

class RuboCop::Cop::Badge
  def self.for(class_name); end

  def self.parse(identifier); end
end

module RuboCop::Cop::Bundler
end

class RuboCop::Cop::Bundler::DuplicatedGem
  include ::RuboCop::Cop::RangeHelp
  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
end

class RuboCop::Cop::Bundler::GemComment
  include ::RuboCop::Cop::DefNode
  def gem_declaration?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def insecure_protocol_source?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
end

class RuboCop::Cop::Bundler::OrderedGems
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
end

module RuboCop::Cop::Bundler
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end
end

module RuboCop::Cop::CheckLineBreakable
end

module RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ClassishLength
end

module RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::CodeLength
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Commissioner
end

class RuboCop::Cop::ConditionCorrector
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableFormatting
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
end

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
end

class RuboCop::Cop::Cop
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_offense(node, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil)); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def correct(node); end

  def corrections(); end

  def disable_uncorrectable(node); end

  def duplicate_location?(location); end

  def excluded_file?(file); end

  def find_location(node, loc); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def join_force?(_force_class); end

  def message(_node=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def parse(source, path=T.unsafe(nil)); end

  def processed_source(); end

  def processed_source=(processed_source); end

  def reason_to_not_correct(node); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
end

class RuboCop::Cop::Cop::Correction
  def call(corrector); end

  def cop(); end

  def cop=(_); end

  def lambda=(_); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Cop
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::NodePattern::Macros
  def self.all(); end

  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.cop_name(); end

  def self.department(); end

  def self.inherited(subclass); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def corrections(); end

  def diagnostics(); end

  def initialize(source_buffer, corrections=T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def remove_leading(range, size); end

  def remove_preceding(range, size); end

  def remove_trailing(range, size); end

  def replace(range, content); end

  def rewrite(); end
end

class RuboCop::Cop::Corrector
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(node=T.unsafe(nil)); end
  NON_PUBLIC_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Duplication
end

module RuboCop::Cop::Duplication
end

class RuboCop::Cop::EachToForCorrector
  def call(corrector); end

  def initialize(block_node); end
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::EmptyLineCorrector
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(node); end

  def self.insert_before(node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

module RuboCop::Cop::FirstElementLineBreak
end

module RuboCop::Cop::FirstElementLineBreak
end

class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end

  def initialize(for_node); end
  CORRECTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  include ::RuboCop::Cop::RangeHelp
  def assignment_method_declarations(node0); end

  def gem_specification(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def dependency_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  def investigate(processed_source); end

  def required_ruby_version(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  def gem_specification?(node0); end

  def on_const(node); end

  def ruby_version?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Generator
  def initialize(name, github_user, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added:); end

  def inject(); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
end

class RuboCop::Cop::Generator
end

module RuboCop::Cop::HashAlignment
end

class RuboCop::Cop::HashAlignment::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(first_pair, _node); end
end

class RuboCop::Cop::HashAlignment::KeyAlignment
end

class RuboCop::Cop::HashAlignment::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignment::ValueAlignment
  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignment::SeparatorAlignment
end

class RuboCop::Cop::HashAlignment::TableAlignment
  include ::RuboCop::Cop::HashAlignment::ValueAlignment
  def deltas_for_first_pair(first_pair, node); end
end

class RuboCop::Cop::HashAlignment::TableAlignment
end

module RuboCop::Cop::HashAlignment::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignment::ValueAlignment
end

module RuboCop::Cop::HashAlignment
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
end

module RuboCop::Cop::IgnoredMethodPatterns
end

module RuboCop::Cop::IgnoredMethodPatterns
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

module RuboCop::Cop::IgnoredNode
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::Interpolation
  def on_dstr(node); end

  def on_dsym(node); end

  def on_node_with_interpolations(node); end

  def on_regexp(node); end

  def on_xstr(node); end
end

module RuboCop::Cop::Interpolation
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
end

class RuboCop::Cop::Layout::AlignArguments
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AlignArguments
end

class RuboCop::Cop::Layout::AlignArray
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AlignArray
end

class RuboCop::Cop::Layout::AlignHash
  include ::RuboCop::Cop::HashAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def column_deltas(); end

  def column_deltas=(column_deltas); end

  def offences_by(); end

  def offences_by=(offences_by); end

  def on_hash(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AlignHash
end

class RuboCop::Cop::Layout::AlignParameters
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AlignParameters
end

class RuboCop::Cop::Layout::BlockAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def block_end_align_target?(node=T.unsafe(nil), param1); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
end

class RuboCop::Cop::Layout::BlockEndNewline
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
end

class RuboCop::Cop::Layout::CaseIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
end

class RuboCop::Cop::Layout::ClassStructure
  def autocorrect(node); end

  def on_class(class_node); end

  def visibility_block?(node=T.unsafe(nil)); end
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def autocorrect(node); end

  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_begin(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
end

class RuboCop::Cop::Layout::CommentIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
end

class RuboCop::Cop::Layout::ConditionPosition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
end

class RuboCop::Cop::Layout::DefEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
end

class RuboCop::Cop::Layout::DotPosition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DotPosition
end

class RuboCop::Cop::Layout::ElseAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  def autocorrect(node); end

  def on_case(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
end

class RuboCop::Cop::Layout::EmptyComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(token); end

  def investigate(source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_defs(nodes); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
end

class RuboCop::Cop::Layout::EmptyLines
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_send(node); end
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_kwbegin(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def constant_definition?(node=T.unsafe(nil)); end

  def empty_line_required?(node=T.unsafe(nil)); end
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_sclass(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_module(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
end

class RuboCop::Cop::Layout::EndAlignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndAlignment
end

class RuboCop::Cop::Layout::EndOfLine
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end

  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
end

class RuboCop::Cop::Layout::ExtraSpacing
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
end

class RuboCop::Cop::Layout::IndentAssignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def check_assignment(node, rhs); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentAssignment
end

class RuboCop::Cop::Layout::IndentFirstArgument
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def eligible_method_call?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentFirstArgument
end

class RuboCop::Cop::Layout::IndentFirstArrayElement
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_array(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentFirstArrayElement
end

class RuboCop::Cop::Layout::IndentFirstHashElement
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentFirstHashElement
end

class RuboCop::Cop::Layout::IndentFirstParameter
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentFirstParameter
end

class RuboCop::Cop::Layout::IndentHeredoc
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_heredoc(node); end
  LIBRARY_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_TYPE_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_WIDTH_MSG = ::T.let(nil, ::T.untyped)
  STRIP_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentHeredoc
end

class RuboCop::Cop::Layout::IndentationConsistency
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
end

class RuboCop::Cop::Layout::IndentationWidth
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern
  def access_modifier?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def on_block(node); end

  def on_case(case_node); end

  def on_class(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_sclass(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
end

class RuboCop::Cop::Layout::InitialIndentation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(_processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
end

class RuboCop::Cop::Layout::LeadingBlankLines
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingBlankLines
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_hash(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end

  def on_ensure(node); end

  def on_resbody(node); end
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RUBY_2_5_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def autocorrect(range); end

  def on_kwoptarg(node); end

  def on_pair(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
end

class RuboCop::Cop::Layout::SpaceAfterComma
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(comma); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterComma
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(pos_before_left_paren); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
end

class RuboCop::Cop::Layout::SpaceAfterNot
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def whitespace_after_operator?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(semicolon); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(target); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def autocorrect(range); end

  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_kwbegin(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_assignment(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_send(node); end

  def on_special_asgn(node); end
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComma
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(lambda_node); end

  def on_send(node); end
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
end

class RuboCop::Cop::Layout::SpaceInsideParens
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def autocorrect(node); end

  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  BRACKET_METHODS = ::T.let(nil, ::T.untyped)
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(begin_node); end

  def on_interpolation(begin_node); end
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
end

class RuboCop::Cop::Layout::Tab
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::Tab
end

class RuboCop::Cop::Layout::TrailingBlankLines
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Layout::TrailingBlankLines
end

class RuboCop::Cop::Layout::TrailingWhitespace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::LineBreakCorrector
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

module RuboCop::Cop::Lint
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
end

class RuboCop::Cop::Lint::AmbiguousOperator
  include ::RuboCop::Cop::ParserDiagnostic
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
end

class RuboCop::Cop::Lint::AssignmentInCondition
  include ::RuboCop::Cop::SafeAssignment
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
end

class RuboCop::Cop::Lint::BigDecimalNew
  def autocorrect(node); end

  def big_decimal_new(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(node=T.unsafe(nil)); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
end

class RuboCop::Cop::Lint::Debugger
  def binding_irb_call?(node=T.unsafe(nil)); end

  def debugger_call?(node=T.unsafe(nil)); end

  def kernel?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def autocorrect(node); end

  def on_send(node); end
  DEPRECATED_METHODS_OBJECT = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp
  def class_constant(); end

  def class_nodes(); end

  def deprecated_method(); end

  def initialize(deprecated:, replacement:, class_constant: T.unsafe(nil)); end

  def replacement_method(); end
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(node=T.unsafe(nil)); end

  def attr?(node=T.unsafe(nil)); end

  def method_alias?(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
end

class RuboCop::Cop::Lint::DuplicatedKey
  include ::RuboCop::Cop::Duplication
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicatedKey
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
end

class RuboCop::Cop::Lint::ElseLayout
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
end

class RuboCop::Cop::Lint::EmptyEnsure
  def autocorrect(node); end

  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
end

class RuboCop::Cop::Lint::EmptyInterpolation
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end

  def on_interpolation(begin_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
end

class RuboCop::Cop::Lint::EndInMethod
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EndInMethod
end

class RuboCop::Cop::Lint::EnsureReturn
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
end

class RuboCop::Cop::Lint::ErbNewArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def erb_new_with_non_keyword_arguments(node=T.unsafe(nil)); end

  def on_send(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(node=T.unsafe(nil)); end

  def on_send(node); end
  DIGIT_DOLLAR_FLAG = ::T.let(nil, ::T.untyped)
  FIELD_REGEX = ::T.let(nil, ::T.untyped)
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NAMED_FIELD_REGEX = ::T.let(nil, ::T.untyped)
  NAMED_INTERPOLATION = ::T.let(nil, ::T.untyped)
  PERCENT = ::T.let(nil, ::T.untyped)
  PERCENT_PERCENT = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
end

class RuboCop::Cop::Lint::HandleExceptions
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HandleExceptions
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(node0); end
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
end

class RuboCop::Cop::Lint::InheritException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def class_new_call?(node=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
  ILLEGAL_CLASSES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
end

class RuboCop::Cop::Lint::InterpolationCheck
  def heredoc?(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
end

class RuboCop::Cop::Lint::LiteralAsCondition
  def message(node); end

  def on_case(case_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_interpolation(begin_node); end
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
end

class RuboCop::Cop::Lint::MultipleCompare
  def autocorrect(node); end

  def multiple_compare?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleCompare
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def eval_call?(node=T.unsafe(nil)); end

  def exec_call?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_body_of_reduce(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
end

class RuboCop::Cop::Lint::NumberConversion
  def autocorrect(node); end

  def datetime?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_method(node=T.unsafe(nil)); end
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
end

class RuboCop::Cop::Lint::OrderedMagicComments
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(_node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
end

class RuboCop::Cop::Lint::PercentStringArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
end

class RuboCop::Cop::Lint::PercentSymbolArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
end

class RuboCop::Cop::Lint::RedundantWithIndex
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_index?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
end

class RuboCop::Cop::Lint::RedundantWithObject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_object?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
end

class RuboCop::Cop::Lint::RequireParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
end

class RuboCop::Cop::Lint::RescueType
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
end

class RuboCop::Cop::Lint::SafeNavigationChain
  include ::RuboCop::Cop::NilMethods
  def bad_method?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  include ::RuboCop::Cop::NilMethods
  def autocorrect(node); end

  def check(node); end

  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def on_if(node); end

  def safe_navigation_empty_in_conditional?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
end

class RuboCop::Cop::Lint::ScriptPermission
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end

  def uses_var?(node0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
end

class RuboCop::Cop::Lint::ShadowedException
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
end

class RuboCop::Cop::Lint::StringConversionInInterpolation
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end

  def on_interpolation(begin_node); end

  def to_s_without_args?(node=T.unsafe(nil)); end
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StringConversionInInterpolation
end

class RuboCop::Cop::Lint::Syntax
  def add_offense_from_diagnostic(diagnostic, ruby_version); end

  def add_offense_from_error(error); end
  ERROR_SOURCE_RANGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def begin_pos(); end

  def begin_pos=(_); end

  def column(); end

  def column=(_); end

  def end_pos(); end

  def end_pos=(_); end

  def line(); end

  def line=(_); end

  def source_line(); end

  def source_line=(_); end
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Lint::Syntax
  def self.offenses_from_processed_source(processed_source, config, options); end
end

class RuboCop::Cop::Lint::ToJSON
  def autocorrect(node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
end

class RuboCop::Cop::Lint::UnifiedInteger
  def autocorrect(node); end

  def fixnum_or_bignum_const(node=T.unsafe(nil)); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
end

class RuboCop::Cop::Lint::UnneededCopDisableDirective
  include ::RuboCop::NameSimilarity
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(args); end

  def check(offenses, cop_disabled_line_ranges, comments); end
  COP_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededCopDisableDirective
end

class RuboCop::Cop::Lint::UnneededCopEnableDirective
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment_and_name); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededCopEnableDirective
end

class RuboCop::Cop::Lint::UnneededRequireStatement
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def unnecessary_require_statement?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededRequireStatement
end

class RuboCop::Cop::Lint::UnneededSplatExpansion
  def array_new?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def literal_expansion(node=T.unsafe(nil)); end

  def on_splat(node); end
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededSplatExpansion
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(node=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end
end

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end
end

class RuboCop::Cop::Lint::UnusedBlockArgument
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(node=T.unsafe(nil)); end
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
end

class RuboCop::Cop::Lint::UriRegexp
  def autocorrect(node); end

  def on_send(node); end

  def uri_regexp_with_argument?(node=T.unsafe(nil)); end

  def uri_regexp_without_argument?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
end

class RuboCop::Cop::Lint::UselessAccessModifier
  def class_or_instance_eval?(node=T.unsafe(nil)); end

  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def dynamic_method_definition?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def static_method_definition?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
end

class RuboCop::Cop::Lint::UselessAssignment
  include ::RuboCop::NameSimilarity
  def after_leaving_scope(scope, _variable_table); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def join_force?(force_class); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def operator_assignment_message(scope, assignment); end

  def return_value_node_of_scope(scope); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
end

class RuboCop::Cop::Lint::UselessComparison
  def on_send(node); end

  def useless_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessComparison
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end

  def setter_call_to_local_variable?(node=T.unsafe(nil)); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
end

class RuboCop::Cop::Lint::UselessSetterCall
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_block(node); end

  def on_kwbegin(node); end
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFINED_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
end

module RuboCop::Cop::Lint
end

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::MatchRange
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message, name); end

  def config(); end

  def cop_config(); end

  def initialize(config, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  def define_method?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

module RuboCop::Cop::MethodComplexity
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::Metrics
end

class RuboCop::Cop::Metrics::AbcSize
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
end

class RuboCop::Cop::Metrics::BlockLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
end

class RuboCop::Cop::Metrics::BlockNesting
  include ::RuboCop::Cop::ConfigurableMax
  def investigate(processed_source); end
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
end

class RuboCop::Cop::Metrics::ClassLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def class_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end
end

class RuboCop::Cop::Metrics::ClassLength
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
end

class RuboCop::Cop::Metrics::LineLength
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate_post_walk(processed_source); end

  def on_array(node); end

  def on_hash(node); end

  def on_potential_breakable_node(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::LineLength
end

class RuboCop::Cop::Metrics::MethodLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
end

class RuboCop::Cop::Metrics::ModuleLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def module_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
end

class RuboCop::Cop::Metrics::ParameterLists
  include ::RuboCop::Cop::ConfigurableMax
  def argument_to_lambda_or_proc?(node=T.unsafe(nil)); end

  def on_args(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
end

module RuboCop::Cop::Metrics::Utils
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def calculate(); end

  def evaluate_branch_nodes(node); end

  def initialize(node); end

  def node_has_else_branch?(node); end
  BRANCH_NODES = ::T.let(nil, ::T.untyped)
  CONDITION_NODES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def self.calculate(node); end
end

module RuboCop::Cop::Metrics::Utils
end

module RuboCop::Cop::Metrics
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_send(node); end
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def call(corrector); end

  def initialize(node, processed_source); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::MultilineLiteralBraceLayout
end

module RuboCop::Cop::Naming
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(node=T.unsafe(nil)); end
  BLACKLISTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(node=T.unsafe(nil)); end

  def literal_receiver?(node=T.unsafe(nil)); end

  def on_casgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
end

class RuboCop::Cop::Naming::FileName
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def memoized?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
end

class RuboCop::Cop::Naming::MethodName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
end

class RuboCop::Cop::Naming::PredicateName
  def dynamic_method_define(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Naming::PredicateName
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
end

class RuboCop::Cop::Naming::UncommunicativeBlockParamName
  include ::RuboCop::Cop::UncommunicativeName
  def on_block(node); end
end

class RuboCop::Cop::Naming::UncommunicativeBlockParamName
end

class RuboCop::Cop::Naming::UncommunicativeMethodParamName
  include ::RuboCop::Cop::UncommunicativeName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::UncommunicativeMethodParamName
end

class RuboCop::Cop::Naming::VariableName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
end

class RuboCop::Cop::Naming::VariableNumber
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
end

module RuboCop::Cop::Naming
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(node=T.unsafe(nil)); end

  def single_negative?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::NilMethods
end

module RuboCop::Cop::NilMethods
end

class RuboCop::Cop::Offense
  include ::Comparable
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def corrected(); end

  def corrected?(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

module RuboCop::Cop::OnNormalIfUnless
end

class RuboCop::Cop::OrderedGemCorrector
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::Parentheses
end

module RuboCop::Cop::Parentheses
end

class RuboCop::Cop::ParenthesesCorrector
end

class RuboCop::Cop::ParenthesesCorrector
  def self.correct(node); end
end

module RuboCop::Cop::ParserDiagnostic
  def investigate(processed_source); end
end

module RuboCop::Cop::ParserDiagnostic
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::PercentLiteral
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def config(); end

  def correct(node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PercentLiteralCorrector
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PreferredDelimiters
end

class RuboCop::Cop::PunctuationCorrector
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(token); end

  def self.remove_space(space_before); end

  def self.swap_comma(range); end
end

module RuboCop::Cop::RSpec
end

class RuboCop::Cop::RSpec::AlignLeftLetBrace
  def autocorrect(let); end

  def investigate(_processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::AlignLeftLetBrace
end

class RuboCop::Cop::RSpec::AlignRightLetBrace
  def autocorrect(let); end

  def investigate(_processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::AlignRightLetBrace
end

class RuboCop::Cop::RSpec::AnyInstance
  def disallowed_stub(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::AnyInstance
end

class RuboCop::Cop::RSpec::AroundBlock
  def find_arg_usage(node0); end

  def hook(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG_NO_ARG = ::T.let(nil, ::T.untyped)
  MSG_UNUSED_ARG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::AroundBlock
end

class RuboCop::Cop::RSpec::Be
  def be_without_args(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Be
end

class RuboCop::Cop::RSpec::BeEql
  def autocorrect(node); end

  def eql_type_with_identity(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::BeEql
end

class RuboCop::Cop::RSpec::BeforeAfterAll
  def before_or_after_all(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::BeforeAfterAll
end

module RuboCop::Cop::RSpec::Capybara
end

class RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation
  def as_is_matcher(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def expectation_set_on_current_path(node=T.unsafe(nil)); end

  def on_send(node); end

  def regexp_str_matcher(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation
end

class RuboCop::Cop::RSpec::Capybara::FeatureMethods
  def autocorrect(node); end

  def feature_method(node=T.unsafe(nil)); end

  def on_block(node); end

  def spec?(node=T.unsafe(nil)); end
  MAP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Capybara::FeatureMethods
end

module RuboCop::Cop::RSpec::Capybara
end

class RuboCop::Cop::RSpec::ContextMethod
  def autocorrect(node); end

  def context_method(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ContextMethod
end

class RuboCop::Cop::RSpec::ContextWording
  def context_wording(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ContextWording
end

class RuboCop::Cop::RSpec::Cop
  include ::RuboCop::RSpec::Language
  include ::RuboCop::RSpec::Language::NodePattern
  DEFAULT_CONFIGURATION = ::T.let(nil, ::T.untyped)
  DEFAULT_PATTERN_RE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Cop
  def self.inherited(subclass); end
end

class RuboCop::Cop::RSpec::DescribeClass
  include ::RuboCop::RSpec::TopLevelDescribe
  def describe_with_rails_metadata?(node=T.unsafe(nil)); end

  def on_top_level_describe(node, args); end

  def rails_metadata?(node=T.unsafe(nil)); end

  def shared_group?(node=T.unsafe(nil)); end

  def valid_describe?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::DescribeClass
end

class RuboCop::Cop::RSpec::DescribeMethod
  include ::RuboCop::RSpec::TopLevelDescribe
  include ::RuboCop::RSpec::Util
  def on_top_level_describe(_node, _); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::DescribeMethod
end

class RuboCop::Cop::RSpec::DescribeSymbol
  def describe_symbol?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::DescribeSymbol
end

class RuboCop::Cop::RSpec::DescribedClass
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def common_instance_exec_closure?(node=T.unsafe(nil)); end

  def contains_described_class?(node0); end

  def described_constant(node=T.unsafe(nil)); end

  def on_block(node); end

  def rspec_block?(node=T.unsafe(nil)); end

  def scope_changing_syntax?(node=T.unsafe(nil)); end
  DESCRIBED_CLASS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::DescribedClass
end

class RuboCop::Cop::RSpec::Dialect
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_send(node); end

  def rspec_method?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Dialect
end

class RuboCop::Cop::RSpec::EmptyExampleGroup
  def contains_example?(node0); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyExampleGroup
end

class RuboCop::Cop::RSpec::EmptyLineAfterExample
  include ::RuboCop::RSpec::BlankLineSeparation
  include ::RuboCop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  def allow_consecutive_one_liners?(); end

  def allowed_one_liner?(node); end

  def consecutive_one_liner?(node); end

  def next_one_line_example?(node); end

  def next_sibling(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyLineAfterExample
end

class RuboCop::Cop::RSpec::EmptyLineAfterExampleGroup
  include ::RuboCop::RSpec::BlankLineSeparation
  include ::RuboCop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyLineAfterExampleGroup
end

class RuboCop::Cop::RSpec::EmptyLineAfterFinalLet
  include ::RuboCop::RSpec::BlankLineSeparation
  include ::RuboCop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyLineAfterFinalLet
end

class RuboCop::Cop::RSpec::EmptyLineAfterHook
  include ::RuboCop::RSpec::BlankLineSeparation
  include ::RuboCop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyLineAfterHook
end

class RuboCop::Cop::RSpec::EmptyLineAfterSubject
  include ::RuboCop::RSpec::BlankLineSeparation
  include ::RuboCop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyLineAfterSubject
end

class RuboCop::Cop::RSpec::ExampleLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExampleLength
end

class RuboCop::Cop::RSpec::ExampleWithoutDescription
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def example_description(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG_ADD_DESCRIPTION = ::T.let(nil, ::T.untyped)
  MSG_DEFAULT_ARGUMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExampleWithoutDescription
end

class RuboCop::Cop::RSpec::ExampleWording
  def autocorrect(node); end

  def it_description(node=T.unsafe(nil)); end

  def on_block(node); end
  IT_PREFIX = ::T.let(nil, ::T.untyped)
  MSG_IT = ::T.let(nil, ::T.untyped)
  MSG_SHOULD = ::T.let(nil, ::T.untyped)
  SHOULD_PREFIX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExampleWording
end

class RuboCop::Cop::RSpec::ExpectActual
  def expect_literal(node=T.unsafe(nil)); end

  def on_send(node); end
  COMPLEX_LITERALS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_LITERALS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExpectActual
end

class RuboCop::Cop::RSpec::ExpectChange
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def expect_change_with_arguments(node=T.unsafe(nil)); end

  def expect_change_with_block(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
  MSG_BLOCK = ::T.let(nil, ::T.untyped)
  MSG_CALL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExpectChange
end

class RuboCop::Cop::RSpec::ExpectInHook
  def expectation(node0); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExpectInHook
end

class RuboCop::Cop::RSpec::ExpectOutput
  def on_gvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExpectOutput
end

module RuboCop::Cop::RSpec::ExplicitHelper
  include ::RuboCop::RSpec::Language
  def predicate_matcher?(node=T.unsafe(nil)); end

  def predicate_matcher_block?(node=T.unsafe(nil)); end
  BUILT_IN_MATCHERS = ::T.let(nil, ::T.untyped)
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RSpec::ExplicitHelper
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::RSpec::FactoryBot
end

class RuboCop::Cop::RSpec::FactoryBot::AttributeDefinedStatically
  def association?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def factory_attributes(node0); end

  def on_block(node); end

  def value_matcher(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::FactoryBot::AttributeDefinedStatically
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def factory_call(node=T.unsafe(nil)); end

  def factory_list_call(node=T.unsafe(nil)); end

  def n_times_block_without_arg?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
  MSG_CREATE_LIST = ::T.let(nil, ::T.untyped)
  MSG_N_TIMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList::Corrector
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList::Corrector
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList::CreateListCorrector
  def call(corrector); end

  def initialize(node); end
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList::CreateListCorrector
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList::TimesCorrector
  def call(corrector); end

  def initialize(node); end
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList::TimesCorrector
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList
end

module RuboCop::Cop::RSpec::FactoryBot
end

class RuboCop::Cop::RSpec::FilePath
  include ::RuboCop::RSpec::TopLevelDescribe
  def const_described?(node0); end

  def on_top_level_describe(node, args); end

  def routing_metadata?(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::FilePath
end

class RuboCop::Cop::RSpec::Focus
  def focused_block?(node=T.unsafe(nil)); end

  def metadata(node=T.unsafe(nil)); end

  def on_send(node); end
  FOCUSABLE_SELECTORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Focus
end

class RuboCop::Cop::RSpec::HookArgument
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end

  def scoped_hook(node=T.unsafe(nil)); end

  def unscoped_hook(node=T.unsafe(nil)); end
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  HOOKS = ::T.let(nil, ::T.untyped)
  IMPLICIT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::HookArgument
end

class RuboCop::Cop::RSpec::HooksBeforeExamples
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::RSpec::FinalEndLocation
  def autocorrect(node); end

  def example_or_group?(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::HooksBeforeExamples
end

class RuboCop::Cop::RSpec::ImplicitBlockExpectation
  def implicit_expect(node=T.unsafe(nil)); end

  def lambda?(node=T.unsafe(nil)); end

  def lambda_subject?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ImplicitBlockExpectation
end

class RuboCop::Cop::RSpec::ImplicitExpect
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def implicit_expect(node=T.unsafe(nil)); end

  def on_send(node); end
  ENFORCED_REPLACEMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ImplicitExpect
end

class RuboCop::Cop::RSpec::ImplicitSubject
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def implicit_subject?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ImplicitSubject
end

module RuboCop::Cop::RSpec::InflectedHelper
  include ::RuboCop::RSpec::Language
  def be_bool?(node=T.unsafe(nil)); end

  def be_boolthy?(node=T.unsafe(nil)); end

  def predicate_in_actual?(node=T.unsafe(nil)); end
  MSG_INFLECTED = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RSpec::InflectedHelper
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::RSpec::InstanceSpy
  def autocorrect(node); end

  def have_received_usage(node0); end

  def null_double(node0); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::InstanceSpy
end

class RuboCop::Cop::RSpec::InstanceVariable
  def dynamic_class?(node=T.unsafe(nil)); end

  def ivar_assigned?(node0, param1); end

  def ivar_usage(node0); end

  def on_block(node); end

  def spec_group?(node=T.unsafe(nil)); end
  EXAMPLE_GROUP_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::InstanceVariable
end

class RuboCop::Cop::RSpec::InvalidPredicateMatcher
  def invalid_predicate_matcher?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::InvalidPredicateMatcher
end

class RuboCop::Cop::RSpec::ItBehavesLike
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def example_inclusion_offense(node=T.unsafe(nil), param1); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ItBehavesLike
end

class RuboCop::Cop::RSpec::IteratedExpectation
  def each?(node=T.unsafe(nil)); end

  def expectation?(node=T.unsafe(nil), param1); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::IteratedExpectation
end

class RuboCop::Cop::RSpec::LeadingSubject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_previous_nodes(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::LeadingSubject
end

class RuboCop::Cop::RSpec::LeakyConstantDeclaration
  def in_example_or_shared_group?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end

  def on_module(node); end
  MSG_CLASS = ::T.let(nil, ::T.untyped)
  MSG_CONST = ::T.let(nil, ::T.untyped)
  MSG_MODULE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::LeakyConstantDeclaration
end

class RuboCop::Cop::RSpec::LetBeforeExamples
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::RSpec::FinalEndLocation
  def autocorrect(node); end

  def example_or_group?(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::LetBeforeExamples
end

class RuboCop::Cop::RSpec::LetSetup
  def let_bang(node0); end

  def method_called?(node0, param1); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::LetSetup
end

class RuboCop::Cop::RSpec::MessageChain
  def message(node); end

  def message_chain(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MessageChain
end

class RuboCop::Cop::RSpec::MessageExpectation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def message_expectation(node=T.unsafe(nil)); end

  def on_send(node); end

  def receive_message?(node0); end
  MSG = ::T.let(nil, ::T.untyped)
  SUPPORTED_STYLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MessageExpectation
end

class RuboCop::Cop::RSpec::MessageSpies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def message_expectation(node=T.unsafe(nil)); end

  def on_send(node); end

  def receive_message(node0); end
  MSG_HAVE_RECEIVED = ::T.let(nil, ::T.untyped)
  MSG_RECEIVE = ::T.let(nil, ::T.untyped)
  SUPPORTED_STYLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MessageSpies
end

class RuboCop::Cop::RSpec::MissingExampleGroupArgument
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MissingExampleGroupArgument
end

class RuboCop::Cop::RSpec::MultipleDescribes
  include ::RuboCop::RSpec::TopLevelDescribe
  def on_top_level_describe(node, _args); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MultipleDescribes
end

class RuboCop::Cop::RSpec::MultipleExpectations
  include ::RuboCop::Cop::ConfigurableMax
  def aggregate_failures?(node=T.unsafe(nil)); end

  def aggregate_failures_block?(node=T.unsafe(nil)); end

  def aggregate_failures_present?(node=T.unsafe(nil)); end

  def expect?(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MultipleExpectations
end

class RuboCop::Cop::RSpec::MultipleSubjects
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MultipleSubjects
end

class RuboCop::Cop::RSpec::NamedSubject
  def ignored_shared_example?(node); end

  def on_block(node); end

  def rspec_block?(node=T.unsafe(nil)); end

  def shared_example?(node=T.unsafe(nil)); end

  def subject_usage(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::NamedSubject
end

class RuboCop::Cop::RSpec::NestedGroups
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::RSpec::TopLevelDescribe
  def find_contexts(node0); end

  def on_top_level_describe(node, _args); end
  DEPRECATED_MAX_KEY = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::NestedGroups
end

class RuboCop::Cop::RSpec::NotToNot
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def not_to_not_offense(node=T.unsafe(nil), param1); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::NotToNot
end

class RuboCop::Cop::RSpec::OverwritingSetup
  def first_argument_name(node=T.unsafe(nil)); end

  def on_block(node); end

  def setup?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::OverwritingSetup
end

class RuboCop::Cop::RSpec::Pending
  def on_send(node); end

  def pending_block?(node=T.unsafe(nil)); end

  def skip_or_pending?(node=T.unsafe(nil)); end

  def skippable?(node=T.unsafe(nil)); end

  def skipped_in_metadata?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PENDING = ::T.let(nil, ::T.untyped)
  SKIPPABLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Pending
end

class RuboCop::Cop::RSpec::PredicateMatcher
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RSpec::InflectedHelper
  include ::RuboCop::Cop::RSpec::ExplicitHelper
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
end

class RuboCop::Cop::RSpec::PredicateMatcher
end

module RuboCop::Cop::RSpec::Rails
end

class RuboCop::Cop::RSpec::Rails::HttpStatus
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def http_status(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::RSpec::Rails::HttpStatus::NumericStyleChecker
  def initialize(node); end

  def message(); end

  def node(); end

  def offensive?(); end

  def preferred_style(); end
  MSG = ::T.let(nil, ::T.untyped)
  WHITELIST_STATUS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Rails::HttpStatus::NumericStyleChecker
end

class RuboCop::Cop::RSpec::Rails::HttpStatus::SymbolicStyleChecker
  def initialize(node); end

  def message(); end

  def node(); end

  def offensive?(); end

  def preferred_style(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Rails::HttpStatus::SymbolicStyleChecker
end

class RuboCop::Cop::RSpec::Rails::HttpStatus
end

module RuboCop::Cop::RSpec::Rails
end

class RuboCop::Cop::RSpec::ReceiveCounts
  def autocorrect(node); end

  def on_send(node); end

  def receive_counts(node=T.unsafe(nil)); end

  def stub?(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ReceiveCounts
end

class RuboCop::Cop::RSpec::ReceiveNever
  def autocorrect(node); end

  def method_on_stub?(node0); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ReceiveNever
end

class RuboCop::Cop::RSpec::RepeatedDescription
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::RepeatedDescription
end

class RuboCop::Cop::RSpec::RepeatedExample
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::RepeatedExample
end

class RuboCop::Cop::RSpec::ReturnFromStub
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def and_return_value(node0); end

  def autocorrect(node); end

  def contains_stub?(node0); end

  def on_block(node); end

  def on_send(node); end
  MSG_AND_RETURN = ::T.let(nil, ::T.untyped)
  MSG_BLOCK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ReturnFromStub::AndReturnCallCorrector
  def call(corrector); end

  def initialize(node); end
end

class RuboCop::Cop::RSpec::ReturnFromStub::AndReturnCallCorrector
end

class RuboCop::Cop::RSpec::ReturnFromStub::BlockBodyCorrector
  def call(corrector); end

  def initialize(block); end
  NULL_BLOCK_BODY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ReturnFromStub::BlockBodyCorrector
end

class RuboCop::Cop::RSpec::ReturnFromStub
end

class RuboCop::Cop::RSpec::ScatteredLet
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ScatteredLet
end

class RuboCop::Cop::RSpec::ScatteredSetup
  def analyzable_hooks(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ScatteredSetup
end

class RuboCop::Cop::RSpec::SharedContext
  def autocorrect(node); end

  def context?(node0); end

  def examples?(node0); end

  def on_block(node); end

  def shared_context(node=T.unsafe(nil)); end

  def shared_example(node=T.unsafe(nil)); end
  MSG_CONTEXT = ::T.let(nil, ::T.untyped)
  MSG_EXAMPLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SharedContext
end

class RuboCop::Cop::RSpec::SharedExamples
  def autocorrect(node); end

  def on_send(node); end

  def shared_examples(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::SharedExamples::Checker
  def initialize(node); end

  def message(); end

  def node(); end

  def preferred_style(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SharedExamples::Checker
end

class RuboCop::Cop::RSpec::SharedExamples
end

class RuboCop::Cop::RSpec::SingleArgumentMessageChain
  def autocorrect(node); end

  def message_chain(node=T.unsafe(nil)); end

  def on_send(node); end

  def single_key_hash?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SingleArgumentMessageChain
end

class RuboCop::Cop::RSpec::SubjectStub
  def message_expectation?(node=T.unsafe(nil), param1); end

  def message_expectation_matcher?(node0); end

  def on_block(node); end

  def subject(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SubjectStub
end

class RuboCop::Cop::RSpec::UnspecifiedException
  def block_with_args?(node); end

  def empty_exception_matcher?(node); end

  def empty_raise_error_or_exception(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::UnspecifiedException
end

class RuboCop::Cop::RSpec::VerifiedDoubles
  def on_send(node); end

  def unverified_double(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::VerifiedDoubles
end

class RuboCop::Cop::RSpec::VoidExpect
  def expect?(node=T.unsafe(nil)); end

  def expect_block?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::VoidExpect
end

class RuboCop::Cop::RSpec::Yield
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def block_arg(node=T.unsafe(nil)); end

  def block_call?(node=T.unsafe(nil), param1); end

  def method_on_stub?(node0); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Yield
end

module RuboCop::Cop::RSpec
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Registry
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def departments(); end

  def each(&block); end

  def enabled(config, only, only_safe=T.unsafe(nil)); end

  def enabled?(cop, config, only_safe); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def initialize(cops=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def qualified_cop_name(name, path); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
end

module RuboCop::Cop::RescueNode
  def investigate(processed_source); end
end

module RuboCop::Cop::RescueNode
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(node=T.unsafe(nil)); end

  def safe_assignment?(node=T.unsafe(nil)); end

  def setter_method?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::SafeMode
end

module RuboCop::Cop::SafeMode
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Security::Eval
  def eval?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
end

class RuboCop::Cop::Security::JSONLoad
  def autocorrect(node); end

  def json_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
end

class RuboCop::Cop::Security::YAMLLoad
  def autocorrect(node); end

  def on_send(node); end

  def yaml_load(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Severity
  include ::Comparable
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
end

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
end

class RuboCop::Cop::SpaceCorrector
end

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::RangeHelp
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

module RuboCop::Cop::StringHelp
end

class RuboCop::Cop::StringLiteralCorrector
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(node, style); end
end

module RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
end

module RuboCop::Cop::StringLiteralsHelp
end

module RuboCop::Cop::Style
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
end

class RuboCop::Cop::Style::Alias
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def identifier(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_send(node); end
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
end

class RuboCop::Cop::Style::AndOr
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
end

module RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::Style::AnnotationComment
end

class RuboCop::Cop::Style::ArrayJoin
  def autocorrect(node); end

  def join_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
end

class RuboCop::Cop::Style::AsciiComments
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
end

class RuboCop::Cop::Style::Attr
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
end

class RuboCop::Cop::Style::BarePercentLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
end

class RuboCop::Cop::Style::BlockComments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
end

class RuboCop::Cop::Style::BlockDelimiters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
end

class RuboCop::Cop::Style::BracesAroundHashParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(send_node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BracesAroundHashParameters
end

class RuboCop::Cop::Style::CaseCorrector
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseEquality
end

class RuboCop::Cop::Style::CharacterLiteral
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
end

class RuboCop::Cop::Style::ClassCheck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def class_check?(node=T.unsafe(nil)); end

  def message(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
end

class RuboCop::Cop::Style::ClassMethods
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
end

class RuboCop::Cop::Style::ClassVars
  def message(node); end

  def on_cvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
end

class RuboCop::Cop::Style::CollectionMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
end

class RuboCop::Cop::Style::ColonMethodCall
  def autocorrect(node); end

  def java_type_node?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def autocorrect(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
end

class RuboCop::Cop::Style::CommandLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_xstr(node); end
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
end

class RuboCop::Cop::Style::CommentAnnotation
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
end

class RuboCop::Cop::Style::CommentedKeyword
  def investigate(processed_source); end
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
end

class RuboCop::Cop::Style::ConditionalAssignment
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def assignment_type?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def candidate_condition?(node=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::ConstantVisibility
  def on_casgn(node); end

  def visibility_declaration_for?(node=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConstantVisibility
end

class RuboCop::Cop::Style::Copyright
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(token); end

  def investigate(processed_source); end
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
end

class RuboCop::Cop::Style::DateTime
  def date_time?(node=T.unsafe(nil)); end

  def historic_date?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_datetime?(node=T.unsafe(nil)); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
end

class RuboCop::Cop::Style::DefWithParentheses
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
end

class RuboCop::Cop::Style::Dir
  def autocorrect(node); end

  def dir_replacement?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
end

class RuboCop::Cop::Style::Documentation
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def constant_definition?(node=T.unsafe(nil)); end

  def on_class(node); end

  def on_module(node); end

  def outer_module(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
end

class RuboCop::Cop::Style::DocumentationMethod
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DefNode
  def module_function_node?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
end

class RuboCop::Cop::Style::DoubleNegation
  def double_negative?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def autocorrect(node); end

  def offending_each_range(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
end

class RuboCop::Cop::Style::EachWithObject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def each_with_object_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
end

class RuboCop::Cop::Style::EmptyBlockParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
end

class RuboCop::Cop::Style::EmptyCaseCondition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(case_node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
end

class RuboCop::Cop::Style::EmptyElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
end

class RuboCop::Cop::Style::EmptyLiteral
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def array_node(node=T.unsafe(nil)); end

  def array_with_block(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def hash_node(node=T.unsafe(nil)); end

  def hash_with_block(node=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(node=T.unsafe(nil)); end
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
end

class RuboCop::Cop::Style::EmptyMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
end

class RuboCop::Cop::Style::Encoding
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
end

class RuboCop::Cop::Style::EndBlock
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
end

class RuboCop::Cop::Style::EvalWithLocation
  def eval_without_location?(node=T.unsafe(nil)); end

  def line_with_offset?(node=T.unsafe(nil), param1, param2); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
end

class RuboCop::Cop::Style::EvenOdd
  def autocorrect(node); end

  def even_odd_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
end

class RuboCop::Cop::Style::ExpandPathArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def file_expand_path(node=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(node=T.unsafe(nil)); end

  def pathname_parent_expand_path(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
end

class RuboCop::Cop::Style::FloatDivision
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def any_coerce?(node=T.unsafe(nil)); end

  def both_coerce?(node=T.unsafe(nil)); end

  def left_coerce?(node=T.unsafe(nil)); end

  def on_send(node); end

  def right_coerce?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::FloatDivision
end

class RuboCop::Cop::Style::For
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_for(node); end
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
end

class RuboCop::Cop::Style::FormatString
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def formatter(node=T.unsafe(nil)); end

  def message(detected_style); end

  def method_name(style_name); end

  def on_send(node); end

  def variable_argument?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
end

class RuboCop::Cop::Style::FormatStringToken
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_str(node); end
  FIELD_CHARACTERS = ::T.let(nil, ::T.untyped)
  FORMAT_STRING_METHODS = ::T.let(nil, ::T.untyped)
  STYLE_PATTERNS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatStringToken
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
end

class RuboCop::Cop::Style::GuardClause
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::StatementModifier
  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
end

class RuboCop::Cop::Style::HashSyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
end

class RuboCop::Cop::Style::IfCorrector
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::IfInsideElse
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfInsideElse
end

class RuboCop::Cop::Style::IfUnlessModifier
  include ::RuboCop::Cop::StatementModifier
  def autocorrect(node); end

  def on_if(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  include ::RuboCop::Cop::StatementModifier
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
end

class RuboCop::Cop::Style::IfWithSemicolon
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
end

class RuboCop::Cop::Style::InfiniteLoop
  def after_leaving_scope(scope, _variable_table); end

  def autocorrect(node); end

  def join_force?(force_class); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
end

class RuboCop::Cop::Style::InlineComment
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
end

class RuboCop::Cop::Style::InverseMethods
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def correct_inverse_block(node); end

  def correct_inverse_selector(block, corrector); end

  def inverse_block?(node=T.unsafe(nil)); end

  def inverse_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
end

class RuboCop::Cop::Style::IpAddresses
  include ::RuboCop::Cop::StringHelp
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
end

class RuboCop::Cop::Style::Lambda
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
end

class RuboCop::Cop::Style::LambdaCall
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::LambdaCall
end

class RuboCop::Cop::Style::LineEndConcatenation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(operator_range); end

  def investigate(processed_source); end
  COMPLEX_STRING_EDGE_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::IgnoredMethodPatterns
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
end

class RuboCop::Cop::Style::MethodDefParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
end

class RuboCop::Cop::Style::MethodMissingSuper
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodMissingSuper
end

class RuboCop::Cop::Style::MinMax
  def autocorrect(node); end

  def min_max_candidate(node=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
end

class RuboCop::Cop::Style::MissingElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
end

class RuboCop::Cop::Style::MixinGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
end

class RuboCop::Cop::Style::MixinUsage
  def include_statement(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
end

class RuboCop::Cop::Style::ModuleFunction
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def extend_self_node?(node=T.unsafe(nil)); end

  def module_function_node?(node=T.unsafe(nil)); end

  def on_module(node); end

  def private_directive?(node=T.unsafe(nil)); end
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
end

class RuboCop::Cop::Style::MultilineBlockChain
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
end

class RuboCop::Cop::Style::MultilineIfModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
end

class RuboCop::Cop::Style::MultilineIfThen
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
end

class RuboCop::Cop::Style::MultilineMemoization
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
end

class RuboCop::Cop::Style::MultilineMethodSignature
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
end

class RuboCop::Cop::Style::MultilineWhenThen
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison?(node=T.unsafe(nil)); end

  def simple_double_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
end

class RuboCop::Cop::Style::MutableConstant
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_casgn(node); end

  def on_or_asgn(node); end

  def operation_produces_immutable_object?(node=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(node=T.unsafe(nil)); end

  def splat_value(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
end

class RuboCop::Cop::Style::NegatedIf
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIf
end

class RuboCop::Cop::Style::NegatedUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedUnless
end

class RuboCop::Cop::Style::NegatedWhile
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NegatedWhile
end

class RuboCop::Cop::Style::NestedModifier
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check(node); end

  def left_hand_operand(node, operator); end

  def modifier?(node); end

  def new_expression(outer_node, inner_node); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end

  def replacement_operator(keyword); end

  def requires_parens?(node); end

  def right_hand_operand(node, left_hand_keyword); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(nested); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
end

class RuboCop::Cop::Style::Next
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(_processed_source); end

  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_while(node); end
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
end

class RuboCop::Cop::Style::NilComparison
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def nil_comparison?(node=T.unsafe(nil)); end

  def on_send(node); end
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
end

class RuboCop::Cop::Style::NonNilCheck
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def not_and_nil_check?(node=T.unsafe(nil)); end

  def not_equal_to_nil?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::NonNilCheck
end

class RuboCop::Cop::Style::Not
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_int(node); end
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
end

class RuboCop::Cop::Style::NumericLiterals
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_float(node); end

  def on_int(node); end
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
end

class RuboCop::Cop::Style::NumericPredicate
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def comparison(node=T.unsafe(nil)); end

  def inverted_comparison(node=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
end

class RuboCop::Cop::Style::OneLineConditional
  include ::RuboCop::Cop::OnNormalIfUnless
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
end

class RuboCop::Cop::Style::OrAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(node=T.unsafe(nil)); end

  def unless_assignment?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
end

class RuboCop::Cop::Style::ParallelAssignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def implicit_self_getter?(node=T.unsafe(nil)); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(node0, param1, param2); end

  def tsort_each_child(assignment); end

  def uses_var?(node0, param1); end

  def var_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, config, new_elements); end

  def node(); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  def autocorrect(node); end

  def control_op_condition(node=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def message(node); end

  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
end

class RuboCop::Cop::Style::PercentQLiterals
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_str(node); end
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
end

class RuboCop::Cop::Style::PerlBackrefs
  def autocorrect(node); end

  def on_nth_ref(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
end

class RuboCop::Cop::Style::PreferredHashMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
end

class RuboCop::Cop::Style::Proc
  def autocorrect(node); end

  def on_block(node); end

  def proc_new?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
end

class RuboCop::Cop::Style::RaiseArgs
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
end

class RuboCop::Cop::Style::RandomWithOffset
  def autocorrect(node); end

  def integer_op_rand?(node=T.unsafe(nil)); end

  def namespace(node=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(node=T.unsafe(nil)); end

  def rand_op_integer?(node=T.unsafe(nil)); end

  def random_call(node=T.unsafe(nil)); end

  def to_int(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
end

class RuboCop::Cop::Style::RedundantBegin
  def autocorrect(node); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
end

class RuboCop::Cop::Style::RedundantConditional
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end

  def redundant_condition?(node=T.unsafe(nil)); end

  def redundant_condition_inverted?(node=T.unsafe(nil)); end
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
end

class RuboCop::Cop::Style::RedundantException
  def autocorrect(node); end

  def compact?(node=T.unsafe(nil)); end

  def exploded?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
end

class RuboCop::Cop::Style::RedundantFreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(node); end

  def on_send(node); end

  def operation_produces_immutable_object?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
end

class RuboCop::Cop::Style::RedundantParentheses
  include ::RuboCop::Cop::Parentheses
  def arg_in_call_with_block?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def first_send_argument?(node=T.unsafe(nil)); end

  def first_super_argument?(node=T.unsafe(nil)); end

  def method_node_and_args(node=T.unsafe(nil)); end

  def on_begin(node); end

  def range_end?(node=T.unsafe(nil)); end

  def rescue?(node=T.unsafe(nil)); end

  def square_brackets?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantParentheses
end

class RuboCop::Cop::Style::RedundantReturn
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
end

class RuboCop::Cop::Style::RedundantSelf
  def autocorrect(node); end

  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_lvasgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
end

class RuboCop::Cop::Style::RedundantSortBy
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_sort_by(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
end

class RuboCop::Cop::Style::RegexpLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_regexp(node); end
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
end

class RuboCop::Cop::Style::RescueModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
end

class RuboCop::Cop::Style::RescueStandardError
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_resbody(node); end

  def rescue_standard_error?(node=T.unsafe(nil)); end

  def rescue_without_error_class?(node=T.unsafe(nil)); end
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
end

class RuboCop::Cop::Style::ReturnNil
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(node=T.unsafe(nil)); end

  def return_node?(node=T.unsafe(nil)); end
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
end

class RuboCop::Cop::Style::SafeNavigation
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_node(node); end

  def modifier_if_safe_navigation_candidate(node=T.unsafe(nil)); end

  def not_nil_check?(node=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def use_var_only_in_unless_modifier?(node, variable); end
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
end

class RuboCop::Cop::Style::Sample
  def autocorrect(node); end

  def on_send(node); end

  def sample_candidate?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
end

class RuboCop::Cop::Style::SelfAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
end

class RuboCop::Cop::Style::Semicolon
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
end

class RuboCop::Cop::Style::Send
  def on_csend(node); end

  def on_send(node); end

  def sending?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
end

class RuboCop::Cop::Style::SignalException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def custom_fail_methods(node0); end

  def investigate(processed_source); end

  def kernel_call?(node=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
end

class RuboCop::Cop::Style::SingleLineMethods
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
end

class RuboCop::Cop::Style::SpecialGlobalVars
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def message(node); end

  def on_gvar(node); end
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
end

class RuboCop::Cop::Style::StderrPuts
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def stderr_puts?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
end

class RuboCop::Cop::Style::StringHashKeys
  def autocorrect(node); end

  def on_pair(node); end

  def receive_environments_method?(node=T.unsafe(nil)); end

  def string_hash_key?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
end

class RuboCop::Cop::Style::StringLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
end

class RuboCop::Cop::Style::StringMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
end

class RuboCop::Cop::Style::Strip
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def lstrip_rstrip(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
end

class RuboCop::Cop::Style::StructInheritance
  def on_class(node); end

  def struct_constructor?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
end

class RuboCop::Cop::Style::SymbolArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def autocorrect(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
end

class RuboCop::Cop::Style::SymbolProc
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def destructuring_block_argument?(argument_node); end

  def on_block(node); end

  def proc_node?(node=T.unsafe(nil)); end

  def symbol_proc?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
end

class RuboCop::Cop::Style::TernaryCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def method_name(node=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryParentheses
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArguments
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
end

class RuboCop::Cop::Style::TrivialAccessors
  def autocorrect(node); end

  def looks_like_trivial_writer?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
end

class RuboCop::Cop::Style::UnlessElse
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
end

class RuboCop::Cop::Style::UnneededCapitalW
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededCapitalW
end

class RuboCop::Cop::Style::UnneededCondition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNNEEDED_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededCondition
end

class RuboCop::Cop::Style::UnneededInterpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededInterpolation
end

class RuboCop::Cop::Style::UnneededPercentQ
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededPercentQ
end

class RuboCop::Cop::Style::UnneededSort
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def unneeded_sort?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededSort
end

class RuboCop::Cop::Style::UnpackFirst
  def autocorrect(node); end

  def on_send(node); end

  def unpack_and_first_element?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::VariableInterpolation
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
end

class RuboCop::Cop::Style::WhenThen
  def autocorrect(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
end

class RuboCop::Cop::Style::WhileUntilDo
  def autocorrect(node); end

  def handle(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
end

class RuboCop::Cop::Style::WhileUntilModifier
  include ::RuboCop::Cop::StatementModifier
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
end

class RuboCop::Cop::Style::WordArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YodaCondition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def autocorrect(node); end

  def non_polymorphic_collection?(node=T.unsafe(nil)); end

  def nonzero_length_predicate(node=T.unsafe(nil)); end

  def on_send(node); end

  def other_receiver(node=T.unsafe(nil)); end

  def zero_length_predicate(node=T.unsafe(nil)); end

  def zero_length_receiver(node=T.unsafe(nil)); end
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
end

module RuboCop::Cop::Style
end

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def support_target_ruby_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Team
  def autocorrect(buffer, cops); end

  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def forces(); end

  def forces_for(cops); end

  def initialize(cop_classes, config, options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Team::Investigation
  def errors(); end

  def errors=(_); end

  def offenses(); end

  def offenses=(_); end
end

class RuboCop::Cop::Team::Investigation
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Team
end

module RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TooManyLines
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingBody
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
end

class RuboCop::Cop::UnusedArgCorrector
end

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(processed_source, node); end

  def self.correct_for_blockarg_type(node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.interpret_string_escapes(string); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.parentheses?(node); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.tokens(node); end

  def self.trim_string_interporation_escape_character(str); end
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable
  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def scope(); end

  def used?(); end

  def variable(); end
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Branch::And
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::And
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*_); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
end

class RuboCop::Cop::VariableForce::Branch::If
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
end

class RuboCop::Cop::VariableForce::Branch::Or
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
end

class RuboCop::Cop::VariableForce::Branch::Until
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
end

class RuboCop::Cop::VariableForce::Branch::While
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

module RuboCop::Cop::VariableForce::Branchable
end

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

class RuboCop::Cop::VariableForce::VariableTable
end

class RuboCop::Cop::VariableForce
end

class RuboCop::Cop::WorkaroundCop
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_offense(node, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil)); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def correct(node); end

  def corrections(); end

  def disable_uncorrectable(node); end

  def duplicate_location?(location); end

  def excluded_file?(file); end

  def find_location(node, loc); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def join_force?(_force_class); end

  def message(_node=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def parse(source, path=T.unsafe(nil)); end

  def processed_source(); end

  def processed_source=(processed_source); end

  def reason_to_not_correct(node); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
end

class RuboCop::Cop::WorkaroundCop
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::NodePattern::Macros
  def self.<(other); end

  def self.all(); end

  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.cop_name(); end

  def self.department(); end

  def self.inherited(*_); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

module RuboCop::Cop
end

class RuboCop::Error
end

class RuboCop::Error
end

class RuboCop::ErrorWithAnalyzedFileLocation
  def column(); end

  def cop(); end

  def initialize(cause:, node:, cop:); end

  def line(); end
end

class RuboCop::ErrorWithAnalyzedFileLocation
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir); end

  def find_files_upwards(filename, start_dir); end
end

module RuboCop::FileFinder
  def self.root_level=(level); end

  def self.root_level?(path); end
end

module RuboCop::Formatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::BaseFormatter
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

module RuboCop::Formatter::Colorizable
end

class RuboCop::Formatter::DisabledConfigFormatter
  def file_started(_file, _file_info); end

  def finished(_inspected_files); end
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::DisabledLinesFormatter
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::Colorizable
  def cop_disabled_line_ranges(); end

  def finished(_inspected_files); end

  def started(_target_files); end
end

class RuboCop::Formatter::DisabledLinesFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlighted_source_line(offense); end

  def hightlight_source_tag(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
end

class RuboCop::Formatter::HTMLFormatter
end

class RuboCop::Formatter::JSONFormatter
  include ::RuboCop::PathUtil
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JSONFormatter
end

class RuboCop::Formatter::OffenseCountFormatter
  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::OffenseCountFormatter
end

class RuboCop::Formatter::ProgressFormatter
  include ::RuboCop::Formatter::TextUtil
  def report_file_as_mark(offenses); end

  def started(target_files); end
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::SimpleTextFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count); end

  def started(_target_files); end
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil
  def initialize(file_count, offense_count, correction_count, rainbow); end

  def summary(); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
end

class RuboCop::Formatter::SimpleTextFormatter
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

class RuboCop::Formatter::TapFormatter
end

module RuboCop::Formatter::TextUtil
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::WorstOffendersFormatter
end

module RuboCop::Formatter
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EmacsComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
end

class RuboCop::MagicComment::VimComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
  def find_similar_name(target_name, scope); end
  MINIMUM_SIMILARITY_TO_SUGGEST = ::T.let(nil, ::T.untyped)
end

module RuboCop::NameSimilarity
end

class RuboCop::NodePattern
  def ==(other); end

  def eql?(other); end

  def initialize(str); end

  def marshal_dump(); end

  def marshal_load(pattern); end

  def match(*args); end

  def pattern(); end
end

class RuboCop::NodePattern::Invalid
end

class RuboCop::NodePattern::Invalid
end

module RuboCop::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str); end

  def def_node_search(method_name, pattern_str); end

  def node_search(method_name, compiler, on_match, prelude, called_from); end

  def node_search_all(method_name, compiler, called_from); end

  def node_search_body(method_name, trailing_params, prelude, match_code, on_match); end

  def node_search_first(method_name, compiler, called_from); end
end

module RuboCop::NodePattern::Macros
end

class RuboCop::NodePattern
end

class RuboCop::OptionArgumentError
end

class RuboCop::OptionArgumentError
end

class RuboCop::Options
  def parse(command_line_args); end
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Options
end

module RuboCop::OptionsHelp
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def display_only_fail_level_offenses_with_autocorrect?(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def only_includes_unneeded_disable?(); end

  def validate_auto_correct(); end

  def validate_auto_gen_config(); end

  def validate_compatibility(); end

  def validate_exclude_limit_option(); end

  def validate_parallel(); end

  def validate_parallel_with_combo_option(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.chdir(dir, &block); end

  def self.hidden_dir?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.pwd(); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.reset_pwd(); end

  def self.smart_path(path); end
end

module RuboCop::Platform
end

module RuboCop::Platform
  def self.windows?(); end
end

class RuboCop::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def buffer(); end

  def checksum(); end

  def comment_config(); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def current_line(token); end

  def diagnostics(); end

  def disabled_line_ranges(); end

  def each_comment(); end

  def each_token(); end

  def file_path(); end

  def find_comment(); end

  def find_token(); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil)); end

  def line_indentation(line_number); end

  def lines(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def start_with?(string); end

  def tokens(); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ProcessedSource
  def self.from_file(path, ruby_version); end
end

module RuboCop::RSpec
  CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::RSpec::AlignLetBrace
  include ::RuboCop::RSpec::Language::NodePattern
  def indent_for(node); end

  def initialize(root, token); end

  def offending_tokens(); end
end

class RuboCop::RSpec::AlignLetBrace
end

module RuboCop::RSpec::BlankLineSeparation
  include ::RuboCop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def last_child?(node); end

  def missing_separating_line(node); end

  def offending_loc(last_line); end
end

module RuboCop::RSpec::BlankLineSeparation
end

class RuboCop::RSpec::Concept
  include ::RuboCop::RSpec::Language
  include ::RuboCop::RSpec::Language::NodePattern
  def ==(other); end

  def eql?(other); end

  def initialize(node); end

  def node(); end

  def to_node(); end
end

class RuboCop::RSpec::Concept
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::RSpec::Example
  def definition(); end

  def doc_string(); end

  def extract_doc_string(node=T.unsafe(nil)); end

  def extract_implementation(node=T.unsafe(nil)); end

  def extract_metadata(node=T.unsafe(nil)); end

  def implementation(); end

  def metadata(); end
end

class RuboCop::RSpec::Example
end

class RuboCop::RSpec::ExampleGroup
  def examples(); end

  def hooks(); end

  def scope_change?(node=T.unsafe(nil)); end

  def subjects(); end
end

class RuboCop::RSpec::ExampleGroup
end

module RuboCop::RSpec::FactoryBot
end

module RuboCop::RSpec::FactoryBot
  def self.attribute_defining_methods(); end

  def self.reserved_methods(); end
end

module RuboCop::RSpec::FinalEndLocation
  def final_end_location(start_node); end
end

module RuboCop::RSpec::FinalEndLocation
end

class RuboCop::RSpec::Hook
  def example?(); end

  def knowable_scope?(); end

  def name(); end

  def scope(); end

  def valid_scope?(); end
end

class RuboCop::RSpec::Hook
end

module RuboCop::RSpec::Inject
end

module RuboCop::RSpec::Inject
  def self.defaults!(); end
end

module RuboCop::RSpec::Language
  ALL = ::T.let(nil, ::T.untyped)
  RSPEC = ::T.let(nil, ::T.untyped)
end

module RuboCop::RSpec::Language::NodePattern
  def example?(node=T.unsafe(nil)); end

  def example_group?(node=T.unsafe(nil)); end

  def example_group_with_body?(node=T.unsafe(nil)); end

  def hook?(node=T.unsafe(nil)); end

  def let?(node=T.unsafe(nil)); end

  def subject?(node=T.unsafe(nil)); end
end

module RuboCop::RSpec::Language::NodePattern
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::RSpec::Language
end

module RuboCop::RSpec::Node
  def recursive_literal_or_const?(); end
end

module RuboCop::RSpec::Node
end

module RuboCop::RSpec::TopLevelDescribe
  def on_send(node); end
end

module RuboCop::RSpec::TopLevelDescribe
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::RSpec::Util
  def one(array); end
end

module RuboCop::RSpec::Util
end

module RuboCop::RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::RSpec::Version
end

class RuboCop::RSpec::Wording
  def initialize(text, ignore:, replace:); end

  def rewrite(); end
end

class RuboCop::RSpec::Wording
end

module RuboCop::RSpec
end

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::RemoteConfig
end

class RuboCop::ResultCache
  def initialize(file, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def save(offenses); end

  def valid?(); end
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def aborting=(aborting); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses); end

  def offenses(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
end

class RuboCop::Runner
end

class RuboCop::StringInterpreter
  STRING_ESCAPES = ::T.let(nil, ::T.untyped)
  STRING_ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

module RuboCop::StringUtil
end

module RuboCop::StringUtil
  def self.similarity(string_a, string_b); end
end

class RuboCop::TargetFinder
  def all_cops_include(); end

  def configured_include?(file); end

  def debug?(); end

  def excluded_dirs(base_dir); end

  def fail_fast?(); end

  def find(args); end

  def find_files(base_dir, flags); end

  def force_exclusion?(); end

  def included_file?(file); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def process_explicit_path(path); end

  def ruby_executable?(file); end

  def ruby_extension?(file); end

  def ruby_extensions(); end

  def ruby_file?(file); end

  def ruby_filename?(file); end

  def ruby_filenames(); end

  def ruby_interpreters(file); end

  def stdin?(); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end

  def to_inspect?(file, hidden_files, base_dir_config); end

  def toplevel_dirs(base_dir, flags); end
end

class RuboCop::TargetFinder
end

class RuboCop::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def pos(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
end

class RuboCop::Token
  def self.from_parser_token(parser_token); end
end

class RuboCop::ValidationError
end

class RuboCop::ValidationError
end

module RuboCop::Version
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Version
  def self.version(debug=T.unsafe(nil)); end
end

class RuboCop::Warning
end

class RuboCop::Warning
end

module RuboCop::YAMLDuplicationChecker
end

module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
end

module RuboCop
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

class RubyVM::DebugInspector
  def backtrace_locations(); end

  def frame_binding(_); end

  def frame_class(_); end

  def frame_iseq(_); end

  def frame_self(_); end
end

class RubyVM::DebugInspector
  def self.open(); end
end

class RubyVM::InstructionSequence
  extend ::Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end
end

class Run
  include ::Run::GeneratedAttributeMethods
  include ::Run::GeneratedAssociationMethods
  def after_add_for_run_transitions(); end

  def after_add_for_run_transitions=(val); end

  def after_add_for_run_transitions?(); end

  def after_remove_for_run_transitions(); end

  def after_remove_for_run_transitions=(val); end

  def after_remove_for_run_transitions?(); end

  def autosave_associated_records_for_csv_results_attachment(); end

  def autosave_associated_records_for_csv_results_blob(); end

  def autosave_associated_records_for_data_file_attachment(); end

  def autosave_associated_records_for_data_file_blob(); end

  def autosave_associated_records_for_ec2_instance(); end

  def autosave_associated_records_for_log_file_attachment(); end

  def autosave_associated_records_for_log_file_blob(); end

  def autosave_associated_records_for_model_file_attachment(); end

  def autosave_associated_records_for_model_file_blob(); end

  def autosave_associated_records_for_result_file_attachment(); end

  def autosave_associated_records_for_result_file_blob(); end

  def autosave_associated_records_for_run_transitions(*args); end

  def autosave_associated_records_for_user(*args); end

  def before_add_for_run_transitions(); end

  def before_add_for_run_transitions=(val); end

  def before_add_for_run_transitions?(); end

  def before_remove_for_run_transitions(); end

  def before_remove_for_run_transitions=(val); end

  def before_remove_for_run_transitions?(); end

  def validate_associated_records_for_run_transitions(*args); end
end

module Run::GeneratedAssociationMethods
  def build_csv_results_attachment(*args, &block); end

  def build_data_file_attachment(*args, &block); end

  def build_ec2_instance(*args, &block); end

  def build_log_file_attachment(*args, &block); end

  def build_model_file_attachment(*args, &block); end

  def build_result_file_attachment(*args, &block); end

  def build_user(*args, &block); end

  def create_csv_results_attachment(*args, &block); end

  def create_csv_results_attachment!(*args, &block); end

  def create_data_file_attachment(*args, &block); end

  def create_data_file_attachment!(*args, &block); end

  def create_ec2_instance(*args, &block); end

  def create_ec2_instance!(*args, &block); end

  def create_log_file_attachment(*args, &block); end

  def create_log_file_attachment!(*args, &block); end

  def create_model_file_attachment(*args, &block); end

  def create_model_file_attachment!(*args, &block); end

  def create_result_file_attachment(*args, &block); end

  def create_result_file_attachment!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def csv_results(); end

  def csv_results=(attachable); end

  def csv_results_attachment(); end

  def csv_results_attachment=(value); end

  def csv_results_blob(); end

  def csv_results_blob=(value); end

  def data_file(); end

  def data_file=(attachable); end

  def data_file_attachment(); end

  def data_file_attachment=(value); end

  def data_file_blob(); end

  def data_file_blob=(value); end

  def ec2_instance(); end

  def ec2_instance=(value); end

  def log_file(); end

  def log_file=(attachable); end

  def log_file_attachment(); end

  def log_file_attachment=(value); end

  def log_file_blob(); end

  def log_file_blob=(value); end

  def model_file(); end

  def model_file=(attachable); end

  def model_file_attachment(); end

  def model_file_attachment=(value); end

  def model_file_blob(); end

  def model_file_blob=(value); end

  def reload_csv_results_attachment(); end

  def reload_csv_results_blob(); end

  def reload_data_file_attachment(); end

  def reload_data_file_blob(); end

  def reload_ec2_instance(); end

  def reload_log_file_attachment(); end

  def reload_log_file_blob(); end

  def reload_model_file_attachment(); end

  def reload_model_file_blob(); end

  def reload_result_file_attachment(); end

  def reload_result_file_blob(); end

  def reload_user(); end

  def result_file(); end

  def result_file=(attachable); end

  def result_file_attachment(); end

  def result_file_attachment=(value); end

  def result_file_blob(); end

  def result_file_blob=(value); end

  def run_transition_ids(); end

  def run_transition_ids=(ids); end

  def run_transitions(); end

  def run_transitions=(value); end

  def user(); end

  def user=(value); end
end

module Run::GeneratedAssociationMethods
end

module Run::GeneratedAttributeMethods
end

module Run::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Run::StateMachine
  include ::Statesman::Machine
  def object(); end
end

class Run
  def self.after_add_for_run_transitions(); end

  def self.after_add_for_run_transitions=(val); end

  def self.after_add_for_run_transitions?(); end

  def self.after_remove_for_run_transitions(); end

  def self.after_remove_for_run_transitions=(val); end

  def self.after_remove_for_run_transitions?(); end

  def self.before_add_for_run_transitions(); end

  def self.before_add_for_run_transitions=(val); end

  def self.before_add_for_run_transitions?(); end

  def self.before_remove_for_run_transitions(); end

  def self.before_remove_for_run_transitions=(val); end

  def self.before_remove_for_run_transitions?(); end

  def self.with_attached_csv_results(*args); end

  def self.with_attached_data_file(*args); end

  def self.with_attached_log_file(*args); end

  def self.with_attached_model_file(*args); end

  def self.with_attached_result_file(*args); end
end

class RunTransition
  include ::RunTransition::GeneratedAttributeMethods
  include ::RunTransition::GeneratedAssociationMethods
  def autosave_associated_records_for_run(*args); end
end

module RunTransition::GeneratedAssociationMethods
  def build_run(*args, &block); end

  def create_run(*args, &block); end

  def create_run!(*args, &block); end

  def reload_run(); end

  def run(); end

  def run=(value); end
end

module RunTransition::GeneratedAssociationMethods
end

module RunTransition::GeneratedAttributeMethods
end

module RunTransition::GeneratedAttributeMethods
  extend ::Mutex_m
end

module SassC
  VERSION = ::T.let(nil, ::T.untyped)
end

class SassC::BaseError
end

class SassC::BaseError
end

class SassC::Dependency
  def filename(); end

  def initialize(filename); end

  def options(); end
end

class SassC::Dependency
  def self.from_filenames(filenames); end
end

class SassC::Engine
  def dependencies(); end

  def filename(); end

  def initialize(template, options=T.unsafe(nil)); end

  def options(); end

  def render(); end

  def source_map(); end

  def template(); end
  OUTPUT_STYLES = ::T.let(nil, ::T.untyped)
end

class SassC::Engine
end

class SassC::FunctionsHandler
  def initialize(options); end

  def setup(native_options, functions: T.unsafe(nil)); end
end

class SassC::FunctionsHandler
end

class SassC::ImportHandler
  def initialize(options); end

  def setup(native_options); end
end

class SassC::ImportHandler
end

class SassC::Importer
  def imports(path, parent_path); end

  def initialize(options); end

  def options(); end
end

class SassC::Importer::Import
  def initialize(path, source: T.unsafe(nil), source_map_path: T.unsafe(nil)); end

  def path(); end

  def path=(path); end

  def source(); end

  def source=(source); end

  def source_map_path(); end

  def source_map_path=(source_map_path); end
end

class SassC::Importer::Import
end

class SassC::Importer
end

class SassC::InvalidStyleError
end

class SassC::InvalidStyleError
end

module SassC::Native
  def _context_get_included_files(*_); end

  def _make_data_context(*_); end

  def boolean_get_value(*_); end

  def color_get_a(*_); end

  def color_get_b(*_); end

  def color_get_g(*_); end

  def color_get_r(*_); end

  def color_set_a(*_); end

  def color_set_b(*_); end

  def color_set_g(*_); end

  def color_set_r(*_); end

  def compile_data_context(*_); end

  def compile_file_context(*_); end

  def compiler_get_last_import(*_); end

  def context_get_error_column(*_); end

  def context_get_error_file(*_); end

  def context_get_error_json(*_); end

  def context_get_error_line(*_); end

  def context_get_error_message(*_); end

  def context_get_error_status(*_); end

  def context_get_options(*_); end

  def context_get_output_string(*_); end

  def context_get_source_map_string(*_); end

  def data_context_get_context(*_); end

  def data_context_get_options(*_); end

  def data_context_set_options(*_); end

  def delete_data_context(*_); end

  def delete_file_context(*_); end

  def error_get_message(*_); end

  def error_set_message(*_); end

  def file_context_get_context(*_); end

  def file_context_get_options(*_); end

  def file_context_set_options(*_); end

  def function_get_cookie(*_); end

  def function_get_function(*_); end

  def function_get_list_entry(*_); end

  def function_get_signature(*_); end

  def function_set_list_entry(*_); end

  def import_get_abs_path(*_); end

  def import_get_imp_path(*_); end

  def import_get_source(*_); end

  def import_set_list_entry(*_); end

  def list_get_length(*_); end

  def list_get_value(*_); end

  def list_set_value(*_); end

  def make_boolean(*_); end

  def make_color(*_); end

  def make_error(*_); end

  def make_file_context(*_); end

  def make_function(*_); end

  def make_function_list(*_); end

  def make_import_entry(*_); end

  def make_import_list(*_); end

  def make_importer(*_); end

  def make_list(*_); end

  def make_map(*_); end

  def make_number(*_); end

  def make_options(*_); end

  def make_qstring(*_); end

  def make_string(*_); end

  def map_get_key(*_); end

  def map_get_length(*_); end

  def map_get_value(*_); end

  def map_set_key(*_); end

  def map_set_value(*_); end

  def number_get_unit(*_); end

  def number_get_value(*_); end

  def option_get_c_functions(*_); end

  def option_get_include_path(*_); end

  def option_get_input_path(*_); end

  def option_get_is_indented_syntax_src(*_); end

  def option_get_omit_source_map_url(*_); end

  def option_get_output_path(*_); end

  def option_get_output_style(*_); end

  def option_get_precision(*_); end

  def option_get_source_comments(*_); end

  def option_get_source_map_contents(*_); end

  def option_get_source_map_embed(*_); end

  def option_get_source_map_file(*_); end

  def option_set_c_functions(*_); end

  def option_set_c_importers(*_); end

  def option_set_include_path(*_); end

  def option_set_input_path(*_); end

  def option_set_is_indented_syntax_src(*_); end

  def option_set_omit_source_map_url(*_); end

  def option_set_output_path(*_); end

  def option_set_output_style(*_); end

  def option_set_precision(*_); end

  def option_set_source_comments(*_); end

  def option_set_source_map_contents(*_); end

  def option_set_source_map_embed(*_); end

  def option_set_source_map_file(*_); end

  def sass2scss(*_); end

  def string_get_value(*_); end

  def string_is_quoted(*_); end

  def value_get_tag(*_); end

  def value_is_null(*_); end

  def version(*_); end
  SassInputStyle = ::T.let(nil, ::T.untyped)
  SassOutputStyle = ::T.let(nil, ::T.untyped)
  SassSeparator = ::T.let(nil, ::T.untyped)
  SassTag = ::T.let(nil, ::T.untyped)
end

class SassC::Native::SassBoolean
end

class SassC::Native::SassBoolean
end

class SassC::Native::SassColor
end

class SassC::Native::SassColor
end

class SassC::Native::SassError
end

class SassC::Native::SassError
end

class SassC::Native::SassList
end

class SassC::Native::SassList
end

class SassC::Native::SassMap
end

class SassC::Native::SassMap
end

class SassC::Native::SassMapPair
end

class SassC::Native::SassMapPair
end

class SassC::Native::SassNull
end

class SassC::Native::SassNull
end

class SassC::Native::SassNumber
end

class SassC::Native::SassNumber
end

class SassC::Native::SassString
end

class SassC::Native::SassString
end

class SassC::Native::SassUnknown
end

class SassC::Native::SassUnknown
end

class SassC::Native::SassValue
end

class SassC::Native::SassValue
end

class SassC::Native::SassWarning
end

class SassC::Native::SassWarning
end

class SassC::Native::StringList
end

class SassC::Native::StringList
end

module SassC::Native
  extend ::FFI::Library
  def self._context_get_included_files(*_); end

  def self._make_data_context(*_); end

  def self.attach_function(*args); end

  def self.boolean_get_value(*_); end

  def self.color_get_a(*_); end

  def self.color_get_b(*_); end

  def self.color_get_g(*_); end

  def self.color_get_r(*_); end

  def self.color_set_a(*_); end

  def self.color_set_b(*_); end

  def self.color_set_g(*_); end

  def self.color_set_r(*_); end

  def self.compile_data_context(*_); end

  def self.compile_file_context(*_); end

  def self.compiler_get_last_import(*_); end

  def self.context_get_error_column(*_); end

  def self.context_get_error_file(*_); end

  def self.context_get_error_json(*_); end

  def self.context_get_error_line(*_); end

  def self.context_get_error_message(*_); end

  def self.context_get_error_status(*_); end

  def self.context_get_included_files(*args); end

  def self.context_get_options(*_); end

  def self.context_get_output_string(*_); end

  def self.context_get_source_map_string(*_); end

  def self.data_context_get_context(*_); end

  def self.data_context_get_options(*_); end

  def self.data_context_set_options(*_); end

  def self.delete_data_context(*_); end

  def self.delete_file_context(*_); end

  def self.error_get_message(*_); end

  def self.error_set_message(*_); end

  def self.file_context_get_context(*_); end

  def self.file_context_get_options(*_); end

  def self.file_context_set_options(*_); end

  def self.function_get_cookie(*_); end

  def self.function_get_function(*_); end

  def self.function_get_list_entry(*_); end

  def self.function_get_signature(*_); end

  def self.function_set_list_entry(*_); end

  def self.import_get_abs_path(*_); end

  def self.import_get_imp_path(*_); end

  def self.import_get_source(*_); end

  def self.import_set_list_entry(*_); end

  def self.list_get_length(*_); end

  def self.list_get_value(*_); end

  def self.list_set_value(*_); end

  def self.make_boolean(*_); end

  def self.make_color(*_); end

  def self.make_data_context(data); end

  def self.make_error(*_); end

  def self.make_file_context(*_); end

  def self.make_function(*_); end

  def self.make_function_list(*_); end

  def self.make_import_entry(*_); end

  def self.make_import_list(*_); end

  def self.make_importer(*_); end

  def self.make_list(*_); end

  def self.make_map(*_); end

  def self.make_number(*_); end

  def self.make_options(*_); end

  def self.make_qstring(*_); end

  def self.make_string(*_); end

  def self.map_get_key(*_); end

  def self.map_get_length(*_); end

  def self.map_get_value(*_); end

  def self.map_set_key(*_); end

  def self.map_set_value(*_); end

  def self.native_string(string); end

  def self.number_get_unit(*_); end

  def self.number_get_value(*_); end

  def self.option_get_c_functions(*_); end

  def self.option_get_include_path(*_); end

  def self.option_get_input_path(*_); end

  def self.option_get_is_indented_syntax_src(*_); end

  def self.option_get_omit_source_map_url(*_); end

  def self.option_get_output_path(*_); end

  def self.option_get_output_style(*_); end

  def self.option_get_precision(*_); end

  def self.option_get_source_comments(*_); end

  def self.option_get_source_map_contents(*_); end

  def self.option_get_source_map_embed(*_); end

  def self.option_get_source_map_file(*_); end

  def self.option_set_c_functions(*_); end

  def self.option_set_c_importers(*_); end

  def self.option_set_include_path(*_); end

  def self.option_set_input_path(*_); end

  def self.option_set_is_indented_syntax_src(*_); end

  def self.option_set_omit_source_map_url(*_); end

  def self.option_set_output_path(*_); end

  def self.option_set_output_style(*_); end

  def self.option_set_precision(*_); end

  def self.option_set_source_comments(*_); end

  def self.option_set_source_map_contents(*_); end

  def self.option_set_source_map_embed(*_); end

  def self.option_set_source_map_file(*_); end

  def self.return_string_array(ptr); end

  def self.sass2scss(*_); end

  def self.string_get_type(native_value); end

  def self.string_get_value(*_); end

  def self.string_is_quoted(*_); end

  def self.value_get_tag(*_); end

  def self.value_is_null(*_); end

  def self.version(*_); end
end

class SassC::NotRenderedError
end

class SassC::NotRenderedError
end

module SassC::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class SassC::Rails::Importer
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  GLOB = ::T.let(nil, ::T.untyped)
  PREFIXS = ::T.let(nil, ::T.untyped)
end

class SassC::Rails::Importer::CSSExtension
  def import_for(full_path, parent_dir, options); end

  def postfix(); end
end

class SassC::Rails::Importer::CSSExtension
end

class SassC::Rails::Importer::CssSassExtension
end

class SassC::Rails::Importer::CssSassExtension
end

class SassC::Rails::Importer::CssScssExtension
end

class SassC::Rails::Importer::CssScssExtension
end

class SassC::Rails::Importer::ERBExtension
end

class SassC::Rails::Importer::ERBExtension
end

class SassC::Rails::Importer::Extension
  def import_for(full_path, parent_dir, options); end

  def initialize(postfix=T.unsafe(nil)); end

  def postfix(); end
end

class SassC::Rails::Importer::Extension
end

class SassC::Rails::Importer::SassERBExtension
end

class SassC::Rails::Importer::SassERBExtension
end

class SassC::Rails::Importer
end

class SassC::Rails::Railtie
end

class SassC::Rails::Railtie
end

class SassC::Rails::SassTemplate
  def config_options(); end

  def line_comments?(); end

  def load_paths(); end

  def safe_merge(_key, left, right); end

  def sass_style(); end
end

module SassC::Rails::SassTemplate::Functions
  def asset_data_url(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def asset_url(path, options=T.unsafe(nil)); end
end

module SassC::Rails::SassTemplate::Functions
end

class SassC::Rails::SassTemplate
end

class SassC::Rails::ScssTemplate
end

class SassC::Rails::ScssTemplate
end

module SassC::Rails
end

class SassC::Sass2Scss
end

class SassC::Sass2Scss
  def self.convert(sass); end
end

module SassC::Script
end

module SassC::Script::Functions
  include ::Sprockets::SassProcessor::Functions
end

module SassC::Script::Functions
end

class SassC::Script::Value
  def ==(other); end

  def _perform(environment); end

  def assert_int!(); end

  def bracketed(); end

  def eql?(other); end

  def initialize(value=T.unsafe(nil)); end

  def null?(); end

  def options(); end

  def options=(options); end

  def separator(); end

  def source_range(); end

  def source_range=(source_range); end

  def to_a(); end

  def to_bool(); end

  def to_h(); end

  def to_i(); end

  def to_s(opts=T.unsafe(nil)); end

  def to_sass(opts=T.unsafe(nil)); end

  def value(); end

  def with_contents(contents, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end
end

class SassC::Script::Value::Bool
  FALSE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class SassC::Script::Value::Bool
  def self.new(value); end
end

class SassC::Script::Value::Color
  def ==(other_color); end

  def alpha(); end

  def alpha_string(); end

  def blue(); end

  def eql?(other_color); end

  def green(); end

  def hlsa?(); end

  def hue(); end

  def initialize(red: T.unsafe(nil), green: T.unsafe(nil), blue: T.unsafe(nil), hue: T.unsafe(nil), saturation: T.unsafe(nil), lightness: T.unsafe(nil), alpha: T.unsafe(nil)); end

  def lightness(); end

  def red(); end

  def rgba?(); end

  def saturation(); end

  def to_s(); end
end

class SassC::Script::Value::Color
end

class SassC::Script::Value::List
  def eq(other); end

  def initialize(value, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end

  def options=(options); end
end

class SassC::Script::Value::List
  def self.assert_valid_index(list, n); end
end

class SassC::Script::Value::Map
  def eq(other); end

  def initialize(hash); end

  def inspect(opts=T.unsafe(nil)); end

  def options=(options); end
end

class SassC::Script::Value::Map
end

class SassC::Script::Value::Number
  def coerce(num_units, den_units); end

  def comparable_to?(other); end

  def denominator_units(); end

  def initialize(value, numerator_units=T.unsafe(nil), denominator_units=T.unsafe(nil)); end

  def inspect(opts=T.unsafe(nil)); end

  def int?(); end

  def is_unit?(unit); end

  def legal_units?(); end

  def numerator_units(); end

  def original(); end

  def original=(original); end

  def unit_str(); end

  def unitless?(); end
  CONVERSION_TABLE = ::T.let(nil, ::T.untyped)
  MUTUALLY_CONVERTIBLE = ::T.let(nil, ::T.untyped)
  NO_UNITS = ::T.let(nil, ::T.untyped)
  OPERATIONS = ::T.let(nil, ::T.untyped)
end

class SassC::Script::Value::Number
  def self.basically_equal?(num1, num2); end

  def self.epsilon(); end

  def self.precision(); end

  def self.precision=(digits); end

  def self.precision_factor(); end

  def self.round(num); end
end

class SassC::Script::Value::String
  def initialize(value, type=T.unsafe(nil)); end

  def plus(other); end

  def type(); end
end

class SassC::Script::Value::String
  def self.quote(contents, opts=T.unsafe(nil)); end
end

class SassC::Script::Value
end

module SassC::Script::ValueConversion
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class SassC::Script::ValueConversion::Base
  def initialize(value); end
end

class SassC::Script::ValueConversion::Base
end

class SassC::Script::ValueConversion::Bool
  def to_native(); end
end

class SassC::Script::ValueConversion::Bool
end

class SassC::Script::ValueConversion::Color
  def to_native(); end
end

class SassC::Script::ValueConversion::Color
end

class SassC::Script::ValueConversion::List
  def to_native(); end
end

class SassC::Script::ValueConversion::List
end

class SassC::Script::ValueConversion::Map
  def to_native(); end
end

class SassC::Script::ValueConversion::Map
end

class SassC::Script::ValueConversion::Number
  def to_native(); end
end

class SassC::Script::ValueConversion::Number
end

class SassC::Script::ValueConversion::String
  def to_native(opts=T.unsafe(nil)); end
end

class SassC::Script::ValueConversion::String
end

module SassC::Script::ValueConversion
  def self.from_native(native_value, options); end

  def self.to_native(value); end
end

module SassC::Script
  def self.custom_functions(functions: T.unsafe(nil)); end

  def self.formatted_function_name(function_name, functions: T.unsafe(nil)); end
end

class SassC::SyntaxError
  def initialize(message, filename: T.unsafe(nil), line: T.unsafe(nil)); end

  def sass_backtrace(); end
end

class SassC::SyntaxError
end

class SassC::UnsupportedValue
end

class SassC::UnsupportedValue
end

module SassC::Util
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class SassC::Util::NormalizedMap
  def [](k); end

  def []=(k, v); end

  def as_stored(); end

  def delete(k); end

  def denormalize(key); end

  def each(&blk); end

  def empty?(); end

  def has_key?(k); end

  def initialize(map=T.unsafe(nil)); end

  def keys(); end

  def map(); end

  def method_missing(method, *args, &block); end

  def normalize(key); end

  def size(); end

  def sort_by(); end

  def to_a(); end

  def to_hash(); end

  def update(map); end

  def values(); end
end

class SassC::Util::NormalizedMap
end

module SassC::Util
  extend ::SassC::Util
end

module SassC
  def self.load_paths(); end
end

ScanError = StringScanner::Error

module Seahorse
end

module Seahorse::Client
end

class Seahorse::Client::AsyncBase
  def close_connection(); end

  def connection(); end

  def connection_errors(); end

  def new_connection(); end
end

class Seahorse::Client::AsyncBase
end

class Seahorse::Client::AsyncResponse
  def context(); end

  def error(); end

  def initialize(options=T.unsafe(nil)); end

  def join!(); end

  def on(range, &block); end

  def on_complete(&block); end

  def wait(); end
end

class Seahorse::Client::AsyncResponse
end

class Seahorse::Client::Base
  include ::Seahorse::Client::HandlerBuilder
  def build_request(operation_name, params=T.unsafe(nil)); end

  def config(); end

  def handlers(); end

  def initialize(plugins, options); end

  def operation_names(); end
end

class Seahorse::Client::Base
  def self.add_plugin(plugin); end

  def self.api(); end

  def self.clear_plugins(); end

  def self.define(options=T.unsafe(nil)); end

  def self.extend(options=T.unsafe(nil)); end

  def self.new(options=T.unsafe(nil)); end

  def self.plugins(); end

  def self.remove_plugin(plugin); end

  def self.set_api(api); end

  def self.set_plugins(plugins); end
end

class Seahorse::Client::BlockIO
  def initialize(&block); end

  def read(bytes=T.unsafe(nil), output_buffer=T.unsafe(nil)); end

  def size(); end

  def write(chunk); end
end

class Seahorse::Client::BlockIO
end

class Seahorse::Client::Configuration
  def add_option(name, default=T.unsafe(nil), &block); end

  def build!(options=T.unsafe(nil)); end
end

class Seahorse::Client::Configuration::DefaultResolver
  def initialize(struct); end

  def resolve(); end

  def respond_to?(method_name, *args); end
end

class Seahorse::Client::Configuration::DefaultResolver
end

class Seahorse::Client::Configuration::Defaults
  def each(&block); end
end

class Seahorse::Client::Configuration::Defaults
end

class Seahorse::Client::Configuration::DynamicDefault
  def block(); end

  def block=(block); end

  def call(*args); end

  def initialize(block=T.unsafe(nil)); end
end

class Seahorse::Client::Configuration::DynamicDefault
end

class Seahorse::Client::Configuration
end

module Seahorse::Client::H2
  DNS_ERROR_MESSAGES = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::H2::Connection
  def close!(); end

  def closed?(); end

  def connect(endpoint); end

  def connection_read_timeout(); end

  def connection_timeout(); end

  def debug_output(msg, type=T.unsafe(nil)); end

  def enable_alpn(); end

  def errors(); end

  def http_wire_trace(); end

  def initialize(options=T.unsafe(nil)); end

  def input_signal_thread(); end

  def input_signal_thread=(input_signal_thread); end

  def logger(); end

  def max_concurrent_streams(); end

  def new_stream(); end

  def ssl_ca_bundle(); end

  def ssl_ca_directory(); end

  def ssl_ca_store(); end

  def ssl_verify_peer(); end

  def ssl_verify_peer?(); end

  def start(stream); end
  CHUNKSIZE = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  SOCKET_FAMILY = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::H2::Connection
end

class Seahorse::Client::H2::Handler
end

class Seahorse::Client::H2::Handler
end

module Seahorse::Client::H2
end

class Seahorse::Client::Handler
  def call(context); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end
end

class Seahorse::Client::Handler
end

module Seahorse::Client::HandlerBuilder
  def handle(*args, &block); end

  def handle_request(*args, &block); end

  def handle_response(*args, &block); end

  def handler(*args, &block); end

  def handler_for(name=T.unsafe(nil), &block); end

  def new_handler(block); end
end

module Seahorse::Client::HandlerBuilder
end

class Seahorse::Client::HandlerList
  include ::Enumerable
  def add(handler_class, options=T.unsafe(nil)); end

  def copy_from(source_list, &block); end

  def each(&block); end

  def entries(); end

  def for(operation); end

  def initialize(options=T.unsafe(nil)); end

  def remove(handler_class); end

  def to_stack(); end
end

class Seahorse::Client::HandlerList
end

class Seahorse::Client::HandlerListEntry
  def copy(options=T.unsafe(nil)); end

  def handler_class(); end

  def initialize(options); end

  def inserted(); end

  def operations(); end

  def priority(); end

  def step(); end

  def weight(); end
  STEPS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::HandlerListEntry
end

module Seahorse::Client::Http
end

class Seahorse::Client::Http::AsyncResponse
  def signal_headers(headers); end
end

class Seahorse::Client::Http::AsyncResponse
end

class Seahorse::Client::Http::Headers
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def each_pair(&block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(headers=T.unsafe(nil)); end

  def key?(key); end

  def keys(); end

  def to_h(); end

  def to_hash(); end

  def update(headers); end

  def values(); end

  def values_at(*keys); end
end

class Seahorse::Client::Http::Headers
end

class Seahorse::Client::Http::Request
  def body(); end

  def body=(io); end

  def body_contents(); end

  def endpoint(); end

  def endpoint=(endpoint); end

  def headers(); end

  def headers=(headers); end

  def http_method(); end

  def http_method=(http_method); end

  def initialize(options=T.unsafe(nil)); end
end

class Seahorse::Client::Http::Request
end

class Seahorse::Client::Http::Response
  def body(); end

  def body=(io); end

  def body_contents(); end

  def error(); end

  def headers(); end

  def headers=(headers); end

  def initialize(options=T.unsafe(nil)); end

  def on_data(&callback); end

  def on_done(status_code_range=T.unsafe(nil), &callback); end

  def on_error(&callback); end

  def on_headers(status_code_range=T.unsafe(nil), &block); end

  def on_success(status_code_range=T.unsafe(nil), &callback); end

  def reset(); end

  def signal_data(chunk); end

  def signal_done(options=T.unsafe(nil)); end

  def signal_error(networking_error); end

  def signal_headers(status_code, headers); end

  def status_code(); end

  def status_code=(status_code); end
end

class Seahorse::Client::Http::Response
end

module Seahorse::Client::Http
end

class Seahorse::Client::Http2ConnectionClosedError
end

class Seahorse::Client::Http2ConnectionClosedError
end

class Seahorse::Client::Http2InitialRequestError
  def initialize(error); end

  def original_error(); end
end

class Seahorse::Client::Http2InitialRequestError
end

class Seahorse::Client::Http2StreamInitializeError
  def initialize(error); end

  def original_error(); end
end

class Seahorse::Client::Http2StreamInitializeError
end

module Seahorse::Client::Logging
end

class Seahorse::Client::Logging::Formatter
  def ==(other); end

  def eql?(other); end

  def format(response); end

  def initialize(pattern, options=T.unsafe(nil)); end

  def max_string_size(); end

  def pattern(); end
end

class Seahorse::Client::Logging::Formatter
  def self.colored(); end

  def self.default(); end

  def self.short(); end
end

class Seahorse::Client::Logging::Handler
end

class Seahorse::Client::Logging::Handler
end

module Seahorse::Client::Logging
end

class Seahorse::Client::ManagedFile
  def open?(); end
end

class Seahorse::Client::ManagedFile
end

module Seahorse::Client::NetHttp
end

class Seahorse::Client::NetHttp::ConnectionPool
  def clean!(); end

  def empty!(); end

  def http_continue_timeout(); end

  def http_idle_timeout(); end

  def http_open_timeout(); end

  def http_proxy(); end

  def http_read_timeout(); end

  def http_wire_trace(); end

  def http_wire_trace?(); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def request(endpoint, request, &block); end

  def session_for(endpoint, &block); end

  def size(); end

  def ssl_ca_bundle(); end

  def ssl_ca_directory(); end

  def ssl_ca_store(); end

  def ssl_verify_peer(); end

  def ssl_verify_peer?(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::ConnectionPool::ExtendedSession
  def finish(); end

  def initialize(http); end

  def last_used(); end

  def request(*args, &block); end
end

class Seahorse::Client::NetHttp::ConnectionPool::ExtendedSession
end

class Seahorse::Client::NetHttp::ConnectionPool
  def self.for(options=T.unsafe(nil)); end

  def self.pools(); end
end

class Seahorse::Client::NetHttp::Handler
  def pool_for(config); end
  DNS_ERROR_MESSAGES = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::Handler::InvalidHttpVerbError
end

class Seahorse::Client::NetHttp::Handler::InvalidHttpVerbError
end

class Seahorse::Client::NetHttp::Handler::TruncatedBodyError
  def initialize(bytes_expected, bytes_received); end
end

class Seahorse::Client::NetHttp::Handler::TruncatedBodyError
end

class Seahorse::Client::NetHttp::Handler
end

module Seahorse::Client::NetHttp::Patches
end

module Seahorse::Client::NetHttp::Patches::Ruby_1_9_3
  def new_transport_request(req); end
end

module Seahorse::Client::NetHttp::Patches::Ruby_1_9_3
end

module Seahorse::Client::NetHttp::Patches::Ruby_2
  def new_transport_request(req); end
end

module Seahorse::Client::NetHttp::Patches::Ruby_2
end

module Seahorse::Client::NetHttp::Patches
  def self.apply!(); end
end

module Seahorse::Client::NetHttp
end

class Seahorse::Client::NetworkingError
  def initialize(error, msg=T.unsafe(nil)); end

  def original_error(); end
end

class Seahorse::Client::NetworkingError
end

class Seahorse::Client::Plugin
  def add_handlers(handlers, config); end

  def add_options(config); end

  def after_initialize(client); end

  def before_initialize(client_class, options); end
end

class Seahorse::Client::Plugin
  extend ::Seahorse::Client::HandlerBuilder
  def self.after_initialize(&block); end

  def self.after_initialize_hooks(); end

  def self.before_initialize(&block); end

  def self.before_initialize_hooks(); end

  def self.handlers(); end

  def self.literal(string); end

  def self.option(name, default=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.options(); end
end

class Seahorse::Client::PluginList
  include ::Enumerable
  def add(plugin); end

  def each(&block); end

  def initialize(plugins=T.unsafe(nil), options=T.unsafe(nil)); end

  def remove(plugin); end

  def set(plugins); end
end

class Seahorse::Client::PluginList::PluginWrapper
  def canonical_name(); end

  def eql?(other); end

  def initialize(plugin); end

  def plugin(); end
end

class Seahorse::Client::PluginList::PluginWrapper
  def self.new(plugin); end
end

class Seahorse::Client::PluginList
end

module Seahorse::Client::Plugins
end

class Seahorse::Client::Plugins::ContentLength
end

class Seahorse::Client::Plugins::ContentLength::Handler
end

class Seahorse::Client::Plugins::ContentLength::Handler
end

class Seahorse::Client::Plugins::ContentLength
end

class Seahorse::Client::Plugins::Endpoint
end

class Seahorse::Client::Plugins::Endpoint::Handler
end

class Seahorse::Client::Plugins::Endpoint::Handler
end

class Seahorse::Client::Plugins::Endpoint
end

class Seahorse::Client::Plugins::H2
end

class Seahorse::Client::Plugins::H2
end

class Seahorse::Client::Plugins::Logging
end

class Seahorse::Client::Plugins::Logging
end

class Seahorse::Client::Plugins::NetHttp
end

class Seahorse::Client::Plugins::NetHttp
end

class Seahorse::Client::Plugins::RaiseResponseErrors
end

class Seahorse::Client::Plugins::RaiseResponseErrors::Handler
end

class Seahorse::Client::Plugins::RaiseResponseErrors::Handler
end

class Seahorse::Client::Plugins::RaiseResponseErrors
end

class Seahorse::Client::Plugins::ResponseTarget
end

class Seahorse::Client::Plugins::ResponseTarget::Handler
end

class Seahorse::Client::Plugins::ResponseTarget::Handler
end

class Seahorse::Client::Plugins::ResponseTarget
end

module Seahorse::Client::Plugins
end

class Seahorse::Client::Request
  include ::Seahorse::Client::HandlerBuilder
  def context(); end

  def handlers(); end

  def initialize(handlers, context); end

  def send_request(options=T.unsafe(nil), &block); end
end

class Seahorse::Client::Request
end

class Seahorse::Client::RequestContext
  def [](key); end

  def []=(key, value); end

  def authorizer(); end

  def authorizer=(authorizer); end

  def client(); end

  def client=(client); end

  def config(); end

  def config=(config); end

  def http_request(); end

  def http_request=(http_request); end

  def http_response(); end

  def http_response=(http_response); end

  def initialize(options=T.unsafe(nil)); end

  def metadata(); end

  def operation(); end

  def operation=(operation); end

  def operation_name(); end

  def operation_name=(operation_name); end

  def params(); end

  def params=(params); end

  def retries(); end

  def retries=(retries); end
end

class Seahorse::Client::RequestContext
end

class Seahorse::Client::Response
  def context(); end

  def data(); end

  def data=(data); end

  def error(); end

  def error=(error); end

  def initialize(options=T.unsafe(nil)); end

  def on(range, &_block); end

  def on_complete(&block); end

  def on_success(&block); end

  def successful?(); end
end

class Seahorse::Client::Response
end

module Seahorse::Client
end

module Seahorse::Model
end

module Seahorse::Model::Shapes
end

module Seahorse::Model::Shapes
end

module Seahorse::Model
end

module Seahorse::Util
end

module Seahorse::Util
  def self.uri_escape(string); end

  def self.uri_path_escape(path); end
end

module Seahorse
end

module SecureRandom
  BASE36_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE58_ALPHABET = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  def self.base36(n=T.unsafe(nil)); end

  def self.base58(n=T.unsafe(nil)); end
end

module Selenium
end

module Selenium::WebDriver
  VERSION = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::ActionBuilder
  def click(element=T.unsafe(nil)); end

  def click_and_hold(element=T.unsafe(nil)); end

  def context_click(element=T.unsafe(nil)); end

  def double_click(element=T.unsafe(nil)); end

  def drag_and_drop(source, target); end

  def drag_and_drop_by(source, right_by, down_by); end

  def initialize(mouse, keyboard); end

  def key_down(*args); end

  def key_up(*args); end

  def move_by(right_by, down_by); end

  def move_to(element, right_by=T.unsafe(nil), down_by=T.unsafe(nil)); end

  def perform(); end

  def release(element=T.unsafe(nil)); end

  def send_keys(*args); end
end

class Selenium::WebDriver::ActionBuilder
end

class Selenium::WebDriver::Alert
  def accept(); end

  def dismiss(); end

  def initialize(bridge); end

  def send_keys(keys); end

  def text(); end
end

class Selenium::WebDriver::Alert
end

module Selenium::WebDriver::Atoms
end

module Selenium::WebDriver::Atoms
end

module Selenium::WebDriver::BridgeHelper
  def element_id_from(id); end

  def parse_cookie_string(str); end

  def unwrap_script_result(arg); end
end

module Selenium::WebDriver::BridgeHelper
end

module Selenium::WebDriver::Chrome
end

module Selenium::WebDriver::Chrome::Bridge
  def available_log_types(); end

  def commands(command); end

  def log(type); end

  def network_conditions(); end

  def network_conditions=(conditions); end

  def send_command(command_params); end
  COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Chrome::Bridge
end

class Selenium::WebDriver::Chrome::Driver
  include ::Selenium::WebDriver::DriverExtensions::HasNetworkConditions
  include ::Selenium::WebDriver::DriverExtensions::HasTouchScreen
  include ::Selenium::WebDriver::DriverExtensions::HasWebStorage
  include ::Selenium::WebDriver::DriverExtensions::HasLocation
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  include ::Selenium::WebDriver::DriverExtensions::DownloadsFiles
  def execute_cdp(cmd, **params); end

  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Chrome::Driver
end

class Selenium::WebDriver::Chrome::Options
  def add_argument(arg); end

  def add_emulation(device_name: T.unsafe(nil), device_metrics: T.unsafe(nil), user_agent: T.unsafe(nil)); end

  def add_encoded_extension(encoded); end

  def add_extension(path); end

  def add_option(name, value); end

  def add_preference(name, value); end

  def args(); end

  def as_json(*_); end

  def binary(); end

  def binary=(binary); end

  def detach(); end

  def detach=(detach); end

  def emulation(); end

  def encoded_extensions(); end

  def extensions(); end

  def headless!(); end

  def initialize(**opts); end

  def options(); end

  def prefs(); end

  def profile(); end

  def profile=(profile); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chrome::Options
end

class Selenium::WebDriver::Chrome::Profile
  include ::Selenium::WebDriver::ProfileHelper
  def [](key); end

  def []=(key, value); end

  def add_encoded_extension(encoded); end

  def add_extension(path); end

  def directory(); end

  def initialize(model=T.unsafe(nil)); end

  def layout_on_disk(); end
end

class Selenium::WebDriver::Chrome::Profile
  extend ::Selenium::WebDriver::ProfileHelper::ClassMethods
end

class Selenium::WebDriver::Chrome::Service
end

class Selenium::WebDriver::Chrome::Service
end

module Selenium::WebDriver::Chrome
  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.path(); end

  def self.path=(path); end
end

module Selenium::WebDriver::Common
end

class Selenium::WebDriver::Common::Options
end

class Selenium::WebDriver::Common::Options
end

module Selenium::WebDriver::Common
end

class Selenium::WebDriver::Dimension
  def height(); end

  def height=(_); end

  def width(); end

  def width=(_); end
end

class Selenium::WebDriver::Dimension
  def self.[](*_); end

  def self.members(); end
end

class Selenium::WebDriver::Driver
  include ::Selenium::WebDriver::SearchContext
  def [](sel); end

  def action(); end

  def all(*args); end

  def browser(); end

  def capabilities(); end

  def close(); end

  def current_url(); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def first(*args); end

  def get(url); end

  def initialize(bridge, listener: T.unsafe(nil)); end

  def keyboard(); end

  def manage(); end

  def mouse(); end

  def navigate(); end

  def page_source(); end

  def quit(); end

  def ref(); end

  def script(script, *args); end

  def switch_to(); end

  def title(); end

  def window_handle(); end

  def window_handles(); end
end

class Selenium::WebDriver::Driver
  def self.for(browser, opts=T.unsafe(nil)); end
end

module Selenium::WebDriver::DriverExtensions
end

module Selenium::WebDriver::DriverExtensions::DownloadsFiles
  def download_path=(path); end
end

module Selenium::WebDriver::DriverExtensions::DownloadsFiles
end

module Selenium::WebDriver::DriverExtensions::HasAddons
  def install_addon(path, temporary=T.unsafe(nil)); end

  def uninstall_addon(id); end
end

module Selenium::WebDriver::DriverExtensions::HasAddons
end

module Selenium::WebDriver::DriverExtensions::HasDebugger
  def attach_debugger(); end
end

module Selenium::WebDriver::DriverExtensions::HasDebugger
end

module Selenium::WebDriver::DriverExtensions::HasLocation
  def location(); end

  def location=(loc); end

  def set_location(lat, lon, alt); end
end

module Selenium::WebDriver::DriverExtensions::HasLocation
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConditions
  def network_conditions(); end

  def network_conditions=(conditions); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConditions
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConnection
  def network_connection_type(); end

  def network_connection_type=(connection_type); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConnection
end

module Selenium::WebDriver::DriverExtensions::HasPermissions
  def permissions(); end

  def permissions=(permissions); end
end

module Selenium::WebDriver::DriverExtensions::HasPermissions
end

module Selenium::WebDriver::DriverExtensions::HasRemoteStatus
  def remote_status(); end
end

module Selenium::WebDriver::DriverExtensions::HasRemoteStatus
end

module Selenium::WebDriver::DriverExtensions::HasSessionId
  def session_id(); end
end

module Selenium::WebDriver::DriverExtensions::HasSessionId
end

module Selenium::WebDriver::DriverExtensions::HasTouchScreen
  def touch(); end
end

module Selenium::WebDriver::DriverExtensions::HasTouchScreen
end

module Selenium::WebDriver::DriverExtensions::HasWebStorage
  def local_storage(); end

  def session_storage(); end
end

module Selenium::WebDriver::DriverExtensions::HasWebStorage
end

module Selenium::WebDriver::DriverExtensions::Rotatable
  def orientation(); end

  def rotate(orientation); end

  def rotation=(orientation); end
  ORIENTATIONS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::DriverExtensions::Rotatable
end

module Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def save_screenshot(png_path); end

  def screenshot_as(format); end
end

module Selenium::WebDriver::DriverExtensions::TakesScreenshot
end

module Selenium::WebDriver::DriverExtensions::UploadsFiles
  def file_detector=(detector); end
end

module Selenium::WebDriver::DriverExtensions::UploadsFiles
end

module Selenium::WebDriver::DriverExtensions
end

module Selenium::WebDriver::Edge
end

module Selenium::WebDriver::Edge::Bridge
  def commands(command); end

  def maximize_window(handle=T.unsafe(nil)); end

  def reposition_window(x, y, handle=T.unsafe(nil)); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def send_keys_to_active_element(key); end

  def window_handle(); end

  def window_position(handle=T.unsafe(nil)); end

  def window_size(handle=T.unsafe(nil)); end
end

module Selenium::WebDriver::Edge::Bridge
end

class Selenium::WebDriver::Edge::Driver
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Edge::Driver
end

class Selenium::WebDriver::Edge::Options
  def add_extension_path(path); end

  def as_json(*_); end

  def extension_paths(); end

  def in_private(); end

  def in_private=(in_private); end

  def initialize(**opts); end

  def start_page(); end

  def start_page=(start_page); end
end

class Selenium::WebDriver::Edge::Options
end

class Selenium::WebDriver::Edge::Service
end

class Selenium::WebDriver::Edge::Service
end

module Selenium::WebDriver::Edge
  def self.driver_path(); end

  def self.driver_path=(path); end
end

class Selenium::WebDriver::Element
  include ::Selenium::WebDriver::SearchContext
  def ==(other); end

  def [](name); end

  def all(*args); end

  def as_json(*_); end

  def attribute(name); end

  def clear(); end

  def click(); end

  def css_value(prop); end

  def displayed?(); end

  def enabled?(); end

  def eql?(other); end

  def first(*args); end

  def initialize(bridge, id); end

  def location(); end

  def location_once_scrolled_into_view(); end

  def property(name); end

  def rect(); end

  def ref(); end

  def selected?(); end

  def send_key(*args); end

  def send_keys(*args); end

  def size(); end

  def style(prop); end

  def submit(); end

  def tag_name(); end

  def text(); end

  def to_json(*_); end
end

class Selenium::WebDriver::Element
end

module Selenium::WebDriver::Error
  DEPRECATED_ERRORS = ::T.let(nil, ::T.untyped)
  ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Error::ElementClickInterceptedError
end

class Selenium::WebDriver::Error::ElementClickInterceptedError
end

class Selenium::WebDriver::Error::ElementNotInteractableError
end

class Selenium::WebDriver::Error::ElementNotInteractableError
end

class Selenium::WebDriver::Error::InsecureCertificateError
end

class Selenium::WebDriver::Error::InsecureCertificateError
end

class Selenium::WebDriver::Error::InvalidArgumentError
end

class Selenium::WebDriver::Error::InvalidArgumentError
end

class Selenium::WebDriver::Error::InvalidCookieDomainError
end

class Selenium::WebDriver::Error::InvalidCookieDomainError
end

class Selenium::WebDriver::Error::InvalidSelectorError
end

class Selenium::WebDriver::Error::InvalidSelectorError
end

class Selenium::WebDriver::Error::InvalidSessionIdError
end

class Selenium::WebDriver::Error::InvalidSessionIdError
end

class Selenium::WebDriver::Error::JavascriptError
end

class Selenium::WebDriver::Error::JavascriptError
end

class Selenium::WebDriver::Error::MoveTargetOutOfBoundsError
end

class Selenium::WebDriver::Error::MoveTargetOutOfBoundsError
end

class Selenium::WebDriver::Error::NoSuchAlertError
end

class Selenium::WebDriver::Error::NoSuchAlertError
end

class Selenium::WebDriver::Error::NoSuchCookieError
end

class Selenium::WebDriver::Error::NoSuchCookieError
end

class Selenium::WebDriver::Error::NoSuchElementError
end

class Selenium::WebDriver::Error::NoSuchElementError
end

class Selenium::WebDriver::Error::NoSuchFrameError
end

class Selenium::WebDriver::Error::NoSuchFrameError
end

class Selenium::WebDriver::Error::NoSuchWindowError
end

class Selenium::WebDriver::Error::NoSuchWindowError
end

class Selenium::WebDriver::Error::NullPointerError
end

class Selenium::WebDriver::Error::NullPointerError
end

class Selenium::WebDriver::Error::ScriptTimeoutError
end

class Selenium::WebDriver::Error::ScriptTimeoutError
end

class Selenium::WebDriver::Error::ScriptTimeoutError
end

class Selenium::WebDriver::Error::ScriptTimeoutError
end

class Selenium::WebDriver::Error::ServerError
  def initialize(response); end
end

class Selenium::WebDriver::Error::ServerError
end

class Selenium::WebDriver::Error::SessionNotCreatedError
end

class Selenium::WebDriver::Error::SessionNotCreatedError
end

class Selenium::WebDriver::Error::StaleElementReferenceError
end

class Selenium::WebDriver::Error::StaleElementReferenceError
end

class Selenium::WebDriver::Error::TimeoutError
end

class Selenium::WebDriver::Error::TimeoutError
end

class Selenium::WebDriver::Error::TimeoutError
end

class Selenium::WebDriver::Error::TimeoutError
end

class Selenium::WebDriver::Error::UnableToCaptureScreenError
end

class Selenium::WebDriver::Error::UnableToCaptureScreenError
end

class Selenium::WebDriver::Error::UnableToSetCookieError
end

class Selenium::WebDriver::Error::UnableToSetCookieError
end

class Selenium::WebDriver::Error::UnexpectedAlertOpenError
end

class Selenium::WebDriver::Error::UnexpectedAlertOpenError
end

class Selenium::WebDriver::Error::UnknownCommandError
end

class Selenium::WebDriver::Error::UnknownCommandError
end

class Selenium::WebDriver::Error::UnknownError
end

class Selenium::WebDriver::Error::UnknownError
end

class Selenium::WebDriver::Error::UnknownMethodError
end

class Selenium::WebDriver::Error::UnknownMethodError
end

class Selenium::WebDriver::Error::UnsupportedOperationError
end

class Selenium::WebDriver::Error::UnsupportedOperationError
end

class Selenium::WebDriver::Error::WebDriverError
end

class Selenium::WebDriver::Error::WebDriverError
end

module Selenium::WebDriver::Error
  def self.const_missing(const_name); end

  def self.for_code(code); end
end

module Selenium::WebDriver::FileReaper
end

module Selenium::WebDriver::FileReaper
  def self.<<(file); end

  def self.reap(file); end

  def self.reap!(); end

  def self.reap=(reap); end

  def self.reap?(); end

  def self.tmp_files(); end
end

module Selenium::WebDriver::Firefox
  DEFAULT_ASSUME_UNTRUSTED_ISSUER = ::T.let(nil, ::T.untyped)
  DEFAULT_ENABLE_NATIVE_EVENTS = ::T.let(nil, ::T.untyped)
  DEFAULT_LOAD_NO_FOCUS_LIB = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_SECURE_SSL = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Binary
  def quit(); end

  def start_with(profile, profile_path, *args); end

  def wait(); end
  NO_FOCUS_LIBRARIES = ::T.let(nil, ::T.untyped)
  NO_FOCUS_LIBRARY_NAME = ::T.let(nil, ::T.untyped)
  QUIT_TIMEOUT = ::T.let(nil, ::T.untyped)
  WAIT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Binary
  def self.path(); end

  def self.path=(path); end

  def self.reset_path!(); end

  def self.version(); end
end

module Selenium::WebDriver::Firefox::Driver
end

module Selenium::WebDriver::Firefox::Driver
  def self.new(**opts); end
end

class Selenium::WebDriver::Firefox::Extension
  def initialize(path); end

  def write_to(extensions_dir); end
  NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Extension
end

class Selenium::WebDriver::Firefox::Launcher
  def assert_profile(); end

  def connect_until_stable(); end

  def create_profile(); end

  def fetch_profile(); end

  def find_free_port(); end

  def initialize(binary, port, profile=T.unsafe(nil)); end

  def launch(); end

  def quit(); end

  def socket_lock(); end

  def start(); end

  def url(); end
  SOCKET_LOCK_TIMEOUT = ::T.let(nil, ::T.untyped)
  STABLE_CONNECTION_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Launcher
end

module Selenium::WebDriver::Firefox::Legacy
end

class Selenium::WebDriver::Firefox::Legacy::Driver
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Firefox::Legacy::Driver
end

module Selenium::WebDriver::Firefox::Legacy
end

module Selenium::WebDriver::Firefox::Marionette
end

module Selenium::WebDriver::Firefox::Marionette::Bridge
  def commands(command); end

  def install_addon(path, temporary); end

  def uninstall_addon(id); end
  COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Firefox::Marionette::Bridge
end

class Selenium::WebDriver::Firefox::Marionette::Driver
  include ::Selenium::WebDriver::DriverExtensions::HasAddons
  include ::Selenium::WebDriver::DriverExtensions::HasWebStorage
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Firefox::Marionette::Driver
end

module Selenium::WebDriver::Firefox::Marionette
end

class Selenium::WebDriver::Firefox::Options
  def add_argument(arg); end

  def add_option(name, value); end

  def add_preference(name, value); end

  def args(); end

  def as_json(*_); end

  def binary(); end

  def binary=(binary); end

  def headless!(); end

  def initialize(**opts); end

  def log_level(); end

  def log_level=(log_level); end

  def options(); end

  def prefs(); end

  def profile(); end

  def profile=(profile); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Options
end

class Selenium::WebDriver::Firefox::Profile
  include ::Selenium::WebDriver::ProfileHelper
  def []=(key, value); end

  def add_extension(path, name=T.unsafe(nil)); end

  def add_webdriver_extension(); end

  def assume_untrusted_certificate_issuer=(bool); end

  def assume_untrusted_certificate_issuer?(); end

  def encoded(); end

  def initialize(model=T.unsafe(nil)); end

  def layout_on_disk(); end

  def load_no_focus_lib=(load_no_focus_lib); end

  def load_no_focus_lib?(); end

  def log_file(); end

  def log_file=(file); end

  def name(); end

  def native_events=(native_events); end

  def native_events?(); end

  def port=(port); end

  def proxy=(proxy); end

  def secure_ssl=(secure_ssl); end

  def secure_ssl?(); end
  VALID_PREFERENCE_TYPES = ::T.let(nil, ::T.untyped)
  WEBDRIVER_EXTENSION_PATH = ::T.let(nil, ::T.untyped)
  WEBDRIVER_PREFS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Profile
  extend ::Selenium::WebDriver::ProfileHelper::ClassMethods
  def self.default_preferences(); end

  def self.from_name(name); end

  def self.ini(); end
end

class Selenium::WebDriver::Firefox::ProfilesIni
  def [](name); end

  def refresh(); end
end

class Selenium::WebDriver::Firefox::ProfilesIni
end

class Selenium::WebDriver::Firefox::Service
end

class Selenium::WebDriver::Firefox::Service
end

module Selenium::WebDriver::Firefox::Util
end

module Selenium::WebDriver::Firefox::Util
  def self.app_data_path(); end

  def self.stringified?(str); end
end

module Selenium::WebDriver::Firefox
  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.path=(path); end
end

module Selenium::WebDriver::HTML5
end

class Selenium::WebDriver::HTML5::LocalStorage
  include ::Selenium::WebDriver::HTML5::SharedWebStorage
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def initialize(bridge); end

  def keys(); end

  def size(); end
end

class Selenium::WebDriver::HTML5::LocalStorage
end

class Selenium::WebDriver::HTML5::SessionStorage
  include ::Selenium::WebDriver::HTML5::SharedWebStorage
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def initialize(bridge); end

  def keys(); end

  def size(); end
end

class Selenium::WebDriver::HTML5::SessionStorage
end

module Selenium::WebDriver::HTML5::SharedWebStorage
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def each(&blk); end

  def empty?(); end

  def fetch(key); end

  def has_key?(key); end

  def key?(key); end

  def member?(key); end
end

module Selenium::WebDriver::HTML5::SharedWebStorage
end

module Selenium::WebDriver::HTML5
end

module Selenium::WebDriver::IE
end

class Selenium::WebDriver::IE::Driver
  include ::Selenium::WebDriver::DriverExtensions::HasWebStorage
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::IE::Driver
end

class Selenium::WebDriver::IE::Options
  def add_argument(arg); end

  def add_option(name, value); end

  def args(); end

  def as_json(*_); end

  def browser_attach_timeout(); end

  def browser_attach_timeout=(value); end

  def element_scroll_behavior(); end

  def element_scroll_behavior=(value); end

  def ensure_clean_session(); end

  def ensure_clean_session=(value); end

  def file_upload_dialog_timeout(); end

  def file_upload_dialog_timeout=(value); end

  def force_create_process_api(); end

  def force_create_process_api=(value); end

  def force_shell_windows_api(); end

  def force_shell_windows_api=(value); end

  def full_page_screenshot(); end

  def full_page_screenshot=(value); end

  def ignore_protected_mode_settings(); end

  def ignore_protected_mode_settings=(value); end

  def ignore_zoom_level(); end

  def ignore_zoom_level=(value); end

  def initial_browser_url(); end

  def initial_browser_url=(value); end

  def initialize(**opts); end

  def native_events(); end

  def native_events=(value); end

  def options(); end

  def persistent_hover(); end

  def persistent_hover=(value); end

  def require_window_focus(); end

  def require_window_focus=(value); end

  def use_per_process_proxy(); end

  def use_per_process_proxy=(value); end

  def validate_cookie_document_type(); end

  def validate_cookie_document_type=(value); end
  CAPABILITIES = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  SCROLL_BOTTOM = ::T.let(nil, ::T.untyped)
  SCROLL_TOP = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::IE::Options
end

class Selenium::WebDriver::IE::Service
end

class Selenium::WebDriver::IE::Service
end

module Selenium::WebDriver::IE
  def self.driver_path(); end

  def self.driver_path=(path); end
end

module Selenium::WebDriver::Interactions
  KEY = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SOURCE_TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::InputDevice
  def actions(); end

  def add_action(action); end

  def clear_actions(); end

  def create_pause(duration=T.unsafe(nil)); end

  def initialize(name=T.unsafe(nil)); end

  def name(); end

  def no_actions?(); end
end

class Selenium::WebDriver::Interactions::InputDevice
end

class Selenium::WebDriver::Interactions::Interaction
  def initialize(source); end

  def source(); end
  PAUSE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::Interaction
end

class Selenium::WebDriver::Interactions::KeyInput
  def create_key_down(key); end

  def create_key_up(key); end

  def encode(); end

  def type(); end
  SUBTYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::KeyInput::TypingInteraction
  def assert_type(type); end

  def encode(); end

  def initialize(source, type, key); end

  def type(); end
end

class Selenium::WebDriver::Interactions::KeyInput::TypingInteraction
end

class Selenium::WebDriver::Interactions::KeyInput
end

class Selenium::WebDriver::Interactions::NoneInput
  def encode(); end

  def type(); end
end

class Selenium::WebDriver::Interactions::NoneInput
end

class Selenium::WebDriver::Interactions::Pause
  def encode(); end

  def initialize(source, duration=T.unsafe(nil)); end

  def type(); end
end

class Selenium::WebDriver::Interactions::Pause
end

class Selenium::WebDriver::Interactions::PointerCancel
  def encode(); end

  def type(); end
end

class Selenium::WebDriver::Interactions::PointerCancel
end

class Selenium::WebDriver::Interactions::PointerInput
  def assert_kind(pointer); end

  def create_pointer_cancel(); end

  def create_pointer_down(button); end

  def create_pointer_move(duration: T.unsafe(nil), x: T.unsafe(nil), y: T.unsafe(nil), element: T.unsafe(nil), origin: T.unsafe(nil)); end

  def create_pointer_up(button); end

  def encode(); end

  def initialize(kind, name: T.unsafe(nil)); end

  def kind(); end

  def type(); end
  KIND = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerInput
end

class Selenium::WebDriver::Interactions::PointerMove
  def encode(); end

  def initialize(source, duration, x, y, element: T.unsafe(nil), origin: T.unsafe(nil)); end

  def type(); end
  ORIGINS = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  VIEWPORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerMove
end

class Selenium::WebDriver::Interactions::PointerPress
  def assert_button(button); end

  def assert_direction(direction); end

  def encode(); end

  def initialize(source, direction, button); end

  def type(); end
  BUTTONS = ::T.let(nil, ::T.untyped)
  DIRECTIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerPress
end

module Selenium::WebDriver::Interactions
  def self.key(name); end

  def self.none(name=T.unsafe(nil)); end

  def self.pointer(kind, **kwargs); end
end

module Selenium::WebDriver::KeyActions
  def key_down(*args, device: T.unsafe(nil)); end

  def key_up(*args, device: T.unsafe(nil)); end

  def send_keys(*args, device: T.unsafe(nil)); end
end

module Selenium::WebDriver::KeyActions
end

class Selenium::WebDriver::Keyboard
  def initialize(bridge); end

  def press(key); end

  def release(key); end

  def send_keys(*keys); end
  MODIFIERS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Keyboard
end

module Selenium::WebDriver::Keys
  KEYS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Keys
  def self.[](key); end

  def self.encode(keys); end

  def self.encode_key(key); end
end

class Selenium::WebDriver::Location
  def altitude(); end

  def altitude=(_); end

  def latitude(); end

  def latitude=(_); end

  def longitude(); end

  def longitude=(_); end
end

class Selenium::WebDriver::Location
  def self.[](*_); end

  def self.members(); end
end

class Selenium::WebDriver::LogEntry
  def as_json(*_); end

  def initialize(level, timestamp, message); end

  def level(); end

  def message(); end

  def time(); end

  def timestamp(); end
end

class Selenium::WebDriver::LogEntry
end

class Selenium::WebDriver::Logger
  def close(*args, &block); end

  def debug(*args, &block); end

  def debug?(*args, &block); end

  def deprecate(old, new=T.unsafe(nil)); end

  def error(*args, &block); end

  def error?(*args, &block); end

  def fatal(*args, &block); end

  def fatal?(*args, &block); end

  def info(*args, &block); end

  def info?(*args, &block); end

  def io(); end

  def level(*args, &block); end

  def level=(*args, &block); end

  def output=(io); end

  def warn(*args, &block); end

  def warn?(*args, &block); end
end

class Selenium::WebDriver::Logger
  extend ::Forwardable
end

class Selenium::WebDriver::Logs
  def available_types(); end

  def get(type); end

  def initialize(bridge); end
end

class Selenium::WebDriver::Logs
end

class Selenium::WebDriver::Manager
  def add_cookie(opts=T.unsafe(nil)); end

  def all_cookies(); end

  def cookie_named(name); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def initialize(bridge); end

  def logs(); end

  def new_window(type=T.unsafe(nil)); end

  def timeouts(); end

  def window(); end
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Manager
end

class Selenium::WebDriver::Mouse
  def click(element=T.unsafe(nil)); end

  def context_click(element=T.unsafe(nil)); end

  def double_click(element=T.unsafe(nil)); end

  def down(element=T.unsafe(nil)); end

  def initialize(bridge); end

  def move_by(right_by, down_by); end

  def move_to(element, right_by=T.unsafe(nil), down_by=T.unsafe(nil)); end

  def up(element=T.unsafe(nil)); end
end

class Selenium::WebDriver::Mouse
end

class Selenium::WebDriver::Navigation
  def back(); end

  def forward(); end

  def initialize(bridge); end

  def refresh(); end

  def to(url); end
end

class Selenium::WebDriver::Navigation
end

module Selenium::WebDriver::Platform
end

module Selenium::WebDriver::Platform
  def self.assert_executable(path); end

  def self.assert_file(path); end

  def self.bitsize(); end

  def self.ci(); end

  def self.cygwin?(); end

  def self.cygwin_path(path, **opts); end

  def self.engine(); end

  def self.exit_hook(); end

  def self.find_binary(*binary_names); end

  def self.find_in_program_files(*binary_names); end

  def self.home(); end

  def self.interfaces(); end

  def self.ip(); end

  def self.jruby?(); end

  def self.linux?(); end

  def self.localhost(); end

  def self.mac?(); end

  def self.make_writable(file); end

  def self.null_device(); end

  def self.os(); end

  def self.ruby_version(); end

  def self.unix_path(path); end

  def self.windows?(); end

  def self.windows_path(path); end

  def self.wrap_in_quotes_if_necessary(str); end

  def self.wsl?(); end
end

class Selenium::WebDriver::Point
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Selenium::WebDriver::Point
  def self.[](*_); end

  def self.members(); end
end

module Selenium::WebDriver::PointerActions
  def click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def click_and_hold(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def context_click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def default_move_duration(); end

  def default_move_duration=(default_move_duration); end

  def double_click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def drag_and_drop(source, target, device: T.unsafe(nil)); end

  def drag_and_drop_by(source, right_by, down_by, device: T.unsafe(nil)); end

  def move_by(right_by, down_by, device: T.unsafe(nil)); end

  def move_to(element, right_by=T.unsafe(nil), down_by=T.unsafe(nil), device: T.unsafe(nil)); end

  def move_to_location(x, y, device: T.unsafe(nil)); end

  def pointer_down(button, device: T.unsafe(nil)); end

  def pointer_up(button, device: T.unsafe(nil)); end

  def release(device: T.unsafe(nil)); end
end

module Selenium::WebDriver::PointerActions
end

class Selenium::WebDriver::PortProber
  IGNORED_ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::PortProber
  def self.above(port); end

  def self.free?(port); end
end

module Selenium::WebDriver::ProfileHelper
  def as_json(*_); end

  def to_json(*_); end
end

module Selenium::WebDriver::ProfileHelper::ClassMethods
  def from_json(json); end
end

module Selenium::WebDriver::ProfileHelper::ClassMethods
end

module Selenium::WebDriver::ProfileHelper
  def self.included(base); end
end

class Selenium::WebDriver::Proxy
  def ==(other); end

  def as_json(*_); end

  def auto_detect(); end

  def auto_detect=(bool); end

  def eql?(other); end

  def ftp(); end

  def ftp=(value); end

  def http(); end

  def http=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def no_proxy(); end

  def no_proxy=(value); end

  def pac(); end

  def pac=(url); end

  def socks(); end

  def socks=(value); end

  def socks_password(); end

  def socks_password=(value); end

  def socks_username(); end

  def socks_username=(value); end

  def socks_version(); end

  def socks_version=(value); end

  def ssl(); end

  def ssl=(value); end

  def to_json(*_); end

  def type(); end

  def type=(type); end
  ALLOWED = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Proxy
  def self.json_create(data); end
end

class Selenium::WebDriver::Rectangle
  def height(); end

  def height=(_); end

  def width(); end

  def width=(_); end

  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Selenium::WebDriver::Rectangle
  def self.[](*_); end

  def self.members(); end
end

module Selenium::WebDriver::Remote
end

class Selenium::WebDriver::Remote::Bridge
  include ::Selenium::WebDriver::Atoms
  include ::Selenium::WebDriver::BridgeHelper
  def browser(); end

  def capabilities(); end

  def context(); end

  def context=(context); end

  def create_session(desired_capabilities, options=T.unsafe(nil)); end

  def dialect(); end

  def file_detector(); end

  def file_detector=(file_detector); end

  def http(); end

  def http=(http); end

  def initialize(opts=T.unsafe(nil)); end

  def session_id(); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Bridge
  def self.handshake(**opts); end
end

class Selenium::WebDriver::Remote::Capabilities
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def as_json(*_); end

  def browser_name(); end

  def browser_name=(value); end

  def capabilities(); end

  def css_selectors_enabled(); end

  def css_selectors_enabled=(value); end

  def css_selectors_enabled?(); end

  def eql?(other); end

  def firefox_profile(); end

  def firefox_profile=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def javascript_enabled(); end

  def javascript_enabled=(value); end

  def javascript_enabled?(); end

  def merge!(other); end

  def native_events(); end

  def native_events=(value); end

  def native_events?(); end

  def platform(); end

  def platform=(value); end

  def proxy(); end

  def proxy=(proxy); end

  def rotatable(); end

  def rotatable=(value); end

  def rotatable?(); end

  def takes_screenshot(); end

  def takes_screenshot=(value); end

  def takes_screenshot?(); end

  def to_json(*_); end

  def version(); end

  def version=(value); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Capabilities
  def self.chrome(opts=T.unsafe(nil)); end

  def self.edge(opts=T.unsafe(nil)); end

  def self.firefox(opts=T.unsafe(nil)); end

  def self.firefox_legacy(opts=T.unsafe(nil)); end

  def self.htmlunit(opts=T.unsafe(nil)); end

  def self.htmlunitwithjs(opts=T.unsafe(nil)); end

  def self.ie(opts=T.unsafe(nil)); end

  def self.internet_explorer(opts=T.unsafe(nil)); end

  def self.json_create(data); end

  def self.phantomjs(opts=T.unsafe(nil)); end

  def self.safari(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Remote::Driver
  include ::Selenium::WebDriver::DriverExtensions::UploadsFiles
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  include ::Selenium::WebDriver::DriverExtensions::HasSessionId
  include ::Selenium::WebDriver::DriverExtensions::Rotatable
  include ::Selenium::WebDriver::DriverExtensions::HasRemoteStatus
  include ::Selenium::WebDriver::DriverExtensions::HasWebStorage
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Remote::Driver
end

module Selenium::WebDriver::Remote::Http
end

class Selenium::WebDriver::Remote::Http::Common
  def call(verb, url, command_hash); end

  def close(); end

  def quit_errors(); end

  def server_url=(server_url); end

  def timeout(); end

  def timeout=(timeout); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_HEADERS = ::T.let(nil, ::T.untyped)
  MAX_REDIRECTS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Common
end

class Selenium::WebDriver::Remote::Http::Default
  def initialize(open_timeout: T.unsafe(nil), read_timeout: T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def proxy=(proxy); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def timeout=(value); end
  MAX_RETRIES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Default
end

module Selenium::WebDriver::Remote::Http
end

module Selenium::WebDriver::Remote::OSS
end

class Selenium::WebDriver::Remote::OSS::Bridge
  def accept_alert(); end

  def action(); end

  def active_element(); end

  def add_cookie(cookie); end

  def alert=(keys); end

  def alert_text(); end

  def authentication(credentials); end

  def available_log_types(); end

  def clear_element(element); end

  def clear_local_storage(); end

  def clear_session_storage(); end

  def click(); end

  def click_element(element); end

  def close(); end

  def context_click(); end

  def cookies(); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def dismiss_alert(); end

  def double_click(); end

  def drag_element(element, right_by, down_by); end

  def element_attribute(element, name); end

  def element_displayed?(element); end

  def element_enabled?(element); end

  def element_location(element); end

  def element_location_once_scrolled_into_view(element); end

  def element_property(element, name); end

  def element_rect(element); end

  def element_selected?(element); end

  def element_size(element); end

  def element_tag_name(element); end

  def element_text(element); end

  def element_value(element); end

  def element_value_of_css_property(element, prop); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def implicit_wait_timeout=(milliseconds); end

  def initialize(capabilities, session_id, **opts); end

  def keyboard(); end

  def local_storage_item(key, value=T.unsafe(nil)); end

  def local_storage_keys(); end

  def local_storage_size(); end

  def location(); end

  def log(type); end

  def manage(); end

  def maximize_window(handle=T.unsafe(nil)); end

  def mouse(); end

  def mouse_down(); end

  def mouse_move_to(element, x=T.unsafe(nil), y=T.unsafe(nil)); end

  def mouse_up(); end

  def network_connection(); end

  def network_connection=(type); end

  def page_source(); end

  def quit(); end

  def refresh(); end

  def remove_local_storage_item(key); end

  def remove_session_storage_item(key); end

  def reposition_window(x, y, handle=T.unsafe(nil)); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def screen_orientation(); end

  def screen_orientation=(orientation); end

  def screenshot(); end

  def script_timeout=(milliseconds); end

  def send_keys_to_active_element(key); end

  def send_keys_to_element(element, keys); end

  def session_capabilities(); end

  def session_storage_item(key, value=T.unsafe(nil)); end

  def session_storage_keys(); end

  def session_storage_size(); end

  def set_location(lat, lon, alt); end

  def status(); end

  def submit_element(element); end

  def switch_to_active_element(); end

  def switch_to_default_content(); end

  def switch_to_frame(id); end

  def switch_to_parent_frame(); end

  def switch_to_window(name); end

  def timeout(type, milliseconds); end

  def title(); end

  def touch_double_tap(element); end

  def touch_down(x, y); end

  def touch_element_flick(element, right_by, down_by, speed); end

  def touch_flick(xspeed, yspeed); end

  def touch_long_press(element); end

  def touch_move(x, y); end

  def touch_scroll(element, x, y); end

  def touch_single_tap(element); end

  def touch_up(x, y); end

  def upload(local_file); end

  def url(); end

  def window_handle(); end

  def window_handles(); end

  def window_position(handle=T.unsafe(nil)); end

  def window_size(handle=T.unsafe(nil)); end
  COMMANDS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::OSS::Bridge
end

module Selenium::WebDriver::Remote::OSS
end

class Selenium::WebDriver::Remote::Response
  def [](key); end

  def code(); end

  def error(); end

  def error_message(); end

  def initialize(code, payload=T.unsafe(nil)); end

  def payload(); end

  def payload=(payload); end
  STACKTRACE_KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Response
end

module Selenium::WebDriver::Remote::W3C
end

class Selenium::WebDriver::Remote::W3C::Bridge
  def accept_alert(); end

  def action(async=T.unsafe(nil)); end

  def actions(async=T.unsafe(nil)); end

  def active_element(); end

  def add_cookie(cookie); end

  def alert=(keys); end

  def alert_text(); end

  def clear_element(element); end

  def clear_local_storage(); end

  def clear_session_storage(); end

  def click_element(element); end

  def close(); end

  def cookie(name); end

  def cookies(); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def dismiss_alert(); end

  def drag_element(element, right_by, down_by); end

  def element_attribute(element, name); end

  def element_displayed?(element); end

  def element_enabled?(element); end

  def element_location(element); end

  def element_location_once_scrolled_into_view(element); end

  def element_property(element, name); end

  def element_rect(element); end

  def element_selected?(element); end

  def element_size(element); end

  def element_tag_name(element); end

  def element_text(element); end

  def element_value(element); end

  def element_value_of_css_property(element, prop); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def full_screen_window(); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def implicit_wait_timeout=(milliseconds); end

  def initialize(capabilities, session_id, **opts); end

  def keyboard(); end

  def local_storage_item(key, value=T.unsafe(nil)); end

  def local_storage_keys(); end

  def local_storage_size(); end

  def location(); end

  def manage(); end

  def maximize_window(handle=T.unsafe(nil)); end

  def minimize_window(); end

  def mouse(); end

  def network_connection(); end

  def network_connection=(_type); end

  def new_window(type); end

  def page_source(); end

  def quit(); end

  def refresh(); end

  def release_actions(); end

  def remove_local_storage_item(key); end

  def remove_session_storage_item(key); end

  def reposition_window(x, y); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def screen_orientation(); end

  def screen_orientation=(orientation); end

  def screenshot(); end

  def script_timeout=(milliseconds); end

  def send_actions(data); end

  def send_keys_to_element(element, keys); end

  def session_storage_item(key, value=T.unsafe(nil)); end

  def session_storage_keys(); end

  def session_storage_size(); end

  def set_location(_lat, _lon, _alt); end

  def set_window_rect(x: T.unsafe(nil), y: T.unsafe(nil), width: T.unsafe(nil), height: T.unsafe(nil)); end

  def status(); end

  def submit_element(element); end

  def switch_to_active_element(); end

  def switch_to_default_content(); end

  def switch_to_frame(id); end

  def switch_to_parent_frame(); end

  def switch_to_window(name); end

  def timeout(type, milliseconds); end

  def title(); end

  def touch_double_tap(element); end

  def touch_down(x, y); end

  def touch_element_flick(element, right_by, down_by, speed); end

  def touch_flick(xspeed, yspeed); end

  def touch_long_press(element); end

  def touch_move(x, y); end

  def touch_scroll(element, x, y); end

  def touch_single_tap(element); end

  def touch_up(x, y); end

  def upload(local_file); end

  def url(); end

  def window_handle(); end

  def window_handles(); end

  def window_position(); end

  def window_rect(); end

  def window_size(handle=T.unsafe(nil)); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  ESCAPE_CSS_REGEXP = ::T.let(nil, ::T.untyped)
  QUIT_ERRORS = ::T.let(nil, ::T.untyped)
  UNICODE_CODE_POINT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::W3C::Bridge
end

class Selenium::WebDriver::Remote::W3C::Capabilities
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def accept_insecure_certs(); end

  def accept_insecure_certs=(value); end

  def accessibility_checks(); end

  def accessibility_checks=(value); end

  def as_json(*_); end

  def browser_name(); end

  def browser_name=(value); end

  def browser_version(); end

  def browser_version=(value); end

  def capabilities(); end

  def device(); end

  def device=(value); end

  def eql?(other); end

  def implicit_timeout(); end

  def implicit_timeout=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def merge!(other); end

  def page_load_strategy(); end

  def page_load_strategy=(value); end

  def page_load_timeout(); end

  def page_load_timeout=(value); end

  def platform(); end

  def platform=(value); end

  def platform_name(); end

  def platform_name=(value); end

  def proxy(); end

  def proxy=(proxy); end

  def remote_session_id(); end

  def remote_session_id=(value); end

  def script_timeout(); end

  def script_timeout=(value); end

  def set_window_rect(); end

  def set_window_rect=(value); end

  def strict_file_interactability(); end

  def strict_file_interactability=(value); end

  def timeouts(); end

  def timeouts=(value); end

  def to_json(*_); end

  def unhandled_prompt_behavior(); end

  def unhandled_prompt_behavior=(value); end

  def version(); end

  def version=(value); end
  EXTENSION_CAPABILITY_PATTERN = ::T.let(nil, ::T.untyped)
  KNOWN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::W3C::Capabilities
  def self.edge(opts=T.unsafe(nil)); end

  def self.ff(opts=T.unsafe(nil)); end

  def self.firefox(opts=T.unsafe(nil)); end

  def self.from_oss(oss_capabilities); end

  def self.json_create(data); end
end

module Selenium::WebDriver::Remote::W3C
end

module Selenium::WebDriver::Remote
end

module Selenium::WebDriver::Safari
end

module Selenium::WebDriver::Safari::Bridge
  def attach_debugger(); end

  def commands(command); end

  def permissions(); end

  def permissions=(permissions); end
  COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Safari::Bridge
end

class Selenium::WebDriver::Safari::Driver
  include ::Selenium::WebDriver::DriverExtensions::HasDebugger
  include ::Selenium::WebDriver::DriverExtensions::HasPermissions
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Safari::Driver
end

class Selenium::WebDriver::Safari::Options
  def as_json(*_); end

  def automatic_inspection(); end

  def automatic_inspection=(automatic_inspection); end

  def automatic_profiling(); end

  def automatic_profiling=(automatic_profiling); end

  def initialize(**opts); end
end

class Selenium::WebDriver::Safari::Options
end

class Selenium::WebDriver::Safari::Service
end

class Selenium::WebDriver::Safari::Service
end

module Selenium::WebDriver::Safari
  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.path(); end

  def self.path=(path); end

  def self.technology_preview(); end

  def self.technology_preview!(); end
end

module Selenium::WebDriver::SearchContext
  def find_element(*args); end

  def find_elements(*args); end
  FINDERS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::SearchContext
end

class Selenium::WebDriver::Service
  def executable_path(); end

  def extract_service_args(driver_opts); end

  def host(); end

  def host=(host); end

  def initialize(path: T.unsafe(nil), port: T.unsafe(nil), args: T.unsafe(nil)); end

  def start(); end

  def stop(); end

  def uri(); end
  SOCKET_LOCK_TIMEOUT = ::T.let(nil, ::T.untyped)
  START_TIMEOUT = ::T.let(nil, ::T.untyped)
  STOP_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Service
  def self.chrome(**opts); end

  def self.default_port(); end

  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.edge(**opts); end

  def self.executable(); end

  def self.firefox(**opts); end

  def self.ie(**opts); end

  def self.internet_explorer(**opts); end

  def self.missing_text(); end

  def self.safari(**opts); end

  def self.shutdown_supported(); end
end

class Selenium::WebDriver::SocketLock
  def initialize(port, timeout); end

  def locked(); end
end

class Selenium::WebDriver::SocketLock
end

class Selenium::WebDriver::SocketPoller
  def closed?(); end

  def connected?(); end

  def initialize(host, port, timeout=T.unsafe(nil), interval=T.unsafe(nil)); end
  CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
  CONNECT_TIMEOUT = ::T.let(nil, ::T.untyped)
  NOT_CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::SocketPoller
end

module Selenium::WebDriver::Support
end

class Selenium::WebDriver::Support::AbstractEventListener
  def after_change_value_of(element, driver); end

  def after_click(element, driver); end

  def after_close(driver); end

  def after_execute_script(script, driver); end

  def after_find(by, what, driver); end

  def after_navigate_back(driver); end

  def after_navigate_forward(driver); end

  def after_navigate_to(url, driver); end

  def after_quit(driver); end

  def before_change_value_of(element, driver); end

  def before_click(element, driver); end

  def before_close(driver); end

  def before_execute_script(script, driver); end

  def before_find(by, what, driver); end

  def before_navigate_back(driver); end

  def before_navigate_forward(driver); end

  def before_navigate_to(url, driver); end

  def before_quit(driver); end
end

class Selenium::WebDriver::Support::AbstractEventListener
end

class Selenium::WebDriver::Support::BlockEventListener
  def initialize(callback); end

  def method_missing(meth, *args); end
end

class Selenium::WebDriver::Support::BlockEventListener
end

class Selenium::WebDriver::Support::Color
  def ==(other); end

  def alpha(); end

  def blue(); end

  def eql?(other); end

  def green(); end

  def hex(); end

  def initialize(red, green, blue, alpha=T.unsafe(nil)); end

  def red(); end

  def rgb(); end

  def rgba(); end
  HEX3_PATTERN = ::T.let(nil, ::T.untyped)
  HEX_PATTERN = ::T.let(nil, ::T.untyped)
  HSLA_PATTERN = ::T.let(nil, ::T.untyped)
  HSL_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PCT_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PCT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Support::Color
  def self.from_hsl(h, s, l, a); end

  def self.from_string(str); end

  def self.hue_to_rgb(lum1, lum2, hue); end
end

module Selenium::WebDriver::Support::Escaper
end

module Selenium::WebDriver::Support::Escaper
  def self.escape(str); end
end

class Selenium::WebDriver::Support::EventFiringBridge
  def clear_element(ref); end

  def click_element(ref); end

  def close(); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def initialize(delegate, listener); end

  def quit(); end

  def send_keys_to_element(ref, keys); end
end

class Selenium::WebDriver::Support::EventFiringBridge
end

class Selenium::WebDriver::Support::Select
  def deselect_all(); end

  def deselect_by(how, what); end

  def first_selected_option(); end

  def initialize(element); end

  def multiple?(); end

  def options(); end

  def select_all(); end

  def select_by(how, what); end

  def selected_options(); end
end

class Selenium::WebDriver::Support::Select
end

module Selenium::WebDriver::Support
end

class Selenium::WebDriver::TargetLocator
  def active_element(); end

  def alert(); end

  def default_content(); end

  def frame(id); end

  def initialize(bridge); end

  def parent_frame(); end

  def window(id); end
end

class Selenium::WebDriver::TargetLocator
end

class Selenium::WebDriver::Timeouts
  def implicit_wait=(seconds); end

  def initialize(bridge); end

  def page_load=(seconds); end

  def script_timeout=(seconds); end
end

class Selenium::WebDriver::Timeouts
end

class Selenium::WebDriver::TouchActionBuilder
  def double_tap(element); end

  def down(x, y=T.unsafe(nil)); end

  def flick(*args); end

  def initialize(mouse, keyboard, touch_screen); end

  def long_press(element); end

  def move(x, y=T.unsafe(nil)); end

  def scroll(*args); end

  def single_tap(element); end

  def up(x, y=T.unsafe(nil)); end
end

class Selenium::WebDriver::TouchActionBuilder
end

class Selenium::WebDriver::TouchScreen
  def double_tap(element); end

  def down(x, y=T.unsafe(nil)); end

  def flick(*args); end

  def initialize(bridge); end

  def long_press(element); end

  def move(x, y=T.unsafe(nil)); end

  def scroll(*args); end

  def single_tap(element); end

  def up(x, y=T.unsafe(nil)); end
  FLICK_SPEED = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::TouchScreen
end

class Selenium::WebDriver::W3CActionBuilder
  include ::Selenium::WebDriver::KeyActions
  include ::Selenium::WebDriver::PointerActions
  def add_key_input(name); end

  def add_pointer_input(kind, name); end

  def clear_all_actions(); end

  def devices(); end

  def get_device(name); end

  def initialize(bridge, mouse, keyboard, async=T.unsafe(nil)); end

  def key_inputs(); end

  def pause(device, duration=T.unsafe(nil)); end

  def pauses(device, number, duration=T.unsafe(nil)); end

  def perform(); end

  def pointer_inputs(); end

  def release_actions(); end
end

class Selenium::WebDriver::W3CActionBuilder
end

class Selenium::WebDriver::W3CManager
end

class Selenium::WebDriver::W3CManager
end

class Selenium::WebDriver::Wait
  def initialize(opts=T.unsafe(nil)); end

  def until(); end
  DEFAULT_INTERVAL = ::T.let(nil, ::T.untyped)
  DEFAULT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Wait
end

class Selenium::WebDriver::Window
  def full_screen(); end

  def initialize(bridge); end

  def maximize(); end

  def minimize(); end

  def move_to(x, y); end

  def position(); end

  def position=(point); end

  def rect(); end

  def rect=(rectangle); end

  def resize_to(width, height); end

  def size(); end

  def size=(dimension); end
end

class Selenium::WebDriver::Window
end

module Selenium::WebDriver::Zipper
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Zipper
  def self.unzip(path); end

  def self.zip(path); end

  def self.zip_file(path); end
end

module Selenium::WebDriver
  def self.for(*args); end

  def self.logger(); end

  def self.root(); end
end

module Selenium
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellany
end

class Shellany::Sheller
  def initialize(*args); end

  def ok?(); end

  def ran?(); end

  def run(); end

  def status(); end

  def stderr(); end

  def stdout(); end
end

class Shellany::Sheller
  def self._shellize_if_needed(args); end

  def self._system_with_capture(*args); end

  def self._system_with_no_capture(*args); end

  def self.run(*args); end

  def self.stderr(*args); end

  def self.stdout(*args); end

  def self.system(*args); end
end

module Shellany
end

module Sidekiq
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULT_WORKER_OPTIONS = ::T.let(nil, ::T.untyped)
  FAKE_INFO = ::T.let(nil, ::T.untyped)
  LICENSE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sidekiq::Client
  def initialize(redis_pool=T.unsafe(nil)); end

  def middleware(&block); end

  def push(item); end

  def push_bulk(items); end

  def redis_pool(); end

  def redis_pool=(redis_pool); end
end

class Sidekiq::Client
  def self.enqueue(klass, *args); end

  def self.enqueue_in(interval, klass, *args); end

  def self.enqueue_to(queue, klass, *args); end

  def self.enqueue_to_in(queue, interval, klass, *args); end

  def self.push(item); end

  def self.push_bulk(items); end

  def self.via(pool); end
end

module Sidekiq::Context
end

module Sidekiq::Context
  def self.current(); end

  def self.with(hash); end
end

class Sidekiq::DeadSet
  def initialize(); end

  def kill(message, opts=T.unsafe(nil)); end

  def retry_all(); end
end

class Sidekiq::DeadSet
  def self.max_jobs(); end

  def self.timeout(); end
end

module Sidekiq::Extensions
end

module Sidekiq::Extensions::PsychAutoload
  def resolve_class(klass_name); end
end

module Sidekiq::Extensions::PsychAutoload
end

module Sidekiq::Extensions
  def self.enable_delay!(); end
end

class Sidekiq::Job
  def [](name); end

  def args(); end

  def created_at(); end

  def delete(); end

  def display_args(); end

  def display_class(); end

  def enqueued_at(); end

  def error_backtrace(); end

  def initialize(item, queue_name=T.unsafe(nil)); end

  def item(); end

  def jid(); end

  def klass(); end

  def latency(); end

  def parse(item); end

  def queue(); end

  def tags(); end

  def value(); end
end

class Sidekiq::Job
end

class Sidekiq::JobSet
  def delete(score, jid); end

  def delete_by_jid(score, jid); end

  def delete_by_value(name, value); end

  def each(&blk); end

  def fetch(score, jid=T.unsafe(nil)); end

  def find_job(jid); end

  def schedule(timestamp, message); end
end

class Sidekiq::JobSet
end

class Sidekiq::Logger
  include ::Sidekiq::LoggingUtils
  def initialize(*args, **kwargs); end
end

module Sidekiq::Logger::Formatters
end

class Sidekiq::Logger::Formatters::Base
  def ctx(); end

  def format_context(); end

  def tid(); end
end

class Sidekiq::Logger::Formatters::Base
end

class Sidekiq::Logger::Formatters::JSON
  def call(severity, time, program_name, message); end
end

class Sidekiq::Logger::Formatters::JSON
end

class Sidekiq::Logger::Formatters::Pretty
  def call(severity, time, program_name, message); end
end

class Sidekiq::Logger::Formatters::Pretty
end

class Sidekiq::Logger::Formatters::WithoutTimestamp
end

class Sidekiq::Logger::Formatters::WithoutTimestamp
end

module Sidekiq::Logger::Formatters
end

class Sidekiq::Logger
end

module Sidekiq::LoggingUtils
  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error?(); end

  def fatal?(); end

  def info?(); end

  def level(); end

  def local_level(); end

  def local_level=(level); end

  def log_at(level); end

  def warn?(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

module Sidekiq::LoggingUtils
end

module Sidekiq::Middleware
end

class Sidekiq::Middleware::Chain
  include ::Enumerable
  def add(klass, *args); end

  def clear(); end

  def each(&block); end

  def empty?(); end

  def entries(); end

  def exists?(klass); end

  def insert_after(oldklass, newklass, *args); end

  def insert_before(oldklass, newklass, *args); end

  def invoke(*args); end

  def prepend(klass, *args); end

  def remove(klass); end

  def retrieve(); end
end

class Sidekiq::Middleware::Chain
end

class Sidekiq::Middleware::Entry
  def initialize(klass, *args); end

  def klass(); end

  def make_new(); end
end

class Sidekiq::Middleware::Entry
end

module Sidekiq::Middleware
end

module Sidekiq::Paginator
  def page(key, pageidx=T.unsafe(nil), page_size=T.unsafe(nil), opts=T.unsafe(nil)); end
end

module Sidekiq::Paginator
end

class Sidekiq::Process
  def [](key); end

  def dump_threads(); end

  def identity(); end

  def initialize(hash); end

  def labels(); end

  def quiet!(); end

  def stop!(); end

  def stopping?(); end

  def tag(); end
end

class Sidekiq::Process
end

class Sidekiq::ProcessSet
  include ::Enumerable
  def cleanup(); end

  def each(&blk); end

  def initialize(clean_plz=T.unsafe(nil)); end

  def leader(); end

  def size(); end
end

class Sidekiq::ProcessSet
end

class Sidekiq::Queue
  include ::Enumerable
  def clear(); end

  def each(&blk); end

  def find_job(jid); end

  def initialize(name=T.unsafe(nil)); end

  def latency(); end

  def name(); end

  def paused?(); end

  def size(); end
end

class Sidekiq::Queue
  def self.all(); end
end

class Sidekiq::Rails
end

class Sidekiq::Rails::Reloader
  def call(); end

  def initialize(app=T.unsafe(nil)); end
end

class Sidekiq::Rails::Reloader
end

class Sidekiq::Rails
end

class Sidekiq::RedisConnection
end

class Sidekiq::RedisConnection
  def self.create(options=T.unsafe(nil)); end
end

class Sidekiq::RetrySet
  def initialize(); end

  def kill_all(); end

  def retry_all(); end
end

class Sidekiq::RetrySet
end

class Sidekiq::ScheduledSet
  def initialize(); end
end

class Sidekiq::ScheduledSet
end

class Sidekiq::Shutdown
end

class Sidekiq::Shutdown
end

class Sidekiq::SortedEntry
  def add_to_queue(); end

  def at(); end

  def error?(); end

  def initialize(parent, score, item); end

  def kill(); end

  def parent(); end

  def reschedule(at); end

  def retry(); end

  def score(); end
end

class Sidekiq::SortedEntry
end

class Sidekiq::SortedSet
  include ::Enumerable
  def clear(); end

  def initialize(name); end

  def name(); end

  def scan(match, count=T.unsafe(nil)); end

  def size(); end
end

class Sidekiq::SortedSet
end

class Sidekiq::Stats
  def dead_size(); end

  def default_queue_latency(); end

  def enqueued(); end

  def failed(); end

  def fetch_stats!(); end

  def processed(); end

  def processes_size(); end

  def queues(); end

  def reset(*stats); end

  def retry_size(); end

  def scheduled_size(); end

  def workers_size(); end
end

class Sidekiq::Stats::History
  def failed(); end

  def initialize(days_previous, start_date=T.unsafe(nil)); end

  def processed(); end
end

class Sidekiq::Stats::History
end

class Sidekiq::Stats::Queues
  def lengths(); end
end

class Sidekiq::Stats::Queues
end

class Sidekiq::Stats
end

class Sidekiq::Web
  def app(); end

  def call(env); end

  def disable(*opts); end

  def enable(*opts); end

  def middlewares(); end

  def sessions(); end

  def sessions=(sessions); end

  def set(attribute, value); end

  def settings(); end

  def use(*middleware_args, &block); end
  ASSETS = ::T.let(nil, ::T.untyped)
  DEFAULT_TABS = ::T.let(nil, ::T.untyped)
  LAYOUT = ::T.let(nil, ::T.untyped)
  LOCALES = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  VIEWS = ::T.let(nil, ::T.untyped)
end

class Sidekiq::Web::CsrfProtection
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

class Sidekiq::Web::CsrfProtection
end

class Sidekiq::Web
  def self.app_url(); end

  def self.app_url=(app_url); end

  def self.call(env); end

  def self.custom_tabs(); end

  def self.default_tabs(); end

  def self.disable(*opts); end

  def self.enable(*opts); end

  def self.inherited(child); end

  def self.locales(); end

  def self.locales=(locales); end

  def self.middlewares(); end

  def self.redis_pool(); end

  def self.redis_pool=(redis_pool); end

  def self.register(extension); end

  def self.session_secret(); end

  def self.session_secret=(session_secret); end

  def self.sessions(); end

  def self.sessions=(sessions); end

  def self.set(attribute, value); end

  def self.settings(); end

  def self.tabs(); end

  def self.use(*middleware_args, &block); end

  def self.views(); end

  def self.views=(views); end
end

class Sidekiq::WebAction
  include ::Sidekiq::WebHelpers
  include ::Sidekiq::Paginator
  def _render(); end

  def block(); end

  def block=(block); end

  def env(); end

  def env=(env); end

  def erb(content, options=T.unsafe(nil)); end

  def halt(res); end

  def initialize(env, block); end

  def json(payload); end

  def params(); end

  def redirect(location); end

  def render(engine, content, options=T.unsafe(nil)); end

  def request(); end

  def route_params(); end

  def session(); end

  def settings(); end

  def type(); end

  def type=(type); end
  RACK_SESSION = ::T.let(nil, ::T.untyped)
end

class Sidekiq::WebAction
end

class Sidekiq::WebApplication
  def call(env); end

  def initialize(klass); end

  def settings(); end
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CSP_HEADER = ::T.let(nil, ::T.untyped)
  REDIS_KEYS = ::T.let(nil, ::T.untyped)
end

class Sidekiq::WebApplication
  extend ::Sidekiq::WebRouter
  def self.after(path=T.unsafe(nil), &block); end

  def self.afters(); end

  def self.before(path=T.unsafe(nil), &block); end

  def self.befores(); end

  def self.helpers(mod=T.unsafe(nil), &block); end

  def self.run_afters(app, action); end

  def self.run_befores(app, action); end

  def self.run_hooks(hooks, app, action); end

  def self.set(key, val); end

  def self.settings(); end

  def self.tabs(); end
end

module Sidekiq::WebHelpers
  def add_to_head(); end

  def available_locales(); end

  def clear_caches(); end

  def csrf_tag(); end

  def current_path(); end

  def current_status(); end

  def delete_or_add_queue(job, params); end

  def display_args(args, truncate_after_chars=T.unsafe(nil)); end

  def display_custom_head(); end

  def display_tags(job, within=T.unsafe(nil)); end

  def environment_title_prefix(); end

  def filtering(*_); end

  def find_locale_files(lang); end

  def get_locale(); end

  def h(text); end

  def job_params(job, score); end

  def locale(); end

  def locale_files(); end

  def namespace(); end

  def number_with_delimiter(number); end

  def parse_params(params); end

  def poll_path(); end

  def processes(); end

  def product_version(); end

  def qparams(options); end

  def redirect_with_query(url); end

  def redis_connection(); end

  def redis_connection_and_namespace(); end

  def redis_info(); end

  def relative_time(time); end

  def retry_extra_items(retry_job); end

  def retry_or_delete_or_kill(job, params); end

  def root_path(); end

  def rtl?(); end

  def server_utc_time(); end

  def sort_direction_label(); end

  def stats(); end

  def strings(lang); end

  def t(msg, options=T.unsafe(nil)); end

  def text_direction(); end

  def to_display(arg); end

  def to_query_string(params); end

  def truncate(text, truncate_after_chars=T.unsafe(nil)); end

  def unfiltered?(); end

  def user_preferred_languages(); end

  def workers(); end
  RETRY_JOB_KEYS = ::T.let(nil, ::T.untyped)
  SAFE_QPARAMS = ::T.let(nil, ::T.untyped)
end

module Sidekiq::WebHelpers
end

class Sidekiq::WebRoute
  def block(); end

  def block=(block); end

  def compile(); end

  def initialize(request_method, pattern, block); end

  def match(request_method, path); end

  def matcher(); end

  def name(); end

  def name=(name); end

  def pattern(); end

  def pattern=(pattern); end

  def request_method(); end

  def request_method=(request_method); end
  NAMED_SEGMENTS_PATTERN = ::T.let(nil, ::T.untyped)
end

class Sidekiq::WebRoute
end

module Sidekiq::WebRouter
  def delete(path, &block); end

  def get(path, &block); end

  def match(env); end

  def patch(path, &block); end

  def post(path, &block); end

  def put(path, &block); end

  def route(method, path, &block); end
  DELETE = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  ROUTE_PARAMS = ::T.let(nil, ::T.untyped)
end

module Sidekiq::WebRouter
end

module Sidekiq::Worker
  def jid(); end

  def jid=(jid); end

  def logger(); end
end

module Sidekiq::Worker::Options
end

module Sidekiq::Worker::Options
  def self.included(base); end
end

module Sidekiq::Worker
  def self.included(base); end
end

class Sidekiq::Workers
  include ::Enumerable
  def each(&blk); end

  def size(); end
end

class Sidekiq::Workers
end

module Sidekiq
  def self.average_scheduled_poll_interval=(interval); end

  def self.client_middleware(); end

  def self.configure_client(); end

  def self.configure_server(); end

  def self.death_handlers(); end

  def self.default_server_middleware(); end

  def self.default_worker_options(); end

  def self.default_worker_options=(hash); end

  def self.dump_json(object); end

  def self.error_handlers(); end

  def self.load_json(string); end

  def self.log_formatter(); end

  def self.log_formatter=(log_formatter); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.on(event, &block); end

  def self.options(); end

  def self.options=(opts); end

  def self.pro?(); end

  def self.redis(); end

  def self.redis=(hash); end

  def self.redis_info(); end

  def self.redis_pool(); end

  def self.server?(); end

  def self.server_middleware(); end
end

class SignedGlobalID
  def expires_at(); end

  def purpose(); end

  def to_h(); end

  def to_s(); end

  def verifier(); end
end

class SignedGlobalID::ExpiredMessage
end

class SignedGlobalID::ExpiredMessage
end

class SignedGlobalID
  def self.expires_in(); end

  def self.expires_in=(expires_in); end

  def self.parse(sgid, options=T.unsafe(nil)); end

  def self.pick_purpose(options); end

  def self.pick_verifier(options); end

  def self.verifier(); end

  def self.verifier=(verifier); end
end

module SimpleCov
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::ArrayFilter
  def matches?(source_files_list); end
end

class SimpleCov::ArrayFilter
end

class SimpleCov::BlockFilter
  def matches?(source_file); end
end

class SimpleCov::BlockFilter
end

module SimpleCov::Combine
end

module SimpleCov::Combine::BranchesCombiner
end

module SimpleCov::Combine::BranchesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::FilesCombiner
end

module SimpleCov::Combine::FilesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::LinesCombiner
end

module SimpleCov::Combine::LinesCombiner
  def self.combine(coverage_a, coverage_b); end

  def self.merge_line_coverage(first_val, second_val); end
end

module SimpleCov::Combine::ResultsCombiner
end

module SimpleCov::Combine::ResultsCombiner
  def self.combine(*results); end

  def self.combine_file_coverage(coverage_a, coverage_b); end

  def self.combine_result_sets(combined_results, result); end
end

module SimpleCov::Combine
  def self.combine(combiner_module, coverage_a, coverage_b); end

  def self.empty_coverage?(coverage_a, coverage_b); end

  def self.existing_coverage(coverage_a, coverage_b); end
end

module SimpleCov::CommandGuesser
end

module SimpleCov::CommandGuesser
  def self.guess(); end

  def self.original_run_command(); end

  def self.original_run_command=(original_run_command); end
end

module SimpleCov::Configuration
  def adapters(); end

  def add_filter(filter_argument=T.unsafe(nil), &filter_proc); end

  def add_group(group_name, filter_argument=T.unsafe(nil), &filter_proc); end

  def at_exit(&block); end

  def branch_coverage?(); end

  def branch_coverage_supported?(); end

  def clear_coverage_criteria(); end

  def command_name(name=T.unsafe(nil)); end

  def configure(&block); end

  def coverage_criteria(); end

  def coverage_criterion(criterion=T.unsafe(nil)); end

  def coverage_criterion_enabled?(criterion); end

  def coverage_dir(dir=T.unsafe(nil)); end

  def coverage_path(); end

  def coverage_start_arguments_supported?(); end

  def enable_coverage(criterion); end

  def filters(); end

  def filters=(filters); end

  def formatter(formatter=T.unsafe(nil)); end

  def formatter=(formatter); end

  def formatters(); end

  def formatters=(formatters); end

  def groups(); end

  def groups=(groups); end

  def maximum_coverage_drop(coverage_drop=T.unsafe(nil)); end

  def merge_timeout(seconds=T.unsafe(nil)); end

  def minimum_coverage(coverage=T.unsafe(nil)); end

  def minimum_coverage_by_file(coverage=T.unsafe(nil)); end

  def nocov_token(nocov_token=T.unsafe(nil)); end

  def print_error_status(); end

  def print_error_status=(print_error_status); end

  def profiles(); end

  def project_name(new_name=T.unsafe(nil)); end

  def refuse_coverage_drop(); end

  def root(root=T.unsafe(nil)); end

  def skip_token(nocov_token=T.unsafe(nil)); end

  def track_files(glob); end

  def tracked_files(); end

  def use_merging(use=T.unsafe(nil)); end
  DEFAULT_COVERAGE_CRITERION = ::T.let(nil, ::T.untyped)
  SUPPORTED_COVERAGE_CRITERIA = ::T.let(nil, ::T.untyped)
end

module SimpleCov::Configuration
end

class SimpleCov::CoverageStatistics
  def covered(); end

  def initialize(covered:, missed:, total_strength: T.unsafe(nil)); end

  def missed(); end

  def percent(); end

  def strength(); end

  def total(); end
end

class SimpleCov::CoverageStatistics
  def self.from(coverage_statistics); end
end

module SimpleCov::ExitCodes
  EXCEPTION = ::T.let(nil, ::T.untyped)
  MAXIMUM_COVERAGE_DROP = ::T.let(nil, ::T.untyped)
  MINIMUM_COVERAGE = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
end

module SimpleCov::ExitCodes
end

class SimpleCov::FileList
  include ::Enumerable
  def branch_covered_percent(); end

  def count(*args, &block); end

  def coverage_statistics(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_percentages(); end

  def covered_strength(); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def initialize(files); end

  def least_covered_file(); end

  def length(*args, &block); end

  def lines_of_code(); end

  def map(*args, &block); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def size(*args, &block); end

  def skipped_lines(); end

  def to_a(*args, &block); end

  def to_ary(*args, &block); end

  def total_branches(); end
end

class SimpleCov::FileList
  extend ::Forwardable
end

class SimpleCov::Filter
  def filter_argument(); end

  def initialize(filter_argument); end

  def matches?(_source_file); end

  def passes?(source_file); end
end

class SimpleCov::Filter
  def self.build_filter(filter_argument); end

  def self.class_for_argument(filter_argument); end
end

module SimpleCov::Formatter
end

class SimpleCov::Formatter::HTMLFormatter
  def branchable_result?(); end

  def format(result); end

  def line_status?(source_file, line); end

  def output_message(result); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::Formatter::HTMLFormatter
end

class SimpleCov::Formatter::MultiFormatter
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
  def format(result); end
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
end

class SimpleCov::Formatter::MultiFormatter
  def self.[](*args); end

  def self.new(formatters=T.unsafe(nil)); end
end

class SimpleCov::Formatter::SimpleFormatter
  def format(result); end
end

class SimpleCov::Formatter::SimpleFormatter
end

module SimpleCov::Formatter
end

module SimpleCov::LastRun
end

module SimpleCov::LastRun
  def self.last_run_path(); end

  def self.read(); end

  def self.write(json); end
end

class SimpleCov::LinesClassifier
  def classify(lines); end
  COMMENT_LINE = ::T.let(nil, ::T.untyped)
  NOT_RELEVANT = ::T.let(nil, ::T.untyped)
  RELEVANT = ::T.let(nil, ::T.untyped)
  WHITESPACE_LINE = ::T.let(nil, ::T.untyped)
  WHITESPACE_OR_COMMENT_LINE = ::T.let(nil, ::T.untyped)
end

class SimpleCov::LinesClassifier
  def self.no_cov_line(); end

  def self.no_cov_line?(line); end

  def self.whitespace_line?(line); end
end

class SimpleCov::Profiles
  def define(name, &blk); end

  def load(name); end
end

class SimpleCov::Profiles
end

class SimpleCov::RegexFilter
  def matches?(source_file); end
end

class SimpleCov::RegexFilter
end

class SimpleCov::Result
  def command_name(); end

  def command_name=(command_name); end

  def coverage_statistics(*args, &block); end

  def covered_branches(*args, &block); end

  def covered_lines(*args, &block); end

  def covered_percent(*args, &block); end

  def covered_percentages(*args, &block); end

  def covered_strength(*args, &block); end

  def created_at(); end

  def created_at=(created_at); end

  def filenames(); end

  def files(); end

  def format!(); end

  def groups(); end

  def initialize(original_result); end

  def least_covered_file(*args, &block); end

  def missed_branches(*args, &block); end

  def missed_lines(*args, &block); end

  def original_result(); end

  def source_files(); end

  def to_hash(); end

  def total_branches(*args, &block); end

  def total_lines(*args, &block); end
end

class SimpleCov::Result
  extend ::Forwardable
  def self.from_hash(hash); end
end

class SimpleCov::ResultAdapter
  def adapt(); end

  def initialize(result); end

  def result(); end
end

class SimpleCov::ResultAdapter
  def self.call(*args); end
end

module SimpleCov::ResultMerger
end

module SimpleCov::ResultMerger
  def self.clear_resultset(); end

  def self.merge_and_store(*results); end

  def self.merge_results(*results); end

  def self.merged_result(); end

  def self.results(); end

  def self.resultset(); end

  def self.resultset_path(); end

  def self.resultset_writelock(); end

  def self.store_result(result); end

  def self.stored_data(); end

  def self.synchronize_resultset(); end
end

module SimpleCov::SimulateCoverage
end

module SimpleCov::SimulateCoverage
  def self.call(absolute_path); end
end

class SimpleCov::SourceFile
  def branches(); end

  def branches_coverage_percent(); end

  def branches_for_line(line_number); end

  def branches_report(); end

  def coverage_data(); end

  def coverage_statistics(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_strength(); end

  def filename(); end

  def initialize(filename, coverage_data); end

  def line(number); end

  def line_with_missed_branch?(line_number); end

  def lines(); end

  def lines_of_code(); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def no_branches?(); end

  def no_lines?(); end

  def project_filename(); end

  def relevant_lines(); end

  def skipped_lines(); end

  def source(); end

  def source_lines(); end

  def src(); end

  def total_branches(); end
  RUBY_FILE_ENCODING_MAGIC_COMMENT_REGEX = ::T.let(nil, ::T.untyped)
  SHEBANG_REGEX = ::T.let(nil, ::T.untyped)
end

class SimpleCov::SourceFile::Branch
  def coverage(); end

  def covered?(); end

  def end_line(); end

  def initialize(start_line:, end_line:, coverage:, inline:, type:); end

  def inline?(); end

  def missed?(); end

  def overlaps_with?(line_range); end

  def report(); end

  def report_line(); end

  def skipped!(); end

  def skipped?(); end

  def start_line(); end

  def type(); end
end

class SimpleCov::SourceFile::Branch
end

class SimpleCov::SourceFile::Line
  def coverage(); end

  def covered?(); end

  def initialize(src, line_number, coverage); end

  def line(); end

  def line_number(); end

  def missed?(); end

  def never?(); end

  def number(); end

  def skipped(); end

  def skipped!(); end

  def skipped?(); end

  def source(); end

  def src(); end

  def status(); end
end

class SimpleCov::SourceFile::Line
end

class SimpleCov::SourceFile
end

class SimpleCov::StringFilter
  def matches?(source_file); end
end

class SimpleCov::StringFilter
end

module SimpleCov::UselessResultsRemover
  ROOT_REGX = ::T.let(nil, ::T.untyped)
end

module SimpleCov::UselessResultsRemover
  def self.call(coverage_result); end
end

module SimpleCov
  extend ::SimpleCov::Configuration
  def self.at_exit_behavior(); end

  def self.clear_result(); end

  def self.collate(result_filenames, profile=T.unsafe(nil), &block); end

  def self.exit_exception(); end

  def self.exit_status_from_exception(); end

  def self.external_at_exit(); end

  def self.external_at_exit=(external_at_exit); end

  def self.external_at_exit?(); end

  def self.filtered(files); end

  def self.final_result_process?(); end

  def self.grouped(files); end

  def self.load_adapter(name); end

  def self.load_profile(name); end

  def self.pid(); end

  def self.pid=(pid); end

  def self.process_result(result, exit_status); end

  def self.result(); end

  def self.result?(); end

  def self.result_exit_status(result, covered_percent); end

  def self.run_exit_tasks!(); end

  def self.running(); end

  def self.running=(running); end

  def self.set_exit_exception(); end

  def self.start(profile=T.unsafe(nil), &block); end

  def self.wait_for_other_processes(); end

  def self.write_last_run(covered_percent); end
end

module SimpleForm
  def boolean_label_class(); end

  def boolean_label_class=(obj); end

  def boolean_style(); end

  def boolean_style=(obj); end

  def browser_validations(); end

  def browser_validations=(obj); end

  def button_class(); end

  def button_class=(obj); end

  def cache_discovery(); end

  def cache_discovery=(obj); end

  def collection_label_methods(); end

  def collection_label_methods=(obj); end

  def collection_value_methods(); end

  def collection_value_methods=(obj); end

  def collection_wrapper_class(); end

  def collection_wrapper_class=(obj); end

  def collection_wrapper_tag(); end

  def collection_wrapper_tag=(obj); end

  def country_priority(); end

  def country_priority=(obj); end

  def custom_inputs_namespaces(); end

  def custom_inputs_namespaces=(obj); end

  def default_form_class(); end

  def default_form_class=(obj); end

  def default_wrapper(); end

  def default_wrapper=(obj); end

  def error_method(); end

  def error_method=(obj); end

  def error_notification_class(); end

  def error_notification_class=(obj); end

  def error_notification_tag(); end

  def error_notification_tag=(obj); end

  def field_error_proc(); end

  def field_error_proc=(obj); end

  def form_class(); end

  def generate_additional_classes_for(); end

  def generate_additional_classes_for=(obj); end

  def i18n_scope(); end

  def i18n_scope=(obj); end

  def include_default_input_wrapper_class(); end

  def include_default_input_wrapper_class=(obj); end

  def input_class(); end

  def input_class=(obj); end

  def input_field_error_class(); end

  def input_field_error_class=(obj); end

  def input_field_valid_class(); end

  def input_field_valid_class=(obj); end

  def input_mappings(); end

  def input_mappings=(obj); end

  def inputs_discovery(); end

  def inputs_discovery=(obj); end

  def item_wrapper_class(); end

  def item_wrapper_class=(obj); end

  def item_wrapper_tag(); end

  def item_wrapper_tag=(obj); end

  def label_class(); end

  def label_class=(obj); end

  def label_text(); end

  def label_text=(obj); end

  def required_by_default(); end

  def required_by_default=(obj); end

  def time_zone_priority(); end

  def time_zone_priority=(obj); end

  def translate_labels(); end

  def translate_labels=(obj); end

  def wrapper_mappings(); end

  def wrapper_mappings=(obj); end
  CUSTOM_INPUT_DEPRECATION_WARN = ::T.let(nil, ::T.untyped)
  FILE_METHODS_DEPRECATION_WARN = ::T.let(nil, ::T.untyped)
end

module SimpleForm::ActionViewExtensions
end

module SimpleForm::ActionViewExtensions::Builder
  def simple_fields_for(*args, &block); end
end

module SimpleForm::ActionViewExtensions::Builder
end

module SimpleForm::ActionViewExtensions::FormHelper
  def simple_fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def simple_form_for(record, options=T.unsafe(nil), &block); end
end

module SimpleForm::ActionViewExtensions::FormHelper
end

module SimpleForm::ActionViewExtensions
end

module SimpleForm::Components
end

module SimpleForm::Components::Errors
  def error(wrapper_options=T.unsafe(nil)); end

  def error_method(); end

  def error_text(); end

  def errors(); end

  def errors_on_association(); end

  def errors_on_attribute(); end

  def full_error(wrapper_options=T.unsafe(nil)); end

  def full_error_text(); end

  def full_errors(); end

  def full_errors_on_association(); end

  def full_errors_on_attribute(); end

  def has_custom_error?(); end

  def has_errors?(); end

  def has_value?(); end

  def object_with_errors?(); end

  def valid?(); end
end

module SimpleForm::Components::Errors
end

module SimpleForm::Components::HTML5
  def has_required?(); end

  def html5(wrapper_options=T.unsafe(nil)); end

  def html5?(); end

  def initialize(*_); end

  def input_html_aria_required_option(); end

  def input_html_required_option(); end
end

module SimpleForm::Components::HTML5
end

module SimpleForm::Components::Hints
  def has_hint?(); end

  def hint(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Hints
end

module SimpleForm::Components::LabelInput
  def label_input(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::LabelInput
  extend ::ActiveSupport::Concern
end

module SimpleForm::Components::Labels
  def generate_label_for_attribute?(); end

  def label(wrapper_options=T.unsafe(nil)); end

  def label_html_options(); end

  def label_target(); end

  def label_text(wrapper_options=T.unsafe(nil)); end

  def label_translation(); end

  def raw_label_text(); end

  def required_label_text(); end
end

module SimpleForm::Components::Labels::ClassMethods
  def translate_required_html(); end

  def translate_required_mark(); end

  def translate_required_text(); end
end

module SimpleForm::Components::Labels::ClassMethods
end

module SimpleForm::Components::Labels
  extend ::ActiveSupport::Concern
end

module SimpleForm::Components::Maxlength
  def maxlength(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Maxlength
end

module SimpleForm::Components::MinMax
  def min_max(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::MinMax
end

module SimpleForm::Components::Minlength
  def minlength(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Minlength
end

module SimpleForm::Components::Pattern
  def pattern(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Pattern
end

module SimpleForm::Components::Placeholders
  def placeholder(wrapper_options=T.unsafe(nil)); end

  def placeholder_text(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Placeholders
end

module SimpleForm::Components::Readonly
  def readonly(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Readonly
end

module SimpleForm::Components
  extend ::ActiveSupport::Autoload
end

class SimpleForm::ErrorNotification
  def error_message(); end

  def error_notification_tag(); end

  def errors(); end

  def has_errors?(); end

  def html_options(); end

  def initialize(builder, options); end

  def object(*args, &block); end

  def object_name(*args, &block); end

  def render(); end

  def template(*args, &block); end

  def translate_error_notification(); end
end

class SimpleForm::ErrorNotification
end

class SimpleForm::FormBuilder
  include ::SimpleForm::Inputs
  def association(association, options=T.unsafe(nil), &block); end

  def attribute(attribute_name, options=T.unsafe(nil), &block); end

  def button(type, *args, &block); end

  def button_button(value=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def error(attribute_name, options=T.unsafe(nil)); end

  def error_notification(options=T.unsafe(nil)); end

  def full_error(attribute_name, options=T.unsafe(nil)); end

  def hint(attribute_name, options=T.unsafe(nil)); end

  def initialize(*_); end

  def input(attribute_name, options=T.unsafe(nil), &block); end

  def input_field(attribute_name, options=T.unsafe(nil)); end

  def label(attribute_name, *args); end

  def lookup_action(); end

  def lookup_model_names(); end

  def mappings(); end

  def mappings=(val); end

  def mappings?(); end

  def template(); end

  def wrapper(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class SimpleForm::FormBuilder
  def self.discovery_cache(); end

  def self.mappings(); end

  def self.mappings=(val); end

  def self.mappings?(); end
end

module SimpleForm::Helpers
end

module SimpleForm::Helpers::Autofocus
end

module SimpleForm::Helpers::Autofocus
end

module SimpleForm::Helpers::Disabled
end

module SimpleForm::Helpers::Disabled
end

module SimpleForm::Helpers::Readonly
end

module SimpleForm::Helpers::Readonly
end

module SimpleForm::Helpers::Required
end

module SimpleForm::Helpers::Required
end

module SimpleForm::Helpers::Validators
  def has_validators?(); end
end

module SimpleForm::Helpers::Validators
end

module SimpleForm::Helpers
end

module SimpleForm::Inputs
end

class SimpleForm::Inputs::Base
  include ::ERB::Util
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::SimpleForm::Helpers::Autofocus
  include ::SimpleForm::Helpers::Disabled
  include ::SimpleForm::Helpers::Readonly
  include ::SimpleForm::Helpers::Required
  include ::SimpleForm::Helpers::Validators
  include ::SimpleForm::Components::Errors
  include ::SimpleForm::Components::Hints
  include ::SimpleForm::Components::HTML5
  include ::SimpleForm::Components::LabelInput
  include ::SimpleForm::Components::Labels
  include ::SimpleForm::Components::Maxlength
  include ::SimpleForm::Components::Minlength
  include ::SimpleForm::Components::MinMax
  include ::SimpleForm::Components::Pattern
  include ::SimpleForm::Components::Placeholders
  include ::SimpleForm::Components::Readonly
  def additional_classes(); end

  def attribute_name(); end

  def column(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end

  def default_options(); end

  def default_options=(val); end

  def default_options?(); end

  def html_classes(); end

  def initialize(builder, attribute_name, column, input_type, options=T.unsafe(nil)); end

  def input(wrapper_options=T.unsafe(nil)); end

  def input_class(); end

  def input_html_classes(); end

  def input_html_options(); end

  def input_options(); end

  def input_type(); end

  def lookup_action(*args, &block); end

  def lookup_model_names(*args, &block); end

  def object(*args, &block); end

  def object_name(*args, &block); end

  def options(); end

  def reflection(); end

  def template(*args, &block); end
end

class SimpleForm::Inputs::Base
  extend ::SimpleForm::Components::Labels::ClassMethods
  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end

  def self.default_options(); end

  def self.default_options=(val); end

  def self.default_options?(); end

  def self.disable(*keys); end

  def self.enable(*keys); end
end

class SimpleForm::Inputs::BlockInput
  def initialize(*args, &block); end
end

class SimpleForm::Inputs::BlockInput
end

class SimpleForm::Inputs::BooleanInput
end

class SimpleForm::Inputs::BooleanInput
end

class SimpleForm::Inputs::CollectionCheckBoxesInput
end

class SimpleForm::Inputs::CollectionCheckBoxesInput
end

class SimpleForm::Inputs::CollectionInput
  BASIC_OBJECT_CLASSES = ::T.let(nil, ::T.untyped)
end

class SimpleForm::Inputs::CollectionInput
  def self.boolean_collection(); end
end

class SimpleForm::Inputs::CollectionRadioButtonsInput
  def apply_default_collection_options!(options); end

  def build_nested_boolean_style_item_tag(collection_builder); end

  def collection_block_for_nested_boolean_style(); end

  def item_wrapper_class(); end
end

class SimpleForm::Inputs::CollectionRadioButtonsInput
end

class SimpleForm::Inputs::CollectionSelectInput
end

class SimpleForm::Inputs::CollectionSelectInput
end

class SimpleForm::Inputs::ColorInput
end

class SimpleForm::Inputs::ColorInput
end

class SimpleForm::Inputs::DateTimeInput
end

class SimpleForm::Inputs::DateTimeInput
end

class SimpleForm::Inputs::FileInput
end

class SimpleForm::Inputs::FileInput
end

class SimpleForm::Inputs::GroupedCollectionSelectInput
end

class SimpleForm::Inputs::GroupedCollectionSelectInput
end

class SimpleForm::Inputs::HiddenInput
end

class SimpleForm::Inputs::HiddenInput
end

class SimpleForm::Inputs::NumericInput
end

class SimpleForm::Inputs::NumericInput
end

class SimpleForm::Inputs::PasswordInput
end

class SimpleForm::Inputs::PasswordInput
end

class SimpleForm::Inputs::PriorityInput
  def input_priority(); end
end

class SimpleForm::Inputs::PriorityInput
end

class SimpleForm::Inputs::RangeInput
end

class SimpleForm::Inputs::RangeInput
end

class SimpleForm::Inputs::RichTextAreaInput
end

class SimpleForm::Inputs::RichTextAreaInput
end

class SimpleForm::Inputs::StringInput
end

class SimpleForm::Inputs::StringInput
end

class SimpleForm::Inputs::TextInput
end

class SimpleForm::Inputs::TextInput
end

module SimpleForm::Inputs
  extend ::ActiveSupport::Autoload
end

class SimpleForm::Railtie
end

class SimpleForm::Railtie
end

class SimpleForm::WrapperNotFound
end

class SimpleForm::WrapperNotFound
end

module SimpleForm::Wrappers
end

class SimpleForm::Wrappers::Builder
  def initialize(options); end

  def optional(name, options=T.unsafe(nil), &block); end

  def to_a(); end

  def use(name, options=T.unsafe(nil)); end

  def wrapper(name, options=T.unsafe(nil)); end
end

class SimpleForm::Wrappers::Builder
end

class SimpleForm::Wrappers::Leaf
  def find(name); end

  def initialize(namespace, options=T.unsafe(nil)); end

  def namespace(); end

  def render(input); end
end

class SimpleForm::Wrappers::Leaf
end

class SimpleForm::Wrappers::Many
  def components(); end

  def defaults(); end

  def find(name); end

  def initialize(namespace, components, defaults=T.unsafe(nil)); end

  def namespace(); end

  def render(input); end
end

class SimpleForm::Wrappers::Many
end

class SimpleForm::Wrappers::Root
  def initialize(*args); end

  def options(); end
end

class SimpleForm::Wrappers::Root
end

class SimpleForm::Wrappers::Single
  def initialize(name, wrapper_options=T.unsafe(nil), options=T.unsafe(nil)); end
end

class SimpleForm::Wrappers::Single
end

module SimpleForm::Wrappers
end

module SimpleForm
  extend ::ActiveSupport::Autoload
  def self.additional_classes_for(component); end

  def self.boolean_label_class(); end

  def self.boolean_label_class=(obj); end

  def self.boolean_style(); end

  def self.boolean_style=(obj); end

  def self.browser_validations(); end

  def self.browser_validations=(obj); end

  def self.build(options=T.unsafe(nil)); end

  def self.button_class(); end

  def self.button_class=(obj); end

  def self.cache_discovery(); end

  def self.cache_discovery=(obj); end

  def self.collection_label_methods(); end

  def self.collection_label_methods=(obj); end

  def self.collection_value_methods(); end

  def self.collection_value_methods=(obj); end

  def self.collection_wrapper_class(); end

  def self.collection_wrapper_class=(obj); end

  def self.collection_wrapper_tag(); end

  def self.collection_wrapper_tag=(obj); end

  def self.configured?(); end

  def self.country_priority(); end

  def self.country_priority=(obj); end

  def self.custom_inputs_namespaces(); end

  def self.custom_inputs_namespaces=(obj); end

  def self.default_form_class(); end

  def self.default_form_class=(obj); end

  def self.default_input_size=(*default_input_size); end

  def self.default_wrapper(); end

  def self.default_wrapper=(obj); end

  def self.error_method(); end

  def self.error_method=(obj); end

  def self.error_notification_class(); end

  def self.error_notification_class=(obj); end

  def self.error_notification_tag(); end

  def self.error_notification_tag=(obj); end

  def self.field_error_proc(); end

  def self.field_error_proc=(obj); end

  def self.file_methods(); end

  def self.file_methods=(file_methods); end

  def self.form_class(); end

  def self.form_class=(value); end

  def self.generate_additional_classes_for(); end

  def self.generate_additional_classes_for=(obj); end

  def self.i18n_scope(); end

  def self.i18n_scope=(obj); end

  def self.include_component(component); end

  def self.include_default_input_wrapper_class(); end

  def self.include_default_input_wrapper_class=(obj); end

  def self.input_class(); end

  def self.input_class=(obj); end

  def self.input_field_error_class(); end

  def self.input_field_error_class=(obj); end

  def self.input_field_valid_class(); end

  def self.input_field_valid_class=(obj); end

  def self.input_mappings(); end

  def self.input_mappings=(obj); end

  def self.inputs_discovery(); end

  def self.inputs_discovery=(obj); end

  def self.item_wrapper_class(); end

  def self.item_wrapper_class=(obj); end

  def self.item_wrapper_tag(); end

  def self.item_wrapper_tag=(obj); end

  def self.label_class(); end

  def self.label_class=(obj); end

  def self.label_text(); end

  def self.label_text=(obj); end

  def self.required_by_default(); end

  def self.required_by_default=(obj); end

  def self.setup(); end

  def self.time_zone_priority(); end

  def self.time_zone_priority=(obj); end

  def self.translate_labels(); end

  def self.translate_labels=(obj); end

  def self.wrapper(name); end

  def self.wrapper_mappings(); end

  def self.wrapper_mappings=(obj); end

  def self.wrappers(*args, &block); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

module Slim
  VERSION = ::T.let(nil, ::T.untyped)
end

class Slim::CodeAttributes
  def on_html_attr(name, value); end

  def on_slim_attrvalue(escape, code); end
end

class Slim::CodeAttributes
end

class Slim::Controls
  IF_RE = ::T.let(nil, ::T.untyped)
end

class Slim::Controls
end

class Slim::DoInserter
  BLOCK_REGEX = ::T.let(nil, ::T.untyped)
end

class Slim::DoInserter
end

class Slim::Embedded
  def enabled?(name); end

  def normalize_engine_list(list); end

  def on_slim_embedded(name, body, attrs); end
end

class Slim::Embedded::Engine
  def collect_newlines(body); end

  def collect_text(body); end
end

class Slim::Embedded::Engine
end

class Slim::Embedded::InterpolateTiltEngine
end

class Slim::Embedded::InterpolateTiltEngine
end

class Slim::Embedded::JavaScriptEngine
end

class Slim::Embedded::JavaScriptEngine
end

class Slim::Embedded::RubyEngine
  def on_slim_embedded(engine, body, attrs); end
end

class Slim::Embedded::RubyEngine
end

class Slim::Embedded::SassEngine
end

class Slim::Embedded::SassEngine
end

class Slim::Embedded::TagEngine
  def on_slim_embedded(engine, body, attrs); end
end

class Slim::Embedded::TagEngine
end

class Slim::Embedded::TiltEngine
  def on_slim_embedded(engine, body, attrs); end

  def tilt_render(tilt_engine, tilt_options, text); end
end

class Slim::Embedded::TiltEngine
end

class Slim::Embedded
  def self.create(name, options); end

  def self.engines(); end

  def self.register(name, klass, *option_filter); end
end

class Slim::EndInserter
  ELSE_RE = ::T.let(nil, ::T.untyped)
  END_RE = ::T.let(nil, ::T.untyped)
  IF_RE = ::T.let(nil, ::T.untyped)
end

class Slim::EndInserter
end

class Slim::Engine
end

class Slim::Engine
end

class Slim::Filter
  def on_slim_control(code, content); end

  def on_slim_embedded(type, content, attrs); end

  def on_slim_output(escape, code, content); end

  def on_slim_text(type, content); end
end

class Slim::Filter
end

class Slim::Interpolation
  def on_slim_interpolate(string); end
end

class Slim::Interpolation
end

class Slim::InvalidAttributeNameError
end

class Slim::InvalidAttributeNameError
end

class Slim::NewlineCollector
  def on_newline(); end
end

class Slim::NewlineCollector
end

class Slim::OutputProtector
  def on_slim_output(escape, text, content); end

  def on_static(text); end

  def unprotect(text); end
end

class Slim::OutputProtector
end

class Slim::Parser
  def call(str); end

  def deprecated_syntax(message); end

  def expect_next_line(); end

  def get_indent(line); end

  def next_line(); end

  def parse_attributes(attributes=T.unsafe(nil)); end

  def parse_broken_line(); end

  def parse_comment_block(); end

  def parse_line(); end

  def parse_line_indicators(); end

  def parse_quoted_attribute(quote); end

  def parse_ruby_code(outer_delimiter); end

  def parse_tag(tag); end

  def parse_text_block(first_line=T.unsafe(nil), text_indent=T.unsafe(nil)); end

  def reset(lines=T.unsafe(nil), stacks=T.unsafe(nil)); end

  def syntax_error!(message); end

  def unknown_line_indicator(); end
end

class Slim::Parser::SyntaxError
  def column(); end

  def error(); end

  def file(); end

  def initialize(error, file, line, lineno, column); end

  def line(); end

  def lineno(); end
end

class Slim::Parser::SyntaxError
end

class Slim::Parser
end

module Slim::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class Slim::Rails::Railtie
end

class Slim::Rails::Railtie
end

module Slim::Rails::RegisterEngine
end

class Slim::Rails::RegisterEngine::Transformer
end

class Slim::Rails::RegisterEngine::Transformer
  def self.call(input); end
end

module Slim::Rails::RegisterEngine
  def self.register_engine(app, config); end
end

module Slim::Rails
end

class Slim::RailsTemplate
end

class Slim::RailsTemplate
end

module Slim::Splat
end

class Slim::Splat::Builder
  def attr(name, value); end

  def build_attrs(); end

  def build_tag(&block); end

  def code_attr(name, escape, value); end

  def initialize(options); end

  def splat_attrs(splat); end
  INVALID_ATTRIBUTE_NAME_REGEX = ::T.let(nil, ::T.untyped)
end

class Slim::Splat::Builder
end

class Slim::Splat::Filter
  def make_builder(attrs); end

  def splat?(attr); end
end

class Slim::Splat::Filter
end

module Slim::Splat
end

class Slim::Template
end

class Slim::Template
end

class Slim::TextCollector
  def on_slim_interpolate(text); end
end

class Slim::TextCollector
end

module Slim
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SolveRunJob
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

module SourceAnnotationExtractor
end

module SourceAnnotationExtractor
end

module Spring
end

class Spring::ClientError
end

class Spring::ClientError
end

class Spring::CommandNotFound
end

class Spring::CommandNotFound
end

class Spring::MissingApplication
  def initialize(project_root); end

  def project_root(); end
end

class Spring::MissingApplication
end

class Spring::UnknownProject
  def current_dir(); end

  def initialize(current_dir); end
end

class Spring::UnknownProject
end

module Spring::Watcher
end

class Spring::Watcher::Abstract
  include ::Mutex_m
  def add(*items); end

  def debug(); end

  def directories(); end

  def files(); end

  def initialize(root, latency); end

  def latency(); end

  def lock(); end

  def locked?(); end

  def mark_stale(); end

  def on_debug(&block); end

  def on_stale(&block); end

  def restart(); end

  def root(); end

  def stale?(); end

  def start(); end

  def stop(); end

  def subjects_changed(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class Spring::Watcher::Abstract
end

class Spring::Watcher::Listen
  def base_directories(); end

  def changed(modified, added, removed); end

  def listener(); end

  def watching?(file); end
end

class Spring::Watcher::Listen
end

class Spring::Watcher::Polling
  def add(*_); end

  def check_stale(); end

  def mtime(); end

  def running?(); end
end

class Spring::Watcher::Polling
end

module Spring::Watcher
end

module Spring
  def self.after_fork(&block); end

  def self.after_fork_callbacks(); end

  def self.application_root(); end

  def self.application_root=(application_root); end

  def self.application_root_path(); end

  def self.gemfile(); end

  def self.project_root_path(); end

  def self.quiet(); end

  def self.quiet=(quiet); end

  def self.verify_environment(); end

  def self.watch(*items); end

  def self.watch_interval(); end

  def self.watch_interval=(watch_interval); end

  def self.watch_method(); end

  def self.watch_method=(method); end

  def self.watcher(); end

  def self.watcher=(watcher); end
end

module Sprockets
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::AddSourceMapCommentToAssetProcessor
end

class Sprockets::AddSourceMapCommentToAssetProcessor
  def self.call(input); end
end

class Sprockets::ArgumentError
end

class Sprockets::ArgumentError
end

class Sprockets::Asset
  def ==(other); end

  def base64digest(); end

  def bytesize(); end

  def charset(); end

  def content_type(); end

  def digest(); end

  def digest_path(); end

  def each(&blk); end

  def environment_version(); end

  def eql?(other); end

  def etag(); end

  def filename(); end

  def full_digest_path(); end

  def hexdigest(); end

  def id(); end

  def initialize(attributes=T.unsafe(nil)); end

  def integrity(); end

  def length(); end

  def links(); end

  def logical_path(); end

  def metadata(); end

  def source(); end

  def to_hash(); end

  def uri(); end

  def write_to(filename); end
end

class Sprockets::Asset
end

module Sprockets::Autoload
end

Sprockets::Autoload::SassC = SassC

Sprockets::Autoload::Uglifier = Uglifier

module Sprockets::Autoload
end

class Sprockets::BabelProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::BabelProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::Base
  include ::Sprockets::SourceMapUtils
  include ::Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Exporting
  include ::Sprockets::Server
  include ::Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::Bower
  include ::Sprockets::Npm
  def [](*args, **options); end

  def cache(); end

  def cache=(cache); end

  def cached(); end

  def compress_from_root(uri); end

  def expand_from_root(uri); end

  def find_all_linked_assets(*args); end

  def find_asset(*args, **options); end

  def find_asset!(*args); end

  def index(); end
end

class Sprockets::Base
end

module Sprockets::Bower
  def read_bower_main(dirname, filename); end

  def resolve_alternates(load_path, logical_path); end
  POSSIBLE_BOWER_JSONS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Bower
end

class Sprockets::Bundle
end

class Sprockets::Bundle
  def self.call(input); end

  def self.dedup(required); end

  def self.process_bundle_reducers(input, assets, reducers); end
end

class Sprockets::Cache
  def clear(options=T.unsafe(nil)); end

  def fetch(key); end

  def get(key, local=T.unsafe(nil)); end

  def initialize(cache=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value, local=T.unsafe(nil)); end
  PEEK_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def initialize(root, max_size=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
  EXCLUDED_DIRS = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def self.default_logger(); end
end

class Sprockets::Cache::GetWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::GetWrapper
end

class Sprockets::Cache::HashWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::HashWrapper
end

class Sprockets::Cache::MemoryStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def initialize(max_size=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::MemoryStore
end

class Sprockets::Cache::NullStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::NullStore
end

class Sprockets::Cache::ReadWriteWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::ReadWriteWrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache
  def self.default_logger(); end
end

class Sprockets::CachedEnvironment
  def initialize(environment); end

  def processor_cache_key(str); end
end

class Sprockets::CachedEnvironment
end

class Sprockets::ClosureCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::ClosureCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets::CoffeeScriptProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::Compressing
  include ::Sprockets::Utils
  def compressors(); end

  def css_compressor(); end

  def css_compressor=(compressor); end

  def gzip=(gzip); end

  def gzip?(); end

  def js_compressor(); end

  def js_compressor=(compressor); end

  def register_compressor(mime_type, sym, klass); end

  def skip_gzip?(); end
end

module Sprockets::Compressing
end

module Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Exporting
  include ::Sprockets::Processing
  include ::Sprockets::Transformers
  include ::Sprockets::Mime
  include ::Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def config(); end

  def config=(config); end

  def context_class(); end

  def digest_class(); end

  def digest_class=(klass); end

  def initialize_configuration(parent); end

  def logger(); end

  def logger=(logger); end

  def version(); end

  def version=(version); end
end

module Sprockets::Configuration
end

class Sprockets::ContentTypeMismatch
end

class Sprockets::ContentTypeMismatch
end

class Sprockets::Context
  def asset_data_uri(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def base64_asset_data_uri(asset); end

  def content_type(); end

  def depend_on(path); end

  def depend_on_asset(path); end

  def depend_on_env(key); end

  def env_proxy(); end

  def environment(); end

  def filename(); end

  def font_path(path); end

  def image_path(path); end

  def initialize(input); end

  def javascript_path(path); end

  def link_asset(path); end

  def load(uri); end

  def load_path(); end

  def logical_path(); end

  def metadata(); end

  def optimize_quoted_uri_escapes!(escaped); end

  def optimize_svg_for_uri_escaping!(svg); end

  def require_asset(path); end

  def resolve(path, **kargs); end

  def root_path(); end

  def stub_asset(path); end

  def stylesheet_path(path); end

  def svg_asset_data_uri(asset); end

  def video_path(path); end
end

class Sprockets::Context::ENVProxy
  def [](key); end

  def fetch(key, *_); end

  def initialize(context); end
end

class Sprockets::Context::ENVProxy
end

class Sprockets::Context
end

class Sprockets::ConversionError
end

class Sprockets::ConversionError
end

module Sprockets::Dependencies
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def add_dependency(uri); end

  def depend_on(uri); end

  def dependencies(); end

  def dependency_resolvers(); end

  def register_dependency_resolver(scheme, &block); end

  def resolve_dependency(str); end
end

module Sprockets::Dependencies
end

module Sprockets::DigestUtils
  def detect_digest_class(bytes); end

  def digest(obj); end

  def digest_class(); end

  def hexdigest(obj); end

  def hexdigest_integrity_uri(hexdigest); end

  def integrity_uri(digest); end

  def pack_base64digest(bin); end

  def pack_hexdigest(bin); end

  def pack_urlsafe_base64digest(bin); end

  def unpack_hexdigest(hex); end
  DIGEST_SIZES = ::T.let(nil, ::T.untyped)
  HASH_ALGORITHMS = ::T.let(nil, ::T.untyped)
end

module Sprockets::DigestUtils
  extend ::Sprockets::DigestUtils
end

class Sprockets::DirectiveProcessor
  def _call(input); end

  def call(input); end

  def compile_header_pattern(comments); end

  def extract_directives(header); end

  def initialize(comments: T.unsafe(nil)); end

  def process_depend_on_asset_directive(path); end

  def process_depend_on_directive(path); end

  def process_directives(directives); end

  def process_link_directive(path); end

  def process_link_directory_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_link_tree_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_require_directive(path); end

  def process_require_directory_directive(path=T.unsafe(nil)); end

  def process_require_self_directive(); end

  def process_require_tree_directive(path=T.unsafe(nil)); end

  def process_source(source); end

  def process_stub_directive(path); end
  DIRECTIVE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Sprockets::DirectiveProcessor
  def self.call(input); end

  def self.instance(); end
end

class Sprockets::DoubleLinkError
  def initialize(parent_filename:, logical_path:, last_filename:, filename:); end
end

class Sprockets::DoubleLinkError
end

class Sprockets::ERBProcessor
  def call(input); end

  def initialize(&block); end
end

class Sprockets::ERBProcessor
  def self.call(input); end

  def self.instance(); end
end

module Sprockets::EcoProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::EjsProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::EncodingUtils
  def base64(str); end

  def charlock_detect(str); end

  def deflate(str); end

  def detect(str); end

  def detect_css(str); end

  def detect_html(str); end

  def detect_unicode(str); end

  def detect_unicode_bom(str); end

  def gzip(str); end

  def scan_css_charset(str); end

  def unmarshaled_deflated(str, window_bits=T.unsafe(nil)); end
  BOM = ::T.let(nil, ::T.untyped)
  CHARSET_DETECT = ::T.let(nil, ::T.untyped)
  CHARSET_SIZE = ::T.let(nil, ::T.untyped)
  CHARSET_START = ::T.let(nil, ::T.untyped)
end

module Sprockets::EncodingUtils
  extend ::Sprockets::EncodingUtils
end

class Sprockets::Environment
  def find_all_linked_assets(*args, &block); end

  def initialize(root=T.unsafe(nil)); end

  def load(*args); end
end

class Sprockets::Environment
end

class Sprockets::Error
end

class Sprockets::Error
end

module Sprockets::Exporters
end

class Sprockets::Exporters::Base
  def asset(); end

  def call(); end

  def directory(); end

  def environment(); end

  def initialize(asset: T.unsafe(nil), environment: T.unsafe(nil), directory: T.unsafe(nil)); end

  def setup(); end

  def skip?(logger); end

  def target(); end

  def write(filename=T.unsafe(nil)); end
end

class Sprockets::Exporters::Base
end

class Sprockets::Exporters::FileExporter
end

class Sprockets::Exporters::FileExporter
end

class Sprockets::Exporters::ZlibExporter
end

class Sprockets::Exporters::ZlibExporter
end

class Sprockets::Exporters::ZopfliExporter
end

class Sprockets::Exporters::ZopfliExporter
end

module Sprockets::Exporters
end

module Sprockets::Exporting
  def export_concurrent(); end

  def export_concurrent=(export_concurrent); end

  def exporters(); end

  def register_exporter(mime_types, klass=T.unsafe(nil)); end

  def unregister_exporter(mime_types, exporter=T.unsafe(nil)); end
end

module Sprockets::Exporting
end

class Sprockets::FileNotFound
end

class Sprockets::FileNotFound
end

class Sprockets::FileOutsidePaths
end

class Sprockets::FileOutsidePaths
end

class Sprockets::FileReader
end

class Sprockets::FileReader
  def self.call(input); end
end

module Sprockets::HTTPUtils
  def find_best_mime_type_match(q_value_header, available); end

  def find_best_q_match(q_values, available, &matcher); end

  def find_mime_type_matches(q_value_header, available); end

  def find_q_matches(q_values, available, &matcher); end

  def match_mime_type?(value, matcher); end

  def match_mime_type_keys(hash, mime_type); end

  def parse_q_values(values); end
end

module Sprockets::HTTPUtils
  extend ::Sprockets::HTTPUtils
end

class Sprockets::JSMincCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::JSMincCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::JstProcessor
  def call(input); end

  def initialize(namespace: T.unsafe(nil)); end
end

class Sprockets::JstProcessor
  def self.call(input); end

  def self.default_namespace(); end

  def self.instance(); end
end

module Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  def load(uri); end
end

module Sprockets::Loader
end

class Sprockets::Manifest
  include ::Sprockets::ManifestUtils
  def assets(); end

  def clean(count=T.unsafe(nil), age=T.unsafe(nil)); end

  def clobber(); end

  def compile(*args); end

  def dir(); end

  def directory(); end

  def environment(); end

  def filename(); end

  def files(); end

  def find(*args); end

  def find_sources(*args); end

  def initialize(*args); end

  def path(); end

  def remove(filename); end

  def save(); end
end

class Sprockets::Manifest
end

module Sprockets::ManifestUtils
  def find_directory_manifest(dirname, logger=T.unsafe(nil)); end

  def generate_manifest_path(); end
  MANIFEST_RE = ::T.let(nil, ::T.untyped)
end

module Sprockets::ManifestUtils
  extend ::Sprockets::ManifestUtils
end

module Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::HTTPUtils
  def mime_exts(); end

  def mime_type_charset_detecter(mime_type); end

  def mime_types(); end

  def read_file(filename, content_type=T.unsafe(nil)); end

  def register_mime_type(mime_type, extensions: T.unsafe(nil), charset: T.unsafe(nil)); end
end

module Sprockets::Mime
end

class Sprockets::NotFound
end

class Sprockets::NotFound
end

class Sprockets::NotImplementedError
end

class Sprockets::NotImplementedError
end

module Sprockets::Npm
  def read_package_directives(dirname, filename); end

  def resolve_alternates(load_path, logical_path); end
end

module Sprockets::Npm
end

module Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
  def entries_with_dependencies(path); end

  def stat_directory_with_dependencies(dir); end

  def stat_sorted_tree_with_dependencies(dir); end
end

module Sprockets::PathDependencyUtils
end

module Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def file_digest(path); end

  def files_digest(paths); end

  def stat_digest(path, stat); end
end

module Sprockets::PathDigestUtils
end

module Sprockets::PathUtils
  def absolute_path?(path); end

  def atomic_write(filename); end

  def directory?(path); end

  def entries(path); end

  def file?(path); end

  def find_matching_path_for_extensions(path, basename, extensions); end

  def find_upwards(basename, path, root=T.unsafe(nil)); end

  def join(base, path); end

  def match_path_extname(path, extensions); end

  def path_extnames(path); end

  def path_parents(path, root=T.unsafe(nil)); end

  def paths_split(paths, filename); end

  def relative_path?(path); end

  def relative_path_from(start, dest); end

  def set_pipeline(path, mime_exts, pipeline_exts, pipeline); end

  def split_subpath(path, subpath); end

  def stat(path); end

  def stat_directory(dir); end

  def stat_sorted_tree(dir, &block); end

  def stat_tree(dir, &block); end
  SEPARATOR_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::PathUtils
  extend ::Sprockets::PathUtils
end

module Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::PathUtils
  def append_path(path); end

  def clear_paths(); end

  def each_file(); end

  def paths(); end

  def prepend_path(path); end

  def root(); end
end

module Sprockets::Paths
end

module Sprockets::Preprocessors
end

class Sprockets::Preprocessors::DefaultSourceMap
  def call(input); end
end

class Sprockets::Preprocessors::DefaultSourceMap
end

module Sprockets::Preprocessors
end

module Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  def build_processors_uri(type, file_type, pipeline); end

  def bundle_processors(); end

  def default_processors_for(type, file_type); end

  def pipelines(); end

  def postprocessors(); end

  def preprocessors(); end

  def processors(); end

  def processors_for(type, file_type, pipeline); end

  def register_bundle_metadata_reducer(mime_type, key, *args, &block); end

  def register_bundle_processor(*args, &block); end

  def register_pipeline(name, proc=T.unsafe(nil), &block); end

  def register_postprocessor(*args, &block); end

  def register_preprocessor(*args, &block); end

  def register_processor(*args, &block); end

  def resolve_processors_cache_key_uri(uri); end

  def self_processors_for(type, file_type); end

  def unregister_bundle_processor(*args); end

  def unregister_postprocessor(*args); end

  def unregister_preprocessor(*args); end

  def unregister_processor(*args); end
end

module Sprockets::Processing
end

module Sprockets::ProcessorUtils
  def call_processor(processor, input); end

  def call_processors(processors, input); end

  def compose_processors(*processors); end

  def processor_cache_key(processor); end

  def processors_cache_keys(processors); end

  def validate_processor_result!(result); end
  VALID_METADATA_COMPOUND_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_COMPOUND_TYPES_HASH = ::T.let(nil, ::T.untyped)
  VALID_METADATA_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES_HASH = ::T.let(nil, ::T.untyped)
end

class Sprockets::ProcessorUtils::CompositeProcessor
  def cache_key(); end

  def call(input); end
  PLURAL = ::T.let(nil, ::T.untyped)
  SINGULAR = ::T.let(nil, ::T.untyped)
end

class Sprockets::ProcessorUtils::CompositeProcessor
  def self.create(processors); end
end

module Sprockets::ProcessorUtils
  extend ::Sprockets::ProcessorUtils
end

module Sprockets::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Context
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def compute_asset_path(path, options=T.unsafe(nil)); end
end

module Sprockets::Rails::Context
  def self.included(klass); end
end

module Sprockets::Rails::Helper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::Sprockets::Rails::Utils
  def asset_digest_path(path, options=T.unsafe(nil)); end

  def asset_integrity(path, options=T.unsafe(nil)); end

  def asset_resolver_strategies(); end

  def compute_asset_path(path, options=T.unsafe(nil)); end

  def compute_integrity?(options); end

  def javascript_include_tag(*sources); end

  def legacy_debug_path(path, debug); end

  def lookup_debug_asset(path, options=T.unsafe(nil)); end

  def path_with_extname(path, options); end

  def request_debug_assets?(); end

  def resolve_asset(); end

  def resolve_asset_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def secure_subresource_integrity_context?(); end

  def stylesheet_link_tag(*sources); end
  VIEW_ACCESSORS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Helper
  def self.extended(obj); end

  def self.included(klass); end
end

module Sprockets::Rails::HelperAssetResolvers
end

class Sprockets::Rails::HelperAssetResolvers::Environment
  def asset_path(path, digest, allow_non_precompiled=T.unsafe(nil)); end

  def digest_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def find_debug_asset(path); end

  def initialize(view); end

  def integrity(path); end
end

class Sprockets::Rails::HelperAssetResolvers::Environment
end

class Sprockets::Rails::HelperAssetResolvers::Manifest
  def asset_path(path, digest, allow_non_precompiled=T.unsafe(nil)); end

  def digest_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def find_debug_asset(path); end

  def initialize(view); end

  def integrity(path); end
end

class Sprockets::Rails::HelperAssetResolvers::Manifest
end

module Sprockets::Rails::HelperAssetResolvers
  def self.[](name); end
end

class Sprockets::Rails::QuietAssets
  def call(env); end

  def initialize(app); end
end

class Sprockets::Rails::QuietAssets
end

module Sprockets::Rails::RouteWrapper
  def internal?(); end

  def internal_assets_path?(); end
end

module Sprockets::Rails::RouteWrapper
  def self.included(klass); end
end

module Sprockets::Rails::Utils
  def using_sprockets4?(); end
end

module Sprockets::Rails::Utils
end

module Sprockets::Rails
end

class Sprockets::Railtie
  include ::Sprockets::Rails::Utils
  def build_environment(app, initialized=T.unsafe(nil)); end
  LOOSE_APP_ASSETS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Railtie::ManifestNeededError
  def initialize(); end
end

class Sprockets::Railtie::ManifestNeededError
end

class Sprockets::Railtie::OrderedOptions
  def configure(&block); end
end

class Sprockets::Railtie::OrderedOptions
end

class Sprockets::Railtie
  def self.build_manifest(app); end
end

module Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
  include ::Sprockets::HTTPUtils
  def parse_accept_options(mime_type, explicit_type); end

  def resolve(path, load_paths: T.unsafe(nil), accept: T.unsafe(nil), pipeline: T.unsafe(nil), base_path: T.unsafe(nil)); end

  def resolve!(path, **kargs); end

  def resolve_absolute_path(paths, filename, accept); end

  def resolve_alternates(load_path, logical_name); end

  def resolve_alts_under_path(load_path, logical_name, mime_exts); end

  def resolve_asset_uri(uri); end

  def resolve_index_under_path(load_path, logical_name, mime_exts); end

  def resolve_logical_path(paths, logical_path, accept); end

  def resolve_main_under_path(load_path, logical_name, mime_exts); end

  def resolve_relative_path(paths, path, dirname, accept); end

  def resolve_under_paths(paths, logical_name, accepts); end
end

module Sprockets::Resolve
end

class Sprockets::SassCompressor
  def cache_key(); end

  def call(*args); end

  def evaluate(*args); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::SassCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

Sprockets::SassFunctions = Sprockets::SassProcessor::Functions

class Sprockets::SassProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil), &block); end
end

module Sprockets::SassProcessor::Functions
  def asset_data_url(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def asset_url(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def audio_url(path); end

  def font_path(path); end

  def font_url(path); end

  def image_path(path); end

  def image_url(path); end

  def javascript_path(path); end

  def javascript_url(path); end

  def sprockets_context(); end

  def sprockets_dependencies(); end

  def sprockets_environment(); end

  def stylesheet_path(path); end

  def stylesheet_url(path); end

  def video_path(path); end

  def video_url(path); end
end

module Sprockets::SassProcessor::Functions
end

class Sprockets::SassProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end

  def self.syntax(); end
end

class Sprockets::SasscCompressor
  def call(input); end

  def initialize(options=T.unsafe(nil)); end
end

class Sprockets::SasscCompressor
  def self.call(input); end

  def self.instance(); end
end

class Sprockets::SasscProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil), &block); end
end

module Sprockets::SasscProcessor::Functions
  def asset_data_url(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def asset_url(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def audio_url(path); end

  def font_path(path); end

  def font_url(path); end

  def image_path(path); end

  def image_url(path); end

  def javascript_path(path); end

  def javascript_url(path); end

  def sprockets_context(); end

  def sprockets_dependencies(); end

  def sprockets_environment(); end

  def stylesheet_path(path); end

  def stylesheet_url(path); end

  def video_path(path); end

  def video_url(path); end
end

module Sprockets::SasscProcessor::Functions
end

class Sprockets::SasscProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end

  def self.syntax(); end
end

class Sprockets::ScssProcessor
end

class Sprockets::ScssProcessor
end

class Sprockets::ScsscProcessor
end

class Sprockets::ScsscProcessor
end

module Sprockets::Server
  def call(env); end
  ALLOWED_REQUEST_METHODS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Server
end

class Sprockets::SourceMapProcessor
end

class Sprockets::SourceMapProcessor
  def self.call(input); end

  def self.original_content_type(source_map_content_type, error_when_not_found: T.unsafe(nil)); end
end

module Sprockets::SourceMapUtils
  def bsearch_mappings(mappings, offset, from=T.unsafe(nil), to=T.unsafe(nil)); end

  def combine_source_maps(first, second); end

  def compare_source_offsets(a, b); end

  def concat_source_maps(a, b); end

  def decode_source_map(map); end

  def decode_vlq_mappings(str, sources: T.unsafe(nil), names: T.unsafe(nil)); end

  def encode_source_map(map); end

  def encode_vlq_mappings(mappings, sources: T.unsafe(nil), names: T.unsafe(nil)); end

  def format_source_map(map, input); end

  def make_index_map(map); end

  def vlq_decode(str); end

  def vlq_decode_mappings(str); end

  def vlq_encode(ary); end

  def vlq_encode_mappings(ary); end
  BASE64_DIGITS = ::T.let(nil, ::T.untyped)
  BASE64_VALUES = ::T.let(nil, ::T.untyped)
  VLQ_BASE = ::T.let(nil, ::T.untyped)
  VLQ_BASE_MASK = ::T.let(nil, ::T.untyped)
  VLQ_BASE_SHIFT = ::T.let(nil, ::T.untyped)
  VLQ_CONTINUATION_BIT = ::T.let(nil, ::T.untyped)
end

module Sprockets::SourceMapUtils
  extend ::Sprockets::SourceMapUtils
end

module Sprockets::Transformers
  include ::Sprockets::Utils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  def compose_transformers(transformers, types, preprocessors, postprocessors); end

  def expand_transform_accepts(parsed_accepts); end

  def register_transformer(from, to, proc); end

  def register_transformer_suffix(types, type_format, extname, processor); end

  def resolve_transform_type(type, accept); end

  def transformers(); end
end

class Sprockets::Transformers::Transformer
  def from(); end

  def from=(_); end

  def proc=(_); end

  def to(); end

  def to=(_); end
end

class Sprockets::Transformers::Transformer
  def self.[](*_); end

  def self.members(); end
end

module Sprockets::Transformers
end

class Sprockets::URITar
  def absolute_path?(); end

  def compress(); end

  def compressed_path(); end

  def expand(); end

  def initialize(uri, env); end

  def path(); end

  def root(); end

  def scheme(); end
end

class Sprockets::URITar
end

module Sprockets::URIUtils
  def build_asset_uri(path, params=T.unsafe(nil)); end

  def build_file_digest_uri(path); end

  def encode_uri_query_params(params); end

  def join_file_uri(scheme, host, path, query); end

  def join_uri(scheme, userinfo, host, port, registry, path, opaque, query, fragment); end

  def parse_asset_uri(uri); end

  def parse_file_digest_uri(uri); end

  def parse_uri_query_params(query); end

  def split_file_uri(uri); end

  def split_uri(uri); end

  def valid_asset_uri?(str); end
end

module Sprockets::URIUtils
  extend ::Sprockets::URIUtils
end

class Sprockets::UglifierCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::UglifierCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::UnloadedAsset
  def asset_key(); end

  def compressed_path(); end

  def dependency_history_key(); end

  def digest_key(digest); end

  def file_digest_key(stat); end

  def filename(); end

  def initialize(uri, env); end

  def params(); end

  def uri(); end
end

class Sprockets::UnloadedAsset
end

module Sprockets::Utils
  def concat_javascript_sources(buf, source); end

  def dfs(initial); end

  def dfs_paths(path); end

  def duplicable?(obj); end

  def hash_reassoc(hash, key_a, key_b=T.unsafe(nil), &block); end

  def hash_reassoc1(hash, key); end

  def module_include(base, mod); end

  def string_end_with_semicolon?(str); end
end

class Sprockets::Utils::Gzip
  def archiver(); end

  def can_compress?(); end

  def cannot_compress?(); end

  def charset(); end

  def compress(file, target); end

  def content_type(); end

  def initialize(asset, archiver: T.unsafe(nil)); end

  def source(); end
  COMPRESSABLE_MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Sprockets::Utils::Gzip::ZlibArchiver
end

module Sprockets::Utils::Gzip::ZlibArchiver
  def self.call(file, source, mtime); end
end

module Sprockets::Utils::Gzip::ZopfliArchiver
end

module Sprockets::Utils::Gzip::ZopfliArchiver
  def self.call(file, source, mtime); end
end

class Sprockets::Utils::Gzip
end

module Sprockets::Utils
  extend ::Sprockets::Utils
end

class Sprockets::YUICompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::YUICompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets
  extend ::Sprockets::Configuration
  extend ::Sprockets::Dependencies
  extend ::Sprockets::Compressing
  extend ::Sprockets::Exporting
  extend ::Sprockets::Processing
  extend ::Sprockets::Transformers
  extend ::Sprockets::Mime
  extend ::Sprockets::Paths
  extend ::Sprockets::Utils
  extend ::Sprockets::URIUtils
  extend ::Sprockets::PathDigestUtils
  extend ::Sprockets::ProcessorUtils
  extend ::Sprockets::HTTPUtils
  extend ::Sprockets::PathUtils
  extend ::Sprockets::DigestUtils
end

module Statesman
  VERSION = ::T.let(nil, ::T.untyped)
end

module Statesman::Adapters
end

class Statesman::Adapters::ActiveRecord
  def create(from, to, metadata=T.unsafe(nil)); end

  def history(force_reload: T.unsafe(nil)); end

  def initialize(transition_class, parent_model, observer, options=T.unsafe(nil)); end

  def last(force_reload: T.unsafe(nil)); end

  def parent_model(); end

  def transition_class(); end

  def transition_table(); end
  JSON_COLUMN_TYPES = ::T.let(nil, ::T.untyped)
end

class Statesman::Adapters::ActiveRecord
  def self.adapter_name(); end

  def self.database_supports_partial_indexes?(); end
end

class Statesman::Adapters::ActiveRecordAfterCommitWrap
  def add_to_transaction(*_); end

  def before_committed!(*_); end

  def committed!(*_); end

  def has_transactional_callbacks?(); end

  def initialize(&block); end

  def rolledback!(*_); end

  def trigger_transactional_callbacks?(); end
end

class Statesman::Adapters::ActiveRecordAfterCommitWrap
  def self.trigger_transactional_callbacks?(); end
end

module Statesman::Adapters::ActiveRecordQueries
end

class Statesman::Adapters::ActiveRecordQueries::ClassMethods
  def included(base); end

  def initialize(**args); end
end

class Statesman::Adapters::ActiveRecordQueries::ClassMethods
end

class Statesman::Adapters::ActiveRecordQueries::QueryBuilder
  def initialize(model, transition_class:, initial_state:, most_recent_transition_alias: T.unsafe(nil), transition_name: T.unsafe(nil)); end

  def most_recent_transition_join(); end

  def states_where(states); end
end

class Statesman::Adapters::ActiveRecordQueries::QueryBuilder
end

module Statesman::Adapters::ActiveRecordQueries
  def self.[](**args); end

  def self.check_missing_methods!(base); end

  def self.included(base); end
end

module Statesman::Adapters::ActiveRecordTransition
  DEFAULT_UPDATED_TIMESTAMP_COLUMN = ::T.let(nil, ::T.untyped)
end

module Statesman::Adapters::ActiveRecordTransition
  extend ::ActiveSupport::Concern
end

class Statesman::Adapters::Memory
  def create(from, to, metadata=T.unsafe(nil)); end

  def history(*_); end

  def initialize(transition_class, parent_model, observer, _opts=T.unsafe(nil)); end

  def last(*_); end

  def parent_model(); end

  def transition_class(); end
end

class Statesman::Adapters::Memory
end

class Statesman::Adapters::MemoryTransition
  def created_at(); end

  def created_at=(created_at); end

  def initialize(to, sort_key, metadata=T.unsafe(nil)); end

  def metadata(); end

  def metadata=(metadata); end

  def sort_key(); end

  def sort_key=(sort_key); end

  def to_state(); end

  def to_state=(to_state); end

  def updated_at(); end

  def updated_at=(updated_at); end
end

class Statesman::Adapters::MemoryTransition
end

module Statesman::Adapters
end

class Statesman::Callback
  def applies_to?(options=T.unsafe(nil)); end

  def call(*args); end

  def callback(); end

  def from(); end

  def initialize(options=T.unsafe(nil)); end

  def to(); end
end

class Statesman::Callback
end

class Statesman::Config
  def adapter_class(); end

  def enable_mysql_gaplock_protection(); end

  def initialize(block=T.unsafe(nil)); end

  def mysql_gaplock_protection?(); end

  def storage_adapter(adapter_class); end
end

class Statesman::Config
end

class Statesman::Guard
end

class Statesman::Guard
end

class Statesman::GuardFailedError
  def from(); end

  def initialize(from, to); end

  def to(); end
end

class Statesman::GuardFailedError
end

class Statesman::IncompatibleSerializationError
  def initialize(transition_class_name); end
end

class Statesman::IncompatibleSerializationError
end

class Statesman::InvalidCallbackError
end

class Statesman::InvalidCallbackError
end

class Statesman::InvalidStateError
end

class Statesman::InvalidStateError
end

class Statesman::InvalidTransitionError
end

class Statesman::InvalidTransitionError
end

module Statesman::Machine
  def allowed_transitions(metadata=T.unsafe(nil)); end

  def can_transition_to?(new_state, metadata=T.unsafe(nil)); end

  def current_state(force_reload: T.unsafe(nil)); end

  def execute(phase, initial_state, new_state, transition); end

  def execute_on_failure(phase, initial_state, new_state, exception); end

  def history(); end

  def in_state?(*states); end

  def initialize(object, options=T.unsafe(nil)); end

  def last_transition(force_reload: T.unsafe(nil)); end

  def transition_to(new_state, metadata=T.unsafe(nil)); end

  def transition_to!(new_state, metadata=T.unsafe(nil)); end
end

module Statesman::Machine
  def self.included(base); end

  def self.retry_conflicts(max_retries=T.unsafe(nil)); end
end

class Statesman::MissingTransitionAssociation
end

class Statesman::MissingTransitionAssociation
end

class Statesman::Railtie
end

class Statesman::Railtie
end

class Statesman::TransitionConflictError
end

class Statesman::TransitionConflictError
end

class Statesman::TransitionFailedError
  def from(); end

  def initialize(from, to); end

  def to(); end
end

class Statesman::TransitionFailedError
end

class Statesman::UnserializedMetadataError
  def initialize(transition_class_name); end
end

class Statesman::UnserializedMetadataError
end

module Statesman::Utils
end

module Statesman::Utils
  def self.rails_4_or_higher?(); end

  def self.rails_5_or_higher?(); end

  def self.rails_major_version(); end
end

module Statesman
  def self.config(); end

  def self.configure(&block); end

  def self.mysql_gaplock_protection?(); end

  def self.storage_adapter(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::MessagePack::CoreExt
  def ext(newext=T.unsafe(nil)); end

  def parse_csv(**options); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def shellescape(); end

  def shellsplit(); end

  def strip_indent(); end

  def truncate_bytes(truncate_at, omission: T.unsafe(nil)); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def bol?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def filter(*_); end
end

class Struct::AwsEmptyStructure
end

class Struct::AwsEmptyStructure
  def self.[](*_); end

  def self.members(); end
end

Struct::Group = Etc::Group

class Struct::HTMLElementDescription
  def attrs_depr(); end

  def attrs_depr=(_); end

  def attrs_opt(); end

  def attrs_opt=(_); end

  def attrs_req(); end

  def attrs_req=(_); end

  def defaultsubelt(); end

  def defaultsubelt=(_); end

  def depr(); end

  def depr=(_); end

  def desc(); end

  def desc=(_); end

  def dtd(); end

  def dtd=(_); end

  def empty(); end

  def empty=(_); end

  def endTag(); end

  def endTag=(_); end

  def isinline(); end

  def isinline=(_); end

  def name(); end

  def name=(_); end

  def saveEndTag(); end

  def saveEndTag=(_); end

  def startTag(); end

  def startTag=(_); end

  def subelts(); end

  def subelts=(_); end
end

class Struct::HTMLElementDescription
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SubstitutionContext
  def match(matches, attribute, matcher); end

  def substitute!(selector, values, format_for_presentation=T.unsafe(nil)); end
end

class SubstitutionContext
end

class Symbol
  include ::MessagePack::CoreExt
  def to_msgpack_ext(); end
end

class Symbol
  def self.from_msgpack_ext(data); end
end

class SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
end

class SynchronizedDelegator
end

module TTY
end

module TTY::Color
  def color?(); end

  def command?(cmd); end

  def mode(); end

  def output(); end

  def output=(output); end

  def support?(); end

  def supports?(); end

  def supports_color?(); end

  def tty?(); end

  def verbose(); end

  def verbose=(verbose); end

  def windows?(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class TTY::Color::Mode
  def from_term(); end

  def from_tput(); end

  def initialize(env); end

  def mode(); end
  METHODS = ::T.let(nil, ::T.untyped)
  TERM_16 = ::T.let(nil, ::T.untyped)
  TERM_256 = ::T.let(nil, ::T.untyped)
  TERM_52 = ::T.let(nil, ::T.untyped)
  TERM_64 = ::T.let(nil, ::T.untyped)
  TERM_8 = ::T.let(nil, ::T.untyped)
end

class TTY::Color::Mode
end

module TTY::Color::NoValue
end

module TTY::Color::NoValue
end

class TTY::Color::Support
  def from_curses(curses_class=T.unsafe(nil)); end

  def from_env(); end

  def from_term(); end

  def from_tput(); end

  def initialize(env, options=T.unsafe(nil)); end

  def support?(); end
  ENV_VARS = ::T.let(nil, ::T.untyped)
  SOURCES = ::T.let(nil, ::T.untyped)
end

class TTY::Color::Support
end

module TTY::Color
  extend ::TTY::Color
end

class TTY::Command
  def dry_run?(); end

  def initialize(**options); end

  def printer(); end

  def ruby(*args, &block); end

  def run(*args, &block); end

  def run!(*args, &block); end

  def test(*args); end

  def wait(*args); end
  RUBY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WIN_PLATFORMS = ::T.let(nil, ::T.untyped)
end

module TTY::Command::ChildProcess
end

module TTY::Command::ChildProcess
  def self.close_fds(*fds); end

  def self.convert(spawn_key, spawn_value); end

  def self.convert_to_fd(object); end

  def self.fd?(object); end

  def self.fd_to_process_key(object); end

  def self.normalize_redirect_options(options); end

  def self.spawn(cmd); end

  def self.try_loading_pty(verbose=T.unsafe(nil)); end

  def self.try_reading(object); end
end

class TTY::Command::Cmd
  def argv(); end

  def chdir(value); end

  def command(); end

  def environment(); end

  def environment_string(); end

  def evars(value, &block); end

  def group(value); end

  def initialize(env_or_cmd, *args); end

  def only_output_on_error(); end

  def options(); end

  def to_command(); end

  def to_hash(); end

  def umask(value); end

  def update(**options); end

  def user(value); end

  def uuid(); end

  def with_clean_env(); end
end

class TTY::Command::Cmd
end

class TTY::Command::DryRunner
  def cmd(); end

  def initialize(cmd, printer); end

  def run!(*_); end
end

class TTY::Command::DryRunner
end

class TTY::Command::ExecuteError
end

class TTY::Command::ExecuteError
end

class TTY::Command::ExitError
  def extract_output(value); end

  def info(cmd_name, result); end

  def initialize(cmd_name, result); end
end

class TTY::Command::ExitError
end

module TTY::Command::Printers
end

class TTY::Command::Printers::Abstract
  def decorate(*args, &block); end

  def err_data(); end

  def err_data=(err_data); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def out_data(); end

  def out_data=(out_data); end

  def output(); end

  def print_command_err_data(cmd, *args); end

  def print_command_exit(cmd, *args); end

  def print_command_out_data(cmd, *args); end

  def print_command_start(cmd, *args); end

  def write(cmd, message); end
end

class TTY::Command::Printers::Abstract
  extend ::Forwardable
end

class TTY::Command::Printers::Null
  def write(*_); end
end

class TTY::Command::Printers::Null
end

class TTY::Command::Printers::Pretty
  def initialize(*_); end

  def print_command_exit(cmd, status, runtime, *args); end

  def write(cmd, message, data=T.unsafe(nil)); end
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class TTY::Command::Printers::Pretty
end

class TTY::Command::Printers::Progress
  def print_command_exit(cmd, status, runtime, *args); end

  def write(*_); end
end

class TTY::Command::Printers::Progress
end

class TTY::Command::Printers::Quiet
  def print_command_exit(cmd, status, *args); end

  def print_command_start(cmd); end

  def write(cmd, message, data=T.unsafe(nil)); end
end

class TTY::Command::Printers::Quiet
end

module TTY::Command::Printers
end

class TTY::Command::ProcessRunner
  def cmd(); end

  def initialize(cmd, printer, &block); end

  def run!(); end

  def terminate(pid); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
end

class TTY::Command::ProcessRunner
end

class TTY::Command::Result
  include ::Enumerable
  def ==(other); end

  def complete?(); end

  def each(separator=T.unsafe(nil), &blk); end

  def err(); end

  def exit_status(); end

  def exited?(); end

  def exitstatus(); end

  def failed?(); end

  def failure?(); end

  def initialize(status, out, err, runtime=T.unsafe(nil)); end

  def out(); end

  def runtime(); end

  def status(); end

  def stderr(); end

  def stdout(); end

  def success?(); end

  def to_ary(); end

  def to_i(); end
end

class TTY::Command::Result
end

class TTY::Command::TimeoutExceeded
end

class TTY::Command::TimeoutExceeded
end

class TTY::Command::Truncator
  def <<(content); end

  def initialize(options=T.unsafe(nil)); end

  def read(); end

  def write(content); end
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class TTY::Command::Truncator
end

class TTY::Command
  def self.record_separator(); end

  def self.record_separator=(sep); end

  def self.windows?(); end
end

module TTY
end

module TZInfo
end

class TZInfo::AmbiguousTime
end

class TZInfo::AmbiguousTime
end

class TZInfo::Country
  include ::Comparable
  def _dump(limit); end

  def code(); end

  def eql?(c); end

  def name(); end

  def zone_identifiers(); end

  def zone_info(); end

  def zone_names(); end

  def zones(); end
end

class TZInfo::Country
  def self._load(data); end

  def self.all(); end

  def self.all_codes(); end

  def self.data_source(); end

  def self.get(identifier); end

  def self.init_countries(); end

  def self.new(identifier); end
end

module TZInfo::CountryIndexDefinition
end

module TZInfo::CountryIndexDefinition::ClassMethods
  def countries(); end

  def country(code, name, &block); end
end

module TZInfo::CountryIndexDefinition::ClassMethods
end

module TZInfo::CountryIndexDefinition
  def self.append_features(base); end
end

class TZInfo::CountryInfo
  def code(); end

  def initialize(code, name); end

  def name(); end

  def zone_identifiers(); end

  def zones(); end
end

class TZInfo::CountryInfo
end

class TZInfo::CountryTimezone
  def ==(ct); end

  def description(); end

  def description_or_friendly_identifier(); end

  def eql?(ct); end

  def identifier(); end

  def initialize(identifier, latitude_numerator, latitude_denominator, longitude_numerator, longitude_denominator, description=T.unsafe(nil)); end

  def latitude(); end

  def longitude(); end

  def timezone(); end
end

class TZInfo::CountryTimezone
  def self.new(identifier, latitude, longitude, description=T.unsafe(nil)); end

  def self.new!(*_); end
end

class TZInfo::DataSource
  def country_codes(); end

  def data_timezone_identifiers(); end

  def linked_timezone_identifiers(); end

  def load_country_info(code); end

  def load_timezone_info(identifier); end

  def timezone_identifiers(); end
end

class TZInfo::DataSource
  def self.create_default_data_source(); end

  def self.get(); end

  def self.set(data_source_or_type, *args); end
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezoneInfo
  def period_for_utc(utc); end

  def periods_for_local(local); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end
end

class TZInfo::DataTimezoneInfo
end

class TZInfo::InfoTimezone
  def info(); end

  def setup(info); end
end

class TZInfo::InfoTimezone
  def self.new(info); end
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidZoneinfoDirectory
end

class TZInfo::InvalidZoneinfoDirectory
end

class TZInfo::InvalidZoneinfoFile
end

class TZInfo::InvalidZoneinfoFile
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezoneInfo
  def initialize(identifier, link_to_identifier); end

  def link_to_identifier(); end
end

class TZInfo::LinkedTimezoneInfo
end

class TZInfo::NoOffsetsDefined
end

class TZInfo::NoOffsetsDefined
end

module TZInfo::OffsetRationals
end

module TZInfo::OffsetRationals
  def self.rational_for_offset(offset); end
end

class TZInfo::PeriodNotFound
end

class TZInfo::PeriodNotFound
end

module TZInfo::RubyCoreSupport
  HALF_DAYS_IN_DAY = ::T.let(nil, ::T.untyped)
end

module TZInfo::RubyCoreSupport
  def self.datetime_new(y=T.unsafe(nil), m=T.unsafe(nil), d=T.unsafe(nil), h=T.unsafe(nil), min=T.unsafe(nil), s=T.unsafe(nil), of=T.unsafe(nil), sg=T.unsafe(nil)); end

  def self.datetime_new!(ajd=T.unsafe(nil), of=T.unsafe(nil), sg=T.unsafe(nil)); end

  def self.force_encoding(str, encoding); end

  def self.open_file(file_name, mode, opts, &block); end

  def self.rational_new!(numerator, denominator=T.unsafe(nil)); end

  def self.time_nsec(time); end

  def self.time_supports_64bit(); end

  def self.time_supports_negative(); end
end

class TZInfo::RubyCountryInfo
  def initialize(code, name, &block); end
end

class TZInfo::RubyCountryInfo::Zones
  def list(); end

  def timezone(identifier, latitude_numerator, latitude_denominator, longitude_numerator, longitude_denominator, description=T.unsafe(nil)); end
end

class TZInfo::RubyCountryInfo::Zones
end

class TZInfo::RubyCountryInfo
end

class TZInfo::RubyDataSource
end

class TZInfo::RubyDataSource
end

class TZInfo::TimeOrDateTime
  include ::Comparable
  def +(seconds); end

  def -(seconds); end

  def add_with_convert(seconds); end

  def day(); end

  def eql?(todt); end

  def hour(); end

  def initialize(timeOrDateTime); end

  def mday(); end

  def min(); end

  def mon(); end

  def month(); end

  def sec(); end

  def to_datetime(); end

  def to_i(); end

  def to_orig(); end

  def to_time(); end

  def usec(); end

  def year(); end
end

class TZInfo::TimeOrDateTime
  def self.wrap(timeOrDateTime); end
end

class TZInfo::Timezone
  include ::Comparable
  def _dump(limit); end

  def canonical_identifier(); end

  def canonical_zone(); end

  def current_period(); end

  def current_period_and_time(); end

  def current_time_and_period(); end

  def eql?(tz); end

  def friendly_identifier(skip_first_part=T.unsafe(nil)); end

  def identifier(); end

  def local_to_utc(local, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def offsets_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def period_for_local(local, dst=T.unsafe(nil)); end

  def period_for_utc(utc); end

  def periods_for_local(local); end

  def strftime(format, utc=T.unsafe(nil)); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def utc_to_local(utc); end
end

class TZInfo::Timezone
  def self._load(data); end

  def self.all(); end

  def self.all_country_zone_identifiers(); end

  def self.all_country_zones(); end

  def self.all_data_zone_identifiers(); end

  def self.all_data_zones(); end

  def self.all_identifiers(); end

  def self.all_linked_zone_identifiers(); end

  def self.all_linked_zones(); end

  def self.data_source(); end

  def self.default_dst(); end

  def self.default_dst=(value); end

  def self.get(identifier); end

  def self.get_proxies(identifiers); end

  def self.get_proxy(identifier); end

  def self.init_loaded_zones(); end

  def self.new(identifier=T.unsafe(nil)); end

  def self.us_zone_identifiers(); end

  def self.us_zones(); end
end

module TZInfo::TimezoneDefinition
end

module TZInfo::TimezoneDefinition::ClassMethods
  def get(); end

  def linked_timezone(identifier, link_to_identifier); end

  def timezone(identifier); end
end

module TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::TimezoneDefinition
  def self.append_features(base); end
end

module TZInfo::TimezoneIndexDefinition
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
  def data_timezones(); end

  def linked_timezone(identifier); end

  def linked_timezones(); end

  def timezone(identifier); end

  def timezones(); end
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
end

module TZInfo::TimezoneIndexDefinition
  def self.append_features(base); end
end

class TZInfo::TimezoneInfo
  def create_timezone(); end

  def identifier(); end

  def initialize(identifier); end
end

class TZInfo::TimezoneInfo
end

class TZInfo::TimezoneOffset
  def ==(toi); end

  def abbreviation(); end

  def dst?(); end

  def eql?(toi); end

  def initialize(utc_offset, std_offset, abbreviation); end

  def std_offset(); end

  def to_local(utc); end

  def to_utc(local); end

  def utc_offset(); end

  def utc_total_offset(); end
end

class TZInfo::TimezoneOffset
end

class TZInfo::TimezonePeriod
  def ==(p); end

  def abbreviation(); end

  def dst?(); end

  def end_transition(); end

  def eql?(p); end

  def initialize(start_transition, end_transition, offset=T.unsafe(nil)); end

  def local_after_start?(local); end

  def local_before_end?(local); end

  def local_end(); end

  def local_end_time(); end

  def local_start(); end

  def local_start_time(); end

  def offset(); end

  def start_transition(); end

  def std_offset(); end

  def to_local(utc); end

  def to_utc(local); end

  def utc_after_start?(utc); end

  def utc_before_end?(utc); end

  def utc_end(); end

  def utc_end_time(); end

  def utc_offset(); end

  def utc_start(); end

  def utc_start_time(); end

  def utc_total_offset(); end

  def utc_total_offset_rational(); end

  def valid_for_local?(local); end

  def valid_for_utc?(utc); end

  def zone_identifier(); end
end

class TZInfo::TimezonePeriod
end

class TZInfo::TimezoneProxy
  def transitions_up_to(to, from=T.unsafe(nil)); end
end

class TZInfo::TimezoneProxy
  def self.new(identifier); end
end

class TZInfo::TimezoneTransition
  def ==(tti); end

  def at(); end

  def datetime(); end

  def eql?(tti); end

  def initialize(offset, previous_offset); end

  def local_end(); end

  def local_end_at(); end

  def local_end_time(); end

  def local_start(); end

  def local_start_at(); end

  def local_start_time(); end

  def offset(); end

  def previous_offset(); end

  def time(); end
end

class TZInfo::TimezoneTransition
end

class TZInfo::TimezoneTransitionDefinition
  def denominator(); end

  def initialize(offset, previous_offset, numerator_or_timestamp, denominator_or_numerator=T.unsafe(nil), denominator=T.unsafe(nil)); end

  def numerator_or_time(); end
end

class TZInfo::TimezoneTransitionDefinition
end

class TZInfo::TransitionDataTimezoneInfo
  def offset(id, utc_offset, std_offset, abbreviation); end

  def transition(year, month, offset_id, numerator_or_timestamp, denominator_or_numerator=T.unsafe(nil), denominator=T.unsafe(nil)); end
end

class TZInfo::TransitionDataTimezoneInfo
end

class TZInfo::UnknownTimezone
end

class TZInfo::UnknownTimezone
end

class TZInfo::ZoneinfoCountryInfo
  def initialize(code, name, zones); end
end

class TZInfo::ZoneinfoCountryInfo
end

class TZInfo::ZoneinfoDataSource
  def initialize(zoneinfo_dir=T.unsafe(nil), alternate_iso3166_tab_path=T.unsafe(nil)); end

  def zoneinfo_dir(); end
  DEFAULT_ALTERNATE_ISO3166_TAB_SEARCH_PATH = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATH = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoDataSource
  def self.alternate_iso3166_tab_search_path(); end

  def self.alternate_iso3166_tab_search_path=(alternate_iso3166_tab_search_path); end

  def self.process_search_path(path, default); end

  def self.search_path(); end

  def self.search_path=(search_path); end
end

class TZInfo::ZoneinfoDirectoryNotFound
end

class TZInfo::ZoneinfoDirectoryNotFound
end

class TZInfo::ZoneinfoTimezoneInfo
  def initialize(identifier, file_path); end
  MAX_TIMESTAMP = ::T.let(nil, ::T.untyped)
  MIN_TIMESTAMP = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoTimezoneInfo
end

module TZInfo
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module Temple
  VERSION = ::T.let(nil, ::T.untyped)
end

module Temple::ERB
end

class Temple::ERB::Engine
end

class Temple::ERB::Engine
end

class Temple::ERB::Parser
  def call(input); end
  ERB_PATTERN = ::T.let(nil, ::T.untyped)
end

class Temple::ERB::Parser
end

class Temple::ERB::Template
end

class Temple::ERB::Template
end

class Temple::ERB::Trimming
end

class Temple::ERB::Trimming
end

module Temple::ERB
end

class Temple::Engine
  include ::Temple::Mixins::Options
  include ::Temple::Mixins::EngineDSL
  def call(input); end

  def call_chain(); end

  def chain(); end
end

class Temple::Engine
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions
  extend ::Temple::Mixins::EngineDSL
  def self.chain(); end
end

class Temple::Filter
  include ::Temple::Utils
  include ::Temple::Mixins::Dispatcher
  include ::Temple::Mixins::CompiledDispatcher
  include ::Temple::Mixins::CoreDispatcher
  include ::Temple::Mixins::EscapeDispatcher
  include ::Temple::Mixins::ControlFlowDispatcher
  include ::Temple::Mixins::Options
end

class Temple::Filter
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions
end

class Temple::FilterError
end

class Temple::FilterError
end

module Temple::Filters
end

class Temple::Filters::CodeMerger
end

class Temple::Filters::CodeMerger
end

class Temple::Filters::ControlFlow
  def on_block(code, exp); end

  def on_if(condition, yes, no=T.unsafe(nil)); end
end

class Temple::Filters::ControlFlow
end

class Temple::Filters::DynamicInliner
end

class Temple::Filters::DynamicInliner
end

class Temple::Filters::Encoding
  def call(s); end
end

class Temple::Filters::Encoding
end

class Temple::Filters::Eraser
  def do?(list, exp); end
end

class Temple::Filters::Eraser
end

class Temple::Filters::Escapable
  def on_dynamic(value); end

  def on_static(value); end
end

class Temple::Filters::Escapable
end

class Temple::Filters::MultiFlattener
end

class Temple::Filters::MultiFlattener
end

class Temple::Filters::RemoveBOM
  def call(s); end
end

class Temple::Filters::RemoveBOM
end

class Temple::Filters::StaticAnalyzer
  def on_dynamic(code); end
end

class Temple::Filters::StaticAnalyzer
end

class Temple::Filters::StaticMerger
end

class Temple::Filters::StaticMerger
end

class Temple::Filters::StringSplitter
  def on_dynamic(code); end
end

class Temple::Filters::StringSplitter::SyntaxChecker
end

class Temple::Filters::StringSplitter::SyntaxChecker::ParseError
end

class Temple::Filters::StringSplitter::SyntaxChecker::ParseError
end

class Temple::Filters::StringSplitter::SyntaxChecker
  def self.syntax_error?(code); end
end

class Temple::Filters::StringSplitter
  def self.compile(code); end
end

class Temple::Filters::Validator
end

class Temple::Filters::Validator
end

module Temple::Filters
end

class Temple::Generator
  include ::Temple::Utils
  include ::Temple::Mixins::CompiledDispatcher
  include ::Temple::Mixins::Options
  def buffer(); end

  def capture_generator(); end

  def concat(str); end

  def create_buffer(); end

  def on(*exp); end

  def on_capture(name, exp); end

  def on_code(code); end

  def on_dynamic(code); end

  def on_multi(*exp); end

  def on_newline(); end

  def on_static(text); end

  def postamble(); end

  def preamble(); end

  def restore_buffer(); end

  def return_buffer(); end

  def save_buffer(); end
end

class Temple::Generator
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions
end

module Temple::Generators
end

class Temple::Generators::Array
end

class Temple::Generators::Array
end

class Temple::Generators::ArrayBuffer
end

class Temple::Generators::ArrayBuffer
end

class Temple::Generators::ERB
end

class Temple::Generators::ERB
end

class Temple::Generators::RailsOutputBuffer
end

class Temple::Generators::RailsOutputBuffer
end

class Temple::Generators::StringBuffer
end

class Temple::Generators::StringBuffer
end

module Temple::Generators
end

module Temple::Grammar
  Bool = ::T.let(nil, ::T.untyped)
  Case = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  EmptyExp = ::T.let(nil, ::T.untyped)
  Expression = ::T.let(nil, ::T.untyped)
  HTMLAttr = ::T.let(nil, ::T.untyped)
  HTMLIdentifier = ::T.let(nil, ::T.untyped)
end

module Temple::Grammar
  extend ::Temple::Mixins::GrammarDSL
end

module Temple::HTML
end

class Temple::HTML::AttributeMerger
end

class Temple::HTML::AttributeMerger
end

class Temple::HTML::AttributeRemover
  def on_html_attr(name, value); end
end

class Temple::HTML::AttributeRemover
end

class Temple::HTML::AttributeSorter
end

class Temple::HTML::AttributeSorter
end

module Temple::HTML::Dispatcher
  def on_html_attr(name, content); end

  def on_html_attrs(*attrs); end

  def on_html_comment(content); end

  def on_html_condcomment(condition, content); end

  def on_html_js(content); end

  def on_html_tag(name, attrs, content=T.unsafe(nil)); end
end

module Temple::HTML::Dispatcher
end

class Temple::HTML::Fast
  def on_html_attr(name, value); end

  def on_html_doctype(type); end
  DOCTYPES = ::T.let(nil, ::T.untyped)
  HTML_VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Temple::HTML::Fast
end

class Temple::HTML::Filter
  include ::Temple::HTML::Dispatcher
  def contains_nonempty_static?(exp); end
end

class Temple::HTML::Filter
end

class Temple::HTML::Pretty
  def indent(); end

  def on_dynamic(code); end

  def on_static(content); end

  def preamble(); end

  def tag_indent(name); end
end

class Temple::HTML::Pretty
end

module Temple::HTML
end

class Temple::ImmutableMap
  include ::Enumerable
  def [](key); end

  def each(&blk); end

  def include?(key); end

  def initialize(*map); end

  def keys(); end

  def to_hash(); end

  def values(); end
end

class Temple::ImmutableMap
end

class Temple::InvalidExpression
end

class Temple::InvalidExpression
end

module Temple::Mixins
end

module Temple::Mixins::ClassOptions
  def default_options(); end

  def define_deprecated_options(*opts); end

  def define_options(*opts); end

  def disable_option_validator!(); end

  def options(); end

  def set_default_options(opts); end

  def set_options(opts); end
end

module Temple::Mixins::ClassOptions
end

module Temple::Mixins::CompiledDispatcher
  def call(exp); end

  def compile(exp); end
end

module Temple::Mixins::CompiledDispatcher
end

module Temple::Mixins::ControlFlowDispatcher
  def on_block(code, content); end

  def on_case(arg, *cases); end

  def on_cond(*cases); end

  def on_if(condition, *cases); end
end

module Temple::Mixins::ControlFlowDispatcher
end

module Temple::Mixins::CoreDispatcher
  def on_capture(name, exp); end

  def on_multi(*exps); end
end

module Temple::Mixins::CoreDispatcher
end

module Temple::Mixins::Dispatcher
  include ::Temple::Mixins::CompiledDispatcher
  include ::Temple::Mixins::CoreDispatcher
  include ::Temple::Mixins::EscapeDispatcher
  include ::Temple::Mixins::ControlFlowDispatcher
end

module Temple::Mixins::Dispatcher
end

module Temple::Mixins::EngineDSL
  def after(name, *args, &block); end

  def append(*args, &block); end

  def before(name, *args, &block); end

  def chain_modified!(); end

  def filter(name, *options); end

  def generator(name, *options); end

  def html(name, *options); end

  def prepend(*args, &block); end

  def remove(name); end

  def replace(name, *args, &block); end

  def use(*args, &block); end
end

module Temple::Mixins::EngineDSL
end

module Temple::Mixins::EscapeDispatcher
  def on_escape(flag, exp); end
end

module Temple::Mixins::EscapeDispatcher
end

module Temple::Mixins::GrammarDSL
  def ===(exp); end

  def =~(exp); end

  def Rule(rule); end

  def Value(value); end

  def const_missing(name); end

  def extended(mod); end

  def match?(exp); end

  def validate!(exp); end
end

class Temple::Mixins::GrammarDSL::Element
  def initialize(grammar, rule); end
end

class Temple::Mixins::GrammarDSL::Element
end

class Temple::Mixins::GrammarDSL::Or
  def <<(rule); end

  def after_copy(source); end

  def initialize(grammar, *children); end

  def match(exp, unmatched); end
end

class Temple::Mixins::GrammarDSL::Or
end

class Temple::Mixins::GrammarDSL::Root
  def initialize(grammar, name); end

  def validate!(exp); end
end

class Temple::Mixins::GrammarDSL::Root
end

class Temple::Mixins::GrammarDSL::Rule
  def ===(exp); end

  def =~(exp); end

  def copy_to(grammar); end

  def initialize(grammar); end

  def match?(exp); end

  def |(rule); end
end

class Temple::Mixins::GrammarDSL::Rule
end

class Temple::Mixins::GrammarDSL::Value
  def initialize(grammar, value); end

  def match(exp, unmatched); end
end

class Temple::Mixins::GrammarDSL::Value
end

module Temple::Mixins::GrammarDSL
end

module Temple::Mixins::Options
  def initialize(opts=T.unsafe(nil)); end

  def options(); end
end

module Temple::Mixins::Options
  def self.included(base); end
end

module Temple::Mixins::Template
  include ::Temple::Mixins::ClassOptions
  def compile(code, options); end

  def create(engine, options); end

  def register_as(*names); end
end

module Temple::Mixins::Template
end

module Temple::Mixins::ThreadOptions
  def thread_options(); end

  def thread_options_key(); end

  def with_options(options); end
end

module Temple::Mixins::ThreadOptions
end

module Temple::Mixins
end

class Temple::MutableMap
  def []=(key, value); end

  def update(map); end
end

class Temple::MutableMap
end

class Temple::OptionMap
  def add_deprecated_keys(*keys); end

  def add_valid_keys(*keys); end

  def deprecated_key?(key); end

  def initialize(*map, &block); end

  def valid_key?(key); end

  def valid_keys(); end

  def validate_key!(key); end

  def validate_map!(map); end
end

class Temple::OptionMap
end

class Temple::Parser
  include ::Temple::Utils
  include ::Temple::Mixins::Options
end

class Temple::Parser
  extend ::Temple::Mixins::ClassOptions
  extend ::Temple::Mixins::ThreadOptions
end

module Temple::StaticAnalyzer
  DYNAMIC_TOKENS = ::T.let(nil, ::T.untyped)
  STATIC_KEYWORDS = ::T.let(nil, ::T.untyped)
  STATIC_OPERATORS = ::T.let(nil, ::T.untyped)
  STATIC_TOKENS = ::T.let(nil, ::T.untyped)
end

class Temple::StaticAnalyzer::SyntaxChecker
end

class Temple::StaticAnalyzer::SyntaxChecker::ParseError
end

class Temple::StaticAnalyzer::SyntaxChecker::ParseError
end

class Temple::StaticAnalyzer::SyntaxChecker
end

module Temple::StaticAnalyzer
  def self.available?(); end

  def self.static?(code); end

  def self.syntax_error?(code); end
end

module Temple::Templates
end

class Temple::Templates::Rails
  def call(template, source=T.unsafe(nil)); end

  def supports_streaming?(); end
end

class Temple::Templates::Rails
  extend ::Temple::Mixins::Template
  extend ::Temple::Mixins::ClassOptions
end

class Temple::Templates::Tilt
  def precompiled_template(locals=T.unsafe(nil)); end
end

class Temple::Templates::Tilt
  extend ::Temple::Mixins::Template
  extend ::Temple::Mixins::ClassOptions
  def self.default_mime_type=(mime_type); end
end

module Temple::Templates
  def self.method_missing(name, engine, options=T.unsafe(nil)); end
end

module Temple::Utils
  def empty_exp?(exp); end

  def escape_html(html); end

  def escape_html_safe(html); end

  def indent_dynamic(text, indent_next, indent, pre_tags=T.unsafe(nil)); end

  def unique_name(prefix=T.unsafe(nil)); end
end

module Temple::Utils
  extend ::Temple::Utils
end

module Temple
end

class Thor
end

module Thor::CoreExt
end

class Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Thor::CoreExt::HashWithIndifferentAccess
end

module Thor::CoreExt
end

class Thor
end

module ThreadSafe
  NULL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

ThreadSafe::Array = Array

class ThreadSafe::AtomicReferenceCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def empty?(); end

  def get_and_set(key, value); end

  def get_or_default(key, else_value=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
  DEFAULT_CAPACITY = ::T.let(nil, ::T.untyped)
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAX_CAPACITY = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  NOW_RESIZING = ::T.let(nil, ::T.untyped)
  TRANSFER_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  include ::ThreadSafe::Util::CheapLockable
  def initialize(hash, key, value, next_node=T.unsafe(nil)); end

  def key(); end

  def key?(key); end

  def locked?(); end

  def matches?(key, hash); end

  def pure_hash(); end

  def try_await_lock(table, i); end

  def try_lock_via_hash(node_hash=T.unsafe(nil)); end

  def unlock_via_hash(locked_hash, node_hash); end
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  SPIN_LOCK_ATTEMPTS = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  extend ::ThreadSafe::Util::Volatile
  def self.locked_hash?(hash); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
  def cas_new_node(i, hash, key, value); end

  def delete_node_at(i, node, predecessor_node); end

  def try_lock_via_hash(i, node, node_hash); end

  def try_to_cas_in_computed(i, hash, key); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
end

class ThreadSafe::AtomicReferenceCacheBackend
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Cache
  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def values(); end
end

class ThreadSafe::Cache
end

ThreadSafe::ConcurrentCacheBackend = ThreadSafe::MriCacheBackend

ThreadSafe::Hash = Hash

class ThreadSafe::MriCacheBackend
  WRITE_LOCK = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::MriCacheBackend
end

class ThreadSafe::NonConcurrentCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end

  def value?(value); end
end

class ThreadSafe::NonConcurrentCacheBackend
end

class ThreadSafe::SynchronizedCacheBackend
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ThreadSafe::SynchronizedCacheBackend
end

module ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Adder
  def add(x); end

  def decrement(); end

  def increment(); end

  def reset(); end

  def sum(); end
end

class ThreadSafe::Util::Adder
end

class ThreadSafe::Util::AtomicReference
  def compare_and_set(old_value, new_value); end

  def get(); end

  def initialize(value=T.unsafe(nil)); end

  def set(new_value); end

  def value(); end

  def value=(new_value); end
end

class ThreadSafe::Util::AtomicReference
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

module ThreadSafe::Util::CheapLockable
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::PowerOfTwoTuple
  def hash_to_index(hash); end

  def next_in_size_table(); end

  def volatile_get_by_hash(hash); end

  def volatile_set_by_hash(hash, value); end
end

class ThreadSafe::Util::PowerOfTwoTuple
end

class ThreadSafe::Util::Striped64
  def busy?(); end

  def initialize(); end

  def retry_update(x, hash_code, was_uncontended); end
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Striped64::Cell
  def cas(old_value, new_value); end

  def cas_computed(); end

  def padding_(); end
end

class ThreadSafe::Util::Striped64::Cell
end

class ThreadSafe::Util::Striped64
  extend ::ThreadSafe::Util::Volatile
end

module ThreadSafe::Util::Volatile
  def attr_volatile(*attr_names); end
end

module ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::VolatileTuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def initialize(size); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class ThreadSafe::Util::VolatileTuple
end

module ThreadSafe::Util::XorShiftRandom
  def get(); end

  def xorshift(x); end
  MAX_XOR_SHIFTABLE_INT = ::T.let(nil, ::T.untyped)
end

module ThreadSafe::Util::XorShiftRandom
  extend ::ThreadSafe::Util::XorShiftRandom
end

module ThreadSafe::Util
end

module ThreadSafe
end

module Threadsafe
end

module Threadsafe
  def self.const_missing(name); end
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::BuilderTemplate
  def precompiled_postamble(locals); end

  def precompiled_template(locals); end
end

class Tilt::BuilderTemplate
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::Cache
  def clear(); end

  def fetch(*key); end
end

class Tilt::Cache
end

module Tilt::CompiledTemplates
end

module Tilt::CompiledTemplates
end

class Tilt::Dummy
end

class Tilt::Dummy
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::ErubiTemplate
  def precompiled_template(locals); end
end

class Tilt::ErubiTemplate
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::Mapping
  def [](file); end

  def extensions_for(template_class); end

  def lazy_map(); end

  def new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def register(template_class, *extensions); end

  def register_lazy(class_name, file, *extensions); end

  def registered?(ext); end

  def template_for(file); end

  def template_map(); end

  def templates_for(file); end
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::Mapping
end

class Tilt::NokogiriTemplate
  def evaluate(scope, locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  DOCUMENT_HEADER = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SassTemplate
  def allows_script?(); end
end

Tilt::SassTemplate::Sass = SassC

class Tilt::SassTemplate
end

class Tilt::ScssTemplate
end

class Tilt::ScssTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Tilt::Template
  def basename(suffix=T.unsafe(nil)); end

  def data(); end

  def default_encoding(); end

  def eval_file(); end

  def evaluate(scope, locals, &block); end

  def file(); end

  def initialize(file=T.unsafe(nil), line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def line(); end

  def metadata(); end

  def name(); end

  def options(); end

  def precompiled(local_keys); end

  def precompiled_postamble(local_keys); end

  def precompiled_preamble(local_keys); end

  def precompiled_template(local_keys); end

  def prepare(); end

  def render(scope=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

class Tilt::Template
  def self.default_mime_type(); end

  def self.default_mime_type=(value); end

  def self.metadata(); end
end

module Tilt
  def self.[](file); end

  def self.current_template(); end

  def self.default_mapping(); end

  def self.lazy_map(); end

  def self.new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.prefer(template_class, *extensions); end

  def self.register(template_class, *extensions); end

  def self.register_lazy(class_name, file, *extensions); end

  def self.registered?(ext); end

  def self.template_for(file); end

  def self.templates_for(file); end
end

class Time
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::DateAndTime::Compatibility
  def acts_like_time?(); end

  def ago(seconds); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_day(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def end_of_day(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def eql_with_coercion(other); end

  def eql_without_coercion(_); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def in(seconds); end

  def minus_with_coercion(other); end

  def minus_with_duration(other); end

  def minus_without_coercion(other); end

  def minus_without_duration(_); end

  def next_day(days=T.unsafe(nil)); end

  def next_month(months=T.unsafe(nil)); end

  def next_year(years=T.unsafe(nil)); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def prev_day(days=T.unsafe(nil)); end

  def prev_month(months=T.unsafe(nil)); end

  def prev_year(years=T.unsafe(nil)); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def sec_fraction(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def since(seconds); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Time
  def self.===(other); end

  def self.at_with_coercion(*args); end

  def self.at_without_coercion(*_); end

  def self.current(); end

  def self.days_in_month(month, year=T.unsafe(nil)); end

  def self.days_in_year(year=T.unsafe(nil)); end

  def self.find_zone(time_zone); end

  def self.find_zone!(time_zone); end

  def self.rfc3339(str); end

  def self.use_zone(time_zone); end

  def self.zone_default(); end

  def self.zone_default=(zone_default); end

end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  include ::MessagePack::CoreExt
end

module Turbolinks
  VERSION = ::T.let(nil, ::T.untyped)
end

module Turbolinks::Assertions
  def assert_redirected_to(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_turbolinks_visited(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def turbolinks_request?(); end

  def turbolinks_visit_location_and_action(); end
  TURBOLINKS_VISIT = ::T.let(nil, ::T.untyped)
end

module Turbolinks::Assertions
end

module Turbolinks::Controller
end

module Turbolinks::Controller
  extend ::ActiveSupport::Concern
end

class Turbolinks::Engine
end

class Turbolinks::Engine
end

module Turbolinks::Redirection
  def redirect_to(url=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Turbolinks::Redirection
  extend ::ActiveSupport::Concern
end

module Turbolinks::Source
  VERSION = ::T.let(nil, ::T.untyped)
end

module Turbolinks::Source
  def self.asset_path(); end
end

module Turbolinks
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::GID
  def app(); end

  def model_id(); end

  def model_name(); end

  def params(); end

  def query=(query); end

  def set_params(params); end

  def set_path(path); end

  def set_query(query); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class URI::GID::MissingModelIdError
end

class URI::GID::MissingModelIdError
end

class URI::GID
  def self.create(app, model, params=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.validate_app(app); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

  def self.parser(); end
end

class Uglifier
  def compile(source); end

  def compile_with_map(source); end

  def compress(source); end

  def initialize(options=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  ES5FallbackPath = ::T.let(nil, ::T.untyped)
  EXTRA_OPTIONS = ::T.let(nil, ::T.untyped)
  HarmonySourcePath = ::T.let(nil, ::T.untyped)
  MANGLE_PROPERTIES_DEFAULTS = ::T.let(nil, ::T.untyped)
  SOURCE_MAP_DEFAULTS = ::T.let(nil, ::T.untyped)
  SourceMapPath = ::T.let(nil, ::T.untyped)
  SourcePath = ::T.let(nil, ::T.untyped)
  SplitFallbackPath = ::T.let(nil, ::T.untyped)
  UglifyJSWrapperPath = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Uglifier::Error
end

class Uglifier::Error
end

class Uglifier
  def self.compile(source, options=T.unsafe(nil)); end

  def self.compile_with_map(source, options=T.unsafe(nil)); end
end

class UnboundMethod
  include ::MethodSource::SourceLocation::UnboundMethodExtensions
  include ::MethodSource::MethodExtensions
end

module Unicode
end

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  NO_STRING_EXT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Unicode::DisplayWidth
  def self.emoji_extra_width_of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), _=T.unsafe(nil)); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Unicode
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class User
  include ::User::GeneratedAttributeMethods
  include ::User::GeneratedAssociationMethods
  include ::Devise::Models::Authenticatable
  include ::Devise::Models::DatabaseAuthenticatable
  include ::Devise::Models::Rememberable
  include ::Devise::Models::Recoverable
  include ::Devise::Models::Registerable
  include ::Devise::Models::Validatable
  def after_add_for_runs(); end

  def after_add_for_runs=(val); end

  def after_add_for_runs?(); end

  def after_remove_for_runs(); end

  def after_remove_for_runs=(val); end

  def after_remove_for_runs?(); end

  def autosave_associated_records_for_runs(*args); end

  def before_add_for_runs(); end

  def before_add_for_runs=(val); end

  def before_add_for_runs?(); end

  def before_remove_for_runs(); end

  def before_remove_for_runs=(val); end

  def before_remove_for_runs?(); end

  def current_password(); end

  def devise_modules(); end

  def devise_modules?(); end

  def password(); end

  def password_confirmation(); end

  def password_confirmation=(password_confirmation); end

  def validate_associated_records_for_runs(*args); end
end

module User::GeneratedAssociationMethods
  def run_ids(); end

  def run_ids=(ids); end

  def runs(); end

  def runs=(value); end
end

module User::GeneratedAssociationMethods
end

module User::GeneratedAttributeMethods
  def admin(); end

  def admin=(value); end

  def admin?(*args); end

  def admin_before_last_save(*args); end

  def admin_before_type_cast(*args); end

  def admin_came_from_user?(*args); end

  def admin_change(*args); end

  def admin_change_to_be_saved(*args); end

  def admin_changed?(*args); end

  def admin_in_database(*args); end

  def admin_previous_change(*args); end

  def admin_previously_changed?(*args); end

  def admin_was(*args); end

  def admin_will_change!(*args); end

  def created_at(); end

  def created_at=(value); end

  def created_at?(*args); end

  def created_at_before_last_save(*args); end

  def created_at_before_type_cast(*args); end

  def created_at_came_from_user?(*args); end

  def created_at_change(*args); end

  def created_at_change_to_be_saved(*args); end

  def created_at_changed?(*args); end

  def created_at_in_database(*args); end

  def created_at_previous_change(*args); end

  def created_at_previously_changed?(*args); end

  def created_at_was(*args); end

  def created_at_will_change!(*args); end

  def email(); end

  def email=(value); end

  def email?(*args); end

  def email_before_last_save(*args); end

  def email_before_type_cast(*args); end

  def email_came_from_user?(*args); end

  def email_change(*args); end

  def email_change_to_be_saved(*args); end

  def email_changed?(*args); end

  def email_in_database(*args); end

  def email_previous_change(*args); end

  def email_previously_changed?(*args); end

  def email_was(*args); end

  def email_will_change!(*args); end

  def encrypted_password(); end

  def encrypted_password=(value); end

  def encrypted_password?(*args); end

  def encrypted_password_before_last_save(*args); end

  def encrypted_password_before_type_cast(*args); end

  def encrypted_password_came_from_user?(*args); end

  def encrypted_password_change(*args); end

  def encrypted_password_change_to_be_saved(*args); end

  def encrypted_password_changed?(*args); end

  def encrypted_password_in_database(*args); end

  def encrypted_password_previous_change(*args); end

  def encrypted_password_previously_changed?(*args); end

  def encrypted_password_was(*args); end

  def encrypted_password_will_change!(*args); end

  def id_before_last_save(*args); end

  def id_came_from_user?(*args); end

  def id_change(*args); end

  def id_change_to_be_saved(*args); end

  def id_changed?(*args); end

  def id_previous_change(*args); end

  def id_previously_changed?(*args); end

  def id_will_change!(*args); end

  def remember_created_at(); end

  def remember_created_at=(value); end

  def remember_created_at?(*args); end

  def remember_created_at_before_last_save(*args); end

  def remember_created_at_before_type_cast(*args); end

  def remember_created_at_came_from_user?(*args); end

  def remember_created_at_change(*args); end

  def remember_created_at_change_to_be_saved(*args); end

  def remember_created_at_changed?(*args); end

  def remember_created_at_in_database(*args); end

  def remember_created_at_previous_change(*args); end

  def remember_created_at_previously_changed?(*args); end

  def remember_created_at_was(*args); end

  def remember_created_at_will_change!(*args); end

  def reset_password_sent_at(); end

  def reset_password_sent_at=(value); end

  def reset_password_sent_at?(*args); end

  def reset_password_sent_at_before_last_save(*args); end

  def reset_password_sent_at_before_type_cast(*args); end

  def reset_password_sent_at_came_from_user?(*args); end

  def reset_password_sent_at_change(*args); end

  def reset_password_sent_at_change_to_be_saved(*args); end

  def reset_password_sent_at_changed?(*args); end

  def reset_password_sent_at_in_database(*args); end

  def reset_password_sent_at_previous_change(*args); end

  def reset_password_sent_at_previously_changed?(*args); end

  def reset_password_sent_at_was(*args); end

  def reset_password_sent_at_will_change!(*args); end

  def reset_password_token(); end

  def reset_password_token=(value); end

  def reset_password_token?(*args); end

  def reset_password_token_before_last_save(*args); end

  def reset_password_token_before_type_cast(*args); end

  def reset_password_token_came_from_user?(*args); end

  def reset_password_token_change(*args); end

  def reset_password_token_change_to_be_saved(*args); end

  def reset_password_token_changed?(*args); end

  def reset_password_token_in_database(*args); end

  def reset_password_token_previous_change(*args); end

  def reset_password_token_previously_changed?(*args); end

  def reset_password_token_was(*args); end

  def reset_password_token_will_change!(*args); end

  def restore_admin!(*args); end

  def restore_created_at!(*args); end

  def restore_email!(*args); end

  def restore_encrypted_password!(*args); end

  def restore_id!(*args); end

  def restore_remember_created_at!(*args); end

  def restore_reset_password_sent_at!(*args); end

  def restore_reset_password_token!(*args); end

  def restore_runs_visible_to_admins!(*args); end

  def restore_updated_at!(*args); end

  def runs_visible_to_admins(); end

  def runs_visible_to_admins=(value); end

  def runs_visible_to_admins?(*args); end

  def runs_visible_to_admins_before_last_save(*args); end

  def runs_visible_to_admins_before_type_cast(*args); end

  def runs_visible_to_admins_came_from_user?(*args); end

  def runs_visible_to_admins_change(*args); end

  def runs_visible_to_admins_change_to_be_saved(*args); end

  def runs_visible_to_admins_changed?(*args); end

  def runs_visible_to_admins_in_database(*args); end

  def runs_visible_to_admins_previous_change(*args); end

  def runs_visible_to_admins_previously_changed?(*args); end

  def runs_visible_to_admins_was(*args); end

  def runs_visible_to_admins_will_change!(*args); end

  def saved_change_to_admin(*args); end

  def saved_change_to_admin?(*args); end

  def saved_change_to_created_at(*args); end

  def saved_change_to_created_at?(*args); end

  def saved_change_to_email(*args); end

  def saved_change_to_email?(*args); end

  def saved_change_to_encrypted_password(*args); end

  def saved_change_to_encrypted_password?(*args); end

  def saved_change_to_id(*args); end

  def saved_change_to_id?(*args); end

  def saved_change_to_remember_created_at(*args); end

  def saved_change_to_remember_created_at?(*args); end

  def saved_change_to_reset_password_sent_at(*args); end

  def saved_change_to_reset_password_sent_at?(*args); end

  def saved_change_to_reset_password_token(*args); end

  def saved_change_to_reset_password_token?(*args); end

  def saved_change_to_runs_visible_to_admins(*args); end

  def saved_change_to_runs_visible_to_admins?(*args); end

  def saved_change_to_updated_at(*args); end

  def saved_change_to_updated_at?(*args); end

  def updated_at(); end

  def updated_at=(value); end

  def updated_at?(*args); end

  def updated_at_before_last_save(*args); end

  def updated_at_before_type_cast(*args); end

  def updated_at_came_from_user?(*args); end

  def updated_at_change(*args); end

  def updated_at_change_to_be_saved(*args); end

  def updated_at_changed?(*args); end

  def updated_at_in_database(*args); end

  def updated_at_previous_change(*args); end

  def updated_at_previously_changed?(*args); end

  def updated_at_was(*args); end

  def updated_at_will_change!(*args); end

  def will_save_change_to_admin?(*args); end

  def will_save_change_to_created_at?(*args); end

  def will_save_change_to_email?(*args); end

  def will_save_change_to_encrypted_password?(*args); end

  def will_save_change_to_id?(*args); end

  def will_save_change_to_remember_created_at?(*args); end

  def will_save_change_to_reset_password_sent_at?(*args); end

  def will_save_change_to_reset_password_token?(*args); end

  def will_save_change_to_runs_visible_to_admins?(*args); end

  def will_save_change_to_updated_at?(*args); end
end

module User::GeneratedAttributeMethods
  extend ::Mutex_m
end

class User
  extend ::Devise::Models::Authenticatable::ClassMethods
  extend ::Devise::Models::DatabaseAuthenticatable::ClassMethods
  extend ::Devise::Models::Rememberable::ClassMethods
  extend ::Devise::Models::Recoverable::ClassMethods
  extend ::Devise::Models::Registerable::ClassMethods
  extend ::Devise::Models::Validatable::ClassMethods
  def self.after_add_for_runs(); end

  def self.after_add_for_runs=(val); end

  def self.after_add_for_runs?(); end

  def self.after_remove_for_runs(); end

  def self.after_remove_for_runs=(val); end

  def self.after_remove_for_runs?(); end

  def self.before_add_for_runs(); end

  def self.before_add_for_runs=(val); end

  def self.before_add_for_runs?(); end

  def self.before_remove_for_runs(); end

  def self.before_remove_for_runs=(val); end

  def self.before_remove_for_runs?(); end

  def self.devise_modules(); end

  def self.devise_modules=(val); end

  def self.devise_modules?(); end
end

class Vector
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  def [](i); end

  def []=(i, v); end

  def collect!(&block); end

  def covector(); end

  def elements(); end

  def initialize(array); end

  def map!(&block); end
end

class Vector::ZeroVectorError
end

class Vector::ZeroVectorError
end

class Vector
  extend ::Exception2MessageMapper
  extend ::Matrix::ConversionHelper
  def self.included(mod); end
end

WEBrick::HTTPAuth::Authenticator::AuthException = WEBrick::HTTPStatus::Unauthorized

WEBrick::HTTPAuth::ProxyAuthenticator::AuthException = WEBrick::HTTPStatus::ProxyAuthenticationRequired

class WEBrick::HTTPRequest
  def body_reader(); end

  def readpartial(size, buf=T.unsafe(nil)); end
  MAX_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
end

class WEBrick::HTTPResponse
  def _rack_setup_header(); end

  def rack(); end

  def rack=(rack); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
  def <<(*buf); end

  def initialize(socket, resp); end

  def write(buf); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
end

class WEBrick::HTTPServer
  def create_request(with_webrick_config); end

  def create_response(with_webrick_config); end
end

class WEBrick::HTTPServlet::DefaultFileHandler
  def multipart_body(body, parts, boundary, mtype, filesize); end
end

module Warden
end

class Warden::Config
  def deep_dup(key, other); end

  def default_scope(); end

  def default_scope=(value); end

  def default_strategies(*strategies); end

  def failure_app(); end

  def failure_app=(value); end

  def initialize(other=T.unsafe(nil)); end

  def intercept_401(); end

  def intercept_401=(value); end

  def scope_defaults(scope, opts=T.unsafe(nil)); end

  def serialize_from_session(*args, &block); end

  def serialize_into_session(*args, &block); end

  def silence_missing_strategies!(); end

  def silence_missing_strategies?(); end

  def strategies(); end
end

class Warden::Config
  def self.hash_accessor(*names); end
end

module Warden::Hooks
  def _after_failed_fetch(); end

  def _after_set_user(); end

  def _before_failure(); end

  def _before_logout(); end

  def _on_request(); end

  def _run_callbacks(kind, *args); end

  def after_authentication(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def after_failed_fetch(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def after_fetch(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def after_set_user(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def before_failure(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def before_logout(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def on_request(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def prepend_after_authentication(options=T.unsafe(nil), &block); end

  def prepend_after_fetch(options=T.unsafe(nil), &block); end

  def prepend_after_set_user(options=T.unsafe(nil), &block); end

  def prepend_before_failure(options=T.unsafe(nil), &block); end

  def prepend_before_logout(options=T.unsafe(nil), &block); end

  def prepend_on_request(options=T.unsafe(nil), &block); end
end

module Warden::Hooks
end

class Warden::Manager
  def _run_callbacks(*args); end

  def call(env); end

  def config(); end

  def config=(config); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Warden::Manager
  extend ::Warden::Hooks
  def self.serialize_from_session(scope=T.unsafe(nil), &block); end

  def self.serialize_into_session(scope=T.unsafe(nil), &block); end
end

module Warden::Mixins
end

module Warden::Mixins::Common
  def cookies(); end

  def params(); end

  def raw_session(); end

  def request(); end

  def reset_session!(); end

  def session(); end

  def warden_cookies(); end
end

module Warden::Mixins::Common
end

module Warden::Mixins
end

class Warden::NotAuthenticated
end

class Warden::NotAuthenticated
end

class Warden::Proxy
  include ::Warden::Mixins::Common
  def asset_request?(); end

  def authenticate(*args); end

  def authenticate!(*args); end

  def authenticate?(*args); end

  def authenticated?(scope=T.unsafe(nil)); end

  def clear_strategies_cache!(*args); end

  def config(); end

  def custom_failure!(); end

  def custom_failure?(); end

  def custom_response(*args, &block); end

  def default_strategies(*args, &block); end

  def env(); end

  def errors(); end

  def headers(*args, &block); end

  def initialize(env, manager); end

  def inspect(*args); end

  def lock!(); end

  def logout(*scopes); end

  def manager(); end

  def message(); end

  def on_request(); end

  def result(); end

  def session(scope=T.unsafe(nil)); end

  def session_serializer(); end

  def set_user(user, opts=T.unsafe(nil)); end

  def status(*args, &block); end

  def to_s(*args); end

  def unauthenticated?(scope=T.unsafe(nil)); end

  def user(argument=T.unsafe(nil)); end

  def winning_strategies(); end

  def winning_strategy(); end

  def winning_strategy=(winning_strategy); end
  ENV_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  ENV_WARDEN_ERRORS = ::T.let(nil, ::T.untyped)
end

class Warden::Proxy::Errors
  include ::Enumerable
  def add(field_name, message); end

  def clear!(); end

  def each(&blk); end

  def empty?(); end

  def full_messages(); end

  def method_missing(meth, *args, &block); end

  def on(field_name); end
end

class Warden::Proxy::Errors
end

class Warden::Proxy
  extend ::Forwardable
end

class Warden::SessionSerializer
  def delete(scope, user=T.unsafe(nil)); end

  def deserialize(key); end

  def env(); end

  def fetch(scope); end

  def initialize(env); end

  def key_for(scope); end

  def serialize(user); end

  def session(); end

  def store(user, scope); end

  def stored?(scope); end

  def user_deserialize(args); end

  def user_serialize(record); end
end

class Warden::SessionSerializer
end

module Warden::Strategies
end

class Warden::Strategies::Base
  include ::Warden::Mixins::Common
  def _run!(); end

  def clear!(); end

  def custom!(response); end

  def custom_response(); end

  def custom_response=(custom_response); end

  def env(); end

  def errors(); end

  def fail(message=T.unsafe(nil)); end

  def fail!(message=T.unsafe(nil)); end

  def halt!(); end

  def halted?(); end

  def headers(header=T.unsafe(nil)); end

  def initialize(env, scope=T.unsafe(nil)); end

  def message(); end

  def message=(message); end

  def pass(); end

  def performed?(); end

  def redirect!(url, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def result(); end

  def result=(result); end

  def scope(); end

  def status(); end

  def store?(); end

  def success!(user, message=T.unsafe(nil)); end

  def successful?(); end

  def user(); end

  def user=(user); end

  def valid?(); end
end

class Warden::Strategies::Base
end

module Warden::Strategies
  def self.[](label); end

  def self._strategies(); end

  def self.add(label, strategy=T.unsafe(nil), &block); end

  def self.clear!(); end

  def self.update(label, &block); end
end

module Warden::Test
end

module Warden::Test::Helpers
  def login_as(user, opts=T.unsafe(nil)); end

  def logout(*scopes); end
end

module Warden::Test::Helpers
  def self.included(_base); end
end

module Warden::Test::Mock
  def warden(); end
end

class Warden::Test::Mock::Session
  def app(); end

  def app=(app); end

  def call(e); end

  def initialize(app, _configs=T.unsafe(nil)); end
end

class Warden::Test::Mock::Session
end

module Warden::Test::Mock
  def self.included(_base); end
end

module Warden::Test::WardenHelpers
  def _on_next_request(); end

  def asset_paths(); end

  def asset_paths=(*vals); end

  def on_next_request(&blk); end

  def test_reset!(); end
end

module Warden::Test::WardenHelpers
end

module Warden::Test
end

class Warden::UserNotSet
end

class Warden::UserNotSet
end

module Warden
  def self.test_mode!(); end
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
end

module WebSocket
end

class WebSocket::Driver
  include ::WebSocket::Driver::EventEmitter
  def add_extension(extension); end

  def binary(message); end

  def close(reason=T.unsafe(nil), code=T.unsafe(nil)); end

  def initialize(socket, options=T.unsafe(nil)); end

  def ping(*args); end

  def pong(*args); end

  def protocol(); end

  def ready_state(); end

  def set_header(name, value); end

  def start(); end

  def state(); end

  def text(message); end
  BINARY = ::T.let(nil, ::T.untyped)
  MAX_LENGTH = ::T.let(nil, ::T.untyped)
  STATES = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Client
  def headers(); end

  def proxy(origin, options=T.unsafe(nil)); end

  def status(); end
  VALID_SCHEMES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Client
  def self.generate_key(); end
end

class WebSocket::Driver::CloseEvent
  def code(); end

  def code=(_); end

  def reason(); end

  def reason=(_); end
end

class WebSocket::Driver::CloseEvent
  def self.[](*_); end

  def self.members(); end
end

class WebSocket::Driver::ConfigurationError
end

class WebSocket::Driver::ConfigurationError
end

class WebSocket::Driver::ConnectEvent
end

class WebSocket::Driver::ConnectEvent
  def self.[](*_); end

  def self.members(); end
end

class WebSocket::Driver::Draft75
  def frame(buffer, type=T.unsafe(nil), error_type=T.unsafe(nil)); end

  def parse(chunk); end

  def version(); end
end

class WebSocket::Driver::Draft75
end

class WebSocket::Driver::Draft76
  BODY_SIZE = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Draft76
end

module WebSocket::Driver::EventEmitter
  def add_listener(event, callable=T.unsafe(nil), &block); end

  def emit(event, *args); end

  def initialize(); end

  def listener_count(event); end

  def listeners(event); end

  def on(event, callable=T.unsafe(nil), &block); end

  def remove_all_listeners(event=T.unsafe(nil)); end

  def remove_listener(event, callable=T.unsafe(nil), &block); end
end

module WebSocket::Driver::EventEmitter
end

class WebSocket::Driver::Headers
  def [](name); end

  def []=(name, value); end

  def clear(); end

  def initialize(received=T.unsafe(nil)); end

  def to_h(); end
  ALLOWED_DUPLICATES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Headers
end

class WebSocket::Driver::Hybi
  def frame(buffer, type=T.unsafe(nil), code=T.unsafe(nil)); end

  def parse(chunk); end

  def ping(message=T.unsafe(nil), &callback); end

  def pong(message=T.unsafe(nil)); end

  def version(); end
  BYTE = ::T.let(nil, ::T.untyped)
  DEFAULT_ERROR_CODE = ::T.let(nil, ::T.untyped)
  ERRORS = ::T.let(nil, ::T.untyped)
  ERROR_CODES = ::T.let(nil, ::T.untyped)
  FIN = ::T.let(nil, ::T.untyped)
  GUID = ::T.let(nil, ::T.untyped)
  LENGTH = ::T.let(nil, ::T.untyped)
  MASK = ::T.let(nil, ::T.untyped)
  MAX_RESERVED_ERROR = ::T.let(nil, ::T.untyped)
  MESSAGE_OPCODES = ::T.let(nil, ::T.untyped)
  MIN_RESERVED_ERROR = ::T.let(nil, ::T.untyped)
  OPCODE = ::T.let(nil, ::T.untyped)
  OPCODES = ::T.let(nil, ::T.untyped)
  OPCODE_CODES = ::T.let(nil, ::T.untyped)
  OPENING_OPCODES = ::T.let(nil, ::T.untyped)
  PACK_FORMATS = ::T.let(nil, ::T.untyped)
  RSV1 = ::T.let(nil, ::T.untyped)
  RSV2 = ::T.let(nil, ::T.untyped)
  RSV3 = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Hybi::Frame
  def final(); end

  def final=(final); end

  def length(); end

  def length=(length); end

  def length_bytes(); end

  def length_bytes=(length_bytes); end

  def masked(); end

  def masked=(masked); end

  def masking_key(); end

  def masking_key=(masking_key); end

  def opcode(); end

  def opcode=(opcode); end

  def payload(); end

  def payload=(payload); end

  def rsv1(); end

  def rsv1=(rsv1); end

  def rsv2(); end

  def rsv2=(rsv2); end

  def rsv3(); end

  def rsv3=(rsv3); end
end

class WebSocket::Driver::Hybi::Frame
end

class WebSocket::Driver::Hybi::Message
  def <<(frame); end

  def data(); end

  def data=(data); end

  def opcode(); end

  def opcode=(opcode); end

  def rsv1(); end

  def rsv1=(rsv1); end

  def rsv2(); end

  def rsv2=(rsv2); end

  def rsv3(); end

  def rsv3=(rsv3); end
end

class WebSocket::Driver::Hybi::Message
end

class WebSocket::Driver::Hybi
  def self.generate_accept(key); end
end

class WebSocket::Driver::MessageEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::MessageEvent
  def self.[](*_); end

  def self.members(); end
end

class WebSocket::Driver::OpenEvent
end

class WebSocket::Driver::OpenEvent
  def self.[](*_); end

  def self.members(); end
end

class WebSocket::Driver::PingEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::PingEvent
  def self.[](*_); end

  def self.members(); end
end

class WebSocket::Driver::PongEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::PongEvent
  def self.[](*_); end

  def self.members(); end
end

class WebSocket::Driver::ProtocolError
end

class WebSocket::Driver::ProtocolError
end

class WebSocket::Driver::Proxy
  include ::WebSocket::Driver::EventEmitter
  def headers(); end

  def initialize(client, origin, options); end

  def parse(chunk); end

  def set_header(name, value); end

  def start(); end

  def status(); end
  PORTS = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Proxy
end

class WebSocket::Driver::Server
  def add_extension(*args, &block); end

  def binary(*args, &block); end

  def close(*args, &block); end

  def env(); end

  def frame(*args, &block); end

  def parse(chunk); end

  def ping(*args, &block); end

  def set_header(*args, &block); end

  def start(*args, &block); end

  def text(*args, &block); end

  def url(); end

  def version(); end

  def write(buffer); end
  EVENTS = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Server
end

class WebSocket::Driver::StreamReader
  def each_byte(); end

  def put(chunk); end

  def read(length); end
  MINIMUM_AUTOMATIC_PRUNE_OFFSET = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::StreamReader
end

class WebSocket::Driver::URIError
end

class WebSocket::Driver::URIError
end

class WebSocket::Driver
  def self.client(socket, options=T.unsafe(nil)); end

  def self.encode(string, encoding=T.unsafe(nil)); end

  def self.rack(socket, options=T.unsafe(nil)); end

  def self.server(socket, options=T.unsafe(nil)); end

  def self.validate_options(options, valid_keys); end

  def self.websocket?(env); end
end

class WebSocket::Extensions
  def activate(header); end

  def add(ext); end

  def close(); end

  def generate_offer(); end

  def generate_response(header); end

  def process_incoming_message(message); end

  def process_outgoing_message(message); end

  def valid_frame_rsv(frame); end

  def valid_frame_rsv?(frame); end
  MESSAGE_OPCODES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Extensions::ExtensionError
end

class WebSocket::Extensions::ExtensionError
end

class WebSocket::Extensions::Parser
  EXT = ::T.let(nil, ::T.untyped)
  EXT_LIST = ::T.let(nil, ::T.untyped)
  NOTOKEN = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PARAM = ::T.let(nil, ::T.untyped)
  QUOTED = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class WebSocket::Extensions::Parser::ParseError
end

class WebSocket::Extensions::Parser::ParseError
end

class WebSocket::Extensions::Parser
  def self.parse_header(header); end

  def self.serialize_params(name, params); end
end

class WebSocket::Extensions
end

module WebSocket::HTTP
end

module WebSocket::HTTP::Headers
  def complete?(); end

  def error?(); end

  def headers(); end

  def initialize(); end

  def parse(chunk); end
  CR = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  MAX_LINE_LENGTH = ::T.let(nil, ::T.untyped)
end

module WebSocket::HTTP::Headers
end

class WebSocket::HTTP::Request
  include ::WebSocket::HTTP::Headers
  def env(); end
  REQUEST_LINE = ::T.let(nil, ::T.untyped)
  REQUEST_TARGET = ::T.let(nil, ::T.untyped)
  RESERVED_HEADERS = ::T.let(nil, ::T.untyped)
end

class WebSocket::HTTP::Request
end

class WebSocket::HTTP::Response
  include ::WebSocket::HTTP::Headers
  def [](name); end

  def body(); end

  def code(); end
  STATUS_LINE = ::T.let(nil, ::T.untyped)
end

class WebSocket::HTTP::Response
end

module WebSocket::HTTP
  def self.normalize_header(name); end
end

module WebSocket::Mask
end

module WebSocket::Mask
  def self.mask(_, _1); end
end

module WebSocket
end

module Webdrivers
  DEFAULT_CACHE_TIME = ::T.let(nil, ::T.untyped)
  DEFAULT_INSTALL_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Webdrivers::BrowserNotFound
end

class Webdrivers::BrowserNotFound
end

class Webdrivers::ChromeFinder
end

class Webdrivers::ChromeFinder
  def self.location(); end

  def self.version(); end
end

class Webdrivers::Chromedriver
end

class Webdrivers::Chromedriver
  def self.base_url(); end

  def self.browser_version(); end

  def self.chrome_version(); end

  def self.current_version(); end

  def self.latest_version(); end
end

class Webdrivers::Common
end

class Webdrivers::Common
  def self.driver_path(); end

  def self.remove(); end

  def self.required_version(); end

  def self.required_version=(required_version); end

  def self.update(); end
end

class Webdrivers::ConnectionError
end

class Webdrivers::ConnectionError
end

class Webdrivers::EdgeFinder
end

class Webdrivers::EdgeFinder
  def self.location(); end

  def self.version(); end
end

class Webdrivers::Edgedriver
end

class Webdrivers::Edgedriver
end

class Webdrivers::Geckodriver
end

class Webdrivers::Geckodriver
  def self.base_url(); end

  def self.current_version(); end

  def self.latest_version(); end
end

class Webdrivers::IEdriver
end

class Webdrivers::IEdriver
  def self.base_url(); end

  def self.current_version(); end

  def self.latest_version(); end
end

class Webdrivers::Logger
  include ::Logger::Severity
  def debug(*args, &block); end

  def debug?(*args, &block); end

  def deprecate(old, new); end

  def error(*args, &block); end

  def error?(*args, &block); end

  def fatal(*args, &block); end

  def fatal?(*args, &block); end

  def info(*args, &block); end

  def info?(*args, &block); end

  def io(); end

  def level(*args, &block); end

  def level=(severity); end

  def output=(io); end

  def warn(*args, &block); end

  def warn?(*args, &block); end
end

class Webdrivers::Logger
  extend ::Forwardable
end

class Webdrivers::Network
end

class Webdrivers::Network
  def self.get(url, limit=T.unsafe(nil)); end

  def self.get_response(url, limit=T.unsafe(nil)); end

  def self.get_url(url, limit=T.unsafe(nil)); end

  def self.http(); end

  def self.using_proxy(); end
end

class Webdrivers::NetworkError
end

class Webdrivers::NetworkError
end

class Webdrivers::Railtie
end

class Webdrivers::Railtie
end

class Webdrivers::System
end

class Webdrivers::System
  def self.bitsize(); end

  def self.cache_version(file_name, version); end

  def self.cached_version(file_name); end

  def self.call(process, arg=T.unsafe(nil)); end

  def self.decompress_file(tempfile, file_name, target); end

  def self.delete(file); end

  def self.download(url, target); end

  def self.download_file(url, target); end

  def self.exists?(file); end

  def self.install_dir(); end

  def self.platform(); end

  def self.to_win32_path(path); end

  def self.to_wsl_path(path); end

  def self.untarbz2_file(filename); end

  def self.untargz_file(source, target); end

  def self.unzip_file(filename, driver_name); end

  def self.valid_cache?(file_name); end

  def self.wsl?(); end
end

class Webdrivers::VersionError
end

class Webdrivers::VersionError
end

module Webdrivers
  def self.cache_time(); end

  def self.cache_time=(cache_time); end

  def self.configure(); end

  def self.install_dir(); end

  def self.install_dir=(install_dir); end

  def self.logger(); end

  def self.net_http_ssl_fix(); end

  def self.proxy_addr(); end

  def self.proxy_addr=(proxy_addr); end

  def self.proxy_pass(); end

  def self.proxy_pass=(proxy_pass); end

  def self.proxy_port(); end

  def self.proxy_port=(proxy_port); end

  def self.proxy_user(); end

  def self.proxy_user=(proxy_user); end
end

module XPath
  include ::XPath::DSL
end

module XPath::DSL
  def !(*args); end

  def !=(rhs); end

  def %(rhs); end

  def &(rhs); end

  def *(rhs); end

  def +(*expressions); end

  def /(rhs); end

  def <(rhs); end

  def <=(rhs); end

  def ==(rhs); end

  def >(rhs); end

  def >=(rhs); end

  def [](expression); end

  def ancestor(*element_names); end

  def ancestor_or_self(*element_names); end

  def and(rhs); end

  def anywhere(*expressions); end

  def attr(expression); end

  def attribute(*element_names); end

  def axis(name, *element_names); end

  def binary_operator(name, rhs); end

  def boolean(*args); end

  def ceiling(*args); end

  def child(*expressions); end

  def concat(*args); end

  def contains(*args); end

  def contains_word(word); end

  def count(*args); end

  def css(selector); end

  def current(); end

  def descendant(*expressions); end

  def descendant_or_self(*element_names); end

  def divide(rhs); end

  def ends_with(suffix); end

  def equals(rhs); end

  def false(*args); end

  def floor(*args); end

  def following(*element_names); end

  def following_sibling(*element_names); end

  def function(name, *arguments); end

  def gt(rhs); end

  def gte(rhs); end

  def id(*args); end

  def inverse(*args); end

  def is(expression); end

  def join(*expressions); end

  def lang(*args); end

  def last(); end

  def local_name(*args); end

  def lowercase(); end

  def lt(rhs); end

  def lte(rhs); end

  def method(name, *arguments); end

  def minus(rhs); end

  def mod(rhs); end

  def multiply(rhs); end

  def n(*args); end

  def namespace(*element_names); end

  def namespace_uri(*args); end

  def next_sibling(*expressions); end

  def normalize(*args); end

  def normalize_space(*args); end

  def not(*args); end

  def not_equals(rhs); end

  def number(*args); end

  def one_of(*expressions); end

  def or(rhs); end

  def parent(*element_names); end

  def plus(rhs); end

  def position(); end

  def preceding(*element_names); end

  def preceding_sibling(*element_names); end

  def previous_sibling(*expressions); end

  def qname(); end

  def round(*args); end

  def self(*element_names); end

  def self_axis(*element_names); end

  def starts_with(*args); end

  def string(*args); end

  def string_length(*args); end

  def substring(*args); end

  def substring_after(*args); end

  def substring_before(*args); end

  def sum(*args); end

  def text(); end

  def translate(*args); end

  def true(*args); end

  def union(*expressions); end

  def uppercase(); end

  def where(expression); end

  def |(rhs); end

  def ~(*args); end
  AXES = ::T.let(nil, ::T.untyped)
  LOWERCASE_LETTERS = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  UPPERCASE_LETTERS = ::T.let(nil, ::T.untyped)
end

module XPath::DSL
end

class XPath::Expression
  include ::XPath::DSL
  def arguments(); end

  def arguments=(arguments); end

  def expression(); end

  def expression=(expression); end

  def initialize(expression, *arguments); end

  def to_s(type=T.unsafe(nil)); end

  def to_xpath(type=T.unsafe(nil)); end
end

class XPath::Expression
end

class XPath::Literal
  def initialize(value); end

  def value(); end
end

class XPath::Literal
end

class XPath::Renderer
  def anywhere(element_names); end

  def attribute(current, name); end

  def axis(current, name, element_names); end

  def binary_operator(name, left, right); end

  def child(current, element_names); end

  def convert_argument(argument); end

  def css(current, selector); end

  def descendant(current, element_names); end

  def function(name, *arguments); end

  def initialize(type); end

  def is(one, two); end

  def join(*expressions); end

  def literal(node); end

  def render(node); end

  def string_literal(string); end

  def text(current); end

  def this_node(); end

  def union(*expressions); end

  def variable(name); end

  def where(on, condition); end
end

class XPath::Renderer
  def self.render(node, type); end
end

class XPath::Union
  include ::Enumerable
  def arguments(); end

  def each(&block); end

  def expression(); end

  def expressions(); end

  def initialize(*expressions); end

  def method_missing(*args); end

  def to_s(type=T.unsafe(nil)); end

  def to_xpath(type=T.unsafe(nil)); end
end

class XPath::Union
end

module XPath
  extend ::XPath::DSL
  def self.generate(); end
end

module Zeitwerk
end

class Zeitwerk::Error
end

class Zeitwerk::Error
end

module Zeitwerk::ExplicitNamespace
end

module Zeitwerk::ExplicitNamespace
  extend ::Zeitwerk::RealModName
  def self.cpaths(); end

  def self.disable_tracer_if_unneeded(); end

  def self.mutex(); end

  def self.register(cpath, loader); end

  def self.tracepoint_class_callback(event); end

  def self.tracer(); end

  def self.unregister(loader); end
end

class Zeitwerk::GemInflector
  def camelize(basename, abspath); end

  def initialize(root_file); end
end

class Zeitwerk::GemInflector
end

class Zeitwerk::Inflector
  def camelize(basename, _abspath); end

  def inflect(inflections); end
end

class Zeitwerk::Inflector
end

class Zeitwerk::Loader
  include ::Zeitwerk::Loader::Callbacks
  include ::Zeitwerk::RealModName
  def autoloaded_dirs(); end

  def autoloads(); end

  def collapse(*glob_patterns); end

  def collapse_dirs(); end

  def collapse_glob_patterns(); end

  def dirs(); end

  def do_not_eager_load(*paths); end

  def eager_load(); end

  def eager_load_exclusions(); end

  def enable_reloading(); end

  def ignore(*glob_patterns); end

  def ignored_glob_patterns(); end

  def ignored_paths(); end

  def inflector(); end

  def inflector=(inflector); end

  def lazy_subdirs(); end

  def log!(); end

  def logger(); end

  def logger=(logger); end

  def manages?(dir); end

  def mutex(); end

  def mutex2(); end

  def preload(*paths); end

  def preloads(); end

  def push_dir(path); end

  def reload(); end

  def reloading_enabled?(); end

  def root_dirs(); end

  def setup(); end

  def tag(); end

  def tag=(tag); end

  def to_unload(); end

  def unload(); end

  def unloadable_cpath?(cpath); end

  def unloadable_cpaths(); end
end

module Zeitwerk::Loader::Callbacks
  include ::Zeitwerk::RealModName
  def on_dir_autoloaded(dir); end

  def on_file_autoloaded(file); end

  def on_namespace_loaded(namespace); end
end

module Zeitwerk::Loader::Callbacks
end

class Zeitwerk::Loader
  def self.all_dirs(); end

  def self.default_logger(); end

  def self.default_logger=(default_logger); end

  def self.eager_load_all(); end

  def self.for_gem(); end

  def self.mutex(); end

  def self.mutex=(mutex); end
end

class Zeitwerk::NameError
end

class Zeitwerk::NameError
end

module Zeitwerk::RealModName
  def real_mod_name(mod); end
end

module Zeitwerk::RealModName
end

module Zeitwerk::Registry
end

module Zeitwerk::Registry
  def self.autoloads(); end

  def self.inception?(cpath); end

  def self.inceptions(); end

  def self.loader_for(path); end

  def self.loader_for_gem(root_file); end

  def self.loaders(); end

  def self.loaders_managing_gems(); end

  def self.on_unload(loader); end

  def self.register_autoload(loader, realpath); end

  def self.register_inception(cpath, realpath, loader); end

  def self.register_loader(loader); end

  def self.unregister_autoload(realpath); end
end

class Zeitwerk::ReloadingDisabledError
end

class Zeitwerk::ReloadingDisabledError
end

module Zeitwerk
end

module Zip
  def case_insensitive_match(); end

  def case_insensitive_match=(case_insensitive_match); end

  def continue_on_exists_proc(); end

  def continue_on_exists_proc=(continue_on_exists_proc); end

  def default_compression(); end

  def default_compression=(default_compression); end

  def force_entry_names_encoding(); end

  def force_entry_names_encoding=(force_entry_names_encoding); end

  def on_exists_proc(); end

  def on_exists_proc=(on_exists_proc); end

  def reset!(); end

  def setup(); end

  def sort_entries(); end

  def sort_entries=(sort_entries); end

  def unicode_names(); end

  def unicode_names=(unicode_names); end

  def validate_entry_sizes(); end

  def validate_entry_sizes=(validate_entry_sizes); end

  def warn_invalid_date(); end

  def warn_invalid_date=(warn_invalid_date); end

  def write_zip64_support(); end

  def write_zip64_support=(write_zip64_support); end
  CDIR_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  CENTRAL_DIRECTORY_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHODS = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_AES = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_BZIP2 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_DEFLATE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_DEFLATE_64 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_CMPSC = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_LZ77 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_TERSE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IMPLODE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_JPEG = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_LZMA = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_PKWARE_DCLI = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_PPMD = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_1 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_2 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_3 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_4 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_SHRINK = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_STORE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_WAVPACK = ::T.let(nil, ::T.untyped)
  FILE_TYPE_DIR = ::T.let(nil, ::T.untyped)
  FILE_TYPE_FILE = ::T.let(nil, ::T.untyped)
  FILE_TYPE_SYMLINK = ::T.let(nil, ::T.untyped)
  FSTYPES = ::T.let(nil, ::T.untyped)
  FSTYPE_ACORN = ::T.let(nil, ::T.untyped)
  FSTYPE_AMIGA = ::T.let(nil, ::T.untyped)
  FSTYPE_ATARI = ::T.let(nil, ::T.untyped)
  FSTYPE_ATHEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_BEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_CPM = ::T.let(nil, ::T.untyped)
  FSTYPE_FAT = ::T.let(nil, ::T.untyped)
  FSTYPE_HPFS = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC_OSX = ::T.let(nil, ::T.untyped)
  FSTYPE_MVS = ::T.let(nil, ::T.untyped)
  FSTYPE_NTFS = ::T.let(nil, ::T.untyped)
  FSTYPE_QDOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TANDEM = ::T.let(nil, ::T.untyped)
  FSTYPE_THEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TOPS20 = ::T.let(nil, ::T.untyped)
  FSTYPE_UNIX = ::T.let(nil, ::T.untyped)
  FSTYPE_VFAT = ::T.let(nil, ::T.untyped)
  FSTYPE_VMS = ::T.let(nil, ::T.untyped)
  FSTYPE_VM_CMS = ::T.let(nil, ::T.untyped)
  FSTYPE_Z_SYSTEM = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = ::T.let(nil, ::T.untyped)
  RUNNING_ON_WINDOWS = ::T.let(nil, ::T.untyped)
  VERSION_MADE_BY = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT_ZIP64 = ::T.let(nil, ::T.untyped)
end

class Zip::CentralDirectory
  include ::Enumerable
  def ==(other); end

  def comment(); end

  def each(&a_proc); end

  def entries(); end

  def get_64_e_o_c_d(buf); end

  def get_e_o_c_d(buf); end

  def initialize(entries=T.unsafe(nil), comment=T.unsafe(nil)); end

  def read_64_e_o_c_d(buf); end

  def read_central_directory_entries(io); end

  def read_e_o_c_d(buf); end

  def read_from_stream(io); end

  def size(); end

  def start_buf(io); end

  def write_to_stream(io); end

  def zip64_file?(buf); end
  END_OF_CDS = ::T.let(nil, ::T.untyped)
  MAX_END_OF_CDS_SIZE = ::T.let(nil, ::T.untyped)
  STATIC_EOCD_SIZE = ::T.let(nil, ::T.untyped)
  ZIP64_END_OF_CDS = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_LOCATOR = ::T.let(nil, ::T.untyped)
end

class Zip::CentralDirectory
  def self.read_from_stream(io); end
end

class Zip::CompressionMethodError
end

class Zip::CompressionMethodError
end

class Zip::Compressor
  def finish(); end
end

class Zip::Compressor
end

class Zip::DOSTime
  def dos_equals(other); end

  def to_binary_dos_date(); end

  def to_binary_dos_time(); end
end

class Zip::DOSTime
  def self.from_time(time); end

  def self.parse_binary_dos_format(bin_dos_date, bin_dos_time); end
end

class Zip::DecompressionError
end

class Zip::DecompressionError
end

class Zip::Decompressor
  def decompressed_size(); end

  def initialize(input_stream, decompressed_size=T.unsafe(nil)); end

  def input_stream(); end
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::Decompressor
  def self.decompressor_classes(); end

  def self.find_by_compression_method(compression_method); end

  def self.register(compression_method, decompressor_class); end
end

class Zip::DecryptedIo
  def initialize(io, decrypter); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::DecryptedIo
end

class Zip::Decrypter
end

class Zip::Decrypter
end

class Zip::Deflater
  def <<(data); end

  def crc(); end

  def initialize(output_stream, level=T.unsafe(nil), encrypter=T.unsafe(nil)); end

  def size(); end
end

class Zip::Deflater
end

class Zip::DestinationFileExistsError
end

class Zip::DestinationFileExistsError
end

class Zip::Encrypter
end

class Zip::Encrypter
end

class Zip::Entry
  def ==(other); end

  def calculate_local_header_size(); end

  def cdir_header_size(); end

  def check_c_dir_entry_comment_size(); end

  def check_c_dir_entry_signature(); end

  def check_c_dir_entry_static_header_length(buf); end

  def check_name(name); end

  def clean_up(); end

  def comment(); end

  def comment=(comment); end

  def comment_size(); end

  def compressed_size(); end

  def compressed_size=(compressed_size); end

  def compression_method(); end

  def compression_method=(compression_method); end

  def crc(); end

  def crc=(crc); end

  def directory?(); end

  def dirty(); end

  def dirty=(dirty); end

  def encrypted?(); end

  def external_file_attributes(); end

  def external_file_attributes=(external_file_attributes); end

  def extra(); end

  def extra=(extra); end

  def extra_size(); end

  def extract(dest_path=T.unsafe(nil), &block); end

  def file?(); end

  def file_stat(path); end

  def file_type_is?(type); end

  def filepath(); end

  def follow_symlinks(); end

  def follow_symlinks=(follow_symlinks); end

  def fstype(); end

  def fstype=(fstype); end

  def ftype(); end

  def gather_fileinfo_from_srcpath(src_path); end

  def get_extra_attributes_from_path(path); end

  def get_input_stream(&block); end

  def get_raw_input_stream(&block); end

  def gp_flags(); end

  def gp_flags=(gp_flags); end

  def header_signature(); end

  def header_signature=(header_signature); end

  def incomplete?(); end

  def initialize(*args); end

  def internal_file_attributes(); end

  def internal_file_attributes=(internal_file_attributes); end

  def local_entry_offset(); end

  def local_header_offset(); end

  def local_header_offset=(local_header_offset); end

  def mtime(); end

  def name(); end

  def name=(name); end

  def name_is_directory?(); end

  def name_safe?(); end

  def name_size(); end

  def next_header_offset(); end

  def pack_c_dir_entry(); end

  def pack_local_entry(); end

  def parent_as_string(); end

  def read_c_dir_entry(io); end

  def read_c_dir_extra_field(io); end

  def read_local_entry(io); end

  def restore_ownership(); end

  def restore_ownership=(restore_ownership); end

  def restore_permissions(); end

  def restore_permissions=(restore_permissions); end

  def restore_times(); end

  def restore_times=(restore_times); end

  def set_default_vars_values(); end

  def set_extra_attributes_on_path(dest_path); end

  def set_ftype_from_c_dir_entry(); end

  def set_unix_attributes_on_path(dest_path); end

  def size(); end

  def size=(size); end

  def symlink?(); end

  def time(); end

  def time=(value); end

  def unix_gid(); end

  def unix_gid=(unix_gid); end

  def unix_perms(); end

  def unix_perms=(unix_perms); end

  def unix_uid(); end

  def unix_uid=(unix_uid); end

  def unpack_c_dir_entry(buf); end

  def unpack_local_entry(buf); end

  def verify_local_header_size!(); end

  def write_c_dir_entry(io); end

  def write_local_entry(io, rewrite=T.unsafe(nil)); end

  def write_to_zip_output_stream(zip_output_stream); end

  def zipfile(); end

  def zipfile=(zipfile); end
  DEFLATED = ::T.let(nil, ::T.untyped)
  EFS = ::T.let(nil, ::T.untyped)
  STORED = ::T.let(nil, ::T.untyped)
end

class Zip::Entry
  def self.read_c_dir_entry(io); end

  def self.read_local_entry(io); end

  def self.read_zip_64_long(io); end

  def self.read_zip_long(io); end

  def self.read_zip_short(io); end
end

class Zip::EntryExistsError
end

class Zip::EntryExistsError
end

class Zip::EntryNameError
end

class Zip::EntryNameError
end

class Zip::EntrySet
  include ::Enumerable
  def <<(entry); end

  def ==(other); end

  def delete(entry); end

  def each(&blk); end

  def entries(); end

  def entry_order(); end

  def entry_order=(entry_order); end

  def entry_set(); end

  def entry_set=(entry_set); end

  def find_entry(entry); end

  def glob(pattern, flags=T.unsafe(nil)); end

  def include?(entry); end

  def initialize(an_enumerable=T.unsafe(nil)); end

  def length(); end

  def parent(entry); end

  def push(entry); end

  def size(); end

  def sorted_entries(); end
end

class Zip::EntrySet
end

class Zip::EntrySizeError
end

class Zip::EntrySizeError
end

class Zip::Error
end

class Zip::Error
end

class Zip::ExtraField
  def c_dir_size(); end

  def create(name); end

  def create_unknown_item(); end

  def extra_field_type_exist(binstr, id, len, index); end

  def extra_field_type_unknown(binstr, len, index); end

  def initialize(binstr=T.unsafe(nil)); end

  def local_size(); end

  def merge(binstr); end

  def ordered_values(); end

  def to_c_dir_bin(); end

  def to_local_bin(); end
  ID_MAP = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Generic
  def ==(other); end

  def initial_parse(binstr); end

  def to_c_dir_bin(); end

  def to_local_bin(); end
end

class Zip::ExtraField::Generic
  def self.register_map(); end
end

class Zip::ExtraField::IUnix
  def gid(); end

  def gid=(gid); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def uid(); end

  def uid=(uid); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::IUnix
end

class Zip::ExtraField::NTFS
  def atime(); end

  def atime=(atime); end

  def ctime(); end

  def ctime=(ctime); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(mtime); end

  def pack_for_c_dir(); end

  def pack_for_local(); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
  SEC_TO_UNIX_EPOCH = ::T.let(nil, ::T.untyped)
  WINDOWS_TICK = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::NTFS
end

class Zip::ExtraField::OldUnix
  def atime(); end

  def atime=(atime); end

  def gid(); end

  def gid=(gid); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(mtime); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def uid(); end

  def uid=(uid); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::OldUnix
end

class Zip::ExtraField::UniversalTime
  def atime(); end

  def atime=(time); end

  def ctime(); end

  def ctime=(time); end

  def flag(); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(time); end

  def pack_for_c_dir(); end

  def pack_for_local(); end
  ATIME_MASK = ::T.let(nil, ::T.untyped)
  CTIME_MASK = ::T.let(nil, ::T.untyped)
  HEADER_ID = ::T.let(nil, ::T.untyped)
  MTIME_MASK = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::UniversalTime
end

class Zip::ExtraField::Zip64
  def compressed_size(); end

  def compressed_size=(compressed_size); end

  def disk_start_number(); end

  def disk_start_number=(disk_start_number); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def original_size(); end

  def original_size=(original_size); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def parse(original_size, compressed_size, relative_header_offset=T.unsafe(nil), disk_start_number=T.unsafe(nil)); end

  def relative_header_offset(); end

  def relative_header_offset=(relative_header_offset); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64
end

class Zip::ExtraField::Zip64Placeholder
  def initialize(_binstr=T.unsafe(nil)); end

  def pack_for_local(); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64Placeholder
end

class Zip::ExtraField
end

class Zip::File
  include ::Zip::FileSystem
  def add(entry, src_path, &continue_on_exists_proc); end

  def add_stored(entry, src_path, &continue_on_exists_proc); end

  def close(); end

  def comment=(comment); end

  def commit(); end

  def commit_required?(); end

  def extract(entry, dest_path, &block); end

  def find_entry(entry_name); end

  def get_entry(entry); end

  def get_input_stream(entry, &a_proc); end

  def get_output_stream(entry, permission_int=T.unsafe(nil), comment=T.unsafe(nil), extra=T.unsafe(nil), compressed_size=T.unsafe(nil), crc=T.unsafe(nil), compression_method=T.unsafe(nil), size=T.unsafe(nil), time=T.unsafe(nil), &a_proc); end

  def glob(*args, &block); end

  def initialize(path_or_io, create=T.unsafe(nil), buffer=T.unsafe(nil), options=T.unsafe(nil)); end

  def mkdir(entry_name, permission=T.unsafe(nil)); end

  def name(); end

  def read(entry); end

  def remove(entry); end

  def rename(entry, new_name, &continue_on_exists_proc); end

  def replace(entry, src_path); end

  def restore_ownership(); end

  def restore_ownership=(restore_ownership); end

  def restore_permissions(); end

  def restore_permissions=(restore_permissions); end

  def restore_times(); end

  def restore_times=(restore_times); end

  def write_buffer(io=T.unsafe(nil)); end
  CREATE = ::T.let(nil, ::T.untyped)
  DATA_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  IO_METHODS = ::T.let(nil, ::T.untyped)
  MAX_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  MIN_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  SPLIT_SIGNATURE = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_SIGNATURE = ::T.let(nil, ::T.untyped)
end

class Zip::File
  def self.add_buffer(); end

  def self.foreach(zip_file_name, &block); end

  def self.get_partial_zip_file_name(zip_file_name, partial_zip_file_name); end

  def self.get_segment_count_for_split(zip_file_size, segment_size); end

  def self.get_segment_size_for_split(segment_size); end

  def self.open(file_name, create=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.open_buffer(io, options=T.unsafe(nil)); end

  def self.put_split_signature(szip_file, segment_size); end

  def self.save_splited_part(zip_file, partial_zip_file_name, zip_file_size, szip_file_index, segment_size, segment_count); end

  def self.split(zip_file_name, segment_size=T.unsafe(nil), delete_zip_file=T.unsafe(nil), partial_zip_file_name=T.unsafe(nil)); end
end

module Zip::FileSystem
  def dir(); end

  def file(); end

  def initialize(); end
end

class Zip::FileSystem::ZipFileNameMapper
  include ::Enumerable
  def each(&blk); end

  def expand_path(path); end

  def find_entry(filename); end

  def get_entry(filename); end

  def get_input_stream(filename, &a_proc); end

  def get_output_stream(filename, permissions=T.unsafe(nil), &a_proc); end

  def glob(pattern, *flags, &block); end

  def initialize(zip_file); end

  def mkdir(filename, permissions=T.unsafe(nil)); end

  def pwd(); end

  def pwd=(pwd); end

  def read(filename); end

  def remove(filename); end

  def rename(filename, new_name, &continue_on_exists_proc); end
end

class Zip::FileSystem::ZipFileNameMapper
end

class Zip::FileSystem::ZipFsDir
  def chdir(directory_name); end

  def chroot(*_args); end

  def delete(entry_name); end

  def entries(directory_name); end

  def file=(file); end

  def foreach(directory_name); end

  def getwd(); end

  def glob(*args, &block); end

  def initialize(mapped_zip); end

  def mkdir(entry_name, permissions=T.unsafe(nil)); end

  def new(directory_name); end

  def open(directory_name); end

  def pwd(); end

  def rmdir(entry_name); end

  def unlink(entry_name); end
end

class Zip::FileSystem::ZipFsDir
end

class Zip::FileSystem::ZipFsDirIterator
  include ::Enumerable
  def close(); end

  def each(&a_proc); end

  def initialize(filenames); end

  def read(); end

  def rewind(); end

  def seek(position); end

  def tell(); end
end

class Zip::FileSystem::ZipFsDirIterator
end

class Zip::FileSystem::ZipFsFile
  def atime(filename); end

  def basename(filename); end

  def blockdev?(_filename); end

  def chardev?(_filename); end

  def chmod(mode, *filenames); end

  def chown(owner, group, *filenames); end

  def ctime(filename); end

  def delete(*args); end

  def dir=(dir); end

  def directory?(filename); end

  def dirname(filename); end

  def executable?(filename); end

  def executable_real?(filename); end

  def exist?(filename); end

  def exists?(filename); end

  def expand_path(path); end

  def file?(filename); end

  def foreach(filename, sep=T.unsafe(nil), &a_proc); end

  def ftype(filename); end

  def grpowned?(filename); end

  def initialize(mapped_zip); end

  def join(*fragments); end

  def link(_filename, _symlink_name); end

  def lstat(filename); end

  def mtime(filename); end

  def new(filename, mode=T.unsafe(nil)); end

  def open(filename, mode=T.unsafe(nil), permissions=T.unsafe(nil), &block); end

  def owned?(filename); end

  def pipe(); end

  def pipe?(_filename); end

  def popen(*args, &a_proc); end

  def read(filename); end

  def readable?(filename); end

  def readable_real?(filename); end

  def readlines(filename); end

  def readlink(_filename); end

  def rename(file_to_rename, new_name); end

  def setgid?(filename); end

  def setuid?(filename); end

  def size(filename); end

  def size?(filename); end

  def socket?(_filename); end

  def split(filename); end

  def stat(filename); end

  def sticky?(filename); end

  def symlink(_filename, _symlink_name); end

  def symlink?(_filename); end

  def truncate(_filename, _len); end

  def umask(*args); end

  def unlink(*args); end

  def utime(modified_time, *filenames); end

  def writable?(filename); end

  def writable_real?(filename); end

  def zero?(filename); end
end

class Zip::FileSystem::ZipFsFile::ZipFsStat
  def atime(); end

  def blksize(); end

  def blockdev?(); end

  def blocks(); end

  def chardev?(); end

  def ctime(); end

  def dev(); end

  def directory?(); end

  def executable?(); end

  def executable_real?(); end

  def file?(); end

  def ftype(); end

  def gid(); end

  def grpowned?(); end

  def initialize(zip_fs_file, entry_name); end

  def ino(); end

  def kind_of?(type); end

  def mode(); end

  def mtime(); end

  def nlink(); end

  def owned?(); end

  def pipe?(); end

  def rdev(); end

  def rdev_major(); end

  def rdev_minor(); end

  def readable?(); end

  def readable_real?(); end

  def setgid?(); end

  def setuid?(); end

  def size(); end

  def size?(); end

  def socket?(); end

  def sticky?(); end

  def symlink?(); end

  def uid(); end

  def writable?(); end

  def writable_real?(); end

  def zero?(); end
end

class Zip::FileSystem::ZipFsFile::ZipFsStat
  def self.delegate_to_fs_file(*methods); end
end

class Zip::FileSystem::ZipFsFile
end

module Zip::FileSystem
end

class Zip::GPFBit3Error
end

class Zip::GPFBit3Error
end

module Zip::IOExtras
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  RANGE_ALL = ::T.let(nil, ::T.untyped)
end

module Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Zip::IOExtras::FakeIO
  def each(a_sep_string=T.unsafe(nil), &blk); end

  def each_line(a_sep_string=T.unsafe(nil)); end

  def eof(); end

  def eof?(); end

  def flush(); end

  def gets(a_sep_string=T.unsafe(nil), number_of_bytes=T.unsafe(nil)); end

  def initialize(); end

  def lineno(); end

  def lineno=(lineno); end

  def pos(); end

  def read(number_of_bytes=T.unsafe(nil), buf=T.unsafe(nil)); end

  def readline(a_sep_string=T.unsafe(nil)); end

  def readlines(a_sep_string=T.unsafe(nil)); end

  def ungetc(byte); end
end

module Zip::IOExtras::AbstractInputStream
end

module Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO
  def print(*params); end

  def printf(a_format_string, *params); end

  def putc(an_object); end

  def puts(*params); end

  def write(data); end
end

module Zip::IOExtras::AbstractOutputStream
end

module Zip::IOExtras::FakeIO
  def kind_of?(object); end
end

module Zip::IOExtras::FakeIO
end

module Zip::IOExtras
  def self.copy_stream(ostream, istream); end

  def self.copy_stream_n(ostream, istream, nbytes); end
end

class Zip::Inflater
  def eof(); end

  def eof?(); end

  def initialize(*args); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
end

class Zip::Inflater
end

class Zip::InputStream
  include ::Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  def close(); end

  def get_decompressor(); end

  def get_decrypted_io(); end

  def get_io(io_or_file, offset=T.unsafe(nil)); end

  def get_next_entry(); end

  def initialize(context, offset=T.unsafe(nil), decrypter=T.unsafe(nil)); end

  def input_finished?(); end

  def open_entry(); end

  def produce_input(); end

  def rewind(); end

  def sysread(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::InputStream
  def self.open(filename_or_io, offset=T.unsafe(nil), decrypter=T.unsafe(nil)); end

  def self.open_buffer(filename_or_io, offset=T.unsafe(nil)); end
end

class Zip::InternalError
end

class Zip::InternalError
end

class Zip::NullCompressor
  include ::Singleton
  def <<(_data); end

  def compressed_size(); end

  def size(); end
end

class Zip::NullCompressor
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module Zip::NullDecompressor
end

module Zip::NullDecompressor
  def self.eof(); end

  def self.read(_length=T.unsafe(nil), _outbuf=T.unsafe(nil)); end
end

class Zip::NullDecrypter
  include ::Zip::NullEncryption
  def decrypt(data); end

  def reset!(_header); end
end

class Zip::NullDecrypter
end

class Zip::NullEncrypter
  include ::Zip::NullEncryption
  def data_descriptor(_crc32, _compressed_size, _uncomprssed_size); end

  def encrypt(data); end

  def header(_mtime); end

  def reset!(); end
end

class Zip::NullEncrypter
end

module Zip::NullEncryption
  def gp_flags(); end

  def header_bytesize(); end
end

module Zip::NullEncryption
end

module Zip::NullInputStream
  include ::Zip::NullDecompressor
  include ::Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Zip::IOExtras::FakeIO
end

module Zip::NullInputStream
end

class Zip::OutputStream
  include ::Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO
  def <<(data); end

  def close(); end

  def close_buffer(); end

  def comment(); end

  def comment=(comment); end

  def copy_raw_entry(entry); end

  def finish(); end

  def initialize(file_name, stream=T.unsafe(nil), encrypter=T.unsafe(nil)); end

  def put_next_entry(entry_name, comment=T.unsafe(nil), extra=T.unsafe(nil), compression_method=T.unsafe(nil), level=T.unsafe(nil)); end
end

class Zip::OutputStream
  def self.open(file_name, encrypter=T.unsafe(nil)); end

  def self.write_buffer(io=T.unsafe(nil), encrypter=T.unsafe(nil)); end
end

class Zip::PassThruCompressor
  def <<(data); end

  def crc(); end

  def initialize(output_stream); end

  def size(); end
end

class Zip::PassThruCompressor
end

class Zip::PassThruDecompressor
  def eof(); end

  def eof?(); end

  def initialize(*args); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
end

class Zip::PassThruDecompressor
end

class Zip::StreamableDirectory
  def initialize(zipfile, entry, src_path=T.unsafe(nil), permission=T.unsafe(nil)); end
end

class Zip::StreamableDirectory
end

class Zip::StreamableStream
  def clean_up(); end

  def get_input_stream(); end

  def get_output_stream(); end

  def initialize(entry); end

  def write_to_zip_output_stream(output_stream); end
end

class Zip::StreamableStream
end

class Zip::TraditionalDecrypter
  include ::Zip::TraditionalEncryption
  def decrypt(data); end

  def reset!(header); end
end

class Zip::TraditionalDecrypter
end

class Zip::TraditionalEncrypter
  include ::Zip::TraditionalEncryption
  def data_descriptor(crc32, compressed_size, uncomprssed_size); end

  def encrypt(data); end

  def header(mtime); end

  def reset!(); end
end

class Zip::TraditionalEncrypter
end

module Zip::TraditionalEncryption
  def decrypt_byte(); end

  def gp_flags(); end

  def header_bytesize(); end

  def initialize(password); end

  def reset_keys!(); end

  def update_keys(num); end
end

module Zip::TraditionalEncryption
end

Zip::ZipCompressionMethodError = Zip::CompressionMethodError

Zip::ZipDestinationFileExistsError = Zip::DestinationFileExistsError

Zip::ZipEntryExistsError = Zip::EntryExistsError

Zip::ZipEntryNameError = Zip::EntryNameError

Zip::ZipError = Zip::Error

Zip::ZipInternalError = Zip::InternalError

module Zip
  extend ::Zip
end

class Zlib::Deflate
  def initialize(*_); end
end

class Zlib::GzipReader
  def initialize(*_); end
end

class Zlib::GzipWriter
  def initialize(*_); end
end

class Zlib::Inflate
  def initialize(*_); end
end
